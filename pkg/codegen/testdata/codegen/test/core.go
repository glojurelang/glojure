// Code generated by glojure codegen. DO NOT EDIT.

package generated

import (
	errors5 "errors"
	fmt "fmt"
	lang "github.com/glojurelang/glojure/pkg/lang"
	runtime4 "github.com/glojurelang/glojure/pkg/runtime"
	uuid10 "github.com/google/uuid"
	math3 "math"
	big6 "math/big"
	rand12 "math/rand"
	url14 "net/url"
	reflect "reflect"
	regexp13 "regexp"
	runtime11 "runtime"
	strconv9 "strconv"
	strings8 "strings"
	time7 "time"
)

func init() {
	// Closed-over values
	var closed0 any
	{
		closed0 = lang.NewSymbol("unchecked_multiply")
	}
	var closed1 any
	{
		closed1 = lang.NewSymbol("multiply")
	}
	var closed10 any
	{
		closed10 = lang.NewSymbol("and")
	}
	var closed11 any
	{
		closed11 = lang.NewSymbol("andNot")
	}
	var closed12 any
	{
		closed12 = lang.NewSymbol("or")
	}
	var closed13 any
	{
		closed13 = lang.NewSymbol("xor")
	}
	var closed14 any
	{
		closed14 = lang.NewSymbol("max")
	}
	var closed15 any
	{
		closed15 = lang.NewSymbol("min")
	}
	var closed16 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			var tmp2 any
			if lang.IsTruthy(v1) {
				tmp2 = false
			} else {
				tmp2 = true
			}
			return tmp2
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp1)).(lang.FnFunc)
		closed16 = tmp0
	}
	var closed17 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_481:
			var tmp3 any
			{ // let
				// let binding "temp__0__auto__"
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v2})
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				if lang.IsTruthy(v8) {
					var tmp10 any
					{ // let
						// let binding "s"
						var v11 any = v8
						_ = v11
						var tmp12 any
						{ // let
							// let binding "or__0__auto__"
							tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp14 := tmp13.FindInternedVar(lang.NewSymbol("first"))
							if tmp14.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
							}
							tmp15 := tmp14.Get()
							tmp16 := lang.Apply(tmp15, []any{v11})
							tmp17 := lang.Apply(v1, []any{tmp16})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								tmp19 = v18
							} else {
								var tmp20 any = v1
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v11})
								var tmp21 any = tmp25
								v1 = tmp20
								v2 = tmp21
								goto recur_loop_481
							}
							tmp12 = tmp19
						} // end let
						tmp10 = tmp12
					} // end let
					tmp9 = tmp10
				} else {
				}
				tmp3 = tmp9
			} // end let
			return tmp3
		})
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		closed17 = tmp0
	}
	var closed18 any
	{
		var tmp0 lang.FnFunc
		tmp0 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v1 := args[0]
			_ = v1
			v2 := args[1]
			_ = v2
		recur_loop_480:
			var tmp3 any
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp9, []any{v2})
			tmp11 := lang.Apply(tmp6, []any{tmp10})
			if lang.IsTruthy(tmp11) {
				tmp3 = true
			} else {
				var tmp12 any
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("first"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v2})
				tmp17 := lang.Apply(v1, []any{tmp16})
				if lang.IsTruthy(tmp17) {
					var tmp18 any = v1
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("next"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{v2})
					var tmp19 any = tmp23
					v1 = tmp18
					v2 = tmp19
					goto recur_loop_480
				} else {
					var tmp24 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp24 = false
					} else {
					}
					tmp12 = tmp24
				}
				tmp3 = tmp12
			}
			return tmp3
		})
		tmp1 := reflect.TypeOf(false)
		tmp0 = tmp0.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp1)).(lang.FnFunc)
		closed18 = tmp0
	}
	var closed2 any
	{
		closed2 = lang.NewSymbol("multiplyP")
	}
	var closed3 any
	{
		closed3 = lang.NewSymbol("unchecked_add")
	}
	var closed4 any
	{
		closed4 = lang.NewSymbol("add")
	}
	var closed5 any
	{
		closed5 = lang.NewSymbol("addP")
	}
	var closed6 any
	{
		closed6 = lang.NewSymbol("unchecked_minus")
	}
	var closed7 any
	{
		closed7 = lang.NewSymbol("minus")
	}
	var closed8 any
	{
		closed8 = lang.NewSymbol("minusP")
	}
	var closed9 any
	{
		closed9 = lang.NewSymbol("divide")
	}

	// reference fmt to avoid unused import error
	_ = fmt.Printf
	ns := lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core"))
	_ = ns
	// *
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed0
					} else {
						tmp4 = closed1
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed0
					} else {
						tmp5 = closed1
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed0
					} else {
						tmp6 = closed1
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1001), lang.NewKeyword("end-line"), int(1001))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Multiply")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Multiply is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("*"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("*"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed2
					} else {
						tmp4 = closed2
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed2
					} else {
						tmp5 = closed2
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed2
					} else {
						tmp6 = closed2
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("*'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(989), lang.NewKeyword("end-line"), int(989))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(1)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MultiplyP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MultiplyP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("*'"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("*'"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *1
	{
		tmp0 := lang.NewSymbol("*1").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *2
	{
		tmp0 := lang.NewSymbol("*2").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *3
	{
		tmp0 := lang.NewSymbol("*3").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *agent*
	{
		tmp0 := lang.NewSymbol("*agent*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *assert*
	{
		tmp0 := lang.NewSymbol("*assert*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical false, 'assert' will omit assertion checks in\n  compiled code. Defaults to true.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *command-line-args*
	{
		tmp0 := lang.NewSymbol("*command-line-args*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A sequence of the supplied command line arguments, or nil if\n  none were supplied", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-files*
	{
		tmp0 := lang.NewSymbol("*compile-files*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Set to true when compiling files, false otherwise.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compile-path*
	{
		tmp0 := lang.NewSymbol("*compile-path*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *compiler-options*
	{
		tmp0 := lang.NewSymbol("*compiler-options*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.4", lang.NewKeyword("doc"), "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  :direct-linking - set to true to use direct static invocation of functions, rather than vars\n    Note that call sites compiled with direct linking will not be affected by var redefinition.\n    Use ^:redef (or ^:dynamic) on a var to prevent direct linking and allow redefinition.\n  See https://glojure.org/reference/compilation for more information.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *data-readers*
	{
		tmp0 := lang.NewSymbol("*data-readers*").WithMeta(lang.NewMap(lang.NewKeyword("doc"), "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  glojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(49), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(7794), lang.NewKeyword("end-line"), int(7794), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *default-data-reader-fn*
	{
		tmp0 := lang.NewSymbol("*default-data-reader-fn*").WithMeta(lang.NewMap(lang.NewKeyword("doc"), "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(59), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(7823), lang.NewKeyword("end-line"), int(7823), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *e
	{
		tmp0 := lang.NewSymbol("*e").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *err*
	{
		tmp0 := lang.NewSymbol("*err*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *file*
	{
		tmp0 := lang.NewSymbol("*file*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "NO_SOURCE_FILE", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *flush-on-newline*
	{
		tmp0 := lang.NewSymbol("*flush-on-newline*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loaded-libs*
	{
		tmp0 := lang.NewSymbol("*loaded-libs*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5817), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5820), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *loading-verbosely*
	{
		tmp0 := lang.NewSymbol("*loading-verbosely*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5827), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5830), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *ns*
	{
		tmp0 := lang.NewSymbol("*ns*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "A glojure.lang.Namespace object representing the current namespace.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *pending-paths*
	{
		tmp0 := lang.NewSymbol("*pending-paths*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5822), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(5825), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewList(), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-dup*
	{
		tmp0 := lang.NewSymbol("*print-dup*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-length*
	{
		tmp0 := lang.NewSymbol("*print-length*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(14), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(23), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-level*
	{
		tmp0 := lang.NewSymbol("*print-level*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(25), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(35), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-meta*
	{
		tmp0 := lang.NewSymbol("*print-meta*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-namespace-maps*
	{
		tmp0 := lang.NewSymbol("*print-namespace-maps*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(39), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(44), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *print-readably*
	{
		tmp0 := lang.NewSymbol("*print-readably*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *read-eval*
	{
		tmp0 := lang.NewSymbol("*read-eval*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: glojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'glojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dglojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dglojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *repl*
	{
		tmp0 := lang.NewSymbol("*repl*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6288), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6291), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *unchecked-math*
	{
		tmp0 := lang.NewSymbol("*unchecked-math*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.3", lang.NewKeyword("doc"), "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *verbose-defrecords*
	{
		tmp0 := lang.NewSymbol("*verbose-defrecords*").WithMeta(lang.NewMap(lang.NewKeyword("dynamic"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(37), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(37), lang.NewKeyword("end-column"), int(35), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, false, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// *warn-on-reflection*
	{
		tmp0 := lang.NewSymbol("*warn-on-reflection*").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("doc"), "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed3
					} else {
						tmp4 = closed4
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed3
					} else {
						tmp5 = closed4
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed3
					} else {
						tmp6 = closed4
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("+").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(977), lang.NewKeyword("end-line"), int(977))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Add")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Add is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("+"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("+"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// +'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed5
					} else {
						tmp4 = closed5
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed5
					} else {
						tmp5 = closed5
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed5
					} else {
						tmp6 = closed5
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("+'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(965), lang.NewKeyword("end-line"), int(965))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return int64(0)
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.MustAsNumber, []any{v5})
				return tmp6
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AddP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("+'"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("+'"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed6
					} else {
						tmp4 = closed7
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed6
					} else {
						tmp5 = closed7
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed6
					} else {
						tmp6 = closed7
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("-").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1036), lang.NewKeyword("end-line"), int(1036))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{int64(-1), v5})
				return tmp9
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Minus")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Minus is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("-"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("-"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -'
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed8
					} else {
						tmp4 = closed8
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed8
					} else {
						tmp5 = closed8
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed8
					} else {
						tmp6 = closed8
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("-'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1024), lang.NewKeyword("end-line"), int(1024))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*'"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{int64(-1), v5})
				return tmp9
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "MinusP")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("MinusP is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("-'"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("-'"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->
	{
		tmp0 := lang.NewSymbol("->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1675), lang.NewKeyword("end-line"), int(1675))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
								if tmp13.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
								}
								tmp14 := tmp13.Get()
								tmp15 := lang.Apply(tmp14, []any{v9})
								var v16 any = tmp15
								_ = v16
								// let binding "threaded"
								var tmp17 any
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq?"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v16})
								if lang.IsTruthy(tmp21) {
									tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp23 := tmp22.FindInternedVar(lang.NewSymbol("with-meta"))
									if tmp23.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
									}
									tmp24 := tmp23.Get()
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
									if tmp35.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
									}
									tmp36 := tmp35.Get()
									tmp37 := lang.Apply(tmp36, []any{v16})
									tmp38 := lang.Apply(tmp33, []any{tmp37})
									tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp40 := tmp39.FindInternedVar(lang.NewSymbol("list"))
									if tmp40.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
									}
									tmp41 := tmp40.Get()
									tmp42 := lang.Apply(tmp41, []any{v8})
									tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp44 := tmp43.FindInternedVar(lang.NewSymbol("next"))
									if tmp44.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
									}
									tmp45 := tmp44.Get()
									tmp46 := lang.Apply(tmp45, []any{v16})
									tmp47 := lang.Apply(tmp30, []any{tmp38, tmp42, tmp46})
									tmp48 := lang.Apply(tmp27, []any{tmp47})
									tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp50 := tmp49.FindInternedVar(lang.NewSymbol("meta"))
									if tmp50.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
									}
									tmp51 := tmp50.Get()
									tmp52 := lang.Apply(tmp51, []any{v16})
									tmp53 := lang.Apply(tmp24, []any{tmp48, tmp52})
									tmp17 = tmp53
								} else {
									tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
									if tmp55.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
									}
									tmp56 := tmp55.Get()
									tmp57 := lang.Apply(tmp56, []any{v16, v8})
									tmp17 = tmp57
								}
								var v58 any = tmp17
								_ = v58
								var tmp59 any = v58
								tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp62 := tmp61.FindInternedVar(lang.NewSymbol("next"))
								if tmp62.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
								}
								tmp63 := tmp62.Get()
								tmp64 := lang.Apply(tmp63, []any{v9})
								var tmp60 any = tmp64
								v8 = tmp59
								v9 = tmp60
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ->>
	{
		tmp0 := lang.NewSymbol("->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1691), lang.NewKeyword("end-line"), int(1691))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "x"
					var v8 any = v5
					_ = v8
					// let binding "forms"
					var v9 any = v6
					_ = v9
					for {
						var tmp10 any
						if lang.IsTruthy(v9) {
							var tmp11 any
							{ // let
								// let binding "form"
								tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
								if tmp13.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
								}
								tmp14 := tmp13.Get()
								tmp15 := lang.Apply(tmp14, []any{v9})
								var v16 any = tmp15
								_ = v16
								// let binding "threaded"
								var tmp17 any
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq?"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v16})
								if lang.IsTruthy(tmp21) {
									tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp23 := tmp22.FindInternedVar(lang.NewSymbol("with-meta"))
									if tmp23.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
									}
									tmp24 := tmp23.Get()
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
									if tmp35.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
									}
									tmp36 := tmp35.Get()
									tmp37 := lang.Apply(tmp36, []any{v16})
									tmp38 := lang.Apply(tmp33, []any{tmp37})
									tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp40 := tmp39.FindInternedVar(lang.NewSymbol("next"))
									if tmp40.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
									}
									tmp41 := tmp40.Get()
									tmp42 := lang.Apply(tmp41, []any{v16})
									tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp44 := tmp43.FindInternedVar(lang.NewSymbol("list"))
									if tmp44.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
									}
									tmp45 := tmp44.Get()
									tmp46 := lang.Apply(tmp45, []any{v8})
									tmp47 := lang.Apply(tmp30, []any{tmp38, tmp42, tmp46})
									tmp48 := lang.Apply(tmp27, []any{tmp47})
									tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp50 := tmp49.FindInternedVar(lang.NewSymbol("meta"))
									if tmp50.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
									}
									tmp51 := tmp50.Get()
									tmp52 := lang.Apply(tmp51, []any{v16})
									tmp53 := lang.Apply(tmp24, []any{tmp48, tmp52})
									tmp17 = tmp53
								} else {
									tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
									if tmp55.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
									}
									tmp56 := tmp55.Get()
									tmp57 := lang.Apply(tmp56, []any{v16, v8})
									tmp17 = tmp57
								}
								var v58 any = tmp17
								_ = v58
								var tmp59 any = v58
								tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp62 := tmp61.FindInternedVar(lang.NewSymbol("next"))
								if tmp62.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
								}
								tmp63 := tmp62.Get()
								tmp64 := lang.Apply(tmp63, []any{v9})
								var tmp60 any = tmp64
								v8 = tmp59
								v9 = tmp60
								continue
							} // end let
							tmp10 = tmp11
						} else {
							tmp10 = v8
						}
						tmp7 = tmp10
						break
					}
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// -protocols
	{
		tmp0 := lang.NewSymbol("-protocols").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("doc"), "Private store of protocols. Go's reflection capabilities\n    don't yet support a native interface-based implementation, so\n    protocols are implemented in Glojure as maps from type to protocol\n    method implementations.", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(21), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(26), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp3 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("coll-reduce"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("coll-reduce"), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("f"), lang.NewSymbol("val"))))))
		tmp4 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("internal-reduce"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("internal-reduce"), lang.NewVector(lang.NewSymbol("seq"), lang.NewSymbol("f"), lang.NewSymbol("start"))))))
		tmp5 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("kv-reduce"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("kv-reduce"), lang.NewVector(lang.NewSymbol("amap"), lang.NewSymbol("f"), lang.NewSymbol("init"))))))
		tmp6 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("datafy"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("datafy"), lang.NewVector(lang.NewSymbol("o")), "return a representation of o as data (default identity)"))))
		tmp7 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("nav"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("nav"), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("k"), lang.NewSymbol("v")), "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v."))))
		tmp8 := lang.NewAtom(lang.NewMap(lang.NewKeyword("multis"), lang.NewMap(lang.NewKeyword("make-reader"), nil, lang.NewKeyword("make-writer"), nil, lang.NewKeyword("make-input-stream"), nil, lang.NewKeyword("make-output-stream"), nil), lang.NewKeyword("on-interface"), true, lang.NewKeyword("sigs"), lang.NewList(lang.NewList(lang.NewSymbol("make-reader"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-writer"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates an io.Reader. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-input-stream"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates a BufferedInputStream. See also IOFactory docs."), lang.NewList(lang.NewSymbol("make-output-stream"), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("opts")), "Creates a BufferedOutputStream. See also IOFactory docs."))))
		tmp2 := lang.NewAtom(lang.NewMap(lang.NewSymbol("CollReduce"), tmp3, lang.NewSymbol("InternalReduce"), tmp4, lang.NewSymbol("IKVReduce"), tmp5, lang.NewSymbol("Datafiable"), tmp6, lang.NewSymbol("Navigable"), tmp7, lang.NewSymbol("IOFactory"), tmp8))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ..
	{
		tmp0 := lang.NewSymbol("..").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("form")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("form"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1657), lang.NewKeyword("end-line"), int(1657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp24})
				tmp26 := lang.Apply(tmp9, []any{tmp25})
				return tmp26
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("..")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol(".")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v5})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v6})
				tmp39 := lang.Apply(tmp26, []any{tmp30, tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp13, []any{tmp17, tmp41, v7})
				tmp43 := lang.Apply(tmp10, []any{tmp42})
				return tmp43
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// /
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed9
					} else {
						tmp4 = closed9
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed9
					} else {
						tmp5 = closed9
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed9
					} else {
						tmp6 = closed9
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("/").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1013), lang.NewKeyword("end-line"), int(1013))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("/"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{int64(1), v5})
				return tmp9
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Divide")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Divide is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("/"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("/"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <
	{
		var tmp1 lang.FnFunc
		{ // function <__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Lt")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("<").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(893), lang.NewKeyword("end-line"), int(893))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_150:
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("<"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					if lang.IsTruthy(tmp16) {
						var tmp17 any = v5
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v4 = tmp17
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_150
					} else {
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("<"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp35 := lang.Apply(tmp30, []any{v5, tmp34})
						tmp12 = tmp35
					}
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// <=
	{
		var tmp1 lang.FnFunc
		{ // function <=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Lte")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("<=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1048), lang.NewKeyword("end-line"), int(1048))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Lte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Lte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_194:
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("<="))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					if lang.IsTruthy(tmp16) {
						var tmp17 any = v5
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v4 = tmp17
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_194
					} else {
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("<="))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp35 := lang.Apply(tmp30, []any{v5, tmp34})
						tmp12 = tmp35
					}
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// =
	{
		var tmp1 lang.FnFunc
		{ // function =__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/equiv")})
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{v4})
				tmp31 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp22, tmp26, tmp30})
				tmp32 := lang.Apply(tmp7, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(776), lang.NewKeyword("end-line"), int(776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Equiv, []any{v4, v5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_126:
				var tmp7 any
				tmp8 := lang.Apply(lang.Equiv, []any{v4, v5})
				if lang.IsTruthy(tmp8) {
					var tmp9 any
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("next"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{v6})
					if lang.IsTruthy(tmp13) {
						var tmp14 any = v5
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp15 any = tmp19
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("next"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v6})
						var tmp20 any = tmp24
						v4 = tmp14
						v5 = tmp15
						v6 = tmp20
						goto recur_loop_126
					} else {
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("first"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(tmp27, []any{v6})
						tmp29 := lang.Apply(lang.Equiv, []any{v5, tmp28})
						tmp9 = tmp29
					}
					tmp7 = tmp9
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ==
	{
		var tmp1 lang.FnFunc
		{ // function ==__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Equiv")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("==").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1093), lang.NewKeyword("end-line"), int(1093))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Equiv")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Equiv is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_206:
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("=="))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					if lang.IsTruthy(tmp16) {
						var tmp17 any = v5
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v4 = tmp17
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_206
					} else {
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("=="))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp35 := lang.Apply(tmp30, []any{v5, tmp34})
						tmp12 = tmp35
					}
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >
	{
		var tmp1 lang.FnFunc
		{ // function >__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Gt")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol(">").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1063), lang.NewKeyword("end-line"), int(1063))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_198:
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol(">"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					if lang.IsTruthy(tmp16) {
						var tmp17 any = v5
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v4 = tmp17
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_198
					} else {
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol(">"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp35 := lang.Apply(tmp30, []any{v5, tmp34})
						tmp12 = tmp35
					}
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >0?
	{
		tmp0 := lang.NewSymbol(">0?").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(963), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(963), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(0)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >1?
	{
		tmp0 := lang.NewSymbol(">1?").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(962), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(962), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// >=
	{
		var tmp1 lang.FnFunc
		{ // function >=__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Gte")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol(">=").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1078), lang.NewKeyword("end-line"), int(1078))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Gte")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gte is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
			recur_loop_202:
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol(">="))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					if lang.IsTruthy(tmp16) {
						var tmp17 any = v5
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v4 = tmp17
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_202
					} else {
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol(">="))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp35 := lang.Apply(tmp30, []any{v5, tmp34})
						tmp12 = tmp35
					}
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// NaN?
	{
		var tmp1 lang.FnFunc
		{ // function NaN?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("math.IsNaN")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := lang.Apply(tmp9, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("NaN?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is NaN, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7968), lang.NewKeyword("end-line"), int(7968))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(math3.IsNaN, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// StackTraceElement->vec
	{
		tmp0 := lang.NewSymbol("StackTraceElement->vec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("doc"), "Constructs a data representation for a StackTraceElement: [class method file line]", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(436), lang.NewKeyword("end-line"), int(436))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("symbol"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7, ok := lang.FieldOrMethod(v3, "getClassName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getClassName")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("symbol"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13, ok := lang.FieldOrMethod(v3, "getMethodName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodName")))
			}
			var tmp14 any
			switch reflect.TypeOf(tmp13).Kind() {
			case reflect.Func:
				tmp14 = lang.Apply(tmp13, nil)
			default:
				tmp14 = tmp13
			}
			tmp15 := lang.Apply(tmp12, []any{tmp14})
			tmp16, ok := lang.FieldOrMethod(v3, "getFileName")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getFileName")))
			}
			var tmp17 any
			switch reflect.TypeOf(tmp16).Kind() {
			case reflect.Func:
				tmp17 = lang.Apply(tmp16, nil)
			default:
				tmp17 = tmp16
			}
			tmp18, ok := lang.FieldOrMethod(v3, "getLineNumber")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getLineNumber")))
			}
			var tmp19 any
			switch reflect.TypeOf(tmp18).Kind() {
			case reflect.Func:
				tmp19 = lang.Apply(tmp18, nil)
			default:
				tmp19 = tmp18
			}
			tmp20 := lang.NewVector(tmp9, tmp15, tmp17, tmp19)
			tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(440), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(440), lang.NewKeyword("end-column"), int(94))
			tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp22
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// Throwable->map
	{
		tmp0 := lang.NewSymbol("Throwable->map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("doc"), "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(442), lang.NewKeyword("end-line"), int(442))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "base"
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("merge"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("symbol"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("class"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v6})
					tmp17, ok := lang.FieldOrMethod(tmp16, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp16, "Name")))
					}
					var tmp18 any
					switch reflect.TypeOf(tmp17).Kind() {
					case reflect.Func:
						tmp18 = lang.Apply(tmp17, nil)
					default:
						tmp18 = tmp17
					}
					tmp19 := lang.Apply(tmp12, []any{tmp18})
					tmp20 := lang.NewMap(lang.NewKeyword("type"), tmp19)
					tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(455), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(455), lang.NewKeyword("end-column"), int(56))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp23 any
					{ // let
						// let binding "temp__0__auto__"
						tmp24, ok := lang.FieldOrMethod(v6, "getLocalizedMessage")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getLocalizedMessage")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						var v26 any = tmp25
						_ = v26
						var tmp27 any
						if lang.IsTruthy(v26) {
							var tmp28 any
							{ // let
								// let binding "msg"
								var v29 any = v26
								_ = v29
								tmp30 := lang.NewMap(lang.NewKeyword("message"), v29)
								tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(457), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(457), lang.NewKeyword("end-column"), int(33))
								tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp28 = tmp32
							} // end let
							tmp27 = tmp28
						} else {
						}
						tmp23 = tmp27
					} // end let
					var tmp24 any
					{ // let
						// let binding "temp__0__auto__"
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("ex-data"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(tmp27, []any{v6})
						var v29 any = tmp28
						_ = v29
						var tmp30 any
						if lang.IsTruthy(v29) {
							var tmp31 any
							{ // let
								// let binding "ed"
								var v32 any = v29
								_ = v32
								tmp33 := lang.NewMap(lang.NewKeyword("data"), v32)
								tmp34 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(459), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(459), lang.NewKeyword("end-column"), int(29))
								tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp31 = tmp35
							} // end let
							tmp30 = tmp31
						} else {
						}
						tmp24 = tmp30
					} // end let
					var tmp25 any
					{ // let
						// let binding "st"
						tmp26, ok := lang.FieldOrMethod(v6, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "getStackTrace")))
						}
						var tmp27 any
						switch reflect.TypeOf(tmp26).Kind() {
						case reflect.Func:
							tmp27 = lang.Apply(tmp26, nil)
						default:
							tmp27 = tmp26
						}
						var v28 any = tmp27
						_ = v28
						var tmp29 any
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("alength"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.Apply(tmp35, []any{v28})
						tmp37 := lang.Apply(tmp32, []any{tmp36})
						if lang.IsTruthy(tmp37) {
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("StackTraceElement->vec"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("aget"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(tmp43, []any{v28, int64(0)})
							tmp45 := lang.Apply(tmp40, []any{tmp44})
							tmp46 := lang.NewMap(lang.NewKeyword("at"), tmp45)
							tmp47 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(462), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(462), lang.NewKeyword("end-column"), int(63))
							tmp48, err := lang.WithMeta(tmp46, tmp47.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp29 = tmp48
						} else {
						}
						tmp25 = tmp29
					} // end let
					tmp26 := lang.Apply(tmp9, []any{tmp22, tmp23, tmp24, tmp25})
					return tmp26
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(454), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(462), lang.NewKeyword("end-column"), int(67))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "via"
				var tmp9 any
				{ // let
					// let binding "via"
					tmp10 := lang.NewVector()
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(463), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(463), lang.NewKeyword("end-column"), int(25))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v13 any = tmp12
					_ = v13
					// let binding "t"
					var v14 any = v3
					_ = v14
					for {
						var tmp15 any
						if lang.IsTruthy(v14) {
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("conj"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.Apply(tmp19, []any{v13, v14})
							var tmp16 any = tmp20
							tmp22, ok := lang.FieldOrMethod(v14, "getCause")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v14, "getCause")))
							}
							var tmp23 any
							switch reflect.TypeOf(tmp22).Kind() {
							case reflect.Func:
								tmp23 = lang.Apply(tmp22, nil)
							default:
								tmp23 = tmp22
							}
							var tmp21 any = tmp23
							v13 = tmp16
							v14 = tmp21
							continue
						} else {
							tmp15 = v13
						}
						tmp9 = tmp15
						break
					}
				} // end let
				var v10 any = tmp9
				_ = v10
				// let binding "root"
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("peek"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v10})
				var v15 any = tmp14
				_ = v15
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("merge"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("vec"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("map"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v8, v10})
				tmp26 := lang.Apply(tmp21, []any{tmp25})
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("vec"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("map"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("StackTraceElement->vec"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				var tmp36 any
				{ // let
					// let binding "or__0__auto__"
					var v37 any = v15
					_ = v37
					var tmp38 any
					if lang.IsTruthy(v37) {
						tmp38 = v37
					} else {
						tmp38 = v3
					}
					tmp36 = tmp38
				} // end let
				tmp37, ok := lang.FieldOrMethod(tmp36, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp36, "getStackTrace")))
				}
				var tmp38 any
				switch reflect.TypeOf(tmp37).Kind() {
				case reflect.Func:
					tmp38 = lang.Apply(tmp37, nil)
				default:
					tmp38 = tmp37
				}
				tmp39 := lang.Apply(tmp32, []any{tmp35, tmp38})
				tmp40 := lang.Apply(tmp29, []any{tmp39})
				tmp41 := lang.NewMap(lang.NewKeyword("via"), tmp26, lang.NewKeyword("trace"), tmp40)
				tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(468), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(470), lang.NewKeyword("end-column"), int(111))
				tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp44 any
				{ // let
					// let binding "temp__0__auto__"
					tmp45, ok := lang.FieldOrMethod(v15, "getLocalizedMessage")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v15, "getLocalizedMessage")))
					}
					var tmp46 any
					switch reflect.TypeOf(tmp45).Kind() {
					case reflect.Func:
						tmp46 = lang.Apply(tmp45, nil)
					default:
						tmp46 = tmp45
					}
					var v47 any = tmp46
					_ = v47
					var tmp48 any
					if lang.IsTruthy(v47) {
						var tmp49 any
						{ // let
							// let binding "root-msg"
							var v50 any = v47
							_ = v50
							tmp51 := lang.NewMap(lang.NewKeyword("cause"), v50)
							tmp52 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(472), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(472), lang.NewKeyword("end-column"), int(25))
							tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp49 = tmp53
						} // end let
						tmp48 = tmp49
					} else {
					}
					tmp44 = tmp48
				} // end let
				var tmp45 any
				{ // let
					// let binding "temp__0__auto__"
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("ex-data"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v15})
					var v50 any = tmp49
					_ = v50
					var tmp51 any
					if lang.IsTruthy(v50) {
						var tmp52 any
						{ // let
							// let binding "data"
							var v53 any = v50
							_ = v53
							tmp54 := lang.NewMap(lang.NewKeyword("data"), v53)
							tmp55 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(474), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(474), lang.NewKeyword("end-column"), int(20))
							tmp56, err := lang.WithMeta(tmp54, tmp55.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp52 = tmp56
						} // end let
						tmp51 = tmp52
					} else {
					}
					tmp45 = tmp51
				} // end let
				var tmp46 any
				{ // let
					// let binding "temp__0__auto__"
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("ex-data"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.Apply(tmp49, []any{v3})
					tmp51 := lang.Apply(lang.NewKeyword("glojure.error/phase"), []any{tmp50})
					var v52 any = tmp51
					_ = v52
					var tmp53 any
					if lang.IsTruthy(v52) {
						var tmp54 any
						{ // let
							// let binding "phase"
							var v55 any = v52
							_ = v55
							tmp56 := lang.NewMap(lang.NewKeyword("phase"), v55)
							tmp57 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(476), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(476), lang.NewKeyword("end-column"), int(22))
							tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp54 = tmp58
						} // end let
						tmp53 = tmp54
					} else {
					}
					tmp46 = tmp53
				} // end let
				tmp47 := lang.Apply(tmp18, []any{tmp43, tmp44, tmp45, tmp46})
				tmp4 = tmp47
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// abs
	{
		var tmp1 lang.FnFunc
		{ // function abs__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Abs")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := lang.Apply(tmp9, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("abs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the absolute value of a.\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\n  If a is a double and zero => +0.0\n  If a is a double and ##Inf or ##-Inf => ##Inf\n  If a is a double and ##NaN => ##NaN", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1128), lang.NewKeyword("end-line"), int(1128))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Abs, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// accessor
	{
		tmp0 := lang.NewSymbol("accessor").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4070), lang.NewKeyword("end-line"), int(4070))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(nil, "getAccessor")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getAccessor is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aclone
	{
		var tmp1 lang.FnFunc
		{ // function aclone__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Aclone")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aclone").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a clone of the Java array. Works on arrays of known\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3904), lang.NewKeyword("end-line"), int(3904))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Aclone")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Aclone is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-classpath
	{
		tmp0 := lang.NewSymbol("add-classpath").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("url"))), lang.NewKeyword("doc"), "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.1", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5176), lang.NewKeyword("end-line"), int(5176))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("println"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{"WARNING: add-classpath is deprecated"})
			_ = tmp7
			tmp8 := lang.Apply(nil, []any{v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-doc-and-meta
	{
		tmp0 := lang.NewSymbol("add-doc-and-meta").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring"), lang.NewSymbol("meta"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6400), lang.NewKeyword("end-line"), int(6400), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 5 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
			if tmp12.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
			}
			tmp13 := tmp12.Get()
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/alter-meta!")})
			tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
			if tmp19.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
			}
			tmp20 := tmp19.Get()
			tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
			if tmp22.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
			}
			tmp23 := tmp22.Get()
			tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
			if tmp25.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
			}
			tmp26 := tmp25.Get()
			tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
			if tmp28.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
			}
			tmp29 := tmp28.Get()
			tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("var")})
			tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
			if tmp32.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
			}
			tmp33 := tmp32.Get()
			tmp34 := lang.Apply(tmp33, []any{v5})
			tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
			tmp36 := lang.Apply(tmp23, []any{tmp35})
			tmp37 := lang.Apply(tmp20, []any{tmp36})
			tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp39 := tmp38.FindInternedVar(lang.NewSymbol("list"))
			if tmp39.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
			}
			tmp40 := tmp39.Get()
			tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/merge")})
			tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp43 := tmp42.FindInternedVar(lang.NewSymbol("list"))
			if tmp43.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
			}
			tmp44 := tmp43.Get()
			tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp46 := tmp45.FindInternedVar(lang.NewSymbol("seq"))
			if tmp46.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
			}
			tmp47 := tmp46.Get()
			tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp49 := tmp48.FindInternedVar(lang.NewSymbol("concat"))
			if tmp49.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
			}
			tmp50 := tmp49.Get()
			tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp52 := tmp51.FindInternedVar(lang.NewSymbol("list"))
			if tmp52.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
			}
			tmp53 := tmp52.Get()
			tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("glojure.core/assoc")})
			tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp56 := tmp55.FindInternedVar(lang.NewSymbol("list"))
			if tmp56.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
			}
			tmp57 := tmp56.Get()
			tmp58 := lang.Apply(tmp57, []any{v7})
			tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp60 := tmp59.FindInternedVar(lang.NewSymbol("list"))
			if tmp60.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
			}
			tmp61 := tmp60.Get()
			tmp62 := lang.Apply(tmp61, []any{lang.NewKeyword("doc")})
			tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp64 := tmp63.FindInternedVar(lang.NewSymbol("list"))
			if tmp64.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
			}
			tmp65 := tmp64.Get()
			tmp66 := lang.Apply(tmp65, []any{v6})
			tmp67 := lang.Apply(tmp50, []any{tmp54, tmp58, tmp62, tmp66})
			tmp68 := lang.Apply(tmp47, []any{tmp67})
			tmp69 := lang.Apply(tmp44, []any{tmp68})
			tmp70 := lang.Apply(tmp13, []any{tmp17, tmp37, tmp41, tmp69})
			tmp71 := lang.Apply(tmp10, []any{tmp70})
			return tmp71
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// add-watch
	{
		tmp0 := lang.NewSymbol("add-watch").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("reference"), lang.NewSymbol("key"), lang.NewSymbol("fn"))), lang.NewKeyword("doc"), "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2142), lang.NewKeyword("end-line"), int(2142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "addWatch")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("addWatch is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent
	{
		tmp0 := lang.NewSymbol("agent").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("state"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2052), lang.NewKeyword("end-line"), int(2052))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "a"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					// let binding "opts"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp9, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("setup-reference"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v6, v4})
					_ = tmp18
					var tmp19 any
					tmp20 := lang.Apply(lang.NewKeyword("error-handler"), []any{v14})
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.Apply(lang.NewKeyword("error-handler"), []any{v14})
						tmp22, _ := lang.FieldOrMethod(v6, "setErrorHandler")
						if reflect.TypeOf(tmp22).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
						}
						tmp23 := lang.Apply(tmp22, []any{tmp21})
						tmp19 = tmp23
					} else {
					}
					_ = tmp19
					var tmp24 any
					{ // let
						// let binding "or__0__auto__"
						tmp25 := lang.Apply(lang.NewKeyword("error-mode"), []any{v14})
						var v26 any = tmp25
						_ = v26
						var tmp27 any
						if lang.IsTruthy(v26) {
							tmp27 = v26
						} else {
							var tmp28 any
							tmp29 := lang.Apply(lang.NewKeyword("error-handler"), []any{v14})
							if lang.IsTruthy(tmp29) {
								tmp28 = lang.NewKeyword("continue")
							} else {
								tmp28 = lang.NewKeyword("fail")
							}
							tmp27 = tmp28
						}
						tmp24 = tmp27
					} // end let
					tmp25, _ := lang.FieldOrMethod(v6, "setErrorMode")
					if reflect.TypeOf(tmp25).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
					}
					tmp26 := lang.Apply(tmp25, []any{tmp24})
					_ = tmp26
					tmp5 = v6
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-error
	{
		tmp0 := lang.NewSymbol("agent-error").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2167), lang.NewKeyword("end-line"), int(2167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getError")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getError")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// agent-errors
	{
		tmp0 := lang.NewSymbol("agent-errors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.2", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2234), lang.NewKeyword("end-line"), int(2234))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("agent-error"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					var tmp11 any
					{ // let
						// let binding "e"
						var v12 any = v9
						_ = v12
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v12})
						tmp11 = tmp16
					} // end let
					tmp10 = tmp11
				} else {
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aget
	{
		var tmp1 lang.FnFunc
		{ // function aget__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Aget")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq"))
				if tmp40.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
				}
				tmp41 := tmp40.Get()
				tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp43 := tmp42.FindInternedVar(lang.NewSymbol("concat"))
				if tmp43.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
				}
				tmp44 := tmp43.Get()
				tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
				if tmp46.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
				}
				tmp47 := tmp46.Get()
				tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("glojure.core/int")})
				tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp50 := tmp49.FindInternedVar(lang.NewSymbol("list"))
				if tmp50.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
				}
				tmp51 := tmp50.Get()
				tmp52 := lang.Apply(tmp51, []any{v4})
				tmp53 := lang.Apply(tmp44, []any{tmp48, tmp52})
				tmp54 := lang.Apply(tmp41, []any{tmp53})
				tmp55 := lang.Apply(tmp38, []any{tmp54})
				tmp56 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp55})
				tmp57 := lang.Apply(tmp24, []any{tmp56})
				tmp58 := lang.Apply(tmp21, []any{tmp57})
				tmp59 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp58})
				tmp60 := lang.Apply(tmp7, []any{tmp59})
				return tmp60
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aget").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("&"), lang.NewSymbol("idxs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value at the index/indices. Works on Java arrays of all\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3911), lang.NewKeyword("end-line"), int(3911))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aget"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v4, v5})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v6})
				return tmp17
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alength
	{
		var tmp1 lang.FnFunc
		{ // function alength__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Alength")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("alength").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the length of the Java array. Works on arrays of all\n  types.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3897), lang.NewKeyword("end-line"), int(3897))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Alength")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Alength is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alias
	{
		tmp0 := lang.NewSymbol("alias").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("alias"), lang.NewSymbol("namespace-sym"))), lang.NewKeyword("doc"), "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4263), lang.NewKeyword("end-line"), int(4263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*ns*"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v4})
			tmp12, _ := lang.FieldOrMethod(tmp7, "AddAlias")
			if reflect.TypeOf(tmp12).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddAlias is not a function")))
			}
			tmp13 := lang.Apply(tmp12, []any{v3, tmp11})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// all-ns
	{
		tmp0 := lang.NewSymbol("all-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a sequence of all namespaces.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4146), lang.NewKeyword("end-line"), int(4146))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter
	{
		tmp0 := lang.NewSymbol("alter").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("fun"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2435), lang.NewKeyword("end-line"), int(2435))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alter")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alter is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-meta!
	{
		tmp0 := lang.NewSymbol("alter-meta!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2398), lang.NewKeyword("end-line"), int(2398))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "AlterMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AlterMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// alter-var-root
	{
		tmp0 := lang.NewSymbol("alter-var-root").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5484), lang.NewKeyword("end-line"), int(5484))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "alterRoot")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("alterRoot is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// amap
	{
		tmp0 := lang.NewSymbol("amap").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("idx"), lang.NewSymbol("ret"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5273), lang.NewKeyword("end-line"), int(5273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 6 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
			if tmp13.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
			}
			tmp14 := tmp13.Get()
			tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
			if tmp16.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
			}
			tmp17 := tmp16.Get()
			tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.core/let")})
			tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
			if tmp20.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
			}
			tmp21 := tmp20.Get()
			tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp23 := tmp22.FindInternedVar(lang.NewSymbol("apply"))
			if tmp23.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
			}
			tmp24 := tmp23.Get()
			tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp26 := tmp25.FindInternedVar(lang.NewSymbol("vector"))
			if tmp26.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
			}
			tmp27 := tmp26.Get()
			tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp29 := tmp28.FindInternedVar(lang.NewSymbol("seq"))
			if tmp29.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
			}
			tmp30 := tmp29.Get()
			tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp32 := tmp31.FindInternedVar(lang.NewSymbol("concat"))
			if tmp32.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
			}
			tmp33 := tmp32.Get()
			tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp35 := tmp34.FindInternedVar(lang.NewSymbol("list"))
			if tmp35.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
			}
			tmp36 := tmp35.Get()
			tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("a__0__auto__")})
			tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp39 := tmp38.FindInternedVar(lang.NewSymbol("list"))
			if tmp39.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
			}
			tmp40 := tmp39.Get()
			tmp41 := lang.Apply(tmp40, []any{v5})
			tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp43 := tmp42.FindInternedVar(lang.NewSymbol("list"))
			if tmp43.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
			}
			tmp44 := tmp43.Get()
			tmp45 := lang.Apply(tmp44, []any{lang.NewSymbol("l__1__auto__")})
			tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
			if tmp47.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
			}
			tmp48 := tmp47.Get()
			tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp50 := tmp49.FindInternedVar(lang.NewSymbol("seq"))
			if tmp50.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
			}
			tmp51 := tmp50.Get()
			tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp53 := tmp52.FindInternedVar(lang.NewSymbol("concat"))
			if tmp53.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
			}
			tmp54 := tmp53.Get()
			tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp56 := tmp55.FindInternedVar(lang.NewSymbol("list"))
			if tmp56.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
			}
			tmp57 := tmp56.Get()
			tmp58 := lang.Apply(tmp57, []any{lang.NewSymbol("glojure.core/alength")})
			tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp60 := tmp59.FindInternedVar(lang.NewSymbol("list"))
			if tmp60.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
			}
			tmp61 := tmp60.Get()
			tmp62 := lang.Apply(tmp61, []any{lang.NewSymbol("a__0__auto__")})
			tmp63 := lang.Apply(tmp54, []any{tmp58, tmp62})
			tmp64 := lang.Apply(tmp51, []any{tmp63})
			tmp65 := lang.Apply(tmp48, []any{tmp64})
			tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
			if tmp67.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
			}
			tmp68 := tmp67.Get()
			tmp69 := lang.Apply(tmp68, []any{v7})
			tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
			if tmp71.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
			}
			tmp72 := tmp71.Get()
			tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp74 := tmp73.FindInternedVar(lang.NewSymbol("seq"))
			if tmp74.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
			}
			tmp75 := tmp74.Get()
			tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp77 := tmp76.FindInternedVar(lang.NewSymbol("concat"))
			if tmp77.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
			}
			tmp78 := tmp77.Get()
			tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp80 := tmp79.FindInternedVar(lang.NewSymbol("list"))
			if tmp80.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
			}
			tmp81 := tmp80.Get()
			tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("glojure.core/aclone")})
			tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp84 := tmp83.FindInternedVar(lang.NewSymbol("list"))
			if tmp84.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
			}
			tmp85 := tmp84.Get()
			tmp86 := lang.Apply(tmp85, []any{lang.NewSymbol("a__0__auto__")})
			tmp87 := lang.Apply(tmp78, []any{tmp82, tmp86})
			tmp88 := lang.Apply(tmp75, []any{tmp87})
			tmp89 := lang.Apply(tmp72, []any{tmp88})
			tmp90 := lang.Apply(tmp33, []any{tmp37, tmp41, tmp45, tmp65, tmp69, tmp89})
			tmp91 := lang.Apply(tmp30, []any{tmp90})
			tmp92 := lang.Apply(tmp24, []any{tmp27, tmp91})
			tmp93 := lang.Apply(tmp21, []any{tmp92})
			tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
			if tmp95.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
			}
			tmp96 := tmp95.Get()
			tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp98 := tmp97.FindInternedVar(lang.NewSymbol("seq"))
			if tmp98.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
			}
			tmp99 := tmp98.Get()
			tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp101 := tmp100.FindInternedVar(lang.NewSymbol("concat"))
			if tmp101.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
			}
			tmp102 := tmp101.Get()
			tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp104 := tmp103.FindInternedVar(lang.NewSymbol("list"))
			if tmp104.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
			}
			tmp105 := tmp104.Get()
			tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("glojure.core/loop")})
			tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
			if tmp108.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
			}
			tmp109 := tmp108.Get()
			tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp111 := tmp110.FindInternedVar(lang.NewSymbol("apply"))
			if tmp111.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
			}
			tmp112 := tmp111.Get()
			tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp114 := tmp113.FindInternedVar(lang.NewSymbol("vector"))
			if tmp114.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
			}
			tmp115 := tmp114.Get()
			tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp117 := tmp116.FindInternedVar(lang.NewSymbol("seq"))
			if tmp117.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
			}
			tmp118 := tmp117.Get()
			tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp120 := tmp119.FindInternedVar(lang.NewSymbol("concat"))
			if tmp120.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
			}
			tmp121 := tmp120.Get()
			tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
			if tmp123.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
			}
			tmp124 := tmp123.Get()
			tmp125 := lang.Apply(tmp124, []any{v6})
			tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
			if tmp127.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
			}
			tmp128 := tmp127.Get()
			tmp129 := lang.Apply(tmp128, []any{int64(0)})
			tmp130 := lang.Apply(tmp121, []any{tmp125, tmp129})
			tmp131 := lang.Apply(tmp118, []any{tmp130})
			tmp132 := lang.Apply(tmp112, []any{tmp115, tmp131})
			tmp133 := lang.Apply(tmp109, []any{tmp132})
			tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
			if tmp135.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
			}
			tmp136 := tmp135.Get()
			tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
			if tmp138.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
			}
			tmp139 := tmp138.Get()
			tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
			if tmp141.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
			}
			tmp142 := tmp141.Get()
			tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
			if tmp144.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
			}
			tmp145 := tmp144.Get()
			tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("if")})
			tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
			if tmp148.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
			}
			tmp149 := tmp148.Get()
			tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp151 := tmp150.FindInternedVar(lang.NewSymbol("seq"))
			if tmp151.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
			}
			tmp152 := tmp151.Get()
			tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp154 := tmp153.FindInternedVar(lang.NewSymbol("concat"))
			if tmp154.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
			}
			tmp155 := tmp154.Get()
			tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp157 := tmp156.FindInternedVar(lang.NewSymbol("list"))
			if tmp157.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
			}
			tmp158 := tmp157.Get()
			tmp159 := lang.Apply(tmp158, []any{lang.NewSymbol("glojure.core/<")})
			tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp161 := tmp160.FindInternedVar(lang.NewSymbol("list"))
			if tmp161.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
			}
			tmp162 := tmp161.Get()
			tmp163 := lang.Apply(tmp162, []any{v6})
			tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp165 := tmp164.FindInternedVar(lang.NewSymbol("list"))
			if tmp165.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
			}
			tmp166 := tmp165.Get()
			tmp167 := lang.Apply(tmp166, []any{lang.NewSymbol("l__1__auto__")})
			tmp168 := lang.Apply(tmp155, []any{tmp159, tmp163, tmp167})
			tmp169 := lang.Apply(tmp152, []any{tmp168})
			tmp170 := lang.Apply(tmp149, []any{tmp169})
			tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
			if tmp172.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
			}
			tmp173 := tmp172.Get()
			tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp175 := tmp174.FindInternedVar(lang.NewSymbol("seq"))
			if tmp175.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
			}
			tmp176 := tmp175.Get()
			tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp178 := tmp177.FindInternedVar(lang.NewSymbol("concat"))
			if tmp178.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
			}
			tmp179 := tmp178.Get()
			tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp181 := tmp180.FindInternedVar(lang.NewSymbol("list"))
			if tmp181.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
			}
			tmp182 := tmp181.Get()
			tmp183 := lang.Apply(tmp182, []any{lang.NewSymbol("do")})
			tmp184 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp185 := tmp184.FindInternedVar(lang.NewSymbol("list"))
			if tmp185.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp185)))
			}
			tmp186 := tmp185.Get()
			tmp187 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp188 := tmp187.FindInternedVar(lang.NewSymbol("seq"))
			if tmp188.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp188)))
			}
			tmp189 := tmp188.Get()
			tmp190 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp191 := tmp190.FindInternedVar(lang.NewSymbol("concat"))
			if tmp191.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp191)))
			}
			tmp192 := tmp191.Get()
			tmp193 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp194 := tmp193.FindInternedVar(lang.NewSymbol("list"))
			if tmp194.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp194)))
			}
			tmp195 := tmp194.Get()
			tmp196 := lang.Apply(tmp195, []any{lang.NewSymbol("glojure.core/aset")})
			tmp197 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp198 := tmp197.FindInternedVar(lang.NewSymbol("list"))
			if tmp198.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp198)))
			}
			tmp199 := tmp198.Get()
			tmp200 := lang.Apply(tmp199, []any{v7})
			tmp201 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp202 := tmp201.FindInternedVar(lang.NewSymbol("list"))
			if tmp202.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp202)))
			}
			tmp203 := tmp202.Get()
			tmp204 := lang.Apply(tmp203, []any{v6})
			tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp206 := tmp205.FindInternedVar(lang.NewSymbol("list"))
			if tmp206.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
			}
			tmp207 := tmp206.Get()
			tmp208 := lang.Apply(tmp207, []any{v8})
			tmp209 := lang.Apply(tmp192, []any{tmp196, tmp200, tmp204, tmp208})
			tmp210 := lang.Apply(tmp189, []any{tmp209})
			tmp211 := lang.Apply(tmp186, []any{tmp210})
			tmp212 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp213 := tmp212.FindInternedVar(lang.NewSymbol("list"))
			if tmp213.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp213)))
			}
			tmp214 := tmp213.Get()
			tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp216 := tmp215.FindInternedVar(lang.NewSymbol("seq"))
			if tmp216.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
			}
			tmp217 := tmp216.Get()
			tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp219 := tmp218.FindInternedVar(lang.NewSymbol("concat"))
			if tmp219.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
			}
			tmp220 := tmp219.Get()
			tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp222 := tmp221.FindInternedVar(lang.NewSymbol("list"))
			if tmp222.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
			}
			tmp223 := tmp222.Get()
			tmp224 := lang.Apply(tmp223, []any{lang.NewSymbol("recur")})
			tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp226 := tmp225.FindInternedVar(lang.NewSymbol("list"))
			if tmp226.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
			}
			tmp227 := tmp226.Get()
			tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp229 := tmp228.FindInternedVar(lang.NewSymbol("seq"))
			if tmp229.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
			}
			tmp230 := tmp229.Get()
			tmp231 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp232 := tmp231.FindInternedVar(lang.NewSymbol("concat"))
			if tmp232.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp232)))
			}
			tmp233 := tmp232.Get()
			tmp234 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp235 := tmp234.FindInternedVar(lang.NewSymbol("list"))
			if tmp235.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp235)))
			}
			tmp236 := tmp235.Get()
			tmp237 := lang.Apply(tmp236, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
			tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp239 := tmp238.FindInternedVar(lang.NewSymbol("list"))
			if tmp239.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
			}
			tmp240 := tmp239.Get()
			tmp241 := lang.Apply(tmp240, []any{v6})
			tmp242 := lang.Apply(tmp233, []any{tmp237, tmp241})
			tmp243 := lang.Apply(tmp230, []any{tmp242})
			tmp244 := lang.Apply(tmp227, []any{tmp243})
			tmp245 := lang.Apply(tmp220, []any{tmp224, tmp244})
			tmp246 := lang.Apply(tmp217, []any{tmp245})
			tmp247 := lang.Apply(tmp214, []any{tmp246})
			tmp248 := lang.Apply(tmp179, []any{tmp183, tmp211, tmp247})
			tmp249 := lang.Apply(tmp176, []any{tmp248})
			tmp250 := lang.Apply(tmp173, []any{tmp249})
			tmp251 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp252 := tmp251.FindInternedVar(lang.NewSymbol("list"))
			if tmp252.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp252)))
			}
			tmp253 := tmp252.Get()
			tmp254 := lang.Apply(tmp253, []any{v7})
			tmp255 := lang.Apply(tmp142, []any{tmp146, tmp170, tmp250, tmp254})
			tmp256 := lang.Apply(tmp139, []any{tmp255})
			tmp257 := lang.Apply(tmp136, []any{tmp256})
			tmp258 := lang.Apply(tmp102, []any{tmp106, tmp133, tmp257})
			tmp259 := lang.Apply(tmp99, []any{tmp258})
			tmp260 := lang.Apply(tmp96, []any{tmp259})
			tmp261 := lang.Apply(tmp14, []any{tmp18, tmp93, tmp260})
			tmp262 := lang.Apply(tmp11, []any{tmp261})
			return tmp262
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ancestors
	{
		tmp0 := lang.NewSymbol("ancestors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5577), lang.NewKeyword("end-line"), int(5577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("ancestors"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("global-hierarchy"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("not-empty"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				var tmp8 any
				{ // let
					// let binding "ta"
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("get"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
					tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("class?"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v4})
					if lang.IsTruthy(tmp19) {
						var tmp20 any
						{ // let
							// let binding "superclasses"
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("set"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("supers"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{v4})
							tmp28 := lang.Apply(tmp23, []any{tmp27})
							var v29 any = tmp28
							_ = v29
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("into1"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("cons"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp40 := tmp39.FindInternedVar(lang.NewSymbol("map"))
							if tmp40.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
							}
							tmp41 := tmp40.Get()
							var tmp42 lang.FnFunc
							tmp42 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v43 := args[0]
								_ = v43
								tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp45 := tmp44.FindInternedVar(lang.NewSymbol("get"))
								if tmp45.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
								}
								tmp46 := tmp45.Get()
								tmp47 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
								tmp48 := lang.Apply(tmp46, []any{tmp47, v43})
								return tmp48
							})
							tmp43 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5590), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(5590), lang.NewKeyword("end-column"), int(54))
							tmp44, err := lang.WithMeta(tmp42, tmp43.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp45 := lang.Apply(tmp41, []any{tmp44, v29})
							tmp46 := lang.Apply(tmp38, []any{v14, tmp45})
							tmp47 := lang.Apply(tmp32, []any{tmp35, v29, tmp46})
							tmp20 = tmp47
						} // end let
						tmp15 = tmp20
					} else {
						tmp15 = v14
					}
					tmp8 = tmp15
				} // end let
				tmp9 := lang.Apply(tmp7, []any{tmp8})
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// and
	{
		tmp0 := lang.NewSymbol("and").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("next"))), lang.NewKeyword("doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(835), lang.NewKeyword("end-line"), int(835))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return true
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/let")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("and__0__auto__")})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v5})
				tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
				tmp41 := lang.Apply(tmp28, []any{tmp40})
				tmp42 := lang.Apply(tmp22, []any{tmp25, tmp41})
				tmp43 := lang.Apply(tmp19, []any{tmp42})
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("if")})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("and__0__auto__")})
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp65 := tmp64.FindInternedVar(lang.NewSymbol("seq"))
				if tmp65.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
				}
				tmp66 := tmp65.Get()
				tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp68 := tmp67.FindInternedVar(lang.NewSymbol("concat"))
				if tmp68.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
				}
				tmp69 := tmp68.Get()
				tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
				if tmp71.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
				}
				tmp72 := tmp71.Get()
				tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("glojure.core/and")})
				tmp74 := lang.Apply(tmp69, []any{tmp73, v6})
				tmp75 := lang.Apply(tmp66, []any{tmp74})
				tmp76 := lang.Apply(tmp63, []any{tmp75})
				tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp78 := tmp77.FindInternedVar(lang.NewSymbol("list"))
				if tmp78.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
				}
				tmp79 := tmp78.Get()
				tmp80 := lang.Apply(tmp79, []any{lang.NewSymbol("and__0__auto__")})
				tmp81 := lang.Apply(tmp52, []any{tmp56, tmp60, tmp76, tmp80})
				tmp82 := lang.Apply(tmp49, []any{tmp81})
				tmp83 := lang.Apply(tmp46, []any{tmp82})
				tmp84 := lang.Apply(tmp12, []any{tmp16, tmp43, tmp83})
				tmp85 := lang.Apply(tmp9, []any{tmp84})
				return tmp85
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("any?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true given any argument.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(537), lang.NewKeyword("end-line"), int(537))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			return true
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// apply
	{
		tmp0 := lang.NewSymbol("apply").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Applies fn f to the argument list formed by prepending intervening arguments to args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(653), lang.NewKeyword("end-line"), int(653))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9 := lang.Apply(lang.Apply, []any{v3, tmp8})
				return tmp9
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("list*"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4, v5})
				tmp10 := lang.Apply(lang.Apply, []any{v3, tmp9})
				return tmp10
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("list*"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v4, v5, v6})
				tmp11 := lang.Apply(lang.Apply, []any{v3, tmp10})
				return tmp11
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("list*"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5, v6, v7})
				tmp12 := lang.Apply(lang.Apply, []any{v3, tmp11})
				return tmp12
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("cons"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("cons"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("cons"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("cons"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("spread"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v8})
				tmp25 := lang.Apply(tmp20, []any{v7, tmp24})
				tmp26 := lang.Apply(tmp17, []any{v6, tmp25})
				tmp27 := lang.Apply(tmp14, []any{v5, tmp26})
				tmp28 := lang.Apply(tmp11, []any{v4, tmp27})
				tmp29 := lang.Apply(lang.Apply, []any{v3, tmp28})
				return tmp29
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// areduce
	{
		tmp0 := lang.NewSymbol("areduce").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("idx"), lang.NewSymbol("ret"), lang.NewSymbol("init"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5289), lang.NewKeyword("end-line"), int(5289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 7 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			v9 := args[6]
			_ = v9
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
			if tmp17.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
			}
			tmp18 := tmp17.Get()
			tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("glojure.core/let")})
			tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
			if tmp21.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
			}
			tmp22 := tmp21.Get()
			tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp24 := tmp23.FindInternedVar(lang.NewSymbol("apply"))
			if tmp24.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
			}
			tmp25 := tmp24.Get()
			tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp27 := tmp26.FindInternedVar(lang.NewSymbol("vector"))
			if tmp27.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
			}
			tmp28 := tmp27.Get()
			tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp30 := tmp29.FindInternedVar(lang.NewSymbol("seq"))
			if tmp30.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
			}
			tmp31 := tmp30.Get()
			tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp33 := tmp32.FindInternedVar(lang.NewSymbol("concat"))
			if tmp33.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
			}
			tmp34 := tmp33.Get()
			tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
			if tmp36.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
			}
			tmp37 := tmp36.Get()
			tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("a__0__auto__")})
			tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp40 := tmp39.FindInternedVar(lang.NewSymbol("list"))
			if tmp40.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
			}
			tmp41 := tmp40.Get()
			tmp42 := lang.Apply(tmp41, []any{v5})
			tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp44 := tmp43.FindInternedVar(lang.NewSymbol("list"))
			if tmp44.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
			}
			tmp45 := tmp44.Get()
			tmp46 := lang.Apply(tmp45, []any{lang.NewSymbol("l__1__auto__")})
			tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp48 := tmp47.FindInternedVar(lang.NewSymbol("list"))
			if tmp48.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
			}
			tmp49 := tmp48.Get()
			tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp51 := tmp50.FindInternedVar(lang.NewSymbol("seq"))
			if tmp51.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
			}
			tmp52 := tmp51.Get()
			tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp54 := tmp53.FindInternedVar(lang.NewSymbol("concat"))
			if tmp54.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
			}
			tmp55 := tmp54.Get()
			tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp57 := tmp56.FindInternedVar(lang.NewSymbol("list"))
			if tmp57.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
			}
			tmp58 := tmp57.Get()
			tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("glojure.core/alength")})
			tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp61 := tmp60.FindInternedVar(lang.NewSymbol("list"))
			if tmp61.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
			}
			tmp62 := tmp61.Get()
			tmp63 := lang.Apply(tmp62, []any{lang.NewSymbol("a__0__auto__")})
			tmp64 := lang.Apply(tmp55, []any{tmp59, tmp63})
			tmp65 := lang.Apply(tmp52, []any{tmp64})
			tmp66 := lang.Apply(tmp49, []any{tmp65})
			tmp67 := lang.Apply(tmp34, []any{tmp38, tmp42, tmp46, tmp66})
			tmp68 := lang.Apply(tmp31, []any{tmp67})
			tmp69 := lang.Apply(tmp25, []any{tmp28, tmp68})
			tmp70 := lang.Apply(tmp22, []any{tmp69})
			tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
			if tmp72.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
			}
			tmp73 := tmp72.Get()
			tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq"))
			if tmp75.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
			}
			tmp76 := tmp75.Get()
			tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp78 := tmp77.FindInternedVar(lang.NewSymbol("concat"))
			if tmp78.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
			}
			tmp79 := tmp78.Get()
			tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
			if tmp81.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
			}
			tmp82 := tmp81.Get()
			tmp83 := lang.Apply(tmp82, []any{lang.NewSymbol("glojure.core/loop")})
			tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp85 := tmp84.FindInternedVar(lang.NewSymbol("list"))
			if tmp85.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
			}
			tmp86 := tmp85.Get()
			tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp88 := tmp87.FindInternedVar(lang.NewSymbol("apply"))
			if tmp88.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
			}
			tmp89 := tmp88.Get()
			tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp91 := tmp90.FindInternedVar(lang.NewSymbol("vector"))
			if tmp91.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
			}
			tmp92 := tmp91.Get()
			tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp94 := tmp93.FindInternedVar(lang.NewSymbol("seq"))
			if tmp94.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
			}
			tmp95 := tmp94.Get()
			tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp97 := tmp96.FindInternedVar(lang.NewSymbol("concat"))
			if tmp97.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
			}
			tmp98 := tmp97.Get()
			tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp100 := tmp99.FindInternedVar(lang.NewSymbol("list"))
			if tmp100.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
			}
			tmp101 := tmp100.Get()
			tmp102 := lang.Apply(tmp101, []any{v6})
			tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp104 := tmp103.FindInternedVar(lang.NewSymbol("list"))
			if tmp104.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
			}
			tmp105 := tmp104.Get()
			tmp106 := lang.Apply(tmp105, []any{int64(0)})
			tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
			if tmp108.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
			}
			tmp109 := tmp108.Get()
			tmp110 := lang.Apply(tmp109, []any{v7})
			tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp112 := tmp111.FindInternedVar(lang.NewSymbol("list"))
			if tmp112.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
			}
			tmp113 := tmp112.Get()
			tmp114 := lang.Apply(tmp113, []any{v8})
			tmp115 := lang.Apply(tmp98, []any{tmp102, tmp106, tmp110, tmp114})
			tmp116 := lang.Apply(tmp95, []any{tmp115})
			tmp117 := lang.Apply(tmp89, []any{tmp92, tmp116})
			tmp118 := lang.Apply(tmp86, []any{tmp117})
			tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp120 := tmp119.FindInternedVar(lang.NewSymbol("list"))
			if tmp120.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
			}
			tmp121 := tmp120.Get()
			tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp123 := tmp122.FindInternedVar(lang.NewSymbol("seq"))
			if tmp123.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
			}
			tmp124 := tmp123.Get()
			tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp126 := tmp125.FindInternedVar(lang.NewSymbol("concat"))
			if tmp126.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
			}
			tmp127 := tmp126.Get()
			tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp129 := tmp128.FindInternedVar(lang.NewSymbol("list"))
			if tmp129.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
			}
			tmp130 := tmp129.Get()
			tmp131 := lang.Apply(tmp130, []any{lang.NewSymbol("if")})
			tmp132 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp133 := tmp132.FindInternedVar(lang.NewSymbol("list"))
			if tmp133.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp133)))
			}
			tmp134 := tmp133.Get()
			tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp136 := tmp135.FindInternedVar(lang.NewSymbol("seq"))
			if tmp136.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
			}
			tmp137 := tmp136.Get()
			tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp139 := tmp138.FindInternedVar(lang.NewSymbol("concat"))
			if tmp139.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
			}
			tmp140 := tmp139.Get()
			tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp142 := tmp141.FindInternedVar(lang.NewSymbol("list"))
			if tmp142.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
			}
			tmp143 := tmp142.Get()
			tmp144 := lang.Apply(tmp143, []any{lang.NewSymbol("glojure.core/<")})
			tmp145 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp146 := tmp145.FindInternedVar(lang.NewSymbol("list"))
			if tmp146.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp146)))
			}
			tmp147 := tmp146.Get()
			tmp148 := lang.Apply(tmp147, []any{v6})
			tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp150 := tmp149.FindInternedVar(lang.NewSymbol("list"))
			if tmp150.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
			}
			tmp151 := tmp150.Get()
			tmp152 := lang.Apply(tmp151, []any{lang.NewSymbol("l__1__auto__")})
			tmp153 := lang.Apply(tmp140, []any{tmp144, tmp148, tmp152})
			tmp154 := lang.Apply(tmp137, []any{tmp153})
			tmp155 := lang.Apply(tmp134, []any{tmp154})
			tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp157 := tmp156.FindInternedVar(lang.NewSymbol("list"))
			if tmp157.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
			}
			tmp158 := tmp157.Get()
			tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp160 := tmp159.FindInternedVar(lang.NewSymbol("seq"))
			if tmp160.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
			}
			tmp161 := tmp160.Get()
			tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp163 := tmp162.FindInternedVar(lang.NewSymbol("concat"))
			if tmp163.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
			}
			tmp164 := tmp163.Get()
			tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp166 := tmp165.FindInternedVar(lang.NewSymbol("list"))
			if tmp166.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
			}
			tmp167 := tmp166.Get()
			tmp168 := lang.Apply(tmp167, []any{lang.NewSymbol("recur")})
			tmp169 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp170 := tmp169.FindInternedVar(lang.NewSymbol("list"))
			if tmp170.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp170)))
			}
			tmp171 := tmp170.Get()
			tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp173 := tmp172.FindInternedVar(lang.NewSymbol("seq"))
			if tmp173.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
			}
			tmp174 := tmp173.Get()
			tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp176 := tmp175.FindInternedVar(lang.NewSymbol("concat"))
			if tmp176.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
			}
			tmp177 := tmp176.Get()
			tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list"))
			if tmp179.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
			}
			tmp180 := tmp179.Get()
			tmp181 := lang.Apply(tmp180, []any{lang.NewSymbol("glojure.core/unchecked-inc-int")})
			tmp182 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp183 := tmp182.FindInternedVar(lang.NewSymbol("list"))
			if tmp183.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp183)))
			}
			tmp184 := tmp183.Get()
			tmp185 := lang.Apply(tmp184, []any{v6})
			tmp186 := lang.Apply(tmp177, []any{tmp181, tmp185})
			tmp187 := lang.Apply(tmp174, []any{tmp186})
			tmp188 := lang.Apply(tmp171, []any{tmp187})
			tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
			if tmp190.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
			}
			tmp191 := tmp190.Get()
			tmp192 := lang.Apply(tmp191, []any{v9})
			tmp193 := lang.Apply(tmp164, []any{tmp168, tmp188, tmp192})
			tmp194 := lang.Apply(tmp161, []any{tmp193})
			tmp195 := lang.Apply(tmp158, []any{tmp194})
			tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp197 := tmp196.FindInternedVar(lang.NewSymbol("list"))
			if tmp197.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
			}
			tmp198 := tmp197.Get()
			tmp199 := lang.Apply(tmp198, []any{v7})
			tmp200 := lang.Apply(tmp127, []any{tmp131, tmp155, tmp195, tmp199})
			tmp201 := lang.Apply(tmp124, []any{tmp200})
			tmp202 := lang.Apply(tmp121, []any{tmp201})
			tmp203 := lang.Apply(tmp79, []any{tmp83, tmp118, tmp202})
			tmp204 := lang.Apply(tmp76, []any{tmp203})
			tmp205 := lang.Apply(tmp73, []any{tmp204})
			tmp206 := lang.Apply(tmp15, []any{tmp19, tmp70, tmp205})
			tmp207 := lang.Apply(tmp12, []any{tmp206})
			return tmp207
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array
	{
		tmp0 := lang.NewSymbol("array").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3457), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(3458), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("items"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("into-array"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// array-map
	{
		tmp0 := lang.NewSymbol("array-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4378), lang.NewKeyword("end-line"), int(4378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3, ok := lang.FieldOrMethod(nil, "EMPTY")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "EMPTY")))
				}
				var tmp4 any
				switch reflect.TypeOf(tmp3).Kind() {
				case reflect.Func:
					tmp4 = lang.Apply(tmp3, nil)
				default:
					tmp4 = tmp3
				}
				return tmp4
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "ary"
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("to-array"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.Apply(tmp7, []any{v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("odd?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("alength"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v9})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					if lang.IsTruthy(tmp18) {
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("str"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("last"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v3})
						tmp26 := lang.Apply(tmp21, []any{"No value supplied for key: ", tmp25})
						tmp27 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp26})
						panic(tmp27)
					} else {
						tmp28 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{v9})
						tmp10 = tmp28
					}
					tmp4 = tmp10
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// as->
	{
		tmp0 := lang.NewSymbol("as->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7598), lang.NewKeyword("end-line"), int(7598))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/let")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("apply"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("vector"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v6})
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.Apply(tmp39, []any{v5})
				tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp42 := tmp41.FindInternedVar(lang.NewSymbol("interleave"))
				if tmp42.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
				}
				tmp43 := tmp42.Get()
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("repeat"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.Apply(tmp46, []any{v6})
				tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp49 := tmp48.FindInternedVar(lang.NewSymbol("butlast"))
				if tmp49.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
				}
				tmp50 := tmp49.Get()
				tmp51 := lang.Apply(tmp50, []any{v7})
				tmp52 := lang.Apply(tmp43, []any{tmp47, tmp51})
				tmp53 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp52})
				tmp54 := lang.Apply(tmp29, []any{tmp53})
				tmp55 := lang.Apply(tmp23, []any{tmp26, tmp54})
				tmp56 := lang.Apply(tmp20, []any{tmp55})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				var tmp60 any
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("empty?"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.Apply(tmp63, []any{v7})
				if lang.IsTruthy(tmp64) {
					tmp60 = v6
				} else {
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("last"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v7})
					tmp60 = tmp68
				}
				tmp69 := lang.Apply(tmp59, []any{tmp60})
				tmp70 := lang.Apply(tmp13, []any{tmp17, tmp56, tmp69})
				tmp71 := lang.Apply(tmp10, []any{tmp70})
				return tmp71
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset
	{
		var tmp1 lang.FnFunc
		{ // function aset__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol(".")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("concat"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/Aset")})
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v3})
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
				if tmp41.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
				}
				tmp42 := tmp41.Get()
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
				if tmp47.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
				}
				tmp48 := tmp47.Get()
				tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.core/int")})
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.Apply(tmp52, []any{v4})
				tmp54 := lang.Apply(tmp45, []any{tmp49, tmp53})
				tmp55 := lang.Apply(tmp42, []any{tmp54})
				tmp56 := lang.Apply(tmp39, []any{tmp55})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{v5})
				tmp61 := lang.Apply(tmp28, []any{tmp32, tmp36, tmp56, tmp60})
				tmp62 := lang.Apply(tmp25, []any{tmp61})
				tmp63 := lang.Apply(tmp22, []any{tmp62})
				tmp64 := lang.Apply(tmp11, []any{tmp15, tmp19, tmp63})
				tmp65 := lang.Apply(tmp8, []any{tmp64})
				return tmp65
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("aset").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3922), lang.NewKeyword("end-line"), int(3922))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.SliceSet, []any{v4, v5, v6})
				_ = tmp7
				return v6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("aset"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("aget"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v4, v5})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v6, v7})
				return tmp18
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-boolean
	{
		tmp0 := lang.NewSymbol("aset-boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3956), lang.NewKeyword("end-line"), int(3958))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("boolean"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setBoolean")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setBoolean is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-boolean"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-byte
	{
		tmp0 := lang.NewSymbol("aset-byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of byte. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3976), lang.NewKeyword("end-line"), int(3978))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("byte"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setByte")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setByte is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-byte"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-char
	{
		tmp0 := lang.NewSymbol("aset-char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of char. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3981), lang.NewKeyword("end-line"), int(3983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("char"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setChar")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setChar is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-char"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-double
	{
		tmp0 := lang.NewSymbol("aset-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of double. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3966), lang.NewKeyword("end-line"), int(3968))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("double"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setDouble")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setDouble is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-double"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-float
	{
		tmp0 := lang.NewSymbol("aset-float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of float. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3961), lang.NewKeyword("end-line"), int(3963))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("float"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setFloat")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setFloat is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-float"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-int
	{
		tmp0 := lang.NewSymbol("aset-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of int. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3946), lang.NewKeyword("end-line"), int(3948))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("int"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setInt")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setInt is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-int"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-long
	{
		tmp0 := lang.NewSymbol("aset-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of long. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3951), lang.NewKeyword("end-line"), int(3953))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("long"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setLong")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setLong is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-long"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// aset-short
	{
		tmp0 := lang.NewSymbol("aset-short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("array"), lang.NewSymbol("idx"), lang.NewSymbol("idx2"), lang.NewSymbol("&"), lang.NewSymbol("idxv"))), lang.NewKeyword("doc"), "Sets the value at the index/indices. Works on arrays of short. Returns val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3971), lang.NewKeyword("end-line"), int(3973))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("short"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				tmp10, _ := lang.FieldOrMethod(nil, "setShort")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setShort is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v3, v4, tmp9})
				_ = tmp11
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("aset-short"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("aget"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16, v5, v6})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert
	{
		tmp0 := lang.NewSymbol("assert").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("message"))), lang.NewKeyword("doc"), "Evaluates expression x and throws an AssertionError with optional\n  message if x does not evaluate to logical true.\n\n  Assertion checks are omitted from compiled code if '*assert*' is\n  false.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4837), lang.NewKeyword("end-line"), int(4837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*assert*"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				if lang.IsTruthy(tmp9) {
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("glojure.core/when-not")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{v5})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("throw")})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("new")})
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("glojure.core/AssertionError")})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("seq"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("concat"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("list"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.Apply(tmp65, []any{lang.NewSymbol("glojure.core/str")})
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("list"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.Apply(tmp69, []any{"Assert failed: "})
					tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
					if tmp72.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
					}
					tmp73 := tmp72.Get()
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("concat"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.Apply(tmp82, []any{lang.NewSymbol("glojure.core/pr-str")})
					tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp85 := tmp84.FindInternedVar(lang.NewSymbol("list"))
					if tmp85.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
					}
					tmp86 := tmp85.Get()
					tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp88 := tmp87.FindInternedVar(lang.NewSymbol("seq"))
					if tmp88.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
					}
					tmp89 := tmp88.Get()
					tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp91 := tmp90.FindInternedVar(lang.NewSymbol("concat"))
					if tmp91.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
					}
					tmp92 := tmp91.Get()
					tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
					if tmp94.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
					}
					tmp95 := tmp94.Get()
					tmp96 := lang.Apply(tmp95, []any{lang.NewSymbol("quote")})
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.Apply(tmp99, []any{v5})
					tmp101 := lang.Apply(tmp92, []any{tmp96, tmp100})
					tmp102 := lang.Apply(tmp89, []any{tmp101})
					tmp103 := lang.Apply(tmp86, []any{tmp102})
					tmp104 := lang.Apply(tmp79, []any{tmp83, tmp103})
					tmp105 := lang.Apply(tmp76, []any{tmp104})
					tmp106 := lang.Apply(tmp73, []any{tmp105})
					tmp107 := lang.Apply(tmp62, []any{tmp66, tmp70, tmp106})
					tmp108 := lang.Apply(tmp59, []any{tmp107})
					tmp109 := lang.Apply(tmp56, []any{tmp108})
					tmp110 := lang.Apply(tmp45, []any{tmp49, tmp53, tmp109})
					tmp111 := lang.Apply(tmp42, []any{tmp110})
					tmp112 := lang.Apply(tmp39, []any{tmp111})
					tmp113 := lang.Apply(tmp32, []any{tmp36, tmp112})
					tmp114 := lang.Apply(tmp29, []any{tmp113})
					tmp115 := lang.Apply(tmp26, []any{tmp114})
					tmp116 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp115})
					tmp117 := lang.Apply(tmp12, []any{tmp116})
					tmp6 = tmp117
				} else {
				}
				return tmp6
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("*assert*"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				if lang.IsTruthy(tmp10) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("concat"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("glojure.core/when-not")})
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v5})
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("seq"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("concat"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("list"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.Apply(tmp36, []any{lang.NewSymbol("throw")})
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("list"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("seq"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("concat"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("list"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.Apply(tmp49, []any{lang.NewSymbol("new")})
					tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp52 := tmp51.FindInternedVar(lang.NewSymbol("list"))
					if tmp52.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
					}
					tmp53 := tmp52.Get()
					tmp54 := lang.Apply(tmp53, []any{lang.NewSymbol("glojure.core/AssertionError")})
					tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp56 := tmp55.FindInternedVar(lang.NewSymbol("list"))
					if tmp56.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
					}
					tmp57 := tmp56.Get()
					tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp59 := tmp58.FindInternedVar(lang.NewSymbol("seq"))
					if tmp59.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
					}
					tmp60 := tmp59.Get()
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("concat"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp65 := tmp64.FindInternedVar(lang.NewSymbol("list"))
					if tmp65.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
					}
					tmp66 := tmp65.Get()
					tmp67 := lang.Apply(tmp66, []any{lang.NewSymbol("glojure.core/str")})
					tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp69 := tmp68.FindInternedVar(lang.NewSymbol("list"))
					if tmp69.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
					}
					tmp70 := tmp69.Get()
					tmp71 := lang.Apply(tmp70, []any{"Assert failed: "})
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("list"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{v6})
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("list"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.Apply(tmp78, []any{"\n"})
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp84 := tmp83.FindInternedVar(lang.NewSymbol("seq"))
					if tmp84.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
					}
					tmp85 := tmp84.Get()
					tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp87 := tmp86.FindInternedVar(lang.NewSymbol("concat"))
					if tmp87.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
					}
					tmp88 := tmp87.Get()
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.Apply(tmp91, []any{lang.NewSymbol("glojure.core/pr-str")})
					tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
					if tmp94.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
					}
					tmp95 := tmp94.Get()
					tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp97 := tmp96.FindInternedVar(lang.NewSymbol("seq"))
					if tmp97.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
					}
					tmp98 := tmp97.Get()
					tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp100 := tmp99.FindInternedVar(lang.NewSymbol("concat"))
					if tmp100.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
					}
					tmp101 := tmp100.Get()
					tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
					if tmp103.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
					}
					tmp104 := tmp103.Get()
					tmp105 := lang.Apply(tmp104, []any{lang.NewSymbol("quote")})
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.Apply(tmp108, []any{v5})
					tmp110 := lang.Apply(tmp101, []any{tmp105, tmp109})
					tmp111 := lang.Apply(tmp98, []any{tmp110})
					tmp112 := lang.Apply(tmp95, []any{tmp111})
					tmp113 := lang.Apply(tmp88, []any{tmp92, tmp112})
					tmp114 := lang.Apply(tmp85, []any{tmp113})
					tmp115 := lang.Apply(tmp82, []any{tmp114})
					tmp116 := lang.Apply(tmp63, []any{tmp67, tmp71, tmp75, tmp79, tmp115})
					tmp117 := lang.Apply(tmp60, []any{tmp116})
					tmp118 := lang.Apply(tmp57, []any{tmp117})
					tmp119 := lang.Apply(tmp46, []any{tmp50, tmp54, tmp118})
					tmp120 := lang.Apply(tmp43, []any{tmp119})
					tmp121 := lang.Apply(tmp40, []any{tmp120})
					tmp122 := lang.Apply(tmp33, []any{tmp37, tmp121})
					tmp123 := lang.Apply(tmp30, []any{tmp122})
					tmp124 := lang.Apply(tmp27, []any{tmp123})
					tmp125 := lang.Apply(tmp16, []any{tmp20, tmp24, tmp124})
					tmp126 := lang.Apply(tmp13, []any{tmp125})
					tmp7 = tmp126
				} else {
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-args
	{
		tmp0 := lang.NewSymbol("assert-args").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("pairs"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(38), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1830), lang.NewKeyword("end-line"), int(1830), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("do")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("concat"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("glojure.core/when-not")})
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("first"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v5})
				tmp36 := lang.Apply(tmp31, []any{tmp35})
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
				if tmp41.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
				}
				tmp42 := tmp41.Get()
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
				if tmp47.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
				}
				tmp48 := tmp47.Get()
				tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("throw")})
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("seq"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp57 := tmp56.FindInternedVar(lang.NewSymbol("concat"))
				if tmp57.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
				}
				tmp58 := tmp57.Get()
				tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp60 := tmp59.FindInternedVar(lang.NewSymbol("list"))
				if tmp60.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
				}
				tmp61 := tmp60.Get()
				tmp62 := lang.Apply(tmp61, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
				tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp64 := tmp63.FindInternedVar(lang.NewSymbol("list"))
				if tmp64.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
				}
				tmp65 := tmp64.Get()
				tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp67 := tmp66.FindInternedVar(lang.NewSymbol("seq"))
				if tmp67.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
				}
				tmp68 := tmp67.Get()
				tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp70 := tmp69.FindInternedVar(lang.NewSymbol("concat"))
				if tmp70.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
				}
				tmp71 := tmp70.Get()
				tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp73 := tmp72.FindInternedVar(lang.NewSymbol("list"))
				if tmp73.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
				}
				tmp74 := tmp73.Get()
				tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("glojure.core/str")})
				tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp77 := tmp76.FindInternedVar(lang.NewSymbol("list"))
				if tmp77.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
				}
				tmp78 := tmp77.Get()
				tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp80 := tmp79.FindInternedVar(lang.NewSymbol("seq"))
				if tmp80.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
				}
				tmp81 := tmp80.Get()
				tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp83 := tmp82.FindInternedVar(lang.NewSymbol("concat"))
				if tmp83.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
				}
				tmp84 := tmp83.Get()
				tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp86 := tmp85.FindInternedVar(lang.NewSymbol("list"))
				if tmp86.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
				}
				tmp87 := tmp86.Get()
				tmp88 := lang.Apply(tmp87, []any{lang.NewSymbol("glojure.core/first")})
				tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
				if tmp90.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
				}
				tmp91 := tmp90.Get()
				tmp92 := lang.Apply(tmp91, []any{lang.NewSymbol("&form")})
				tmp93 := lang.Apply(tmp84, []any{tmp88, tmp92})
				tmp94 := lang.Apply(tmp81, []any{tmp93})
				tmp95 := lang.Apply(tmp78, []any{tmp94})
				tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp97 := tmp96.FindInternedVar(lang.NewSymbol("list"))
				if tmp97.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
				}
				tmp98 := tmp97.Get()
				tmp99 := lang.Apply(tmp98, []any{" requires "})
				tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp101 := tmp100.FindInternedVar(lang.NewSymbol("list"))
				if tmp101.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
				}
				tmp102 := tmp101.Get()
				tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp104 := tmp103.FindInternedVar(lang.NewSymbol("second"))
				if tmp104.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
				}
				tmp105 := tmp104.Get()
				tmp106 := lang.Apply(tmp105, []any{v5})
				tmp107 := lang.Apply(tmp102, []any{tmp106})
				tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp109 := tmp108.FindInternedVar(lang.NewSymbol("list"))
				if tmp109.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
				}
				tmp110 := tmp109.Get()
				tmp111 := lang.Apply(tmp110, []any{" in "})
				tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp113 := tmp112.FindInternedVar(lang.NewSymbol("list"))
				if tmp113.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
				}
				tmp114 := tmp113.Get()
				tmp115 := lang.Apply(tmp114, []any{lang.NewSymbol("*ns*")})
				tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp117 := tmp116.FindInternedVar(lang.NewSymbol("list"))
				if tmp117.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
				}
				tmp118 := tmp117.Get()
				tmp119 := lang.Apply(tmp118, []any{":"})
				tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp121 := tmp120.FindInternedVar(lang.NewSymbol("list"))
				if tmp121.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
				}
				tmp122 := tmp121.Get()
				tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp124 := tmp123.FindInternedVar(lang.NewSymbol("seq"))
				if tmp124.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
				}
				tmp125 := tmp124.Get()
				tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp127 := tmp126.FindInternedVar(lang.NewSymbol("concat"))
				if tmp127.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
				}
				tmp128 := tmp127.Get()
				tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp130 := tmp129.FindInternedVar(lang.NewSymbol("list"))
				if tmp130.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
				}
				tmp131 := tmp130.Get()
				tmp132 := lang.Apply(tmp131, []any{lang.NewKeyword("line")})
				tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp134 := tmp133.FindInternedVar(lang.NewSymbol("list"))
				if tmp134.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
				}
				tmp135 := tmp134.Get()
				tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp137 := tmp136.FindInternedVar(lang.NewSymbol("seq"))
				if tmp137.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
				}
				tmp138 := tmp137.Get()
				tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp140 := tmp139.FindInternedVar(lang.NewSymbol("concat"))
				if tmp140.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
				}
				tmp141 := tmp140.Get()
				tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp143 := tmp142.FindInternedVar(lang.NewSymbol("list"))
				if tmp143.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
				}
				tmp144 := tmp143.Get()
				tmp145 := lang.Apply(tmp144, []any{lang.NewSymbol("glojure.core/meta")})
				tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
				if tmp147.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
				}
				tmp148 := tmp147.Get()
				tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("&form")})
				tmp150 := lang.Apply(tmp141, []any{tmp145, tmp149})
				tmp151 := lang.Apply(tmp138, []any{tmp150})
				tmp152 := lang.Apply(tmp135, []any{tmp151})
				tmp153 := lang.Apply(tmp128, []any{tmp132, tmp152})
				tmp154 := lang.Apply(tmp125, []any{tmp153})
				tmp155 := lang.Apply(tmp122, []any{tmp154})
				tmp156 := lang.Apply(tmp71, []any{tmp75, tmp95, tmp99, tmp107, tmp111, tmp115, tmp119, tmp155})
				tmp157 := lang.Apply(tmp68, []any{tmp156})
				tmp158 := lang.Apply(tmp65, []any{tmp157})
				tmp159 := lang.Apply(tmp58, []any{tmp62, tmp158})
				tmp160 := lang.Apply(tmp55, []any{tmp159})
				tmp161 := lang.Apply(tmp52, []any{tmp160})
				tmp162 := lang.Apply(tmp45, []any{tmp49, tmp161})
				tmp163 := lang.Apply(tmp42, []any{tmp162})
				tmp164 := lang.Apply(tmp39, []any{tmp163})
				tmp165 := lang.Apply(tmp24, []any{tmp28, tmp36, tmp164})
				tmp166 := lang.Apply(tmp21, []any{tmp165})
				tmp167 := lang.Apply(tmp18, []any{tmp166})
				tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp169 := tmp168.FindInternedVar(lang.NewSymbol("list"))
				if tmp169.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
				}
				tmp170 := tmp169.Get()
				var tmp171 any
				{ // let
					// let binding "more"
					tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp173 := tmp172.FindInternedVar(lang.NewSymbol("nnext"))
					if tmp173.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
					}
					tmp174 := tmp173.Get()
					tmp175 := lang.Apply(tmp174, []any{v5})
					var v176 any = tmp175
					_ = v176
					var tmp177 any
					if lang.IsTruthy(v176) {
						tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list*"))
						if tmp179.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
						}
						tmp180 := tmp179.Get()
						tmp181 := lang.Apply(tmp180, []any{lang.NewSymbol("glojure.core/assert-args"), v176})
						tmp177 = tmp181
					} else {
					}
					tmp171 = tmp177
				} // end let
				tmp172 := lang.Apply(tmp170, []any{tmp171})
				tmp173 := lang.Apply(tmp11, []any{tmp15, tmp167, tmp172})
				tmp174 := lang.Apply(tmp8, []any{tmp173})
				return tmp174
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assert-valid-fdecl
	{
		tmp0 := lang.NewSymbol("assert-valid-fdecl").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fdecl"))), lang.NewKeyword("doc"), "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(42), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(7502), lang.NewKeyword("end-line"), int(7502), lang.NewKeyword("private"), true, lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("empty?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.Apply(lang.NewIllegalArgumentError, []any{"Parameter declaration missing"})
				panic(tmp9)
			} else {
			}
			_ = tmp4
			var tmp10 any
			{ // let
				// let binding "argdecls"
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("map"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v15 := args[0]
					_ = v15
					var tmp16 any
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq?"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v15})
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v15})
						tmp16 = tmp24
					} else {
						var tmp25 any
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
						if tmp30.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
						}
						tmp31 := tmp30.Get()
						tmp32 := lang.Apply(tmp31, []any{v3})
						tmp33 := lang.Apply(tmp28, []any{tmp32})
						if lang.IsTruthy(tmp33) {
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("str"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.Apply(tmp36, []any{"Invalid signature \"", v15, "\" should be a list"})
							tmp25 = tmp37
						} else {
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.Apply(tmp40, []any{"Parameter declaration \"", v15, "\" should be a vector"})
							tmp25 = tmp41
						}
						tmp42 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp25})
						panic(tmp42)
					}
					return tmp16
				})
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7508), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7517), lang.NewKeyword("end-column"), int(59))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp17 := lang.Apply(tmp13, []any{tmp16, v3})
				var v18 any = tmp17
				_ = v18
				// let binding "bad-args"
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("remove"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				var tmp25 lang.FnFunc
				tmp25 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v26 := args[0]
					_ = v26
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("vector?"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{v26})
					return tmp30
				})
				tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7519), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(7519), lang.NewKeyword("end-column"), int(42))
				tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp28 := lang.Apply(tmp24, []any{tmp27, v18})
				tmp29 := lang.Apply(tmp21, []any{tmp28})
				var v30 any = tmp29
				_ = v30
				var tmp31 any
				if lang.IsTruthy(v30) {
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("str"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("first"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{v30})
					tmp39 := lang.Apply(tmp34, []any{"Parameter declaration \"", tmp38, "\" should be a vector"})
					tmp40 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp39})
					panic(tmp40)
				} else {
				}
				tmp10 = tmp31
			} // end let
			return tmp10
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc
	{
		tmp0 := lang.NewSymbol("assoc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("val"), lang.NewSymbol("&"), lang.NewSymbol("kvs"))), lang.NewKeyword("doc"), "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(181), lang.NewKeyword("end-line"), int(188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function assoc
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 3:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					tmp7 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
					return tmp7
				default:
					if len(args) < 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
				recur_loop_24:
					var tmp8 any
					{ // let
						// let binding "ret"
						tmp9 := lang.Apply(lang.Assoc, []any{v4, v5, v6})
						var v10 any = tmp9
						_ = v10
						var tmp11 any
						if lang.IsTruthy(v7) {
							var tmp12 any
							tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
							if tmp14.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
							}
							tmp15 := tmp14.Get()
							tmp16 := lang.Apply(tmp15, []any{v7})
							if lang.IsTruthy(tmp16) {
								var tmp17 any = v10
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.Apply(tmp21, []any{v7})
								var tmp18 any = tmp22
								tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp25 := tmp24.FindInternedVar(lang.NewSymbol("second"))
								if tmp25.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
								}
								tmp26 := tmp25.Get()
								tmp27 := lang.Apply(tmp26, []any{v7})
								var tmp23 any = tmp27
								tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp30 := tmp29.FindInternedVar(lang.NewSymbol("nnext"))
								if tmp30.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
								}
								tmp31 := tmp30.Get()
								tmp32 := lang.Apply(tmp31, []any{v7})
								var tmp28 any = tmp32
								v4 = tmp17
								v5 = tmp18
								v6 = tmp23
								v7 = tmp28
								goto recur_loop_24
							} else {
								tmp33 := lang.Apply(lang.NewIllegalArgumentError, []any{"assoc expects even number of arguments after map/vector, found odd number"})
								panic(tmp33)
							}
							tmp11 = tmp12
						} else {
							tmp11 = v10
						}
						tmp8 = tmp11
					} // end let
					return tmp8
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(189), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(198), lang.NewKeyword("end-column"), int(15))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc!
	{
		tmp0 := lang.NewSymbol("assoc!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"), lang.NewSymbol("val")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"), lang.NewSymbol("val"), lang.NewSymbol("&"), lang.NewSymbol("kvs"))), lang.NewKeyword("doc"), "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3369), lang.NewKeyword("end-line"), int(3369))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Assoc")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
			recur_loop_609:
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8, _ := lang.FieldOrMethod(v3, "Assoc")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Assoc is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, v5})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v6) {
						var tmp12 any = v10
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("first"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v6})
						var tmp13 any = tmp17
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("second"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var tmp18 any = tmp22
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("nnext"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v6})
						var tmp23 any = tmp27
						v3 = tmp12
						v4 = tmp13
						v5 = tmp18
						v6 = tmp23
						goto recur_loop_609
					} else {
						tmp11 = v10
					}
					tmp7 = tmp11
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// assoc-in
	{
		tmp0 := lang.NewSymbol("assoc-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("&"), lang.NewSymbol("ks")), lang.NewSymbol("v"))), lang.NewKeyword("doc"), "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6147), lang.NewKeyword("end-line"), int(6147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "vec__138"
				var v7 any = v4
				_ = v7
				// let binding "seq__139"
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v7})
				var v12 any = tmp11
				_ = v12
				// let binding "first__140"
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("first"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v12})
				var v17 any = tmp16
				_ = v17
				// let binding "seq__139"
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("next"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{v12})
				var v22 any = tmp21
				_ = v22
				// let binding "k"
				var v23 any = v17
				_ = v23
				// let binding "ks"
				var v24 any = v22
				_ = v24
				var tmp25 any
				if lang.IsTruthy(v24) {
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("assoc"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("assoc-in"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("get"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v3, v23})
					tmp36 := lang.Apply(tmp31, []any{tmp35, v24, v5})
					tmp37 := lang.Apply(tmp28, []any{v3, v23, tmp36})
					tmp25 = tmp37
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("assoc"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp40, []any{v3, v23, v5})
					tmp25 = tmp41
				}
				tmp6 = tmp25
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// associative?
	{
		tmp0 := lang.NewSymbol("associative?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Associative", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6223), lang.NewKeyword("end-line"), int(6223))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// atom
	{
		tmp0 := lang.NewSymbol("atom").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2325), lang.NewKeyword("end-line"), int(2325))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewAtom, []any{v3})
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("setup-reference"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("atom"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				tmp12 := lang.Apply(tmp7, []any{tmp11, v4})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await
	{
		tmp0 := lang.NewSymbol("await").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("agents"))), lang.NewKeyword("doc"), "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3267), lang.NewKeyword("end-line"), int(3267))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp5) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*agent*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp10 := lang.Apply(errors5.New, []any{"Can't await in agent action"})
						panic(tmp10)
					} else {
					}
					_ = tmp6
					var tmp11 any
					{ // let
						// let binding "latch"
						var v12 any = "unimplemented: new with non-constant class type"
						_ = v12
						// let binding "count-down"
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v14 := args[0]
							_ = v14
							tmp15, _ := lang.FieldOrMethod(v12, "countDown")
							if reflect.TypeOf(tmp15).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp16 := lang.Apply(tmp15, []any{})
							_ = tmp16
							return v14
						})
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3279), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(3279), lang.NewKeyword("end-column"), int(61))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						{ // let
							// let binding "seq_1"
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.Apply(tmp20, []any{v3})
							var v22 any = tmp21
							_ = v22
							// let binding "chunk_2"
							var v23 any = nil
							_ = v23
							// let binding "count_3"
							var v24 any = int64(0)
							_ = v24
							// let binding "i_4"
							var v25 any = int64(0)
							_ = v25
							for {
								var tmp26 any
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("<"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{v25, v24})
								if lang.IsTruthy(tmp30) {
									var tmp31 any
									{ // let
										// let binding "agent"
										tmp32, _ := lang.FieldOrMethod(v23, "nth")
										if reflect.TypeOf(tmp32).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp33 := lang.Apply(tmp32, []any{v25})
										var v34 any = tmp33
										_ = v34
										tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp36 := tmp35.FindInternedVar(lang.NewSymbol("send"))
										if tmp36.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
										}
										tmp37 := tmp36.Get()
										tmp38 := lang.Apply(tmp37, []any{v34, v16})
										_ = tmp38
										var tmp39 any = v22
										var tmp40 any = v23
										var tmp41 any = v24
										tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp44 := tmp43.FindInternedVar(lang.NewSymbol("unchecked-inc"))
										if tmp44.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
										}
										tmp45 := tmp44.Get()
										tmp46 := lang.Apply(tmp45, []any{v25})
										var tmp42 any = tmp46
										v22 = tmp39
										v23 = tmp40
										v24 = tmp41
										v25 = tmp42
										continue
									} // end let
									tmp26 = tmp31
								} else {
									var tmp32 any
									{ // let
										// let binding "temp__0__auto__"
										tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp34 := tmp33.FindInternedVar(lang.NewSymbol("seq"))
										if tmp34.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
										}
										tmp35 := tmp34.Get()
										tmp36 := lang.Apply(tmp35, []any{v22})
										var v37 any = tmp36
										_ = v37
										var tmp38 any
										if lang.IsTruthy(v37) {
											var tmp39 any
											{ // let
												// let binding "seq_1"
												var v40 any = v37
												_ = v40
												var tmp41 any
												tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp43 := tmp42.FindInternedVar(lang.NewSymbol("chunked-seq?"))
												if tmp43.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
												}
												tmp44 := tmp43.Get()
												tmp45 := lang.Apply(tmp44, []any{v40})
												if lang.IsTruthy(tmp45) {
													var tmp46 any
													{ // let
														// let binding "c__0__auto__"
														tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp48 := tmp47.FindInternedVar(lang.NewSymbol("chunk-first"))
														if tmp48.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
														}
														tmp49 := tmp48.Get()
														tmp50 := lang.Apply(tmp49, []any{v40})
														var v51 any = tmp50
														_ = v51
														tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp54 := tmp53.FindInternedVar(lang.NewSymbol("chunk-rest"))
														if tmp54.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
														}
														tmp55 := tmp54.Get()
														tmp56 := lang.Apply(tmp55, []any{v40})
														var tmp52 any = tmp56
														var tmp57 any = v51
														tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp60 := tmp59.FindInternedVar(lang.NewSymbol("int"))
														if tmp60.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
														}
														tmp61 := tmp60.Get()
														tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp63 := tmp62.FindInternedVar(lang.NewSymbol("count"))
														if tmp63.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
														}
														tmp64 := tmp63.Get()
														tmp65 := lang.Apply(tmp64, []any{v51})
														tmp66 := lang.Apply(tmp61, []any{tmp65})
														var tmp58 any = tmp66
														tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp69 := tmp68.FindInternedVar(lang.NewSymbol("int"))
														if tmp69.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
														}
														tmp70 := tmp69.Get()
														tmp71 := lang.Apply(tmp70, []any{int64(0)})
														var tmp67 any = tmp71
														v22 = tmp52
														v23 = tmp57
														v24 = tmp58
														v25 = tmp67
														continue
													} // end let
													tmp41 = tmp46
												} else {
													var tmp47 any
													{ // let
														// let binding "agent"
														tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp49 := tmp48.FindInternedVar(lang.NewSymbol("first"))
														if tmp49.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
														}
														tmp50 := tmp49.Get()
														tmp51 := lang.Apply(tmp50, []any{v40})
														var v52 any = tmp51
														_ = v52
														tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp54 := tmp53.FindInternedVar(lang.NewSymbol("send"))
														if tmp54.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
														}
														tmp55 := tmp54.Get()
														tmp56 := lang.Apply(tmp55, []any{v52, v16})
														_ = tmp56
														tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp59 := tmp58.FindInternedVar(lang.NewSymbol("next"))
														if tmp59.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
														}
														tmp60 := tmp59.Get()
														tmp61 := lang.Apply(tmp60, []any{v40})
														var tmp57 any = tmp61
														var tmp62 any = nil
														var tmp63 any = int64(0)
														var tmp64 any = int64(0)
														v22 = tmp57
														v23 = tmp62
														v24 = tmp63
														v25 = tmp64
														continue
													} // end let
													tmp41 = tmp47
												}
												tmp39 = tmp41
											} // end let
											tmp38 = tmp39
										} else {
										}
										tmp32 = tmp38
									} // end let
									tmp26 = tmp32
								}
								tmp17 = tmp26
								break
							}
						} // end let
						_ = tmp17
						tmp18, _ := lang.FieldOrMethod(v12, "await")
						if reflect.TypeOf(tmp18).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp19 := lang.Apply(tmp18, []any{})
						tmp11 = tmp19
					} // end let
					tmp4 = tmp11
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await-for
	{
		tmp0 := lang.NewSymbol("await-for").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("timeout-ms"), lang.NewSymbol("&"), lang.NewSymbol("agents"))), lang.NewKeyword("doc"), "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3289), lang.NewKeyword("end-line"), int(3289))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := lang.Apply(nil, nil)
				if lang.IsTruthy(tmp6) {
					panic("unimplemented: new with non-constant class type")
				} else {
					var tmp7 any
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("*agent*"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.Apply(errors5.New, []any{"Can't await in agent action"})
						panic(tmp11)
					} else {
					}
					_ = tmp7
					var tmp12 any
					{ // let
						// let binding "latch"
						var v13 any = "unimplemented: new with non-constant class type"
						_ = v13
						// let binding "count-down"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v15 := args[0]
							_ = v15
							tmp16, _ := lang.FieldOrMethod(v13, "countDown")
							if reflect.TypeOf(tmp16).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("countDown is not a function")))
							}
							tmp17 := lang.Apply(tmp16, []any{})
							_ = tmp17
							return v15
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3301), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(3301), lang.NewKeyword("end-column"), int(62))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						{ // let
							// let binding "seq_5"
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.Apply(tmp21, []any{v4})
							var v23 any = tmp22
							_ = v23
							// let binding "chunk_6"
							var v24 any = nil
							_ = v24
							// let binding "count_7"
							var v25 any = int64(0)
							_ = v25
							// let binding "i_8"
							var v26 any = int64(0)
							_ = v26
							for {
								var tmp27 any
								tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp29 := tmp28.FindInternedVar(lang.NewSymbol("<"))
								if tmp29.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
								}
								tmp30 := tmp29.Get()
								tmp31 := lang.Apply(tmp30, []any{v26, v25})
								if lang.IsTruthy(tmp31) {
									var tmp32 any
									{ // let
										// let binding "agent"
										tmp33, _ := lang.FieldOrMethod(v24, "nth")
										if reflect.TypeOf(tmp33).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
										}
										tmp34 := lang.Apply(tmp33, []any{v26})
										var v35 any = tmp34
										_ = v35
										tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp37 := tmp36.FindInternedVar(lang.NewSymbol("send"))
										if tmp37.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
										}
										tmp38 := tmp37.Get()
										tmp39 := lang.Apply(tmp38, []any{v35, v17})
										_ = tmp39
										var tmp40 any = v23
										var tmp41 any = v24
										var tmp42 any = v25
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("unchecked-inc"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.Apply(tmp46, []any{v26})
										var tmp43 any = tmp47
										v23 = tmp40
										v24 = tmp41
										v25 = tmp42
										v26 = tmp43
										continue
									} // end let
									tmp27 = tmp32
								} else {
									var tmp33 any
									{ // let
										// let binding "temp__0__auto__"
										tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
										if tmp35.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
										}
										tmp36 := tmp35.Get()
										tmp37 := lang.Apply(tmp36, []any{v23})
										var v38 any = tmp37
										_ = v38
										var tmp39 any
										if lang.IsTruthy(v38) {
											var tmp40 any
											{ // let
												// let binding "seq_5"
												var v41 any = v38
												_ = v41
												var tmp42 any
												tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp44 := tmp43.FindInternedVar(lang.NewSymbol("chunked-seq?"))
												if tmp44.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
												}
												tmp45 := tmp44.Get()
												tmp46 := lang.Apply(tmp45, []any{v41})
												if lang.IsTruthy(tmp46) {
													var tmp47 any
													{ // let
														// let binding "c__0__auto__"
														tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp49 := tmp48.FindInternedVar(lang.NewSymbol("chunk-first"))
														if tmp49.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
														}
														tmp50 := tmp49.Get()
														tmp51 := lang.Apply(tmp50, []any{v41})
														var v52 any = tmp51
														_ = v52
														tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp55 := tmp54.FindInternedVar(lang.NewSymbol("chunk-rest"))
														if tmp55.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
														}
														tmp56 := tmp55.Get()
														tmp57 := lang.Apply(tmp56, []any{v41})
														var tmp53 any = tmp57
														var tmp58 any = v52
														tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp61 := tmp60.FindInternedVar(lang.NewSymbol("int"))
														if tmp61.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
														}
														tmp62 := tmp61.Get()
														tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp64 := tmp63.FindInternedVar(lang.NewSymbol("count"))
														if tmp64.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
														}
														tmp65 := tmp64.Get()
														tmp66 := lang.Apply(tmp65, []any{v52})
														tmp67 := lang.Apply(tmp62, []any{tmp66})
														var tmp59 any = tmp67
														tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp70 := tmp69.FindInternedVar(lang.NewSymbol("int"))
														if tmp70.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
														}
														tmp71 := tmp70.Get()
														tmp72 := lang.Apply(tmp71, []any{int64(0)})
														var tmp68 any = tmp72
														v23 = tmp53
														v24 = tmp58
														v25 = tmp59
														v26 = tmp68
														continue
													} // end let
													tmp42 = tmp47
												} else {
													var tmp48 any
													{ // let
														// let binding "agent"
														tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp50 := tmp49.FindInternedVar(lang.NewSymbol("first"))
														if tmp50.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
														}
														tmp51 := tmp50.Get()
														tmp52 := lang.Apply(tmp51, []any{v41})
														var v53 any = tmp52
														_ = v53
														tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp55 := tmp54.FindInternedVar(lang.NewSymbol("send"))
														if tmp55.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
														}
														tmp56 := tmp55.Get()
														tmp57 := lang.Apply(tmp56, []any{v53, v17})
														_ = tmp57
														tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp60 := tmp59.FindInternedVar(lang.NewSymbol("next"))
														if tmp60.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
														}
														tmp61 := tmp60.Get()
														tmp62 := lang.Apply(tmp61, []any{v41})
														var tmp58 any = tmp62
														var tmp63 any = nil
														var tmp64 any = int64(0)
														var tmp65 any = int64(0)
														v23 = tmp58
														v24 = tmp63
														v25 = tmp64
														v26 = tmp65
														continue
													} // end let
													tmp42 = tmp48
												}
												tmp40 = tmp42
											} // end let
											tmp39 = tmp40
										} else {
										}
										tmp33 = tmp39
									} // end let
									tmp27 = tmp33
								}
								tmp18 = tmp27
								break
							}
						} // end let
						_ = tmp18
						tmp19, ok := lang.FieldOrMethod(nil, "MILLISECONDS")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "MILLISECONDS")))
						}
						var tmp20 any
						switch reflect.TypeOf(tmp19).Kind() {
						case reflect.Func:
							tmp20 = lang.Apply(tmp19, nil)
						default:
							tmp20 = tmp19
						}
						tmp21, _ := lang.FieldOrMethod(v13, "await")
						if reflect.TypeOf(tmp21).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
						}
						tmp22 := lang.Apply(tmp21, []any{v3, tmp20})
						tmp12 = tmp22
					} // end let
					tmp5 = tmp12
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// await1
	{
		tmp0 := lang.NewSymbol("await1").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3284), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(3284), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("pos?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8, ok := lang.FieldOrMethod(v3, "getQueueCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getQueueCount")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			tmp10 := lang.Apply(tmp7, []any{tmp9})
			if lang.IsTruthy(tmp10) {
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("await"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp4 = tmp14
			} else {
			}
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bases
	{
		tmp0 := lang.NewSymbol("bases").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"))), lang.NewKeyword("doc"), "Returns the immediate superclass and direct interfaces of c, if any", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5522), lang.NewKeyword("end-line"), int(5522))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			if lang.IsTruthy(v3) {
				var tmp5 any
				{ // let
					// let binding "i"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(tmp8, []any{nil})
					var v10 any = tmp9
					_ = v10
					// let binding "s"
					var v11 any = nil
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("cons"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v11, v10})
						tmp12 = tmp16
					} else {
						tmp12 = v10
					}
					tmp5 = tmp12
				} // end let
				tmp4 = tmp5
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigdec
	{
		tmp1 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp0 := lang.NewSymbol("bigdec").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigDecimal", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3648), lang.NewKeyword("end-line"), int(3648))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("decimal?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v4})
			if lang.IsTruthy(tmp9) {
				tmp5 = v4
			} else {
				var tmp10 any
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("float?"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v4})
				if lang.IsTruthy(tmp14) {
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("double"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v4})
					tmp19 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp18})
					tmp10 = tmp19
				} else {
					var tmp20 any
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("ratio?"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v4})
					if lang.IsTruthy(tmp24) {
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("/"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(lang.NewBigDecimalFromRatio, []any{v4})
						tmp29, ok := lang.FieldOrMethod(v4, "denominator")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
						}
						var tmp30 any
						switch reflect.TypeOf(tmp29).Kind() {
						case reflect.Func:
							tmp30 = lang.Apply(tmp29, nil)
						default:
							tmp30 = tmp29
						}
						tmp31 := lang.Apply(tmp27, []any{tmp28, tmp30})
						tmp20 = tmp31
					} else {
						var tmp32 any
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := reflect.TypeOf((*lang.BigInt)(nil))
						tmp37 := lang.Apply(tmp35, []any{tmp36, v4})
						if lang.IsTruthy(tmp37) {
							tmp38, ok := lang.FieldOrMethod(v4, "toBigDecimal")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigDecimal")))
							}
							var tmp39 any
							switch reflect.TypeOf(tmp38).Kind() {
							case reflect.Func:
								tmp39 = lang.Apply(tmp38, nil)
							default:
								tmp39 = tmp38
							}
							tmp32 = tmp39
						} else {
							var tmp40 any
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("instance?"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := reflect.TypeOf((*big6.Int)(nil))
							tmp45 := lang.Apply(tmp43, []any{tmp44, v4})
							if lang.IsTruthy(tmp45) {
								tmp46 := lang.Apply(lang.NewBigDecimal, []any{v4})
								tmp40 = tmp46
							} else {
								var tmp47 any
								tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp49 := tmp48.FindInternedVar(lang.NewSymbol("number?"))
								if tmp49.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
								}
								tmp50 := tmp49.Get()
								tmp51 := lang.Apply(tmp50, []any{v4})
								if lang.IsTruthy(tmp51) {
									tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp53 := tmp52.FindInternedVar(lang.NewSymbol("long"))
									if tmp53.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
									}
									tmp54 := tmp53.Get()
									tmp55 := lang.Apply(tmp54, []any{v4})
									tmp56 := lang.Apply(lang.NewBigDecimalFromInt64, []any{tmp55})
									tmp47 = tmp56
								} else {
									var tmp57 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp58 := lang.Apply(lang.NewBigDecimal, []any{v4})
										tmp57 = tmp58
									} else {
									}
									tmp47 = tmp57
								}
								tmp40 = tmp47
							}
							tmp32 = tmp40
						}
						tmp20 = tmp32
					}
					tmp10 = tmp20
				}
				tmp5 = tmp10
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigDecimal)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bigint
	{
		tmp1 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp0 := lang.NewSymbol("bigint").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigInt", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3620), lang.NewKeyword("end-line"), int(3620))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := reflect.TypeOf((*lang.BigInt)(nil))
			tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
			if lang.IsTruthy(tmp10) {
				tmp5 = v4
			} else {
				var tmp11 any
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := reflect.TypeOf((*big6.Int)(nil))
				tmp16 := lang.Apply(tmp14, []any{tmp15, v4})
				if lang.IsTruthy(tmp16) {
					tmp17 := lang.Apply(lang.NewBigIntFromGoBigInt, []any{v4})
					tmp11 = tmp17
				} else {
					var tmp18 any
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("decimal?"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v4})
					if lang.IsTruthy(tmp22) {
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("bigint"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp27 any
						switch reflect.TypeOf(tmp26).Kind() {
						case reflect.Func:
							tmp27 = lang.Apply(tmp26, nil)
						default:
							tmp27 = tmp26
						}
						tmp28 := lang.Apply(tmp25, []any{tmp27})
						tmp18 = tmp28
					} else {
						var tmp29 any
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("float?"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.Apply(tmp32, []any{v4})
						if lang.IsTruthy(tmp33) {
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("bigint"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("double"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.Apply(tmp39, []any{v4})
							tmp41 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp40})
							tmp42 := lang.Apply(tmp36, []any{tmp41})
							tmp29 = tmp42
						} else {
							var tmp43 any
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("ratio?"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.Apply(tmp46, []any{v4})
							if lang.IsTruthy(tmp47) {
								tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp49 := tmp48.FindInternedVar(lang.NewSymbol("bigint"))
								if tmp49.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
								}
								tmp50 := tmp49.Get()
								tmp51, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp52 any
								switch reflect.TypeOf(tmp51).Kind() {
								case reflect.Func:
									tmp52 = lang.Apply(tmp51, nil)
								default:
									tmp52 = tmp51
								}
								tmp53 := lang.Apply(tmp50, []any{tmp52})
								tmp43 = tmp53
							} else {
								var tmp54 any
								tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp56 := tmp55.FindInternedVar(lang.NewSymbol("number?"))
								if tmp56.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
								}
								tmp57 := tmp56.Get()
								tmp58 := lang.Apply(tmp57, []any{v4})
								if lang.IsTruthy(tmp58) {
									tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp60 := tmp59.FindInternedVar(lang.NewSymbol("long"))
									if tmp60.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
									}
									tmp61 := tmp60.Get()
									tmp62 := lang.Apply(tmp61, []any{v4})
									tmp63 := lang.Apply(lang.NewBigIntFromInt64, []any{tmp62})
									tmp54 = tmp63
								} else {
									var tmp64 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp66 := tmp65.FindInternedVar(lang.NewSymbol("bigint"))
										if tmp66.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
										}
										tmp67 := tmp66.Get()
										tmp68 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp69 := lang.Apply(tmp67, []any{tmp68})
										tmp64 = tmp69
									} else {
									}
									tmp54 = tmp64
								}
								tmp43 = tmp54
							}
							tmp29 = tmp43
						}
						tmp18 = tmp29
					}
					tmp11 = tmp18
				}
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.BigInt)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// biginteger
	{
		tmp1 := reflect.TypeOf((*big6.Int)(nil))
		tmp0 := lang.NewSymbol("biginteger").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Coerce to BigInteger", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3634), lang.NewKeyword("end-line"), int(3634))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := reflect.TypeOf((*big6.Int)(nil))
			tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
			if lang.IsTruthy(tmp10) {
				tmp5 = v4
			} else {
				var tmp11 any
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := reflect.TypeOf((*lang.BigInt)(nil))
				tmp16 := lang.Apply(tmp14, []any{tmp15, v4})
				if lang.IsTruthy(tmp16) {
					tmp17, ok := lang.FieldOrMethod(v4, "toBigInteger")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
					}
					var tmp18 any
					switch reflect.TypeOf(tmp17).Kind() {
					case reflect.Func:
						tmp18 = lang.Apply(tmp17, nil)
					default:
						tmp18 = tmp17
					}
					tmp11 = tmp18
				} else {
					var tmp19 any
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("decimal?"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{v4})
					if lang.IsTruthy(tmp23) {
						tmp24, ok := lang.FieldOrMethod(v4, "toBigInteger")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toBigInteger")))
						}
						var tmp25 any
						switch reflect.TypeOf(tmp24).Kind() {
						case reflect.Func:
							tmp25 = lang.Apply(tmp24, nil)
						default:
							tmp25 = tmp24
						}
						tmp19 = tmp25
					} else {
						var tmp26 any
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("float?"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{v4})
						if lang.IsTruthy(tmp30) {
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("double"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.Apply(tmp33, []any{v4})
							tmp35 := lang.Apply(lang.NewBigDecimalFromFloat64, []any{tmp34})
							tmp36, ok := lang.FieldOrMethod(tmp35, "toBigInteger")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp35, "toBigInteger")))
							}
							var tmp37 any
							switch reflect.TypeOf(tmp36).Kind() {
							case reflect.Func:
								tmp37 = lang.Apply(tmp36, nil)
							default:
								tmp37 = tmp36
							}
							tmp26 = tmp37
						} else {
							var tmp38 any
							tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp40 := tmp39.FindInternedVar(lang.NewSymbol("ratio?"))
							if tmp40.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
							}
							tmp41 := tmp40.Get()
							tmp42 := lang.Apply(tmp41, []any{v4})
							if lang.IsTruthy(tmp42) {
								tmp43, ok := lang.FieldOrMethod(v4, "bigIntegerValue")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "bigIntegerValue")))
								}
								var tmp44 any
								switch reflect.TypeOf(tmp43).Kind() {
								case reflect.Func:
									tmp44 = lang.Apply(tmp43, nil)
								default:
									tmp44 = tmp43
								}
								tmp38 = tmp44
							} else {
								var tmp45 any
								tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp47 := tmp46.FindInternedVar(lang.NewSymbol("number?"))
								if tmp47.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
								}
								tmp48 := tmp47.Get()
								tmp49 := lang.Apply(tmp48, []any{v4})
								if lang.IsTruthy(tmp49) {
									tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp51 := tmp50.FindInternedVar(lang.NewSymbol("long"))
									if tmp51.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
									}
									tmp52 := tmp51.Get()
									tmp53 := lang.Apply(tmp52, []any{v4})
									tmp54 := lang.Apply(big6.NewInt, []any{tmp53})
									tmp45 = tmp54
								} else {
									var tmp55 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp56 := lang.Apply(lang.NewBigInt, []any{v4})
										tmp55 = tmp56
									} else {
									}
									tmp45 = tmp55
								}
								tmp38 = tmp45
							}
							tmp26 = tmp38
						}
						tmp19 = tmp26
					}
					tmp11 = tmp19
				}
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*big6.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding
	{
		tmp0 := lang.NewSymbol("binding").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1945), lang.NewKeyword("end-line"), int(1945))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "var-ize"
					var tmp56 lang.FnFunc
					tmp56 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v57 := args[0]
						_ = v57
						var tmp58 any
						{ // let
							// let binding "ret"
							tmp59 := lang.NewVector()
							tmp60 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1959), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(1959), lang.NewKeyword("end-column"), int(31))
							tmp61, err := lang.WithMeta(tmp59, tmp60.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v62 any = tmp61
							_ = v62
							// let binding "vvs"
							tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
							if tmp64.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
							}
							tmp65 := tmp64.Get()
							tmp66 := lang.Apply(tmp65, []any{v57})
							var v67 any = tmp66
							_ = v67
							for {
								var tmp68 any
								if lang.IsTruthy(v67) {
									tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp71 := tmp70.FindInternedVar(lang.NewSymbol("conj"))
									if tmp71.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
									}
									tmp72 := tmp71.Get()
									tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp74 := tmp73.FindInternedVar(lang.NewSymbol("conj"))
									if tmp74.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
									}
									tmp75 := tmp74.Get()
									tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp77 := tmp76.FindInternedVar(lang.NewSymbol("seq"))
									if tmp77.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
									}
									tmp78 := tmp77.Get()
									tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp80 := tmp79.FindInternedVar(lang.NewSymbol("concat"))
									if tmp80.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
									}
									tmp81 := tmp80.Get()
									tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp83 := tmp82.FindInternedVar(lang.NewSymbol("list"))
									if tmp83.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
									}
									tmp84 := tmp83.Get()
									tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("var")})
									tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp87 := tmp86.FindInternedVar(lang.NewSymbol("list"))
									if tmp87.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
									}
									tmp88 := tmp87.Get()
									tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp90 := tmp89.FindInternedVar(lang.NewSymbol("first"))
									if tmp90.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
									}
									tmp91 := tmp90.Get()
									tmp92 := lang.Apply(tmp91, []any{v67})
									tmp93 := lang.Apply(tmp88, []any{tmp92})
									tmp94 := lang.Apply(tmp81, []any{tmp85, tmp93})
									tmp95 := lang.Apply(tmp78, []any{tmp94})
									tmp96 := lang.Apply(tmp75, []any{v62, tmp95})
									tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp98 := tmp97.FindInternedVar(lang.NewSymbol("second"))
									if tmp98.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
									}
									tmp99 := tmp98.Get()
									tmp100 := lang.Apply(tmp99, []any{v67})
									tmp101 := lang.Apply(tmp72, []any{tmp96, tmp100})
									var tmp69 any = tmp101
									tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp104 := tmp103.FindInternedVar(lang.NewSymbol("next"))
									if tmp104.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
									}
									tmp105 := tmp104.Get()
									tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp107 := tmp106.FindInternedVar(lang.NewSymbol("next"))
									if tmp107.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
									}
									tmp108 := tmp107.Get()
									tmp109 := lang.Apply(tmp108, []any{v67})
									tmp110 := lang.Apply(tmp105, []any{tmp109})
									var tmp102 any = tmp110
									v62 = tmp69
									v67 = tmp102
									continue
								} else {
									tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp112 := tmp111.FindInternedVar(lang.NewSymbol("seq"))
									if tmp112.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
									}
									tmp113 := tmp112.Get()
									tmp114 := lang.Apply(tmp113, []any{v62})
									tmp68 = tmp114
								}
								tmp58 = tmp68
								break
							}
						} // end let
						return tmp58
					})
					tmp57 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1958), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(1963), lang.NewKeyword("end-column"), int(34))
					tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v59 any = tmp58
					_ = v59
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("concat"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/let")})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("apply"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("vector"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("seq"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp83 := tmp82.FindInternedVar(lang.NewSymbol("concat"))
					if tmp83.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
					}
					tmp84 := tmp83.Get()
					tmp85 := lang.Apply(tmp84, nil)
					tmp86 := lang.Apply(tmp81, []any{tmp85})
					tmp87 := lang.Apply(tmp75, []any{tmp78, tmp86})
					tmp88 := lang.Apply(tmp72, []any{tmp87})
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp93 := tmp92.FindInternedVar(lang.NewSymbol("seq"))
					if tmp93.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
					}
					tmp94 := tmp93.Get()
					tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp96 := tmp95.FindInternedVar(lang.NewSymbol("concat"))
					if tmp96.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
					}
					tmp97 := tmp96.Get()
					tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp99 := tmp98.FindInternedVar(lang.NewSymbol("list"))
					if tmp99.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
					}
					tmp100 := tmp99.Get()
					tmp101 := lang.Apply(tmp100, []any{lang.NewSymbol("glojure.core/push-thread-bindings")})
					tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
					if tmp103.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
					}
					tmp104 := tmp103.Get()
					tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp106 := tmp105.FindInternedVar(lang.NewSymbol("seq"))
					if tmp106.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
					}
					tmp107 := tmp106.Get()
					tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp109 := tmp108.FindInternedVar(lang.NewSymbol("concat"))
					if tmp109.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
					}
					tmp110 := tmp109.Get()
					tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp112 := tmp111.FindInternedVar(lang.NewSymbol("list"))
					if tmp112.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
					}
					tmp113 := tmp112.Get()
					tmp114 := lang.Apply(tmp113, []any{lang.NewSymbol("glojure.core/hash-map")})
					tmp115 := lang.Apply(v59, []any{v5})
					tmp116 := lang.Apply(tmp110, []any{tmp114, tmp115})
					tmp117 := lang.Apply(tmp107, []any{tmp116})
					tmp118 := lang.Apply(tmp104, []any{tmp117})
					tmp119 := lang.Apply(tmp97, []any{tmp101, tmp118})
					tmp120 := lang.Apply(tmp94, []any{tmp119})
					tmp121 := lang.Apply(tmp91, []any{tmp120})
					tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
					if tmp123.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
					}
					tmp124 := tmp123.Get()
					tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp126 := tmp125.FindInternedVar(lang.NewSymbol("seq"))
					if tmp126.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
					}
					tmp127 := tmp126.Get()
					tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp129 := tmp128.FindInternedVar(lang.NewSymbol("concat"))
					if tmp129.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
					}
					tmp130 := tmp129.Get()
					tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
					if tmp132.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
					}
					tmp133 := tmp132.Get()
					tmp134 := lang.Apply(tmp133, []any{lang.NewSymbol("try")})
					tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp136 := tmp135.FindInternedVar(lang.NewSymbol("list"))
					if tmp136.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
					}
					tmp137 := tmp136.Get()
					tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp139 := tmp138.FindInternedVar(lang.NewSymbol("seq"))
					if tmp139.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
					}
					tmp140 := tmp139.Get()
					tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp142 := tmp141.FindInternedVar(lang.NewSymbol("concat"))
					if tmp142.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
					}
					tmp143 := tmp142.Get()
					tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp145 := tmp144.FindInternedVar(lang.NewSymbol("list"))
					if tmp145.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
					}
					tmp146 := tmp145.Get()
					tmp147 := lang.Apply(tmp146, []any{lang.NewSymbol("finally")})
					tmp148 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp149 := tmp148.FindInternedVar(lang.NewSymbol("list"))
					if tmp149.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp149)))
					}
					tmp150 := tmp149.Get()
					tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp152 := tmp151.FindInternedVar(lang.NewSymbol("seq"))
					if tmp152.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
					}
					tmp153 := tmp152.Get()
					tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp155 := tmp154.FindInternedVar(lang.NewSymbol("concat"))
					if tmp155.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
					}
					tmp156 := tmp155.Get()
					tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp158 := tmp157.FindInternedVar(lang.NewSymbol("list"))
					if tmp158.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
					}
					tmp159 := tmp158.Get()
					tmp160 := lang.Apply(tmp159, []any{lang.NewSymbol("glojure.core/pop-thread-bindings")})
					tmp161 := lang.Apply(tmp156, []any{tmp160})
					tmp162 := lang.Apply(tmp153, []any{tmp161})
					tmp163 := lang.Apply(tmp150, []any{tmp162})
					tmp164 := lang.Apply(tmp143, []any{tmp147, tmp163})
					tmp165 := lang.Apply(tmp140, []any{tmp164})
					tmp166 := lang.Apply(tmp137, []any{tmp165})
					tmp167 := lang.Apply(tmp130, []any{tmp134, v6, tmp166})
					tmp168 := lang.Apply(tmp127, []any{tmp167})
					tmp169 := lang.Apply(tmp124, []any{tmp168})
					tmp170 := lang.Apply(tmp65, []any{tmp69, tmp88, tmp121, tmp169})
					tmp171 := lang.Apply(tmp62, []any{tmp170})
					tmp55 = tmp171
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// binding-conveyor-fn
	{
		tmp0 := lang.NewSymbol("binding-conveyor-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2020), lang.NewKeyword("end-line"), int(2020), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "frame"
				tmp5 := lang.Apply(lang.CloneThreadBindingFrame, nil)
				var v6 any = tmp5
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp8
						tmp9 := lang.Apply(v3, nil)
						return tmp9
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp9
						tmp10 := lang.Apply(v3, []any{v8})
						return tmp10
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp10
						tmp11 := lang.Apply(v3, []any{v8, v9})
						return tmp11
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp11
						tmp12 := lang.Apply(v3, []any{v8, v9, v10})
						return tmp12
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := lang.Apply(lang.ResetThreadBindingFrame, []any{v6})
						_ = tmp12
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("apply"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v3, v8, v9, v10, v11})
						return tmp16
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2025), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2040), lang.NewKeyword("end-column"), int(31))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp9
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed10
					} else {
						tmp4 = closed10
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed10
					} else {
						tmp5 = closed10
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed10
					} else {
						tmp6 = closed10
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-and").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise and", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1298), lang.NewKeyword("end-line"), int(1298))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "And")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("And is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("bit-and"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("bit-and"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-and-not
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed11
					} else {
						tmp4 = closed11
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed11
					} else {
						tmp5 = closed11
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed11
					} else {
						tmp6 = closed11
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-and-not").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise and with complement", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1325), lang.NewKeyword("end-line"), int(1325))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "AndNot")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("AndNot is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("bit-and-not"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("bit-and-not"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-clear
	{
		tmp0 := lang.NewSymbol("bit-clear").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Clear bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1336), lang.NewKeyword("end-line"), int(1336))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ClearBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ClearBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-flip
	{
		tmp0 := lang.NewSymbol("bit-flip").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Flip bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1348), lang.NewKeyword("end-line"), int(1348))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FlipBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FlipBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-not
	{
		var tmp1 lang.FnFunc
		{ // function bit-not__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Not")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-not").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise complement", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1291), lang.NewKeyword("end-line"), int(1291))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Not")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Not is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-or
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed12
					} else {
						tmp4 = closed12
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed12
					} else {
						tmp5 = closed12
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed12
					} else {
						tmp6 = closed12
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-or").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise or", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1307), lang.NewKeyword("end-line"), int(1307))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Or")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Or is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("bit-or"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("bit-or"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-set
	{
		tmp0 := lang.NewSymbol("bit-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Set bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1342), lang.NewKeyword("end-line"), int(1342))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "SetBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("SetBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-left
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-left__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/ShiftLeft")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-shift-left").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift left", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1361), lang.NewKeyword("end-line"), int(1361))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftLeft")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftLeft is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/ShiftRight")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bit-shift-right").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift right", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1367), lang.NewKeyword("end-line"), int(1367))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-test
	{
		tmp0 := lang.NewSymbol("bit-test").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Test bit at index n", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1354), lang.NewKeyword("end-line"), int(1354))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "TestBit")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("TestBit is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bit-xor
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed13
					} else {
						tmp4 = closed13
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed13
					} else {
						tmp5 = closed13
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed13
					} else {
						tmp6 = closed13
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("bit-xor").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise exclusive or", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1316), lang.NewKeyword("end-line"), int(1316))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Xor")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Xor is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("bit-xor"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("bit-xor"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean
	{
		var tmp1 lang.FnFunc
		{ // function boolean__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/BooleanCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to boolean", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1601), lang.NewKeyword("end-line"), int(1601))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "BooleanCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean-array
	{
		var tmp1 lang.FnFunc
		{ // function boolean-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/BooleanArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("boolean-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of booleans", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5309), lang.NewKeyword("end-line"), int(5309))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "BooleanArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("BooleanArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// boolean?
	{
		tmp0 := lang.NewSymbol("boolean?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Boolean", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(518), lang.NewKeyword("end-line"), int(518))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{lang.Builtins["bool"], v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// booleans
	{
		var tmp1 lang.FnFunc
		{ // function booleans
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Booleans")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("booleans").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to boolean[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5372), lang.NewKeyword("end-line"), int(5372))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Booleans")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Booleans is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn
	{
		tmp0 := lang.NewSymbol("bound-fn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("fntail"))), lang.NewKeyword("doc"), "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2004), lang.NewKeyword("end-line"), int(2004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/bound-fn*")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("concat"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("glojure.core/fn")})
				tmp29 := lang.Apply(tmp24, []any{tmp28, v5})
				tmp30 := lang.Apply(tmp21, []any{tmp29})
				tmp31 := lang.Apply(tmp18, []any{tmp30})
				tmp32 := lang.Apply(tmp11, []any{tmp15, tmp31})
				tmp33 := lang.Apply(tmp8, []any{tmp32})
				return tmp33
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound-fn*
	{
		tmp0 := lang.NewSymbol("bound-fn*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1992), lang.NewKeyword("end-line"), int(1992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bindings"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("get-thread-bindings"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, nil)
				var v9 any = tmp8
				_ = v9
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v11 any = lang.NewList(args[0:]...)
						_ = v11
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("apply"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("with-bindings*"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp14, []any{tmp17, v9, v3, v11})
						return tmp18
					}
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2001), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2002), lang.NewKeyword("end-column"), int(45))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bound?
	{
		tmp0 := lang.NewSymbol("bound?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("vars"))), lang.NewKeyword("doc"), "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5491), lang.NewKeyword("end-line"), int(5491))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("every?"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					tmp9, ok := lang.FieldOrMethod(v8, "isBound")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "isBound")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					return tmp10
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5497), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5497), lang.NewKeyword("end-column"), int(69))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bounded-count
	{
		tmp0 := lang.NewSymbol("bounded-count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7410), lang.NewKeyword("end-line"), int(7410))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("counted?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v4})
			if lang.IsTruthy(tmp9) {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("count"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v4})
				tmp5 = tmp13
			} else {
				var tmp14 any
				{ // let
					// let binding "i"
					var v15 any = int64(0)
					_ = v15
					// let binding "s"
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("seq"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v4})
					var v20 any = tmp19
					_ = v20
					for {
						var tmp21 any
						var tmp22 any
						{ // let
							// let binding "and__0__auto__"
							var v23 any = v20
							_ = v23
							var tmp24 any
							if lang.IsTruthy(v23) {
								tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp26 := tmp25.FindInternedVar(lang.NewSymbol("<"))
								if tmp26.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
								}
								tmp27 := tmp26.Get()
								tmp28 := lang.Apply(tmp27, []any{v15, v3})
								tmp24 = tmp28
							} else {
								tmp24 = v23
							}
							tmp22 = tmp24
						} // end let
						if lang.IsTruthy(tmp22) {
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("inc"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{v15})
							var tmp23 any = tmp27
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("next"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v20})
							var tmp28 any = tmp32
							v15 = tmp23
							v20 = tmp28
							continue
						} else {
							tmp21 = v15
						}
						tmp14 = tmp21
						break
					}
				} // end let
				tmp5 = tmp14
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// butlast
	{
		tmp0 := lang.NewSymbol("butlast").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a seq of all but the last item in coll, in linear time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(272), lang.NewKeyword("end-line"), int(276))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function butlast
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ret"
					tmp6 := lang.NewVector()
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(277), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(277), lang.NewKeyword("end-column"), int(24))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					// let binding "s"
					var v10 any = v4
					_ = v10
					for {
						var tmp11 any
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("next"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v10})
						if lang.IsTruthy(tmp15) {
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("conj"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("first"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{v10})
							tmp24 := lang.Apply(tmp19, []any{v9, tmp23})
							var tmp16 any = tmp24
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("next"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.Apply(tmp28, []any{v10})
							var tmp25 any = tmp29
							v9 = tmp16
							v10 = tmp25
							continue
						} else {
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.Apply(tmp32, []any{v9})
							tmp11 = tmp33
						}
						tmp5 = tmp11
						break
					}
				} // end let
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(276), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(280), lang.NewKeyword("end-column"), int(27))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte
	{
		var tmp1 lang.FnFunc
		{ // function byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("uncheckedByteCast")
				} else {
					tmp30 = lang.NewSymbol("byteCast")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to byte", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3505), lang.NewKeyword("end-line"), int(3505))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// byte-array
	{
		var tmp1 lang.FnFunc
		{ // function byte-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/ByteArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("byte-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of bytes", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5317), lang.NewKeyword("end-line"), int(5317))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ByteArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ByteArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ByteArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes
	{
		var tmp1 lang.FnFunc
		{ // function bytes
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Bytes")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("bytes").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to bytes[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5377), lang.NewKeyword("end-line"), int(5377))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Bytes")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Bytes is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// bytes?
	{
		tmp0 := lang.NewSymbol("bytes?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a byte array", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5412), lang.NewKeyword("end-line"), int(5412))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp4 = false
			} else {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("="))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("class"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16, ok := lang.FieldOrMethod(tmp15, "getComponentType")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp15, "getComponentType")))
				}
				var tmp17 any
				switch reflect.TypeOf(tmp16).Kind() {
				case reflect.Func:
					tmp17 = lang.Apply(tmp16, nil)
				default:
					tmp17 = tmp16
				}
				tmp18 := lang.Apply(tmp11, []any{tmp17, nil})
				tmp4 = tmp18
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case
	{
		tmp0 := lang.NewSymbol("case").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6712), lang.NewKeyword("end-line"), int(6712))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ge"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, nil)
					tmp15 := reflect.TypeOf((*lang.Object)(nil)).Elem()
					tmp16 := lang.NewMap(lang.NewKeyword("tag"), tmp15)
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6738), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(6738), lang.NewKeyword("end-column"), int(84))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp10, []any{tmp14, tmp18})
					var v20 any = tmp19
					_ = v20
					// let binding "default"
					var tmp21 any
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("odd?"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("count"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.Apply(tmp27, []any{v6})
					tmp29 := lang.Apply(tmp24, []any{tmp28})
					if lang.IsTruthy(tmp29) {
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("last"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.Apply(tmp32, []any{v6})
						tmp21 = tmp33
					} else {
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol("throw")})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
						if tmp48.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
						}
						tmp49 := tmp48.Get()
						tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
						if tmp51.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
						}
						tmp52 := tmp51.Get()
						tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
						if tmp54.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
						}
						tmp55 := tmp54.Get()
						tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
						tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
						if tmp58.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
						}
						tmp59 := tmp58.Get()
						tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
						if tmp61.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
						}
						tmp62 := tmp61.Get()
						tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp64 := tmp63.FindInternedVar(lang.NewSymbol("concat"))
						if tmp64.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
						}
						tmp65 := tmp64.Get()
						tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
						if tmp67.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
						}
						tmp68 := tmp67.Get()
						tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/str")})
						tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
						if tmp71.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
						}
						tmp72 := tmp71.Get()
						tmp73 := lang.Apply(tmp72, []any{"No matching clause: "})
						tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
						if tmp75.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
						}
						tmp76 := tmp75.Get()
						tmp77 := lang.Apply(tmp76, []any{v20})
						tmp78 := lang.Apply(tmp65, []any{tmp69, tmp73, tmp77})
						tmp79 := lang.Apply(tmp62, []any{tmp78})
						tmp80 := lang.Apply(tmp59, []any{tmp79})
						tmp81 := lang.Apply(tmp52, []any{tmp56, tmp80})
						tmp82 := lang.Apply(tmp49, []any{tmp81})
						tmp83 := lang.Apply(tmp46, []any{tmp82})
						tmp84 := lang.Apply(tmp39, []any{tmp43, tmp83})
						tmp85 := lang.Apply(tmp36, []any{tmp84})
						tmp21 = tmp85
					}
					var v86 any = tmp21
					_ = v86
					var tmp87 any
					tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp89 := tmp88.FindInternedVar(lang.NewSymbol(">"))
					if tmp89.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
					}
					tmp90 := tmp89.Get()
					tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp92 := tmp91.FindInternedVar(lang.NewSymbol("count"))
					if tmp92.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
					}
					tmp93 := tmp92.Get()
					tmp94 := lang.Apply(tmp93, []any{v6})
					tmp95 := lang.Apply(tmp90, []any{int64(2), tmp94})
					if lang.IsTruthy(tmp95) {
						tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp97 := tmp96.FindInternedVar(lang.NewSymbol("seq"))
						if tmp97.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
						}
						tmp98 := tmp97.Get()
						tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp100 := tmp99.FindInternedVar(lang.NewSymbol("concat"))
						if tmp100.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
						}
						tmp101 := tmp100.Get()
						tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
						if tmp103.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
						}
						tmp104 := tmp103.Get()
						tmp105 := lang.Apply(tmp104, []any{lang.NewSymbol("glojure.core/let")})
						tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
						if tmp107.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
						}
						tmp108 := tmp107.Get()
						tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp110 := tmp109.FindInternedVar(lang.NewSymbol("apply"))
						if tmp110.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
						}
						tmp111 := tmp110.Get()
						tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp113 := tmp112.FindInternedVar(lang.NewSymbol("vector"))
						if tmp113.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
						}
						tmp114 := tmp113.Get()
						tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp116 := tmp115.FindInternedVar(lang.NewSymbol("seq"))
						if tmp116.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
						}
						tmp117 := tmp116.Get()
						tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp119 := tmp118.FindInternedVar(lang.NewSymbol("concat"))
						if tmp119.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
						}
						tmp120 := tmp119.Get()
						tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp122 := tmp121.FindInternedVar(lang.NewSymbol("list"))
						if tmp122.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
						}
						tmp123 := tmp122.Get()
						tmp124 := lang.Apply(tmp123, []any{v20})
						tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp126 := tmp125.FindInternedVar(lang.NewSymbol("list"))
						if tmp126.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
						}
						tmp127 := tmp126.Get()
						tmp128 := lang.Apply(tmp127, []any{v5})
						tmp129 := lang.Apply(tmp120, []any{tmp124, tmp128})
						tmp130 := lang.Apply(tmp117, []any{tmp129})
						tmp131 := lang.Apply(tmp111, []any{tmp114, tmp130})
						tmp132 := lang.Apply(tmp108, []any{tmp131})
						tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp134 := tmp133.FindInternedVar(lang.NewSymbol("list"))
						if tmp134.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
						}
						tmp135 := tmp134.Get()
						tmp136 := lang.Apply(tmp135, []any{v86})
						tmp137 := lang.Apply(tmp101, []any{tmp105, tmp132, tmp136})
						tmp138 := lang.Apply(tmp98, []any{tmp137})
						tmp87 = tmp138
					} else {
						var tmp139 any
						{ // let
							// let binding "pairs"
							tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp141 := tmp140.FindInternedVar(lang.NewSymbol("partition"))
							if tmp141.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
							}
							tmp142 := tmp141.Get()
							tmp143 := lang.Apply(tmp142, []any{int64(2), v6})
							var v144 any = tmp143
							_ = v144
							// let binding "assoc-test"
							var tmp145 lang.FnFunc
							{ // function assoc-test
								var v146 lang.FnFunc
								tmp145 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 3 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v147 := args[0]
									_ = v147
									v148 := args[1]
									_ = v148
									v149 := args[2]
									_ = v149
									var tmp150 any
									tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp152 := tmp151.FindInternedVar(lang.NewSymbol("contains?"))
									if tmp152.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
									}
									tmp153 := tmp152.Get()
									tmp154 := lang.Apply(tmp153, []any{v147, v148})
									if lang.IsTruthy(tmp154) {
										tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp156 := tmp155.FindInternedVar(lang.NewSymbol("str"))
										if tmp156.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
										}
										tmp157 := tmp156.Get()
										tmp158 := lang.Apply(tmp157, []any{"Duplicate case test constant: ", v148})
										tmp159 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp158})
										panic(tmp159)
									} else {
										tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp161 := tmp160.FindInternedVar(lang.NewSymbol("assoc"))
										if tmp161.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
										}
										tmp162 := tmp161.Get()
										tmp163 := lang.Apply(tmp162, []any{v147, v148, v149})
										tmp150 = tmp163
									}
									return tmp150
								})
								v146 = tmp145
								_ = v146
							}
							tmp146 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6745), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6748), lang.NewKeyword("end-column"), int(48))
							tmp147, err := lang.WithMeta(tmp145, tmp146.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v148 any = tmp147
							_ = v148
							// let binding "pairs"
							tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp150 := tmp149.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp150.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
							}
							tmp151 := tmp150.Get()
							var tmp152 lang.FnFunc
							tmp152 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v153 := args[0]
								_ = v153
								v154 := args[1]
								_ = v154
								var tmp155 any
								{ // let
									// let binding "vec__177"
									var v156 any = v154
									_ = v156
									// let binding "test"
									tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp158 := tmp157.FindInternedVar(lang.NewSymbol("nth"))
									if tmp158.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
									}
									tmp159 := tmp158.Get()
									tmp160 := lang.Apply(tmp159, []any{v156, int64(0), nil})
									var v161 any = tmp160
									_ = v161
									// let binding "expr"
									tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp163 := tmp162.FindInternedVar(lang.NewSymbol("nth"))
									if tmp163.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
									}
									tmp164 := tmp163.Get()
									tmp165 := lang.Apply(tmp164, []any{v156, int64(1), nil})
									var v166 any = tmp165
									_ = v166
									var tmp167 any
									tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp169 := tmp168.FindInternedVar(lang.NewSymbol("seq?"))
									if tmp169.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
									}
									tmp170 := tmp169.Get()
									tmp171 := lang.Apply(tmp170, []any{v161})
									if lang.IsTruthy(tmp171) {
										tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp173 := tmp172.FindInternedVar(lang.NewSymbol("reduce1"))
										if tmp173.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
										}
										tmp174 := tmp173.Get()
										var tmp175 lang.FnFunc
										tmp175 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 2 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v176 := args[0]
											_ = v176
											v177 := args[1]
											_ = v177
											tmp178 := lang.Apply(v148, []any{v176, v177, v166})
											return tmp178
										})
										tmp176 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6752), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(6752), lang.NewKeyword("end-column"), int(60))
										tmp177, err := lang.WithMeta(tmp175, tmp176.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp178 := lang.Apply(tmp174, []any{tmp177, v153, v161})
										tmp167 = tmp178
									} else {
										tmp179 := lang.Apply(v148, []any{v153, v161, v166})
										tmp167 = tmp179
									}
									tmp155 = tmp167
								} // end let
								return tmp155
							})
							tmp153 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6750), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6753), lang.NewKeyword("end-column"), int(53))
							tmp154, err := lang.WithMeta(tmp152, tmp153.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp155 := lang.NewMap()
							tmp156 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6754), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(6754), lang.NewKeyword("end-column"), int(25))
							tmp157, err := lang.WithMeta(tmp155, tmp156.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp158 := lang.Apply(tmp151, []any{tmp154, tmp157, v144})
							var v159 any = tmp158
							_ = v159
							// let binding "tests"
							tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp161 := tmp160.FindInternedVar(lang.NewSymbol("keys"))
							if tmp161.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
							}
							tmp162 := tmp161.Get()
							tmp163 := lang.Apply(tmp162, []any{v159})
							var v164 any = tmp163
							_ = v164
							// let binding "thens"
							tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp166 := tmp165.FindInternedVar(lang.NewSymbol("vals"))
							if tmp166.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
							}
							tmp167 := tmp166.Get()
							tmp168 := lang.Apply(tmp167, []any{v159})
							var v169 any = tmp168
							_ = v169
							// let binding "mode"
							var tmp170 any
							tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp172 := tmp171.FindInternedVar(lang.NewSymbol("every?"))
							if tmp172.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
							}
							tmp173 := tmp172.Get()
							var tmp174 lang.FnFunc
							tmp174 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v175 := args[0]
								_ = v175
								var tmp176 any
								{ // let
									// let binding "and__0__auto__"
									tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp178 := tmp177.FindInternedVar(lang.NewSymbol("integer?"))
									if tmp178.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
									}
									tmp179 := tmp178.Get()
									tmp180 := lang.Apply(tmp179, []any{v175})
									var v181 any = tmp180
									_ = v181
									var tmp182 any
									if lang.IsTruthy(v181) {
										tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp184 := tmp183.FindInternedVar(lang.NewSymbol("<="))
										if tmp184.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
										}
										tmp185 := tmp184.Get()
										tmp186 := lang.Apply(tmp185, []any{math3.MinInt, v175, math3.MaxInt})
										tmp182 = tmp186
									} else {
										tmp182 = v181
									}
									tmp176 = tmp182
								} // end let
								return tmp176
							})
							tmp175 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6758), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(6758), lang.NewKeyword("end-column"), int(77))
							tmp176, err := lang.WithMeta(tmp174, tmp175.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp177 := lang.Apply(tmp173, []any{tmp176, v164})
							if lang.IsTruthy(tmp177) {
								tmp170 = lang.NewKeyword("ints")
							} else {
								var tmp178 any
								tmp179 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp180 := tmp179.FindInternedVar(lang.NewSymbol("every?"))
								if tmp180.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp180)))
								}
								tmp181 := tmp180.Get()
								tmp182 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp183 := tmp182.FindInternedVar(lang.NewSymbol("keyword?"))
								if tmp183.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp183)))
								}
								tmp184 := tmp183.Get()
								tmp185 := lang.Apply(tmp181, []any{tmp184, v164})
								if lang.IsTruthy(tmp185) {
									tmp178 = lang.NewKeyword("identity")
								} else {
									var tmp186 any
									if lang.IsTruthy(lang.NewKeyword("else")) {
										tmp186 = lang.NewKeyword("hashes")
									} else {
									}
									tmp178 = tmp186
								}
								tmp170 = tmp178
							}
							var v187 any = tmp170
							_ = v187
							var tmp188 any
							{ // let
								// let binding "pred__180"
								tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp190 := tmp189.FindInternedVar(lang.NewSymbol("="))
								if tmp190.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
								}
								tmp191 := tmp190.Get()
								var v192 any = tmp191
								_ = v192
								// let binding "expr__181"
								var v193 any = v187
								_ = v193
								var tmp194 any
								tmp195 := lang.Apply(v192, []any{lang.NewKeyword("ints"), v193})
								if lang.IsTruthy(tmp195) {
									var tmp196 any
									{ // let
										// let binding "vec__182"
										tmp197 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp198 := tmp197.FindInternedVar(lang.NewSymbol("prep-ints"))
										if tmp198.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp198)))
										}
										tmp199 := tmp198.Get()
										tmp200 := lang.Apply(tmp199, []any{v164, v169})
										var v201 any = tmp200
										_ = v201
										// let binding "shift"
										tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp203 := tmp202.FindInternedVar(lang.NewSymbol("nth"))
										if tmp203.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
										}
										tmp204 := tmp203.Get()
										tmp205 := lang.Apply(tmp204, []any{v201, int64(0), nil})
										var v206 any = tmp205
										_ = v206
										// let binding "mask"
										tmp207 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp208 := tmp207.FindInternedVar(lang.NewSymbol("nth"))
										if tmp208.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp208)))
										}
										tmp209 := tmp208.Get()
										tmp210 := lang.Apply(tmp209, []any{v201, int64(1), nil})
										var v211 any = tmp210
										_ = v211
										// let binding "imap"
										tmp212 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp213 := tmp212.FindInternedVar(lang.NewSymbol("nth"))
										if tmp213.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp213)))
										}
										tmp214 := tmp213.Get()
										tmp215 := lang.Apply(tmp214, []any{v201, int64(2), nil})
										var v216 any = tmp215
										_ = v216
										// let binding "switch-type"
										tmp217 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp218 := tmp217.FindInternedVar(lang.NewSymbol("nth"))
										if tmp218.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp218)))
										}
										tmp219 := tmp218.Get()
										tmp220 := lang.Apply(tmp219, []any{v201, int64(3), nil})
										var v221 any = tmp220
										_ = v221
										tmp222 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp223 := tmp222.FindInternedVar(lang.NewSymbol("seq"))
										if tmp223.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp223)))
										}
										tmp224 := tmp223.Get()
										tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp226 := tmp225.FindInternedVar(lang.NewSymbol("concat"))
										if tmp226.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
										}
										tmp227 := tmp226.Get()
										tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp229 := tmp228.FindInternedVar(lang.NewSymbol("list"))
										if tmp229.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
										}
										tmp230 := tmp229.Get()
										tmp231 := lang.Apply(tmp230, []any{lang.NewSymbol("glojure.core/let")})
										tmp232 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp233 := tmp232.FindInternedVar(lang.NewSymbol("list"))
										if tmp233.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp233)))
										}
										tmp234 := tmp233.Get()
										tmp235 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp236 := tmp235.FindInternedVar(lang.NewSymbol("apply"))
										if tmp236.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp236)))
										}
										tmp237 := tmp236.Get()
										tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp239 := tmp238.FindInternedVar(lang.NewSymbol("vector"))
										if tmp239.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
										}
										tmp240 := tmp239.Get()
										tmp241 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp242 := tmp241.FindInternedVar(lang.NewSymbol("seq"))
										if tmp242.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp242)))
										}
										tmp243 := tmp242.Get()
										tmp244 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp245 := tmp244.FindInternedVar(lang.NewSymbol("concat"))
										if tmp245.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp245)))
										}
										tmp246 := tmp245.Get()
										tmp247 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp248 := tmp247.FindInternedVar(lang.NewSymbol("list"))
										if tmp248.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp248)))
										}
										tmp249 := tmp248.Get()
										tmp250 := lang.Apply(tmp249, []any{v20})
										tmp251 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp252 := tmp251.FindInternedVar(lang.NewSymbol("list"))
										if tmp252.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp252)))
										}
										tmp253 := tmp252.Get()
										tmp254 := lang.Apply(tmp253, []any{v5})
										tmp255 := lang.Apply(tmp246, []any{tmp250, tmp254})
										tmp256 := lang.Apply(tmp243, []any{tmp255})
										tmp257 := lang.Apply(tmp237, []any{tmp240, tmp256})
										tmp258 := lang.Apply(tmp234, []any{tmp257})
										tmp259 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp260 := tmp259.FindInternedVar(lang.NewSymbol("list"))
										if tmp260.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp260)))
										}
										tmp261 := tmp260.Get()
										tmp262 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp263 := tmp262.FindInternedVar(lang.NewSymbol("seq"))
										if tmp263.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp263)))
										}
										tmp264 := tmp263.Get()
										tmp265 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp266 := tmp265.FindInternedVar(lang.NewSymbol("concat"))
										if tmp266.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp266)))
										}
										tmp267 := tmp266.Get()
										tmp268 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp269 := tmp268.FindInternedVar(lang.NewSymbol("list"))
										if tmp269.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp269)))
										}
										tmp270 := tmp269.Get()
										tmp271 := lang.Apply(tmp270, []any{lang.NewSymbol("case*")})
										tmp272 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp273 := tmp272.FindInternedVar(lang.NewSymbol("list"))
										if tmp273.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp273)))
										}
										tmp274 := tmp273.Get()
										tmp275 := lang.Apply(tmp274, []any{v20})
										tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp277 := tmp276.FindInternedVar(lang.NewSymbol("list"))
										if tmp277.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
										}
										tmp278 := tmp277.Get()
										tmp279 := lang.Apply(tmp278, []any{v206})
										tmp280 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp281 := tmp280.FindInternedVar(lang.NewSymbol("list"))
										if tmp281.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp281)))
										}
										tmp282 := tmp281.Get()
										tmp283 := lang.Apply(tmp282, []any{v211})
										tmp284 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp285 := tmp284.FindInternedVar(lang.NewSymbol("list"))
										if tmp285.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp285)))
										}
										tmp286 := tmp285.Get()
										tmp287 := lang.Apply(tmp286, []any{v86})
										tmp288 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp289 := tmp288.FindInternedVar(lang.NewSymbol("list"))
										if tmp289.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp289)))
										}
										tmp290 := tmp289.Get()
										tmp291 := lang.Apply(tmp290, []any{v216})
										tmp292 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp293 := tmp292.FindInternedVar(lang.NewSymbol("list"))
										if tmp293.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp293)))
										}
										tmp294 := tmp293.Get()
										tmp295 := lang.Apply(tmp294, []any{v221})
										tmp296 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp297 := tmp296.FindInternedVar(lang.NewSymbol("list"))
										if tmp297.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp297)))
										}
										tmp298 := tmp297.Get()
										tmp299 := lang.Apply(tmp298, []any{lang.NewKeyword("int")})
										tmp300 := lang.Apply(tmp267, []any{tmp271, tmp275, tmp279, tmp283, tmp287, tmp291, tmp295, tmp299})
										tmp301 := lang.Apply(tmp264, []any{tmp300})
										tmp302 := lang.Apply(tmp261, []any{tmp301})
										tmp303 := lang.Apply(tmp227, []any{tmp231, tmp258, tmp302})
										tmp304 := lang.Apply(tmp224, []any{tmp303})
										tmp196 = tmp304
									} // end let
									tmp194 = tmp196
								} else {
									var tmp197 any
									tmp198 := lang.Apply(v192, []any{lang.NewKeyword("hashes"), v193})
									if lang.IsTruthy(tmp198) {
										var tmp199 any
										{ // let
											// let binding "vec__185"
											tmp200 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp201 := tmp200.FindInternedVar(lang.NewSymbol("prep-hashes"))
											if tmp201.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp201)))
											}
											tmp202 := tmp201.Get()
											tmp203 := lang.Apply(tmp202, []any{v20, v86, v164, v169})
											var v204 any = tmp203
											_ = v204
											// let binding "shift"
											tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp206 := tmp205.FindInternedVar(lang.NewSymbol("nth"))
											if tmp206.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
											}
											tmp207 := tmp206.Get()
											tmp208 := lang.Apply(tmp207, []any{v204, int64(0), nil})
											var v209 any = tmp208
											_ = v209
											// let binding "mask"
											tmp210 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp211 := tmp210.FindInternedVar(lang.NewSymbol("nth"))
											if tmp211.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp211)))
											}
											tmp212 := tmp211.Get()
											tmp213 := lang.Apply(tmp212, []any{v204, int64(1), nil})
											var v214 any = tmp213
											_ = v214
											// let binding "imap"
											tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp216 := tmp215.FindInternedVar(lang.NewSymbol("nth"))
											if tmp216.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
											}
											tmp217 := tmp216.Get()
											tmp218 := lang.Apply(tmp217, []any{v204, int64(2), nil})
											var v219 any = tmp218
											_ = v219
											// let binding "switch-type"
											tmp220 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp221 := tmp220.FindInternedVar(lang.NewSymbol("nth"))
											if tmp221.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp221)))
											}
											tmp222 := tmp221.Get()
											tmp223 := lang.Apply(tmp222, []any{v204, int64(3), nil})
											var v224 any = tmp223
											_ = v224
											// let binding "skip-check"
											tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp226 := tmp225.FindInternedVar(lang.NewSymbol("nth"))
											if tmp226.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
											}
											tmp227 := tmp226.Get()
											tmp228 := lang.Apply(tmp227, []any{v204, int64(4), nil})
											var v229 any = tmp228
											_ = v229
											tmp230 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp231 := tmp230.FindInternedVar(lang.NewSymbol("seq"))
											if tmp231.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp231)))
											}
											tmp232 := tmp231.Get()
											tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp234 := tmp233.FindInternedVar(lang.NewSymbol("concat"))
											if tmp234.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
											}
											tmp235 := tmp234.Get()
											tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp237 := tmp236.FindInternedVar(lang.NewSymbol("list"))
											if tmp237.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
											}
											tmp238 := tmp237.Get()
											tmp239 := lang.Apply(tmp238, []any{lang.NewSymbol("glojure.core/let")})
											tmp240 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp241 := tmp240.FindInternedVar(lang.NewSymbol("list"))
											if tmp241.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp241)))
											}
											tmp242 := tmp241.Get()
											tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp244 := tmp243.FindInternedVar(lang.NewSymbol("apply"))
											if tmp244.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
											}
											tmp245 := tmp244.Get()
											tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp247 := tmp246.FindInternedVar(lang.NewSymbol("vector"))
											if tmp247.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
											}
											tmp248 := tmp247.Get()
											tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp250 := tmp249.FindInternedVar(lang.NewSymbol("seq"))
											if tmp250.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
											}
											tmp251 := tmp250.Get()
											tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp253 := tmp252.FindInternedVar(lang.NewSymbol("concat"))
											if tmp253.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
											}
											tmp254 := tmp253.Get()
											tmp255 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp256 := tmp255.FindInternedVar(lang.NewSymbol("list"))
											if tmp256.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp256)))
											}
											tmp257 := tmp256.Get()
											tmp258 := lang.Apply(tmp257, []any{v20})
											tmp259 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp260 := tmp259.FindInternedVar(lang.NewSymbol("list"))
											if tmp260.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp260)))
											}
											tmp261 := tmp260.Get()
											tmp262 := lang.Apply(tmp261, []any{v5})
											tmp263 := lang.Apply(tmp254, []any{tmp258, tmp262})
											tmp264 := lang.Apply(tmp251, []any{tmp263})
											tmp265 := lang.Apply(tmp245, []any{tmp248, tmp264})
											tmp266 := lang.Apply(tmp242, []any{tmp265})
											tmp267 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp268 := tmp267.FindInternedVar(lang.NewSymbol("list"))
											if tmp268.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp268)))
											}
											tmp269 := tmp268.Get()
											tmp270 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp271 := tmp270.FindInternedVar(lang.NewSymbol("seq"))
											if tmp271.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp271)))
											}
											tmp272 := tmp271.Get()
											tmp273 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp274 := tmp273.FindInternedVar(lang.NewSymbol("concat"))
											if tmp274.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp274)))
											}
											tmp275 := tmp274.Get()
											tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp277 := tmp276.FindInternedVar(lang.NewSymbol("list"))
											if tmp277.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
											}
											tmp278 := tmp277.Get()
											tmp279 := lang.Apply(tmp278, []any{lang.NewSymbol("case*")})
											tmp280 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp281 := tmp280.FindInternedVar(lang.NewSymbol("list"))
											if tmp281.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp281)))
											}
											tmp282 := tmp281.Get()
											tmp283 := lang.Apply(tmp282, []any{v20})
											tmp284 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp285 := tmp284.FindInternedVar(lang.NewSymbol("list"))
											if tmp285.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp285)))
											}
											tmp286 := tmp285.Get()
											tmp287 := lang.Apply(tmp286, []any{v209})
											tmp288 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp289 := tmp288.FindInternedVar(lang.NewSymbol("list"))
											if tmp289.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp289)))
											}
											tmp290 := tmp289.Get()
											tmp291 := lang.Apply(tmp290, []any{v214})
											tmp292 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp293 := tmp292.FindInternedVar(lang.NewSymbol("list"))
											if tmp293.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp293)))
											}
											tmp294 := tmp293.Get()
											tmp295 := lang.Apply(tmp294, []any{v86})
											tmp296 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp297 := tmp296.FindInternedVar(lang.NewSymbol("list"))
											if tmp297.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp297)))
											}
											tmp298 := tmp297.Get()
											tmp299 := lang.Apply(tmp298, []any{v219})
											tmp300 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp301 := tmp300.FindInternedVar(lang.NewSymbol("list"))
											if tmp301.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp301)))
											}
											tmp302 := tmp301.Get()
											tmp303 := lang.Apply(tmp302, []any{v224})
											tmp304 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp305 := tmp304.FindInternedVar(lang.NewSymbol("list"))
											if tmp305.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp305)))
											}
											tmp306 := tmp305.Get()
											tmp307 := lang.Apply(tmp306, []any{lang.NewKeyword("hash-equiv")})
											tmp308 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp309 := tmp308.FindInternedVar(lang.NewSymbol("list"))
											if tmp309.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp309)))
											}
											tmp310 := tmp309.Get()
											tmp311 := lang.Apply(tmp310, []any{v229})
											tmp312 := lang.Apply(tmp275, []any{tmp279, tmp283, tmp287, tmp291, tmp295, tmp299, tmp303, tmp307, tmp311})
											tmp313 := lang.Apply(tmp272, []any{tmp312})
											tmp314 := lang.Apply(tmp269, []any{tmp313})
											tmp315 := lang.Apply(tmp235, []any{tmp239, tmp266, tmp314})
											tmp316 := lang.Apply(tmp232, []any{tmp315})
											tmp199 = tmp316
										} // end let
										tmp197 = tmp199
									} else {
										var tmp200 any
										tmp201 := lang.Apply(v192, []any{lang.NewKeyword("identity"), v193})
										if lang.IsTruthy(tmp201) {
											var tmp202 any
											{ // let
												// let binding "vec__188"
												tmp203 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp204 := tmp203.FindInternedVar(lang.NewSymbol("prep-hashes"))
												if tmp204.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp204)))
												}
												tmp205 := tmp204.Get()
												tmp206 := lang.Apply(tmp205, []any{v20, v86, v164, v169})
												var v207 any = tmp206
												_ = v207
												// let binding "shift"
												tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp209 := tmp208.FindInternedVar(lang.NewSymbol("nth"))
												if tmp209.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
												}
												tmp210 := tmp209.Get()
												tmp211 := lang.Apply(tmp210, []any{v207, int64(0), nil})
												var v212 any = tmp211
												_ = v212
												// let binding "mask"
												tmp213 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp214 := tmp213.FindInternedVar(lang.NewSymbol("nth"))
												if tmp214.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp214)))
												}
												tmp215 := tmp214.Get()
												tmp216 := lang.Apply(tmp215, []any{v207, int64(1), nil})
												var v217 any = tmp216
												_ = v217
												// let binding "imap"
												tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp219 := tmp218.FindInternedVar(lang.NewSymbol("nth"))
												if tmp219.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
												}
												tmp220 := tmp219.Get()
												tmp221 := lang.Apply(tmp220, []any{v207, int64(2), nil})
												var v222 any = tmp221
												_ = v222
												// let binding "switch-type"
												tmp223 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp224 := tmp223.FindInternedVar(lang.NewSymbol("nth"))
												if tmp224.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp224)))
												}
												tmp225 := tmp224.Get()
												tmp226 := lang.Apply(tmp225, []any{v207, int64(3), nil})
												var v227 any = tmp226
												_ = v227
												// let binding "skip-check"
												tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp229 := tmp228.FindInternedVar(lang.NewSymbol("nth"))
												if tmp229.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
												}
												tmp230 := tmp229.Get()
												tmp231 := lang.Apply(tmp230, []any{v207, int64(4), nil})
												var v232 any = tmp231
												_ = v232
												tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp234 := tmp233.FindInternedVar(lang.NewSymbol("seq"))
												if tmp234.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
												}
												tmp235 := tmp234.Get()
												tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp237 := tmp236.FindInternedVar(lang.NewSymbol("concat"))
												if tmp237.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
												}
												tmp238 := tmp237.Get()
												tmp239 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp240 := tmp239.FindInternedVar(lang.NewSymbol("list"))
												if tmp240.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp240)))
												}
												tmp241 := tmp240.Get()
												tmp242 := lang.Apply(tmp241, []any{lang.NewSymbol("glojure.core/let")})
												tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp244 := tmp243.FindInternedVar(lang.NewSymbol("list"))
												if tmp244.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
												}
												tmp245 := tmp244.Get()
												tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp247 := tmp246.FindInternedVar(lang.NewSymbol("apply"))
												if tmp247.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
												}
												tmp248 := tmp247.Get()
												tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp250 := tmp249.FindInternedVar(lang.NewSymbol("vector"))
												if tmp250.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
												}
												tmp251 := tmp250.Get()
												tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp253 := tmp252.FindInternedVar(lang.NewSymbol("seq"))
												if tmp253.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
												}
												tmp254 := tmp253.Get()
												tmp255 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp256 := tmp255.FindInternedVar(lang.NewSymbol("concat"))
												if tmp256.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp256)))
												}
												tmp257 := tmp256.Get()
												tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp259 := tmp258.FindInternedVar(lang.NewSymbol("list"))
												if tmp259.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
												}
												tmp260 := tmp259.Get()
												tmp261 := lang.Apply(tmp260, []any{v20})
												tmp262 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp263 := tmp262.FindInternedVar(lang.NewSymbol("list"))
												if tmp263.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp263)))
												}
												tmp264 := tmp263.Get()
												tmp265 := lang.Apply(tmp264, []any{v5})
												tmp266 := lang.Apply(tmp257, []any{tmp261, tmp265})
												tmp267 := lang.Apply(tmp254, []any{tmp266})
												tmp268 := lang.Apply(tmp248, []any{tmp251, tmp267})
												tmp269 := lang.Apply(tmp245, []any{tmp268})
												tmp270 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp271 := tmp270.FindInternedVar(lang.NewSymbol("list"))
												if tmp271.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp271)))
												}
												tmp272 := tmp271.Get()
												tmp273 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp274 := tmp273.FindInternedVar(lang.NewSymbol("seq"))
												if tmp274.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp274)))
												}
												tmp275 := tmp274.Get()
												tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp277 := tmp276.FindInternedVar(lang.NewSymbol("concat"))
												if tmp277.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
												}
												tmp278 := tmp277.Get()
												tmp279 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp280 := tmp279.FindInternedVar(lang.NewSymbol("list"))
												if tmp280.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp280)))
												}
												tmp281 := tmp280.Get()
												tmp282 := lang.Apply(tmp281, []any{lang.NewSymbol("case*")})
												tmp283 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp284 := tmp283.FindInternedVar(lang.NewSymbol("list"))
												if tmp284.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp284)))
												}
												tmp285 := tmp284.Get()
												tmp286 := lang.Apply(tmp285, []any{v20})
												tmp287 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp288 := tmp287.FindInternedVar(lang.NewSymbol("list"))
												if tmp288.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp288)))
												}
												tmp289 := tmp288.Get()
												tmp290 := lang.Apply(tmp289, []any{v212})
												tmp291 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp292 := tmp291.FindInternedVar(lang.NewSymbol("list"))
												if tmp292.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp292)))
												}
												tmp293 := tmp292.Get()
												tmp294 := lang.Apply(tmp293, []any{v217})
												tmp295 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp296 := tmp295.FindInternedVar(lang.NewSymbol("list"))
												if tmp296.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp296)))
												}
												tmp297 := tmp296.Get()
												tmp298 := lang.Apply(tmp297, []any{v86})
												tmp299 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp300 := tmp299.FindInternedVar(lang.NewSymbol("list"))
												if tmp300.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp300)))
												}
												tmp301 := tmp300.Get()
												tmp302 := lang.Apply(tmp301, []any{v222})
												tmp303 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp304 := tmp303.FindInternedVar(lang.NewSymbol("list"))
												if tmp304.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp304)))
												}
												tmp305 := tmp304.Get()
												tmp306 := lang.Apply(tmp305, []any{v227})
												tmp307 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp308 := tmp307.FindInternedVar(lang.NewSymbol("list"))
												if tmp308.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp308)))
												}
												tmp309 := tmp308.Get()
												tmp310 := lang.Apply(tmp309, []any{lang.NewKeyword("hash-identity")})
												tmp311 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp312 := tmp311.FindInternedVar(lang.NewSymbol("list"))
												if tmp312.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp312)))
												}
												tmp313 := tmp312.Get()
												tmp314 := lang.Apply(tmp313, []any{v232})
												tmp315 := lang.Apply(tmp278, []any{tmp282, tmp286, tmp290, tmp294, tmp298, tmp302, tmp306, tmp310, tmp314})
												tmp316 := lang.Apply(tmp275, []any{tmp315})
												tmp317 := lang.Apply(tmp272, []any{tmp316})
												tmp318 := lang.Apply(tmp238, []any{tmp242, tmp269, tmp317})
												tmp319 := lang.Apply(tmp235, []any{tmp318})
												tmp202 = tmp319
											} // end let
											tmp200 = tmp202
										} else {
											tmp203 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp204 := tmp203.FindInternedVar(lang.NewSymbol("str"))
											if tmp204.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp204)))
											}
											tmp205 := tmp204.Get()
											tmp206 := lang.Apply(tmp205, []any{"No matching clause: ", v193})
											tmp207 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp206})
											panic(tmp207)
										}
										tmp197 = tmp200
									}
									tmp194 = tmp197
								}
								tmp188 = tmp194
							} // end let
							tmp139 = tmp188
						} // end let
						tmp87 = tmp139
					}
					tmp7 = tmp87
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// case-map
	{
		tmp0 := lang.NewSymbol("case-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("case-f"), lang.NewSymbol("test-f"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6614), lang.NewKeyword("end-line"), int(6614), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("into1"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("sorted-map"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp12, nil)
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("zipmap"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp18 := tmp17.FindInternedVar(lang.NewSymbol("map"))
			if tmp18.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
			}
			tmp19 := tmp18.Get()
			tmp20 := lang.Apply(tmp19, []any{v3, v5})
			tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp22 := tmp21.FindInternedVar(lang.NewSymbol("map"))
			if tmp22.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
			}
			tmp23 := tmp22.Get()
			tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp25 := tmp24.FindInternedVar(lang.NewSymbol("vector"))
			if tmp25.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
			}
			tmp26 := tmp25.Get()
			tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp28 := tmp27.FindInternedVar(lang.NewSymbol("map"))
			if tmp28.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
			}
			tmp29 := tmp28.Get()
			tmp30 := lang.Apply(tmp29, []any{v4, v5})
			tmp31 := lang.Apply(tmp23, []any{tmp26, tmp30, v6})
			tmp32 := lang.Apply(tmp16, []any{tmp20, tmp31})
			tmp33 := lang.Apply(tmp9, []any{tmp13, tmp32})
			return tmp33
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cast
	{
		tmp0 := lang.NewSymbol("cast").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Throws a ClassCastException if x is not a c, else returns x.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(345), lang.NewKeyword("end-line"), int(345))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "cast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cat
	{
		tmp0 := lang.NewSymbol("cat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rf"))), lang.NewKeyword("doc"), "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7645), lang.NewKeyword("end-line"), int(7645))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rrf"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("preserving-reduced"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp11 := lang.Apply(v3, nil)
						return tmp11
					case 1:
						v11 := args[0]
						_ = v11
						tmp12 := lang.Apply(v3, []any{v11})
						return tmp12
					case 2:
						v11 := args[0]
						_ = v11
						v12 := args[1]
						_ = v12
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("reduce"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v9, v11, v12})
						return tmp16
					default:
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7651), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(7655), lang.NewKeyword("end-column"), int(36))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp12
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char
	{
		var tmp1 lang.FnFunc
		{ // function char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("uncheckedCharCast")
				} else {
					tmp30 = lang.NewSymbol("charCast")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to char", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3511), lang.NewKeyword("end-line"), int(3511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "CharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-array
	{
		var tmp1 lang.FnFunc
		{ // function char-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/CharArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("char-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of chars", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5325), lang.NewKeyword("end-line"), int(5325))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "CharArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "CharArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("CharArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-escape-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("char-escape-string").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("doc"), "Returns escape string for char or nil if none", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(214), lang.NewKeyword("end-line"), int(217))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "\\n", lang.NewChar(9), "\\t", lang.NewChar(13), "\\r", lang.NewChar(34), "\\\"", lang.NewChar(92), "\\\\", lang.NewChar(12), "\\f", lang.NewChar(8), "\\b"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char-name-string
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("char-name-string").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("doc"), "Returns name string for char or nil if none", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(6), lang.NewKeyword("line"), int(335), lang.NewKeyword("end-line"), int(338))).(*lang.Symbol)
		tmp2 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewChar(10), "newline", lang.NewChar(9), "tab", lang.NewChar(32), "space", lang.NewChar(8), "backspace", lang.NewChar(12), "formfeed", lang.NewChar(13), "return"), true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// char?
	{
		tmp0 := lang.NewSymbol("char?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Character", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(153), lang.NewKeyword("end-line"), int(157))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function char?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf(int32(0))
				tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
				return tmp9
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(157), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(157), lang.NewKeyword("end-column"), int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chars
	{
		var tmp1 lang.FnFunc
		{ // function chars
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Chars")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("chars").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to chars[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5382), lang.NewKeyword("end-line"), int(5382))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Chars")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Chars is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-cyclic-dependency
	{
		tmp0 := lang.NewSymbol("check-cyclic-dependency").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("path"))), lang.NewKeyword("doc"), "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5974), lang.NewKeyword("end-line"), int(5974), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("some"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v3}))
			tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5981), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5981), lang.NewKeyword("end-column"), int(21))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp12 := tmp11.FindInternedVar(lang.NewSymbol("rest"))
			if tmp12.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
			}
			tmp13 := tmp12.Get()
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("*pending-paths*"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.Apply(tmp13, []any{tmp16})
			tmp18 := lang.Apply(tmp7, []any{tmp10, tmp17})
			if lang.IsTruthy(tmp18) {
				var tmp19 any
				{ // let
					// let binding "pending"
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("map"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					var tmp23 lang.FnFunc
					tmp23 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v24 := args[0]
						_ = v24
						var tmp25 any
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("="))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.Apply(tmp28, []any{v24, v3})
						if lang.IsTruthy(tmp29) {
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("str"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.Apply(tmp32, []any{"[ ", v24, " ]"})
							tmp25 = tmp33
						} else {
							tmp25 = v24
						}
						return tmp25
					})
					tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5982), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(5982), lang.NewKeyword("end-column"), int(59))
					tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("cons"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("*pending-paths*"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp28, []any{v3, tmp31})
					tmp33 := lang.Apply(tmp22, []any{tmp25, tmp32})
					var v34 any = tmp33
					_ = v34
					// let binding "chain"
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("apply"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("interpose"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{"->", v34})
					tmp45 := lang.Apply(tmp37, []any{tmp40, tmp44})
					var v46 any = tmp45
					_ = v46
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("throw-if"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.Apply(tmp49, []any{true, "Cyclic load dependency: %s", v46})
					tmp19 = tmp50
				} // end let
				tmp4 = tmp19
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// check-valid-options
	{
		tmp0 := lang.NewSymbol("check-valid-options").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("options"), lang.NewSymbol("&"), lang.NewSymbol("valid-keys"))), lang.NewKeyword("doc"), "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(35), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1709), lang.NewKeyword("end-line"), int(1709), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("apply"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("disj"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("apply"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("hash-set"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("keys"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v3})
				tmp25 := lang.Apply(tmp17, []any{tmp20, tmp24})
				tmp26 := lang.Apply(tmp11, []any{tmp14, tmp25, v4})
				tmp27 := lang.Apply(tmp8, []any{tmp26})
				if lang.IsTruthy(tmp27) {
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("apply"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("str"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.Apply(tmp36, []any{v4})
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("map"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					var tmp41 lang.FnFunc
					tmp41 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v42 := args[0]
						_ = v42
						tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp44 := tmp43.FindInternedVar(lang.NewSymbol("str"))
						if tmp44.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
						}
						tmp45 := tmp44.Get()
						tmp46 := lang.Apply(tmp45, []any{", ", v42})
						return tmp46
					})
					tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1718), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(1718), lang.NewKeyword("end-column"), int(28))
					tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("rest"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v4})
					tmp48 := lang.Apply(tmp40, []any{tmp43, tmp47})
					tmp49 := lang.Apply(tmp30, []any{tmp33, "Only these options are valid: ", tmp37, tmp48})
					tmp50 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp49})
					panic(tmp50)
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk
	{
		tmp0 := lang.NewSymbol("chunk").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(691), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(691), lang.NewKeyword("end-column"), int(41), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("b"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunk")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunk")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-append
	{
		tmp0 := lang.NewSymbol("chunk-append").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(688), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(688), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("b"), lang.NewSymbol("x"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "add")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-buffer
	{
		tmp0 := lang.NewSymbol("chunk-buffer").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(685), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(685), lang.NewKeyword("end-column"), int(53), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("capacity"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewChunkBuffer, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-cons
	{
		tmp0 := lang.NewSymbol("chunk-cons").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(703), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(703), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("chunk"), lang.NewSymbol("rest"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.Apply(lang.Count, []any{v3})
			tmp7 := lang.Apply(lang.IsZero, []any{tmp6})
			if lang.IsTruthy(tmp7) {
				tmp5 = v4
			} else {
				tmp8 := lang.Apply(lang.NewChunkedCons, []any{v3, v4})
				tmp5 = tmp8
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-first
	{
		tmp0 := lang.NewSymbol("chunk-first").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(694), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(694), lang.NewKeyword("end-column"), int(48), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedFirst")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedFirst")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-next
	{
		tmp0 := lang.NewSymbol("chunk-next").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(700), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(700), lang.NewKeyword("end-column"), int(71), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedNext")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedNext")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunk-rest
	{
		tmp0 := lang.NewSymbol("chunk-rest").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(697), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(697), lang.NewKeyword("end-column"), int(71), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "chunkedMore")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "chunkedMore")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// chunked-seq?
	{
		tmp0 := lang.NewSymbol("chunked-seq?").WithMeta(lang.NewMap(lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(708), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(708), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.IChunkedSeq)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class
	{
		tmp0 := lang.NewSymbol("class").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the Class of x", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3461), lang.NewKeyword("end-line"), int(3461))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp4 = v3
			} else {
				tmp9 := lang.Apply(lang.TypeOf, []any{v3})
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// class?
	{
		tmp0 := lang.NewSymbol("class?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is an instance of Class", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5465), lang.NewKeyword("end-line"), int(5465))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// clear-agent-errors
	{
		tmp0 := lang.NewSymbol("clear-agent-errors").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.2", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2244), lang.NewKeyword("end-line"), int(2244))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("restart-agent"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7, ok := lang.FieldOrMethod(v3, "Deref")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(tmp6, []any{v3, tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// coll?
	{
		tmp0 := lang.NewSymbol("coll?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentCollection", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6192), lang.NewKeyword("end-line"), int(6192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comment
	{
		tmp0 := lang.NewSymbol("comment").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Ignores body, yields nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4733), lang.NewKeyword("end-line"), int(4733))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				return nil
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// commute
	{
		tmp0 := lang.NewSymbol("commute").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("fun"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2414), lang.NewKeyword("end-line"), int(2414))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "Commute")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Commute is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comp
	{
		tmp0 := lang.NewSymbol("comp").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("&"), lang.NewSymbol("fs"))), lang.NewKeyword("doc"), "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2549), lang.NewKeyword("end-line"), int(2549))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("identity"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v4, nil)
						tmp7 := lang.Apply(v3, []any{tmp6})
						return tmp7
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						tmp8 := lang.Apply(v3, []any{tmp7})
						return tmp8
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v4, []any{v6, v7})
						tmp9 := lang.Apply(v3, []any{tmp8})
						return tmp9
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v4, []any{v6, v7, v8})
						tmp10 := lang.Apply(v3, []any{tmp9})
						return tmp10
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v4, v6, v7, v8, v9})
						tmp14 := lang.Apply(v3, []any{tmp13})
						return tmp14
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("comp"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list*"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3, v4, v5})
				tmp16 := lang.Apply(tmp8, []any{tmp11, tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// comparator
	{
		tmp0 := lang.NewSymbol("comparator").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"))), lang.NewKeyword("doc"), "Returns an implementation of java.util.Comparator based upon pred.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3077), lang.NewKeyword("end-line"), int(3077))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				tmp8 := lang.Apply(v3, []any{v5, v6})
				if lang.IsTruthy(tmp8) {
					tmp7 = int64(-1)
				} else {
					var tmp9 any
					tmp10 := lang.Apply(v3, []any{v6, v5})
					if lang.IsTruthy(tmp10) {
						tmp9 = int64(1)
					} else {
						var tmp11 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp11 = int64(0)
						} else {
						}
						tmp9 = tmp11
					}
					tmp7 = tmp9
				}
				return tmp7
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3082), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(3083), lang.NewKeyword("end-column"), int(48))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare
	{
		var tmp1 lang.FnFunc
		{ // function compare__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/compare")})
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{v4})
				tmp31 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp22, tmp26, tmp30})
				tmp32 := lang.Apply(tmp7, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("compare").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(824), lang.NewKeyword("end-line"), int(824))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Compare, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compare-and-set!
	{
		tmp0 := lang.NewSymbol("compare-and-set!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("oldval"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2360), lang.NewKeyword("end-line"), int(2360))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "compareAndSet")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("compareAndSet is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// compile
	{
		tmp0 := lang.NewSymbol("compile").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6114), lang.NewKeyword("end-line"), int(6114))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("hash-map"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*compile-files*"))
				tmp12 := lang.Apply(tmp10, []any{tmp11, true})
				tmp13 := lang.Apply(tmp7, []any{tmp12})
				_ = tmp13
				var tmp14 any
				func() {
					defer func() {
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, nil)
						_ = tmp18
					}()
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("load-one"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v3, true, true})
					tmp14 = tmp22
				}()
				tmp4 = tmp14
			} // end let
			_ = tmp4
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// complement
	{
		tmp0 := lang.NewSymbol("complement").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1428), lang.NewKeyword("end-line"), int(1428))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("not"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.Apply(v3, nil)
					tmp9 := lang.Apply(tmp7, []any{tmp8})
					return tmp9
				case 1:
					v5 := args[0]
					_ = v5
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("not"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(v3, []any{v5})
					tmp10 := lang.Apply(tmp8, []any{tmp9})
					return tmp10
				case 2:
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("not"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(v3, []any{v5, v6})
					tmp11 := lang.Apply(tmp9, []any{tmp10})
					return tmp11
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					v6 := args[1]
					_ = v6
					var v7 any = lang.NewList(args[2:]...)
					_ = v7
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("not"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("apply"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3, v5, v6, v7})
					tmp15 := lang.Apply(tmp10, []any{tmp14})
					return tmp15
				}
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1434), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(1438), lang.NewKeyword("end-column"), int(40))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// completing
	{
		tmp0 := lang.NewSymbol("completing").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("cf"))), lang.NewKeyword("doc"), "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6893), lang.NewKeyword("end-line"), int(6893))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("completing"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("identity"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{v3, tmp9})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v4, []any{v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						return tmp8
					default:
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6900), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6903), lang.NewKeyword("end-column"), int(23))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// concat
	{
		tmp0 := lang.NewSymbol("concat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("zs"))), lang.NewKeyword("doc"), "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(711), lang.NewKeyword("end-line"), int(711))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return nil
				})
				tmp4 := lang.Apply(lang.NewLazySeq, []any{tmp3})
				return tmp4
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "s"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("chunked-seq?"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.Apply(tmp16, []any{v11})
							if lang.IsTruthy(tmp17) {
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("chunk-cons"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("chunk-first"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(tmp23, []any{v11})
								tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
								if tmp26.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
								}
								tmp27 := tmp26.Get()
								tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp29 := tmp28.FindInternedVar(lang.NewSymbol("chunk-rest"))
								if tmp29.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
								}
								tmp30 := tmp29.Get()
								tmp31 := lang.Apply(tmp30, []any{v11})
								tmp32 := lang.Apply(tmp27, []any{tmp31, v4})
								tmp33 := lang.Apply(tmp20, []any{tmp24, tmp32})
								tmp13 = tmp33
							} else {
								tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp35 := tmp34.FindInternedVar(lang.NewSymbol("cons"))
								if tmp35.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
								}
								tmp36 := tmp35.Get()
								tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp38 := tmp37.FindInternedVar(lang.NewSymbol("first"))
								if tmp38.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
								}
								tmp39 := tmp38.Get()
								tmp40 := lang.Apply(tmp39, []any{v11})
								tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
								if tmp42.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
								}
								tmp43 := tmp42.Get()
								tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp45 := tmp44.FindInternedVar(lang.NewSymbol("rest"))
								if tmp45.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
								}
								tmp46 := tmp45.Get()
								tmp47 := lang.Apply(tmp46, []any{v11})
								tmp48 := lang.Apply(tmp43, []any{tmp47, v4})
								tmp49 := lang.Apply(tmp36, []any{tmp40, tmp48})
								tmp13 = tmp49
							}
							tmp12 = tmp13
						} else {
							tmp12 = v4
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "cat"
					var tmp7 lang.FnFunc
					{ // function cat
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v9 := args[0]
							_ = v9
							v10 := args[1]
							_ = v10
							var tmp11 lang.FnFunc
							tmp11 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp12 any
								{ // let
									// let binding "xys"
									tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq"))
									if tmp14.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
									}
									tmp15 := tmp14.Get()
									tmp16 := lang.Apply(tmp15, []any{v9})
									var v17 any = tmp16
									_ = v17
									var tmp18 any
									if lang.IsTruthy(v17) {
										var tmp19 any
										tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp21 := tmp20.FindInternedVar(lang.NewSymbol("chunked-seq?"))
										if tmp21.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
										}
										tmp22 := tmp21.Get()
										tmp23 := lang.Apply(tmp22, []any{v17})
										if lang.IsTruthy(tmp23) {
											tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp25 := tmp24.FindInternedVar(lang.NewSymbol("chunk-cons"))
											if tmp25.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
											}
											tmp26 := tmp25.Get()
											tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp28 := tmp27.FindInternedVar(lang.NewSymbol("chunk-first"))
											if tmp28.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
											}
											tmp29 := tmp28.Get()
											tmp30 := lang.Apply(tmp29, []any{v17})
											tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp32 := tmp31.FindInternedVar(lang.NewSymbol("chunk-rest"))
											if tmp32.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
											}
											tmp33 := tmp32.Get()
											tmp34 := lang.Apply(tmp33, []any{v17})
											tmp35 := lang.Apply(v8, []any{tmp34, v10})
											tmp36 := lang.Apply(tmp26, []any{tmp30, tmp35})
											tmp19 = tmp36
										} else {
											tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp38 := tmp37.FindInternedVar(lang.NewSymbol("cons"))
											if tmp38.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
											}
											tmp39 := tmp38.Get()
											tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
											if tmp41.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
											}
											tmp42 := tmp41.Get()
											tmp43 := lang.Apply(tmp42, []any{v17})
											tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp45 := tmp44.FindInternedVar(lang.NewSymbol("rest"))
											if tmp45.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
											}
											tmp46 := tmp45.Get()
											tmp47 := lang.Apply(tmp46, []any{v17})
											tmp48 := lang.Apply(v8, []any{tmp47, v10})
											tmp49 := lang.Apply(tmp39, []any{tmp43, tmp48})
											tmp19 = tmp49
										}
										tmp18 = tmp19
									} else {
										var tmp50 any
										if lang.IsTruthy(v10) {
											tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp52 := tmp51.FindInternedVar(lang.NewSymbol("first"))
											if tmp52.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
											}
											tmp53 := tmp52.Get()
											tmp54 := lang.Apply(tmp53, []any{v10})
											tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp56 := tmp55.FindInternedVar(lang.NewSymbol("next"))
											if tmp56.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
											}
											tmp57 := tmp56.Get()
											tmp58 := lang.Apply(tmp57, []any{v10})
											tmp59 := lang.Apply(v8, []any{tmp54, tmp58})
											tmp50 = tmp59
										} else {
										}
										tmp18 = tmp50
									}
									tmp12 = tmp18
								} // end let
								return tmp12
							})
							tmp12 := lang.Apply(lang.NewLazySeq, []any{tmp11})
							return tmp12
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(726), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(735), lang.NewKeyword("end-column"), int(56))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3, v4})
					tmp15 := lang.Apply(v10, []any{tmp14, v5})
					tmp6 = tmp15
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond
	{
		tmp0 := lang.NewSymbol("cond").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(569), lang.NewKeyword("end-line"), int(569))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v5) {
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("list"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("first"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{v5})
					var tmp14 any
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("next"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v5})
					if lang.IsTruthy(tmp18) {
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("second"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v5})
						tmp14 = tmp22
					} else {
						tmp23 := lang.Apply(lang.NewIllegalArgumentError, []any{"cond requires an even number of forms"})
						panic(tmp23)
					}
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("cons"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("next"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("next"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.Apply(tmp32, []any{v5})
					tmp34 := lang.Apply(tmp29, []any{tmp33})
					tmp35 := lang.Apply(tmp26, []any{lang.NewSymbol("glojure.core/cond"), tmp34})
					tmp36 := lang.Apply(tmp9, []any{lang.NewSymbol("if"), tmp13, tmp14, tmp35})
					tmp6 = tmp36
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->
	{
		tmp0 := lang.NewSymbol("cond->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7564), lang.NewKeyword("end-line"), int(7564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, nil)
					var v12 any = tmp11
					_ = v12
					// let binding "steps"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v17 := args[0]
						_ = v17
						var tmp18 any
						{ // let
							// let binding "vec__337"
							var v19 any = v17
							_ = v19
							// let binding "test"
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("nth"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{v19, int64(0), nil})
							var v24 any = tmp23
							_ = v24
							// let binding "step"
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("nth"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v19, int64(1), nil})
							var v29 any = tmp28
							_ = v29
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("concat"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{lang.NewSymbol("if")})
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v24})
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
							if tmp48.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
							}
							tmp49 := tmp48.Get()
							tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
							if tmp51.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
							}
							tmp52 := tmp51.Get()
							tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
							if tmp54.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
							}
							tmp55 := tmp54.Get()
							tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("glojure.core/->")})
							tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
							if tmp58.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
							}
							tmp59 := tmp58.Get()
							tmp60 := lang.Apply(tmp59, []any{v12})
							tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
							if tmp62.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
							}
							tmp63 := tmp62.Get()
							tmp64 := lang.Apply(tmp63, []any{v29})
							tmp65 := lang.Apply(tmp52, []any{tmp56, tmp60, tmp64})
							tmp66 := lang.Apply(tmp49, []any{tmp65})
							tmp67 := lang.Apply(tmp46, []any{tmp66})
							tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp69 := tmp68.FindInternedVar(lang.NewSymbol("list"))
							if tmp69.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
							}
							tmp70 := tmp69.Get()
							tmp71 := lang.Apply(tmp70, []any{v12})
							tmp72 := lang.Apply(tmp35, []any{tmp39, tmp43, tmp67, tmp71})
							tmp73 := lang.Apply(tmp32, []any{tmp72})
							tmp18 = tmp73
						} // end let
						return tmp18
					})
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7573), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7573), lang.NewKeyword("end-column"), int(66))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("partition"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{int64(2), v6})
					tmp23 := lang.Apply(tmp15, []any{tmp18, tmp22})
					var v24 any = tmp23
					_ = v24
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/let")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("apply"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("vector"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("concat"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.Apply(tmp52, []any{v12})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.Apply(tmp56, []any{v5})
					tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp59 := tmp58.FindInternedVar(lang.NewSymbol("interleave"))
					if tmp59.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
					}
					tmp60 := tmp59.Get()
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("repeat"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.Apply(tmp63, []any{v12})
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("butlast"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v24})
					tmp69 := lang.Apply(tmp60, []any{tmp64, tmp68})
					tmp70 := lang.Apply(tmp49, []any{tmp53, tmp57, tmp69})
					tmp71 := lang.Apply(tmp46, []any{tmp70})
					tmp72 := lang.Apply(tmp40, []any{tmp43, tmp71})
					tmp73 := lang.Apply(tmp37, []any{tmp72})
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					var tmp77 any
					tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp79 := tmp78.FindInternedVar(lang.NewSymbol("empty?"))
					if tmp79.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
					}
					tmp80 := tmp79.Get()
					tmp81 := lang.Apply(tmp80, []any{v24})
					if lang.IsTruthy(tmp81) {
						tmp77 = v12
					} else {
						tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp83 := tmp82.FindInternedVar(lang.NewSymbol("last"))
						if tmp83.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
						}
						tmp84 := tmp83.Get()
						tmp85 := lang.Apply(tmp84, []any{v24})
						tmp77 = tmp85
					}
					tmp86 := lang.Apply(tmp76, []any{tmp77})
					tmp87 := lang.Apply(tmp30, []any{tmp34, tmp73, tmp86})
					tmp88 := lang.Apply(tmp27, []any{tmp87})
					tmp7 = tmp88
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cond->>
	{
		tmp0 := lang.NewSymbol("cond->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7581), lang.NewKeyword("end-line"), int(7581))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, nil)
					var v12 any = tmp11
					_ = v12
					// let binding "steps"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v17 := args[0]
						_ = v17
						var tmp18 any
						{ // let
							// let binding "vec__341"
							var v19 any = v17
							_ = v19
							// let binding "test"
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("nth"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{v19, int64(0), nil})
							var v24 any = tmp23
							_ = v24
							// let binding "step"
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("nth"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v19, int64(1), nil})
							var v29 any = tmp28
							_ = v29
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("concat"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{lang.NewSymbol("if")})
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v24})
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
							if tmp48.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
							}
							tmp49 := tmp48.Get()
							tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
							if tmp51.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
							}
							tmp52 := tmp51.Get()
							tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
							if tmp54.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
							}
							tmp55 := tmp54.Get()
							tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("glojure.core/->>")})
							tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
							if tmp58.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
							}
							tmp59 := tmp58.Get()
							tmp60 := lang.Apply(tmp59, []any{v12})
							tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
							if tmp62.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
							}
							tmp63 := tmp62.Get()
							tmp64 := lang.Apply(tmp63, []any{v29})
							tmp65 := lang.Apply(tmp52, []any{tmp56, tmp60, tmp64})
							tmp66 := lang.Apply(tmp49, []any{tmp65})
							tmp67 := lang.Apply(tmp46, []any{tmp66})
							tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp69 := tmp68.FindInternedVar(lang.NewSymbol("list"))
							if tmp69.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
							}
							tmp70 := tmp69.Get()
							tmp71 := lang.Apply(tmp70, []any{v12})
							tmp72 := lang.Apply(tmp35, []any{tmp39, tmp43, tmp67, tmp71})
							tmp73 := lang.Apply(tmp32, []any{tmp72})
							tmp18 = tmp73
						} // end let
						return tmp18
					})
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7590), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7590), lang.NewKeyword("end-column"), int(67))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("partition"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{int64(2), v6})
					tmp23 := lang.Apply(tmp15, []any{tmp18, tmp22})
					var v24 any = tmp23
					_ = v24
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/let")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("apply"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("vector"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("concat"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.Apply(tmp52, []any{v12})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.Apply(tmp56, []any{v5})
					tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp59 := tmp58.FindInternedVar(lang.NewSymbol("interleave"))
					if tmp59.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
					}
					tmp60 := tmp59.Get()
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("repeat"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.Apply(tmp63, []any{v12})
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("butlast"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v24})
					tmp69 := lang.Apply(tmp60, []any{tmp64, tmp68})
					tmp70 := lang.Apply(tmp49, []any{tmp53, tmp57, tmp69})
					tmp71 := lang.Apply(tmp46, []any{tmp70})
					tmp72 := lang.Apply(tmp40, []any{tmp43, tmp71})
					tmp73 := lang.Apply(tmp37, []any{tmp72})
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					var tmp77 any
					tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp79 := tmp78.FindInternedVar(lang.NewSymbol("empty?"))
					if tmp79.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
					}
					tmp80 := tmp79.Get()
					tmp81 := lang.Apply(tmp80, []any{v24})
					if lang.IsTruthy(tmp81) {
						tmp77 = v12
					} else {
						tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp83 := tmp82.FindInternedVar(lang.NewSymbol("last"))
						if tmp83.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
						}
						tmp84 := tmp83.Get()
						tmp85 := lang.Apply(tmp84, []any{v24})
						tmp77 = tmp85
					}
					tmp86 := lang.Apply(tmp76, []any{tmp77})
					tmp87 := lang.Apply(tmp30, []any{tmp34, tmp73, tmp86})
					tmp88 := lang.Apply(tmp27, []any{tmp87})
					tmp7 = tmp88
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// condp
	{
		tmp0 := lang.NewSymbol("condp").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("clauses"))), lang.NewKeyword("doc"), "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6353), lang.NewKeyword("end-line"), int(6353))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "gpred"
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{"pred__"})
					var v13 any = tmp12
					_ = v13
					// let binding "gexpr"
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{"expr__"})
					var v18 any = tmp17
					_ = v18
					// let binding "emit"
					var tmp19 lang.FnFunc
					{ // function emit
						var v20 lang.FnFunc
						tmp19 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v21 := args[0]
							_ = v21
							v22 := args[1]
							_ = v22
							v23 := args[2]
							_ = v23
							var tmp24 any
							{ // let
								// let binding "vec__144"
								tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp26 := tmp25.FindInternedVar(lang.NewSymbol("split-at"))
								if tmp26.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
								}
								tmp27 := tmp26.Get()
								var tmp28 any
								tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp30 := tmp29.FindInternedVar(lang.NewSymbol("="))
								if tmp30.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
								}
								tmp31 := tmp30.Get()
								tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp33 := tmp32.FindInternedVar(lang.NewSymbol("second"))
								if tmp33.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
								}
								tmp34 := tmp33.Get()
								tmp35 := lang.Apply(tmp34, []any{v23})
								tmp36 := lang.Apply(tmp31, []any{lang.NewKeyword(">>"), tmp35})
								if lang.IsTruthy(tmp36) {
									tmp28 = int64(3)
								} else {
									tmp28 = int64(2)
								}
								tmp37 := lang.Apply(tmp27, []any{tmp28, v23})
								var v38 any = tmp37
								_ = v38
								// let binding "vec__147"
								tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp40 := tmp39.FindInternedVar(lang.NewSymbol("nth"))
								if tmp40.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
								}
								tmp41 := tmp40.Get()
								tmp42 := lang.Apply(tmp41, []any{v38, int64(0), nil})
								var v43 any = tmp42
								_ = v43
								// let binding "a"
								tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp45 := tmp44.FindInternedVar(lang.NewSymbol("nth"))
								if tmp45.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
								}
								tmp46 := tmp45.Get()
								tmp47 := lang.Apply(tmp46, []any{v43, int64(0), nil})
								var v48 any = tmp47
								_ = v48
								// let binding "b"
								tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp50 := tmp49.FindInternedVar(lang.NewSymbol("nth"))
								if tmp50.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
								}
								tmp51 := tmp50.Get()
								tmp52 := lang.Apply(tmp51, []any{v43, int64(1), nil})
								var v53 any = tmp52
								_ = v53
								// let binding "c"
								tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp55 := tmp54.FindInternedVar(lang.NewSymbol("nth"))
								if tmp55.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
								}
								tmp56 := tmp55.Get()
								tmp57 := lang.Apply(tmp56, []any{v43, int64(2), nil})
								var v58 any = tmp57
								_ = v58
								// let binding "clause"
								var v59 any = v43
								_ = v59
								// let binding "more"
								tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp61 := tmp60.FindInternedVar(lang.NewSymbol("nth"))
								if tmp61.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
								}
								tmp62 := tmp61.Get()
								tmp63 := lang.Apply(tmp62, []any{v38, int64(1), nil})
								var v64 any = tmp63
								_ = v64
								// let binding "n"
								tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp66 := tmp65.FindInternedVar(lang.NewSymbol("count"))
								if tmp66.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
								}
								tmp67 := tmp66.Get()
								tmp68 := lang.Apply(tmp67, []any{v59})
								var v69 any = tmp68
								_ = v69
								var tmp70 any
								tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp72 := tmp71.FindInternedVar(lang.NewSymbol("="))
								if tmp72.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
								}
								tmp73 := tmp72.Get()
								tmp74 := lang.Apply(tmp73, []any{int64(0), v69})
								if lang.IsTruthy(tmp74) {
									tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp76 := tmp75.FindInternedVar(lang.NewSymbol("seq"))
									if tmp76.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
									}
									tmp77 := tmp76.Get()
									tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp79 := tmp78.FindInternedVar(lang.NewSymbol("concat"))
									if tmp79.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
									}
									tmp80 := tmp79.Get()
									tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp82 := tmp81.FindInternedVar(lang.NewSymbol("list"))
									if tmp82.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
									}
									tmp83 := tmp82.Get()
									tmp84 := lang.Apply(tmp83, []any{lang.NewSymbol("throw")})
									tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp86 := tmp85.FindInternedVar(lang.NewSymbol("list"))
									if tmp86.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
									}
									tmp87 := tmp86.Get()
									tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp89 := tmp88.FindInternedVar(lang.NewSymbol("seq"))
									if tmp89.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
									}
									tmp90 := tmp89.Get()
									tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp92 := tmp91.FindInternedVar(lang.NewSymbol("concat"))
									if tmp92.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
									}
									tmp93 := tmp92.Get()
									tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
									if tmp95.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
									}
									tmp96 := tmp95.Get()
									tmp97 := lang.Apply(tmp96, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewIllegalArgumentError")})
									tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp99 := tmp98.FindInternedVar(lang.NewSymbol("list"))
									if tmp99.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
									}
									tmp100 := tmp99.Get()
									tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp102 := tmp101.FindInternedVar(lang.NewSymbol("seq"))
									if tmp102.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
									}
									tmp103 := tmp102.Get()
									tmp104 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp105 := tmp104.FindInternedVar(lang.NewSymbol("concat"))
									if tmp105.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp105)))
									}
									tmp106 := tmp105.Get()
									tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
									if tmp108.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
									}
									tmp109 := tmp108.Get()
									tmp110 := lang.Apply(tmp109, []any{lang.NewSymbol("glojure.core/str")})
									tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp112 := tmp111.FindInternedVar(lang.NewSymbol("list"))
									if tmp112.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
									}
									tmp113 := tmp112.Get()
									tmp114 := lang.Apply(tmp113, []any{"No matching clause: "})
									tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp116 := tmp115.FindInternedVar(lang.NewSymbol("list"))
									if tmp116.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
									}
									tmp117 := tmp116.Get()
									tmp118 := lang.Apply(tmp117, []any{v22})
									tmp119 := lang.Apply(tmp106, []any{tmp110, tmp114, tmp118})
									tmp120 := lang.Apply(tmp103, []any{tmp119})
									tmp121 := lang.Apply(tmp100, []any{tmp120})
									tmp122 := lang.Apply(tmp93, []any{tmp97, tmp121})
									tmp123 := lang.Apply(tmp90, []any{tmp122})
									tmp124 := lang.Apply(tmp87, []any{tmp123})
									tmp125 := lang.Apply(tmp80, []any{tmp84, tmp124})
									tmp126 := lang.Apply(tmp77, []any{tmp125})
									tmp70 = tmp126
								} else {
									var tmp127 any
									tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp129 := tmp128.FindInternedVar(lang.NewSymbol("="))
									if tmp129.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
									}
									tmp130 := tmp129.Get()
									tmp131 := lang.Apply(tmp130, []any{int64(1), v69})
									if lang.IsTruthy(tmp131) {
										tmp127 = v48
									} else {
										var tmp132 any
										tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp134 := tmp133.FindInternedVar(lang.NewSymbol("="))
										if tmp134.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
										}
										tmp135 := tmp134.Get()
										tmp136 := lang.Apply(tmp135, []any{int64(2), v69})
										if lang.IsTruthy(tmp136) {
											tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
											if tmp138.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
											}
											tmp139 := tmp138.Get()
											tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
											if tmp141.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
											}
											tmp142 := tmp141.Get()
											tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
											if tmp144.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
											}
											tmp145 := tmp144.Get()
											tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("if")})
											tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
											if tmp148.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
											}
											tmp149 := tmp148.Get()
											tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp151 := tmp150.FindInternedVar(lang.NewSymbol("seq"))
											if tmp151.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
											}
											tmp152 := tmp151.Get()
											tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp154 := tmp153.FindInternedVar(lang.NewSymbol("concat"))
											if tmp154.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
											}
											tmp155 := tmp154.Get()
											tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp157 := tmp156.FindInternedVar(lang.NewSymbol("list"))
											if tmp157.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
											}
											tmp158 := tmp157.Get()
											tmp159 := lang.Apply(tmp158, []any{v21})
											tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp161 := tmp160.FindInternedVar(lang.NewSymbol("list"))
											if tmp161.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
											}
											tmp162 := tmp161.Get()
											tmp163 := lang.Apply(tmp162, []any{v48})
											tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp165 := tmp164.FindInternedVar(lang.NewSymbol("list"))
											if tmp165.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
											}
											tmp166 := tmp165.Get()
											tmp167 := lang.Apply(tmp166, []any{v22})
											tmp168 := lang.Apply(tmp155, []any{tmp159, tmp163, tmp167})
											tmp169 := lang.Apply(tmp152, []any{tmp168})
											tmp170 := lang.Apply(tmp149, []any{tmp169})
											tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
											if tmp172.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
											}
											tmp173 := tmp172.Get()
											tmp174 := lang.Apply(tmp173, []any{v53})
											tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp176 := tmp175.FindInternedVar(lang.NewSymbol("list"))
											if tmp176.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
											}
											tmp177 := tmp176.Get()
											tmp178 := lang.Apply(v20, []any{v21, v22, v64})
											tmp179 := lang.Apply(tmp177, []any{tmp178})
											tmp180 := lang.Apply(tmp142, []any{tmp146, tmp170, tmp174, tmp179})
											tmp181 := lang.Apply(tmp139, []any{tmp180})
											tmp132 = tmp181
										} else {
											var tmp182 any
											if lang.IsTruthy(lang.NewKeyword("else")) {
												tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp184 := tmp183.FindInternedVar(lang.NewSymbol("seq"))
												if tmp184.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
												}
												tmp185 := tmp184.Get()
												tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp187 := tmp186.FindInternedVar(lang.NewSymbol("concat"))
												if tmp187.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
												}
												tmp188 := tmp187.Get()
												tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
												if tmp190.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
												}
												tmp191 := tmp190.Get()
												tmp192 := lang.Apply(tmp191, []any{lang.NewSymbol("glojure.core/if-let")})
												tmp193 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp194 := tmp193.FindInternedVar(lang.NewSymbol("list"))
												if tmp194.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp194)))
												}
												tmp195 := tmp194.Get()
												tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp197 := tmp196.FindInternedVar(lang.NewSymbol("apply"))
												if tmp197.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
												}
												tmp198 := tmp197.Get()
												tmp199 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp200 := tmp199.FindInternedVar(lang.NewSymbol("vector"))
												if tmp200.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp200)))
												}
												tmp201 := tmp200.Get()
												tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp203 := tmp202.FindInternedVar(lang.NewSymbol("seq"))
												if tmp203.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
												}
												tmp204 := tmp203.Get()
												tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp206 := tmp205.FindInternedVar(lang.NewSymbol("concat"))
												if tmp206.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
												}
												tmp207 := tmp206.Get()
												tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp209 := tmp208.FindInternedVar(lang.NewSymbol("list"))
												if tmp209.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
												}
												tmp210 := tmp209.Get()
												tmp211 := lang.Apply(tmp210, []any{lang.NewSymbol("p__0__auto__")})
												tmp212 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp213 := tmp212.FindInternedVar(lang.NewSymbol("list"))
												if tmp213.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp213)))
												}
												tmp214 := tmp213.Get()
												tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp216 := tmp215.FindInternedVar(lang.NewSymbol("seq"))
												if tmp216.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
												}
												tmp217 := tmp216.Get()
												tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp219 := tmp218.FindInternedVar(lang.NewSymbol("concat"))
												if tmp219.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
												}
												tmp220 := tmp219.Get()
												tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp222 := tmp221.FindInternedVar(lang.NewSymbol("list"))
												if tmp222.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
												}
												tmp223 := tmp222.Get()
												tmp224 := lang.Apply(tmp223, []any{v21})
												tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp226 := tmp225.FindInternedVar(lang.NewSymbol("list"))
												if tmp226.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
												}
												tmp227 := tmp226.Get()
												tmp228 := lang.Apply(tmp227, []any{v48})
												tmp229 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp230 := tmp229.FindInternedVar(lang.NewSymbol("list"))
												if tmp230.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp230)))
												}
												tmp231 := tmp230.Get()
												tmp232 := lang.Apply(tmp231, []any{v22})
												tmp233 := lang.Apply(tmp220, []any{tmp224, tmp228, tmp232})
												tmp234 := lang.Apply(tmp217, []any{tmp233})
												tmp235 := lang.Apply(tmp214, []any{tmp234})
												tmp236 := lang.Apply(tmp207, []any{tmp211, tmp235})
												tmp237 := lang.Apply(tmp204, []any{tmp236})
												tmp238 := lang.Apply(tmp198, []any{tmp201, tmp237})
												tmp239 := lang.Apply(tmp195, []any{tmp238})
												tmp240 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp241 := tmp240.FindInternedVar(lang.NewSymbol("list"))
												if tmp241.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp241)))
												}
												tmp242 := tmp241.Get()
												tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp244 := tmp243.FindInternedVar(lang.NewSymbol("seq"))
												if tmp244.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
												}
												tmp245 := tmp244.Get()
												tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp247 := tmp246.FindInternedVar(lang.NewSymbol("concat"))
												if tmp247.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
												}
												tmp248 := tmp247.Get()
												tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp250 := tmp249.FindInternedVar(lang.NewSymbol("list"))
												if tmp250.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
												}
												tmp251 := tmp250.Get()
												tmp252 := lang.Apply(tmp251, []any{v58})
												tmp253 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp254 := tmp253.FindInternedVar(lang.NewSymbol("list"))
												if tmp254.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp254)))
												}
												tmp255 := tmp254.Get()
												tmp256 := lang.Apply(tmp255, []any{lang.NewSymbol("p__0__auto__")})
												tmp257 := lang.Apply(tmp248, []any{tmp252, tmp256})
												tmp258 := lang.Apply(tmp245, []any{tmp257})
												tmp259 := lang.Apply(tmp242, []any{tmp258})
												tmp260 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp261 := tmp260.FindInternedVar(lang.NewSymbol("list"))
												if tmp261.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp261)))
												}
												tmp262 := tmp261.Get()
												tmp263 := lang.Apply(v20, []any{v21, v22, v64})
												tmp264 := lang.Apply(tmp262, []any{tmp263})
												tmp265 := lang.Apply(tmp188, []any{tmp192, tmp239, tmp259, tmp264})
												tmp266 := lang.Apply(tmp185, []any{tmp265})
												tmp182 = tmp266
											} else {
											}
											tmp132 = tmp182
										}
										tmp127 = tmp132
									}
									tmp70 = tmp127
								}
								tmp24 = tmp70
							} // end let
							return tmp24
						})
						v20 = tmp19
						_ = v20
					}
					tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6377), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(6389), lang.NewKeyword("end-column"), int(53))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v22 any = tmp21
					_ = v22
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("concat"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/let")})
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("apply"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp40 := tmp39.FindInternedVar(lang.NewSymbol("vector"))
					if tmp40.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
					}
					tmp41 := tmp40.Get()
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("seq"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("concat"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v13})
					tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
					if tmp53.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
					}
					tmp54 := tmp53.Get()
					tmp55 := lang.Apply(tmp54, []any{v5})
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("list"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.Apply(tmp58, []any{v18})
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("list"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.Apply(tmp62, []any{v6})
					tmp64 := lang.Apply(tmp47, []any{tmp51, tmp55, tmp59, tmp63})
					tmp65 := lang.Apply(tmp44, []any{tmp64})
					tmp66 := lang.Apply(tmp38, []any{tmp41, tmp65})
					tmp67 := lang.Apply(tmp35, []any{tmp66})
					tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp69 := tmp68.FindInternedVar(lang.NewSymbol("list"))
					if tmp69.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
					}
					tmp70 := tmp69.Get()
					tmp71 := lang.Apply(v22, []any{v13, v18, v7})
					tmp72 := lang.Apply(tmp70, []any{tmp71})
					tmp73 := lang.Apply(tmp28, []any{tmp32, tmp67, tmp72})
					tmp74 := lang.Apply(tmp25, []any{tmp73})
					tmp8 = tmp74
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj
	{
		tmp0 := lang.NewSymbol("conj").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).\n    (conj coll) returns coll. (conj) returns [].\n    The 'addition' may happen at different 'places' depending\n    on the concrete type.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(73), lang.NewKeyword("end-line"), int(81))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function conj
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				case 0:
					tmp4 := lang.NewVector()
					tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(82), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(82), lang.NewKeyword("end-column"), int(14))
					tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp6
				case 1:
					v4 := args[0]
					_ = v4
					return v4
				case 2:
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					tmp6 := lang.Apply(lang.Conj, []any{v4, v5})
					return tmp6
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					var v6 any = lang.NewList(args[2:]...)
					_ = v6
				recur_loop_10:
					var tmp7 any
					if lang.IsTruthy(v6) {
						tmp9 := lang.Apply(lang.Conj, []any{v4, v5})
						var tmp8 any = tmp9
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("first"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v6})
						var tmp10 any = tmp14
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("next"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v6})
						var tmp15 any = tmp19
						v4 = tmp8
						v5 = tmp10
						v6 = tmp15
						goto recur_loop_10
					} else {
						tmp20 := lang.Apply(lang.Conj, []any{v4, v5})
						tmp7 = tmp20
					}
					return tmp7
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(81), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(88), lang.NewKeyword("end-column"), int(67))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// conj!
	{
		tmp0 := lang.NewSymbol("conj!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3359), lang.NewKeyword("end-line"), int(3359))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("transient"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				tmp6 := lang.NewVector()
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3364), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3364), lang.NewKeyword("end-column"), int(19))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Conj")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Conj is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cons
	{
		tmp0 := lang.NewSymbol("cons").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("seq"))), lang.NewKeyword("doc"), "Returns a new seq where x is the first element and seq is\n    the rest.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(21), lang.NewKeyword("end-line"), int(27))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function cons
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.NewCons, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(27), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(27), lang.NewKeyword("end-column"), int(89))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// constantly
	{
		tmp0 := lang.NewSymbol("constantly").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a function that takes any number of arguments and returns x.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1440), lang.NewKeyword("end-line"), int(1440))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v5 any = lang.NewList(args[0:]...)
					_ = v5
					return v3
				}
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1444), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(1444), lang.NewKeyword("end-column"), int(21))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// contains?
	{
		tmp0 := lang.NewSymbol("contains?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1479), lang.NewKeyword("end-line"), int(1479))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Contains")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Contains is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// count
	{
		var tmp1 lang.FnFunc
		{ // function count__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Count")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(867), lang.NewKeyword("end-line"), int(867))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Count, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// counted?
	{
		tmp0 := lang.NewSymbol("counted?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements count in constant time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6241), lang.NewKeyword("end-line"), int(6241))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Counted)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-ns
	{
		tmp0 := lang.NewSymbol("create-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4131), lang.NewKeyword("end-line"), int(4131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// create-struct
	{
		tmp0 := lang.NewSymbol("create-struct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a structure basis object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4037), lang.NewKeyword("end-line"), int(4037))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentStructMapSlotMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// cycle
	{
		tmp0 := lang.NewSymbol("cycle").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2977), lang.NewKeyword("end-line"), int(2977))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8 := lang.Apply(lang.NewCycle, []any{tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-urls
	{
		tmp0 := lang.NewSymbol("data-reader-urls").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7830), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7830), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			return lang.NewList()
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// data-reader-var
	{
		tmp0 := lang.NewSymbol("data-reader-var").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7832), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7832), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("intern"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("create-ns"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("symbol"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("namespace"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := lang.Apply(tmp15, []any{v3})
			tmp17 := lang.Apply(tmp12, []any{tmp16})
			tmp18 := lang.Apply(tmp9, []any{tmp17})
			tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp20 := tmp19.FindInternedVar(lang.NewSymbol("symbol"))
			if tmp20.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
			}
			tmp21 := tmp20.Get()
			tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp23 := tmp22.FindInternedVar(lang.NewSymbol("name"))
			if tmp23.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
			}
			tmp24 := tmp23.Get()
			tmp25 := lang.Apply(tmp24, []any{v3})
			tmp26 := lang.Apply(tmp21, []any{tmp25})
			tmp27 := lang.Apply(tmp6, []any{tmp18, tmp26})
			return tmp27
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec
	{
		var tmp1 lang.FnFunc
		{ // function dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("unchecked_dec")
				} else {
					tmp30 = lang.NewSymbol("dec")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("dec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1147), lang.NewKeyword("end-line"), int(1147))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dec'
	{
		var tmp1 lang.FnFunc
		{ // function dec'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/DecP")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("dec'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1140), lang.NewKeyword("end-line"), int(1140))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DecP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("DecP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// decimal?
	{
		tmp0 := lang.NewSymbol("decimal?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a BigDecimal", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3599), lang.NewKeyword("end-line"), int(3599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.BigDecimal)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// declare
	{
		tmp0 := lang.NewSymbol("declare").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("names"))), lang.NewKeyword("doc"), "defs the supplied var names with no bindings, useful for making forward declarations.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2768), lang.NewKeyword("end-line"), int(2768))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("do")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("map"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				var tmp19 lang.FnFunc
				tmp19 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v20 := args[0]
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("vary-meta"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("assoc"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp26, []any{v20, tmp29, lang.NewKeyword("declared"), true})
					tmp31 := lang.Apply(tmp23, []any{lang.NewSymbol("def"), tmp30})
					return tmp31
				})
				tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2771), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(2771), lang.NewKeyword("end-column"), int(71))
				tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp22 := lang.Apply(tmp18, []any{tmp21, v5})
				tmp23 := lang.Apply(tmp11, []any{tmp15, tmp22})
				tmp24 := lang.Apply(tmp8, []any{tmp23})
				return tmp24
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dedupe
	{
		tmp0 := lang.NewSymbol("dedupe").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7681), lang.NewKeyword("end-line"), int(7681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "pv"
						tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp7 := tmp6.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp7.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
						}
						tmp8 := tmp7.Get()
						tmp9 := lang.Apply(tmp8, []any{lang.NewKeyword("glojure.core/none")})
						var v10 any = tmp9
						_ = v10
						var tmp11 lang.FnFunc
						tmp11 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp12 := lang.Apply(v4, nil)
								return tmp12
							case 1:
								v12 := args[0]
								_ = v12
								tmp13 := lang.Apply(v4, []any{v12})
								return tmp13
							case 2:
								v12 := args[0]
								_ = v12
								v13 := args[1]
								_ = v13
								var tmp14 any
								{ // let
									// let binding "prior"
									tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp16 := tmp15.FindInternedVar(lang.NewSymbol("deref"))
									if tmp16.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
									}
									tmp17 := tmp16.Get()
									tmp18 := lang.Apply(tmp17, []any{v10})
									var v19 any = tmp18
									_ = v19
									tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp21 := tmp20.FindInternedVar(lang.NewSymbol("vreset!"))
									if tmp21.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
									}
									tmp22 := tmp21.Get()
									tmp23 := lang.Apply(tmp22, []any{v10, v13})
									_ = tmp23
									var tmp24 any
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("="))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.Apply(tmp27, []any{v19, v13})
									if lang.IsTruthy(tmp28) {
										tmp24 = v12
									} else {
										tmp29 := lang.Apply(v4, []any{v12, v13})
										tmp24 = tmp29
									}
									tmp14 = tmp24
								} // end let
								return tmp14
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7688), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7696), lang.NewKeyword("end-column"), int(37))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp13
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7686), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7696), lang.NewKeyword("end-column"), int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("sequence"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("dedupe"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, nil)
				tmp11 := lang.Apply(tmp6, []any{tmp10, v3})
				return tmp11
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// def-aset
	{
		tmp0 := lang.NewSymbol("def-aset").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("method"), lang.NewSymbol("coerce"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(3), lang.NewKeyword("line"), int(3935), lang.NewKeyword("end-line"), int(3936), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 5 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
			if tmp12.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
			}
			tmp13 := tmp12.Get()
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("glojure.core/defn")})
			tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
			if tmp19.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
			}
			tmp20 := tmp19.Get()
			tmp21 := lang.Apply(tmp20, []any{v5})
			tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
			if tmp23.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
			}
			tmp24 := tmp23.Get()
			tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp26 := tmp25.FindInternedVar(lang.NewSymbol("apply"))
			if tmp26.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
			}
			tmp27 := tmp26.Get()
			tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp29 := tmp28.FindInternedVar(lang.NewSymbol("hash-map"))
			if tmp29.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
			}
			tmp30 := tmp29.Get()
			tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp32 := tmp31.FindInternedVar(lang.NewSymbol("seq"))
			if tmp32.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
			}
			tmp33 := tmp32.Get()
			tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp35 := tmp34.FindInternedVar(lang.NewSymbol("concat"))
			if tmp35.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
			}
			tmp36 := tmp35.Get()
			tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
			if tmp38.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
			}
			tmp39 := tmp38.Get()
			tmp40 := lang.Apply(tmp39, []any{lang.NewKeyword("arglists")})
			tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
			if tmp42.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
			}
			tmp43 := tmp42.Get()
			tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq"))
			if tmp45.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
			}
			tmp46 := tmp45.Get()
			tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp48 := tmp47.FindInternedVar(lang.NewSymbol("concat"))
			if tmp48.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
			}
			tmp49 := tmp48.Get()
			tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
			if tmp51.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
			}
			tmp52 := tmp51.Get()
			tmp53 := lang.Apply(tmp52, []any{lang.NewSymbol("quote")})
			tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
			if tmp55.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
			}
			tmp56 := tmp55.Get()
			tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp58 := tmp57.FindInternedVar(lang.NewSymbol("seq"))
			if tmp58.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
			}
			tmp59 := tmp58.Get()
			tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp61 := tmp60.FindInternedVar(lang.NewSymbol("concat"))
			if tmp61.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
			}
			tmp62 := tmp61.Get()
			tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp64 := tmp63.FindInternedVar(lang.NewSymbol("list"))
			if tmp64.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
			}
			tmp65 := tmp64.Get()
			tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp67 := tmp66.FindInternedVar(lang.NewSymbol("apply"))
			if tmp67.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
			}
			tmp68 := tmp67.Get()
			tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp70 := tmp69.FindInternedVar(lang.NewSymbol("vector"))
			if tmp70.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
			}
			tmp71 := tmp70.Get()
			tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp73 := tmp72.FindInternedVar(lang.NewSymbol("seq"))
			if tmp73.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
			}
			tmp74 := tmp73.Get()
			tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp76 := tmp75.FindInternedVar(lang.NewSymbol("concat"))
			if tmp76.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
			}
			tmp77 := tmp76.Get()
			tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp79 := tmp78.FindInternedVar(lang.NewSymbol("list"))
			if tmp79.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
			}
			tmp80 := tmp79.Get()
			tmp81 := lang.Apply(tmp80, []any{lang.NewSymbol("array")})
			tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp83 := tmp82.FindInternedVar(lang.NewSymbol("list"))
			if tmp83.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
			}
			tmp84 := tmp83.Get()
			tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("idx")})
			tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp87 := tmp86.FindInternedVar(lang.NewSymbol("list"))
			if tmp87.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
			}
			tmp88 := tmp87.Get()
			tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("val")})
			tmp90 := lang.Apply(tmp77, []any{tmp81, tmp85, tmp89})
			tmp91 := lang.Apply(tmp74, []any{tmp90})
			tmp92 := lang.Apply(tmp68, []any{tmp71, tmp91})
			tmp93 := lang.Apply(tmp65, []any{tmp92})
			tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
			if tmp95.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
			}
			tmp96 := tmp95.Get()
			tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp98 := tmp97.FindInternedVar(lang.NewSymbol("apply"))
			if tmp98.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
			}
			tmp99 := tmp98.Get()
			tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp101 := tmp100.FindInternedVar(lang.NewSymbol("vector"))
			if tmp101.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
			}
			tmp102 := tmp101.Get()
			tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp104 := tmp103.FindInternedVar(lang.NewSymbol("seq"))
			if tmp104.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
			}
			tmp105 := tmp104.Get()
			tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp107 := tmp106.FindInternedVar(lang.NewSymbol("concat"))
			if tmp107.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
			}
			tmp108 := tmp107.Get()
			tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
			if tmp110.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
			}
			tmp111 := tmp110.Get()
			tmp112 := lang.Apply(tmp111, []any{lang.NewSymbol("array")})
			tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp114 := tmp113.FindInternedVar(lang.NewSymbol("list"))
			if tmp114.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
			}
			tmp115 := tmp114.Get()
			tmp116 := lang.Apply(tmp115, []any{lang.NewSymbol("idx")})
			tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp118 := tmp117.FindInternedVar(lang.NewSymbol("list"))
			if tmp118.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
			}
			tmp119 := tmp118.Get()
			tmp120 := lang.Apply(tmp119, []any{lang.NewSymbol("idx2")})
			tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp122 := tmp121.FindInternedVar(lang.NewSymbol("list"))
			if tmp122.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
			}
			tmp123 := tmp122.Get()
			tmp124 := lang.Apply(tmp123, []any{lang.NewSymbol("&")})
			tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp126 := tmp125.FindInternedVar(lang.NewSymbol("list"))
			if tmp126.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
			}
			tmp127 := tmp126.Get()
			tmp128 := lang.Apply(tmp127, []any{lang.NewSymbol("idxv")})
			tmp129 := lang.Apply(tmp108, []any{tmp112, tmp116, tmp120, tmp124, tmp128})
			tmp130 := lang.Apply(tmp105, []any{tmp129})
			tmp131 := lang.Apply(tmp99, []any{tmp102, tmp130})
			tmp132 := lang.Apply(tmp96, []any{tmp131})
			tmp133 := lang.Apply(tmp62, []any{tmp93, tmp132})
			tmp134 := lang.Apply(tmp59, []any{tmp133})
			tmp135 := lang.Apply(tmp56, []any{tmp134})
			tmp136 := lang.Apply(tmp49, []any{tmp53, tmp135})
			tmp137 := lang.Apply(tmp46, []any{tmp136})
			tmp138 := lang.Apply(tmp43, []any{tmp137})
			tmp139 := lang.Apply(tmp36, []any{tmp40, tmp138})
			tmp140 := lang.Apply(tmp33, []any{tmp139})
			tmp141 := lang.Apply(tmp27, []any{tmp30, tmp140})
			tmp142 := lang.Apply(tmp24, []any{tmp141})
			tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
			if tmp144.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
			}
			tmp145 := tmp144.Get()
			tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp147 := tmp146.FindInternedVar(lang.NewSymbol("seq"))
			if tmp147.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
			}
			tmp148 := tmp147.Get()
			tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp150 := tmp149.FindInternedVar(lang.NewSymbol("concat"))
			if tmp150.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
			}
			tmp151 := tmp150.Get()
			tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp153 := tmp152.FindInternedVar(lang.NewSymbol("list"))
			if tmp153.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
			}
			tmp154 := tmp153.Get()
			tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp156 := tmp155.FindInternedVar(lang.NewSymbol("apply"))
			if tmp156.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
			}
			tmp157 := tmp156.Get()
			tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp159 := tmp158.FindInternedVar(lang.NewSymbol("vector"))
			if tmp159.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
			}
			tmp160 := tmp159.Get()
			tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp162 := tmp161.FindInternedVar(lang.NewSymbol("seq"))
			if tmp162.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
			}
			tmp163 := tmp162.Get()
			tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp165 := tmp164.FindInternedVar(lang.NewSymbol("concat"))
			if tmp165.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
			}
			tmp166 := tmp165.Get()
			tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp168 := tmp167.FindInternedVar(lang.NewSymbol("list"))
			if tmp168.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
			}
			tmp169 := tmp168.Get()
			tmp170 := lang.Apply(tmp169, []any{lang.NewSymbol("array__0__auto__")})
			tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
			if tmp172.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
			}
			tmp173 := tmp172.Get()
			tmp174 := lang.Apply(tmp173, []any{lang.NewSymbol("idx__1__auto__")})
			tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp176 := tmp175.FindInternedVar(lang.NewSymbol("list"))
			if tmp176.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
			}
			tmp177 := tmp176.Get()
			tmp178 := lang.Apply(tmp177, []any{lang.NewSymbol("val__2__auto__")})
			tmp179 := lang.Apply(tmp166, []any{tmp170, tmp174, tmp178})
			tmp180 := lang.Apply(tmp163, []any{tmp179})
			tmp181 := lang.Apply(tmp157, []any{tmp160, tmp180})
			tmp182 := lang.Apply(tmp154, []any{tmp181})
			tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp184 := tmp183.FindInternedVar(lang.NewSymbol("list"))
			if tmp184.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
			}
			tmp185 := tmp184.Get()
			tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp187 := tmp186.FindInternedVar(lang.NewSymbol("seq"))
			if tmp187.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
			}
			tmp188 := tmp187.Get()
			tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp190 := tmp189.FindInternedVar(lang.NewSymbol("concat"))
			if tmp190.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
			}
			tmp191 := tmp190.Get()
			tmp192 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp193 := tmp192.FindInternedVar(lang.NewSymbol("list"))
			if tmp193.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp193)))
			}
			tmp194 := tmp193.Get()
			tmp195 := lang.Apply(tmp194, []any{lang.NewSymbol(".")})
			tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp197 := tmp196.FindInternedVar(lang.NewSymbol("list"))
			if tmp197.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
			}
			tmp198 := tmp197.Get()
			tmp199 := lang.Apply(tmp198, []any{lang.NewSymbol("glojure.core/Array")})
			tmp200 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp201 := tmp200.FindInternedVar(lang.NewSymbol("list"))
			if tmp201.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp201)))
			}
			tmp202 := tmp201.Get()
			tmp203 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp204 := tmp203.FindInternedVar(lang.NewSymbol("seq"))
			if tmp204.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp204)))
			}
			tmp205 := tmp204.Get()
			tmp206 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp207 := tmp206.FindInternedVar(lang.NewSymbol("concat"))
			if tmp207.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp207)))
			}
			tmp208 := tmp207.Get()
			tmp209 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp210 := tmp209.FindInternedVar(lang.NewSymbol("list"))
			if tmp210.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp210)))
			}
			tmp211 := tmp210.Get()
			tmp212 := lang.Apply(tmp211, []any{v6})
			tmp213 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp214 := tmp213.FindInternedVar(lang.NewSymbol("list"))
			if tmp214.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp214)))
			}
			tmp215 := tmp214.Get()
			tmp216 := lang.Apply(tmp215, []any{lang.NewSymbol("array__0__auto__")})
			tmp217 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp218 := tmp217.FindInternedVar(lang.NewSymbol("list"))
			if tmp218.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp218)))
			}
			tmp219 := tmp218.Get()
			tmp220 := lang.Apply(tmp219, []any{lang.NewSymbol("idx__1__auto__")})
			tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp222 := tmp221.FindInternedVar(lang.NewSymbol("list"))
			if tmp222.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
			}
			tmp223 := tmp222.Get()
			tmp224 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp225 := tmp224.FindInternedVar(lang.NewSymbol("seq"))
			if tmp225.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp225)))
			}
			tmp226 := tmp225.Get()
			tmp227 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp228 := tmp227.FindInternedVar(lang.NewSymbol("concat"))
			if tmp228.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp228)))
			}
			tmp229 := tmp228.Get()
			tmp230 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp231 := tmp230.FindInternedVar(lang.NewSymbol("list"))
			if tmp231.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp231)))
			}
			tmp232 := tmp231.Get()
			tmp233 := lang.Apply(tmp232, []any{v7})
			tmp234 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp235 := tmp234.FindInternedVar(lang.NewSymbol("list"))
			if tmp235.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp235)))
			}
			tmp236 := tmp235.Get()
			tmp237 := lang.Apply(tmp236, []any{lang.NewSymbol("val__2__auto__")})
			tmp238 := lang.Apply(tmp229, []any{tmp233, tmp237})
			tmp239 := lang.Apply(tmp226, []any{tmp238})
			tmp240 := lang.Apply(tmp223, []any{tmp239})
			tmp241 := lang.Apply(tmp208, []any{tmp212, tmp216, tmp220, tmp240})
			tmp242 := lang.Apply(tmp205, []any{tmp241})
			tmp243 := lang.Apply(tmp202, []any{tmp242})
			tmp244 := lang.Apply(tmp191, []any{tmp195, tmp199, tmp243})
			tmp245 := lang.Apply(tmp188, []any{tmp244})
			tmp246 := lang.Apply(tmp185, []any{tmp245})
			tmp247 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp248 := tmp247.FindInternedVar(lang.NewSymbol("list"))
			if tmp248.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp248)))
			}
			tmp249 := tmp248.Get()
			tmp250 := lang.Apply(tmp249, []any{lang.NewSymbol("val__2__auto__")})
			tmp251 := lang.Apply(tmp151, []any{tmp182, tmp246, tmp250})
			tmp252 := lang.Apply(tmp148, []any{tmp251})
			tmp253 := lang.Apply(tmp145, []any{tmp252})
			tmp254 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp255 := tmp254.FindInternedVar(lang.NewSymbol("list"))
			if tmp255.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp255)))
			}
			tmp256 := tmp255.Get()
			tmp257 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp258 := tmp257.FindInternedVar(lang.NewSymbol("seq"))
			if tmp258.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp258)))
			}
			tmp259 := tmp258.Get()
			tmp260 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp261 := tmp260.FindInternedVar(lang.NewSymbol("concat"))
			if tmp261.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp261)))
			}
			tmp262 := tmp261.Get()
			tmp263 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp264 := tmp263.FindInternedVar(lang.NewSymbol("list"))
			if tmp264.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp264)))
			}
			tmp265 := tmp264.Get()
			tmp266 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp267 := tmp266.FindInternedVar(lang.NewSymbol("apply"))
			if tmp267.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp267)))
			}
			tmp268 := tmp267.Get()
			tmp269 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp270 := tmp269.FindInternedVar(lang.NewSymbol("vector"))
			if tmp270.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp270)))
			}
			tmp271 := tmp270.Get()
			tmp272 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp273 := tmp272.FindInternedVar(lang.NewSymbol("seq"))
			if tmp273.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp273)))
			}
			tmp274 := tmp273.Get()
			tmp275 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp276 := tmp275.FindInternedVar(lang.NewSymbol("concat"))
			if tmp276.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp276)))
			}
			tmp277 := tmp276.Get()
			tmp278 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp279 := tmp278.FindInternedVar(lang.NewSymbol("list"))
			if tmp279.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp279)))
			}
			tmp280 := tmp279.Get()
			tmp281 := lang.Apply(tmp280, []any{lang.NewSymbol("array__0__auto__")})
			tmp282 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp283 := tmp282.FindInternedVar(lang.NewSymbol("list"))
			if tmp283.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp283)))
			}
			tmp284 := tmp283.Get()
			tmp285 := lang.Apply(tmp284, []any{lang.NewSymbol("idx__1__auto__")})
			tmp286 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp287 := tmp286.FindInternedVar(lang.NewSymbol("list"))
			if tmp287.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp287)))
			}
			tmp288 := tmp287.Get()
			tmp289 := lang.Apply(tmp288, []any{lang.NewSymbol("idx2__3__auto__")})
			tmp290 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp291 := tmp290.FindInternedVar(lang.NewSymbol("list"))
			if tmp291.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp291)))
			}
			tmp292 := tmp291.Get()
			tmp293 := lang.Apply(tmp292, []any{lang.NewSymbol("&")})
			tmp294 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp295 := tmp294.FindInternedVar(lang.NewSymbol("list"))
			if tmp295.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp295)))
			}
			tmp296 := tmp295.Get()
			tmp297 := lang.Apply(tmp296, []any{lang.NewSymbol("idxv__4__auto__")})
			tmp298 := lang.Apply(tmp277, []any{tmp281, tmp285, tmp289, tmp293, tmp297})
			tmp299 := lang.Apply(tmp274, []any{tmp298})
			tmp300 := lang.Apply(tmp268, []any{tmp271, tmp299})
			tmp301 := lang.Apply(tmp265, []any{tmp300})
			tmp302 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp303 := tmp302.FindInternedVar(lang.NewSymbol("list"))
			if tmp303.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp303)))
			}
			tmp304 := tmp303.Get()
			tmp305 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp306 := tmp305.FindInternedVar(lang.NewSymbol("seq"))
			if tmp306.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp306)))
			}
			tmp307 := tmp306.Get()
			tmp308 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp309 := tmp308.FindInternedVar(lang.NewSymbol("concat"))
			if tmp309.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp309)))
			}
			tmp310 := tmp309.Get()
			tmp311 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp312 := tmp311.FindInternedVar(lang.NewSymbol("list"))
			if tmp312.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp312)))
			}
			tmp313 := tmp312.Get()
			tmp314 := lang.Apply(tmp313, []any{lang.NewSymbol("glojure.core/apply")})
			tmp315 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp316 := tmp315.FindInternedVar(lang.NewSymbol("list"))
			if tmp316.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp316)))
			}
			tmp317 := tmp316.Get()
			tmp318 := lang.Apply(tmp317, []any{v5})
			tmp319 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp320 := tmp319.FindInternedVar(lang.NewSymbol("list"))
			if tmp320.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp320)))
			}
			tmp321 := tmp320.Get()
			tmp322 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp323 := tmp322.FindInternedVar(lang.NewSymbol("seq"))
			if tmp323.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp323)))
			}
			tmp324 := tmp323.Get()
			tmp325 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp326 := tmp325.FindInternedVar(lang.NewSymbol("concat"))
			if tmp326.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp326)))
			}
			tmp327 := tmp326.Get()
			tmp328 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp329 := tmp328.FindInternedVar(lang.NewSymbol("list"))
			if tmp329.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp329)))
			}
			tmp330 := tmp329.Get()
			tmp331 := lang.Apply(tmp330, []any{lang.NewSymbol("glojure.core/aget")})
			tmp332 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp333 := tmp332.FindInternedVar(lang.NewSymbol("list"))
			if tmp333.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp333)))
			}
			tmp334 := tmp333.Get()
			tmp335 := lang.Apply(tmp334, []any{lang.NewSymbol("array__0__auto__")})
			tmp336 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp337 := tmp336.FindInternedVar(lang.NewSymbol("list"))
			if tmp337.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp337)))
			}
			tmp338 := tmp337.Get()
			tmp339 := lang.Apply(tmp338, []any{lang.NewSymbol("idx__1__auto__")})
			tmp340 := lang.Apply(tmp327, []any{tmp331, tmp335, tmp339})
			tmp341 := lang.Apply(tmp324, []any{tmp340})
			tmp342 := lang.Apply(tmp321, []any{tmp341})
			tmp343 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp344 := tmp343.FindInternedVar(lang.NewSymbol("list"))
			if tmp344.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp344)))
			}
			tmp345 := tmp344.Get()
			tmp346 := lang.Apply(tmp345, []any{lang.NewSymbol("idx2__3__auto__")})
			tmp347 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp348 := tmp347.FindInternedVar(lang.NewSymbol("list"))
			if tmp348.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp348)))
			}
			tmp349 := tmp348.Get()
			tmp350 := lang.Apply(tmp349, []any{lang.NewSymbol("idxv__4__auto__")})
			tmp351 := lang.Apply(tmp310, []any{tmp314, tmp318, tmp342, tmp346, tmp350})
			tmp352 := lang.Apply(tmp307, []any{tmp351})
			tmp353 := lang.Apply(tmp304, []any{tmp352})
			tmp354 := lang.Apply(tmp262, []any{tmp301, tmp353})
			tmp355 := lang.Apply(tmp259, []any{tmp354})
			tmp356 := lang.Apply(tmp256, []any{tmp355})
			tmp357 := lang.Apply(tmp13, []any{tmp17, tmp21, tmp142, tmp253, tmp356})
			tmp358 := lang.Apply(tmp10, []any{tmp357})
			return tmp358
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// definline
	{
		tmp0 := lang.NewSymbol("definline").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("decl"))), lang.NewKeyword("doc"), "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5253), lang.NewKeyword("end-line"), int(5253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__80"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("split-with"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("comp"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("not"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("vector?"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp13, []any{tmp16, tmp19})
					tmp21 := lang.Apply(tmp10, []any{tmp20, v6})
					var v22 any = tmp21
					_ = v22
					// let binding "pre-args"
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("nth"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{v22, int64(0), nil})
					var v27 any = tmp26
					_ = v27
					// let binding "vec__83"
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("nth"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.Apply(tmp30, []any{v22, int64(1), nil})
					var v32 any = tmp31
					_ = v32
					// let binding "args"
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("nth"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v32, int64(0), nil})
					var v37 any = tmp36
					_ = v37
					// let binding "expr"
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("nth"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp40, []any{v32, int64(1), nil})
					var v42 any = tmp41
					_ = v42
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("concat"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp50 := tmp49.FindInternedVar(lang.NewSymbol("list"))
					if tmp50.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
					}
					tmp51 := tmp50.Get()
					tmp52 := lang.Apply(tmp51, []any{lang.NewSymbol("do")})
					tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
					if tmp54.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
					}
					tmp55 := tmp54.Get()
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("seq"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp60 := tmp59.FindInternedVar(lang.NewSymbol("concat"))
					if tmp60.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
					}
					tmp61 := tmp60.Get()
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("list"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("glojure.core/defn")})
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(tmp68, []any{v5})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.Apply(tmp72, []any{v37})
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("apply"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("eval"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp84 := tmp83.FindInternedVar(lang.NewSymbol("list"))
					if tmp84.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
					}
					tmp85 := tmp84.Get()
					tmp86 := lang.Apply(tmp85, []any{lang.NewSymbol("glojure.core/fn"), v37, v42})
					tmp87 := lang.Apply(tmp82, []any{tmp86})
					tmp88 := lang.Apply(tmp79, []any{tmp87, v37})
					tmp89 := lang.Apply(tmp76, []any{tmp88})
					tmp90 := lang.Apply(tmp61, []any{tmp65, tmp69, v27, tmp73, tmp89})
					tmp91 := lang.Apply(tmp58, []any{tmp90})
					tmp92 := lang.Apply(tmp55, []any{tmp91})
					tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
					if tmp94.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
					}
					tmp95 := tmp94.Get()
					tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp97 := tmp96.FindInternedVar(lang.NewSymbol("seq"))
					if tmp97.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
					}
					tmp98 := tmp97.Get()
					tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp100 := tmp99.FindInternedVar(lang.NewSymbol("concat"))
					if tmp100.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
					}
					tmp101 := tmp100.Get()
					tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
					if tmp103.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
					}
					tmp104 := tmp103.Get()
					tmp105 := lang.Apply(tmp104, []any{lang.NewSymbol("glojure.core/alter-meta!")})
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp110 := tmp109.FindInternedVar(lang.NewSymbol("seq"))
					if tmp110.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
					}
					tmp111 := tmp110.Get()
					tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp113 := tmp112.FindInternedVar(lang.NewSymbol("concat"))
					if tmp113.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
					}
					tmp114 := tmp113.Get()
					tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp116 := tmp115.FindInternedVar(lang.NewSymbol("list"))
					if tmp116.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
					}
					tmp117 := tmp116.Get()
					tmp118 := lang.Apply(tmp117, []any{lang.NewSymbol("var")})
					tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp120 := tmp119.FindInternedVar(lang.NewSymbol("list"))
					if tmp120.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
					}
					tmp121 := tmp120.Get()
					tmp122 := lang.Apply(tmp121, []any{v5})
					tmp123 := lang.Apply(tmp114, []any{tmp118, tmp122})
					tmp124 := lang.Apply(tmp111, []any{tmp123})
					tmp125 := lang.Apply(tmp108, []any{tmp124})
					tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
					if tmp127.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
					}
					tmp128 := tmp127.Get()
					tmp129 := lang.Apply(tmp128, []any{lang.NewSymbol("glojure.core/assoc")})
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{lang.NewKeyword("inline")})
					tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
					if tmp135.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
					}
					tmp136 := tmp135.Get()
					tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
					if tmp138.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
					}
					tmp139 := tmp138.Get()
					tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
					if tmp141.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
					}
					tmp142 := tmp141.Get()
					tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
					if tmp144.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
					}
					tmp145 := tmp144.Get()
					tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("glojure.core/fn")})
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.Apply(tmp149, []any{v5})
					tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp152 := tmp151.FindInternedVar(lang.NewSymbol("list"))
					if tmp152.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
					}
					tmp153 := tmp152.Get()
					tmp154 := lang.Apply(tmp153, []any{v37})
					tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp156 := tmp155.FindInternedVar(lang.NewSymbol("list"))
					if tmp156.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
					}
					tmp157 := tmp156.Get()
					tmp158 := lang.Apply(tmp157, []any{v42})
					tmp159 := lang.Apply(tmp142, []any{tmp146, tmp150, tmp154, tmp158})
					tmp160 := lang.Apply(tmp139, []any{tmp159})
					tmp161 := lang.Apply(tmp136, []any{tmp160})
					tmp162 := lang.Apply(tmp101, []any{tmp105, tmp125, tmp129, tmp133, tmp161})
					tmp163 := lang.Apply(tmp98, []any{tmp162})
					tmp164 := lang.Apply(tmp95, []any{tmp163})
					tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp166 := tmp165.FindInternedVar(lang.NewSymbol("list"))
					if tmp166.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
					}
					tmp167 := tmp166.Get()
					tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp169 := tmp168.FindInternedVar(lang.NewSymbol("seq"))
					if tmp169.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
					}
					tmp170 := tmp169.Get()
					tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp172 := tmp171.FindInternedVar(lang.NewSymbol("concat"))
					if tmp172.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
					}
					tmp173 := tmp172.Get()
					tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp175 := tmp174.FindInternedVar(lang.NewSymbol("list"))
					if tmp175.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
					}
					tmp176 := tmp175.Get()
					tmp177 := lang.Apply(tmp176, []any{lang.NewSymbol("var")})
					tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list"))
					if tmp179.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
					}
					tmp180 := tmp179.Get()
					tmp181 := lang.Apply(tmp180, []any{v5})
					tmp182 := lang.Apply(tmp173, []any{tmp177, tmp181})
					tmp183 := lang.Apply(tmp170, []any{tmp182})
					tmp184 := lang.Apply(tmp167, []any{tmp183})
					tmp185 := lang.Apply(tmp48, []any{tmp52, tmp92, tmp164, tmp184})
					tmp186 := lang.Apply(tmp45, []any{tmp185})
					tmp7 = tmp186
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmacro
	{
		tmp0 := lang.NewSymbol("defmacro").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("body")), lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("body")), lang.NewSymbol("+"), lang.NewSymbol("attr-map?"))), lang.NewKeyword("doc"), "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(445), lang.NewKeyword("end-line"), int(451))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "prefix"
					var tmp8 any
					{ // let
						// let binding "p"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("list"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v5})
						var v13 any = tmp12
						_ = v13
						// let binding "args"
						var v14 any = v6
						_ = v14
						for {
							var tmp15 any
							{ // let
								// let binding "f"
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v14})
								var v20 any = tmp19
								_ = v20
								var tmp21 any
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("string?"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v20})
								if lang.IsTruthy(tmp25) {
									tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp28 := tmp27.FindInternedVar(lang.NewSymbol("cons"))
									if tmp28.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
									}
									tmp29 := tmp28.Get()
									tmp30 := lang.Apply(tmp29, []any{v20, v13})
									var tmp26 any = tmp30
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("next"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v14})
									var tmp31 any = tmp35
									v13 = tmp26
									v14 = tmp31
									continue
								} else {
									var tmp36 any
									tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp38 := tmp37.FindInternedVar(lang.NewSymbol("map?"))
									if tmp38.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
									}
									tmp39 := tmp38.Get()
									tmp40 := lang.Apply(tmp39, []any{v20})
									if lang.IsTruthy(tmp40) {
										tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp43 := tmp42.FindInternedVar(lang.NewSymbol("cons"))
										if tmp43.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
										}
										tmp44 := tmp43.Get()
										tmp45 := lang.Apply(tmp44, []any{v20, v13})
										var tmp41 any = tmp45
										tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp48 := tmp47.FindInternedVar(lang.NewSymbol("next"))
										if tmp48.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
										}
										tmp49 := tmp48.Get()
										tmp50 := lang.Apply(tmp49, []any{v14})
										var tmp46 any = tmp50
										v13 = tmp41
										v14 = tmp46
										continue
									} else {
										tmp36 = v13
									}
									tmp21 = tmp36
								}
								tmp15 = tmp21
							} // end let
							tmp8 = tmp15
							break
						}
					} // end let
					var v9 any = tmp8
					_ = v9
					// let binding "fdecl"
					var tmp10 any
					{ // let
						// let binding "fd"
						var v11 any = v6
						_ = v11
						for {
							var tmp12 any
							tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp14 := tmp13.FindInternedVar(lang.NewSymbol("string?"))
							if tmp14.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
							}
							tmp15 := tmp14.Get()
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.Apply(tmp18, []any{v11})
							tmp20 := lang.Apply(tmp15, []any{tmp19})
							if lang.IsTruthy(tmp20) {
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v11})
								var tmp21 any = tmp25
								v11 = tmp21
								continue
							} else {
								var tmp26 any
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("map?"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp31 := tmp30.FindInternedVar(lang.NewSymbol("first"))
								if tmp31.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
								}
								tmp32 := tmp31.Get()
								tmp33 := lang.Apply(tmp32, []any{v11})
								tmp34 := lang.Apply(tmp29, []any{tmp33})
								if lang.IsTruthy(tmp34) {
									tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp37 := tmp36.FindInternedVar(lang.NewSymbol("next"))
									if tmp37.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
									}
									tmp38 := tmp37.Get()
									tmp39 := lang.Apply(tmp38, []any{v11})
									var tmp35 any = tmp39
									v11 = tmp35
									continue
								} else {
									tmp26 = v11
								}
								tmp12 = tmp26
							}
							tmp10 = tmp12
							break
						}
					} // end let
					var v11 any = tmp10
					_ = v11
					// let binding "fdecl"
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("vector?"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v11})
					tmp20 := lang.Apply(tmp15, []any{tmp19})
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v11})
						tmp12 = tmp24
					} else {
						tmp12 = v11
					}
					var v25 any = tmp12
					_ = v25
					// let binding "add-implicit-args"
					var tmp26 lang.FnFunc
					tmp26 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v27 := args[0]
						_ = v27
						var tmp28 any
						{ // let
							// let binding "args"
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v27})
							var v33 any = tmp32
							_ = v33
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("cons"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("vec"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("cons"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp44 := tmp43.FindInternedVar(lang.NewSymbol("cons"))
							if tmp44.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
							}
							tmp45 := tmp44.Get()
							tmp46 := lang.Apply(tmp45, []any{lang.NewSymbol("&env"), v33})
							tmp47 := lang.Apply(tmp42, []any{lang.NewSymbol("&form"), tmp46})
							tmp48 := lang.Apply(tmp39, []any{tmp47})
							tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp50 := tmp49.FindInternedVar(lang.NewSymbol("next"))
							if tmp50.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
							}
							tmp51 := tmp50.Get()
							tmp52 := lang.Apply(tmp51, []any{v27})
							tmp53 := lang.Apply(tmp36, []any{tmp48, tmp52})
							tmp28 = tmp53
						} // end let
						return tmp28
					})
					tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(469), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(471), lang.NewKeyword("end-column"), int(87))
					tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v29 any = tmp28
					_ = v29
					// let binding "add-args"
					var tmp30 lang.FnFunc
					tmp30 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v31 := args[0]
						_ = v31
						v32 := args[1]
						_ = v32
					recur_loop_61:
						var tmp33 any
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.Apply(tmp36, []any{v32})
						if lang.IsTruthy(tmp37) {
							tmp33 = v31
						} else {
							var tmp38 any
							{ // let
								// let binding "d"
								tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp40 := tmp39.FindInternedVar(lang.NewSymbol("first"))
								if tmp40.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
								}
								tmp41 := tmp40.Get()
								tmp42 := lang.Apply(tmp41, []any{v32})
								var v43 any = tmp42
								_ = v43
								var tmp44 any
								tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp46 := tmp45.FindInternedVar(lang.NewSymbol("map?"))
								if tmp46.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
								}
								tmp47 := tmp46.Get()
								tmp48 := lang.Apply(tmp47, []any{v43})
								if lang.IsTruthy(tmp48) {
									tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp50 := tmp49.FindInternedVar(lang.NewSymbol("conj"))
									if tmp50.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
									}
									tmp51 := tmp50.Get()
									tmp52 := lang.Apply(tmp51, []any{v31, v43})
									tmp44 = tmp52
								} else {
									tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp55 := tmp54.FindInternedVar(lang.NewSymbol("conj"))
									if tmp55.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
									}
									tmp56 := tmp55.Get()
									tmp57 := lang.Apply(v29, []any{v43})
									tmp58 := lang.Apply(tmp56, []any{v31, tmp57})
									var tmp53 any = tmp58
									tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp61 := tmp60.FindInternedVar(lang.NewSymbol("next"))
									if tmp61.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
									}
									tmp62 := tmp61.Get()
									tmp63 := lang.Apply(tmp62, []any{v32})
									var tmp59 any = tmp63
									v31 = tmp53
									v32 = tmp59
									goto recur_loop_61
								}
								tmp38 = tmp44
							} // end let
							tmp33 = tmp38
						}
						return tmp33
					})
					tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(472), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(478), lang.NewKeyword("end-column"), int(90))
					tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v33 any = tmp32
					_ = v33
					// let binding "fdecl"
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.NewVector()
					tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(479), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(479), lang.NewKeyword("end-column"), int(42))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.Apply(v33, []any{tmp39, v25})
					tmp41 := lang.Apply(tmp36, []any{tmp40})
					var v42 any = tmp41
					_ = v42
					// let binding "decl"
					var tmp43 any
					{ // let
						// let binding "p"
						var v44 any = v9
						_ = v44
						// let binding "d"
						var v45 any = v42
						_ = v45
						for {
							var tmp46 any
							if lang.IsTruthy(v44) {
								tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp49 := tmp48.FindInternedVar(lang.NewSymbol("next"))
								if tmp49.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
								}
								tmp50 := tmp49.Get()
								tmp51 := lang.Apply(tmp50, []any{v44})
								var tmp47 any = tmp51
								tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp54 := tmp53.FindInternedVar(lang.NewSymbol("cons"))
								if tmp54.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
								}
								tmp55 := tmp54.Get()
								tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp57 := tmp56.FindInternedVar(lang.NewSymbol("first"))
								if tmp57.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
								}
								tmp58 := tmp57.Get()
								tmp59 := lang.Apply(tmp58, []any{v44})
								tmp60 := lang.Apply(tmp55, []any{tmp59, v45})
								var tmp52 any = tmp60
								v44 = tmp47
								v45 = tmp52
								continue
							} else {
								tmp46 = v45
							}
							tmp43 = tmp46
							break
						}
					} // end let
					var v44 any = tmp43
					_ = v44
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("cons"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("glojure.core/defn"), v44})
					tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
					if tmp53.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
					}
					tmp54 := tmp53.Get()
					tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp56 := tmp55.FindInternedVar(lang.NewSymbol("list"))
					if tmp56.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
					}
					tmp57 := tmp56.Get()
					tmp58 := lang.Apply(tmp57, []any{lang.NewSymbol("var"), v5})
					tmp59 := lang.Apply(tmp54, []any{lang.NewSymbol("."), tmp58, lang.NewList(lang.NewSymbol("SetMacro"))})
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("list"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.Apply(tmp62, []any{lang.NewSymbol("var"), v5})
					tmp64 := lang.Apply(tmp47, []any{lang.NewSymbol("do"), tmp51, tmp59, tmp63})
					tmp7 = tmp64
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(451), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(487), lang.NewKeyword("end-column"), int(40))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmethod
	{
		tmp0 := lang.NewSymbol("defmethod").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"), lang.NewSymbol("&"), lang.NewSymbol("fn-tail"))), lang.NewKeyword("doc"), "Creates and installs a new method of multimethod associated with dispatch-value. ", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1781), lang.NewKeyword("end-line"), int(1781))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol(".")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("with-meta"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn"))
				tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1785), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(1785), lang.NewKeyword("end-column"), int(82))
				tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp27 := lang.Apply(tmp23, []any{v5, tmp26})
				tmp28 := lang.Apply(tmp20, []any{tmp27})
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/AddMethod")})
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v6})
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
				if tmp41.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
				}
				tmp42 := tmp41.Get()
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
				if tmp47.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
				}
				tmp48 := tmp47.Get()
				tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.core/fn")})
				tmp50 := lang.Apply(tmp45, []any{tmp49, v7})
				tmp51 := lang.Apply(tmp42, []any{tmp50})
				tmp52 := lang.Apply(tmp39, []any{tmp51})
				tmp53 := lang.Apply(tmp13, []any{tmp17, tmp28, tmp32, tmp36, tmp52})
				tmp54 := lang.Apply(tmp10, []any{tmp53})
				return tmp54
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defmulti
	{
		tmp0 := lang.NewSymbol("defmulti").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring?"), lang.NewSymbol("attr-map?"), lang.NewSymbol("dispatch-fn"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1723), lang.NewKeyword("end-line"), int(1723))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "docstring"
					var tmp8 any
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("string?"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp11, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v6})
						tmp8 = tmp20
					} else {
					}
					var v21 any = tmp8
					_ = v21
					// let binding "options"
					var tmp22 any
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("string?"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("first"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.Apply(tmp28, []any{v6})
					tmp30 := lang.Apply(tmp25, []any{tmp29})
					if lang.IsTruthy(tmp30) {
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("next"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v6})
						tmp22 = tmp34
					} else {
						tmp22 = v6
					}
					var v35 any = tmp22
					_ = v35
					// let binding "m"
					var tmp36 any
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("map?"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v35})
					tmp44 := lang.Apply(tmp39, []any{tmp43})
					if lang.IsTruthy(tmp44) {
						tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp46 := tmp45.FindInternedVar(lang.NewSymbol("first"))
						if tmp46.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
						}
						tmp47 := tmp46.Get()
						tmp48 := lang.Apply(tmp47, []any{v35})
						tmp36 = tmp48
					} else {
						tmp49 := lang.NewMap()
						tmp50 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1757), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(1757), lang.NewKeyword("end-column"), int(24))
						tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp36 = tmp51
					}
					var v52 any = tmp36
					_ = v52
					// let binding "options"
					var tmp53 any
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("map?"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("first"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v35})
					tmp61 := lang.Apply(tmp56, []any{tmp60})
					if lang.IsTruthy(tmp61) {
						tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp63 := tmp62.FindInternedVar(lang.NewSymbol("next"))
						if tmp63.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
						}
						tmp64 := tmp63.Get()
						tmp65 := lang.Apply(tmp64, []any{v35})
						tmp53 = tmp65
					} else {
						tmp53 = v35
					}
					var v66 any = tmp53
					_ = v66
					// let binding "dispatch-fn"
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("first"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.Apply(tmp69, []any{v66})
					var v71 any = tmp70
					_ = v71
					// let binding "options"
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("next"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{v66})
					var v76 any = tmp75
					_ = v76
					// let binding "m"
					var tmp77 any
					if lang.IsTruthy(v21) {
						tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp79 := tmp78.FindInternedVar(lang.NewSymbol("assoc"))
						if tmp79.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
						}
						tmp80 := tmp79.Get()
						tmp81 := lang.Apply(tmp80, []any{v52, lang.NewKeyword("doc"), v21})
						tmp77 = tmp81
					} else {
						tmp77 = v52
					}
					var v82 any = tmp77
					_ = v82
					// let binding "m"
					var tmp83 any
					tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp85 := tmp84.FindInternedVar(lang.NewSymbol("meta"))
					if tmp85.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
					}
					tmp86 := tmp85.Get()
					tmp87 := lang.Apply(tmp86, []any{v5})
					if lang.IsTruthy(tmp87) {
						tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp89 := tmp88.FindInternedVar(lang.NewSymbol("conj"))
						if tmp89.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
						}
						tmp90 := tmp89.Get()
						tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp92 := tmp91.FindInternedVar(lang.NewSymbol("meta"))
						if tmp92.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
						}
						tmp93 := tmp92.Get()
						tmp94 := lang.Apply(tmp93, []any{v5})
						tmp95 := lang.Apply(tmp90, []any{tmp94, v82})
						tmp83 = tmp95
					} else {
						tmp83 = v82
					}
					var v96 any = tmp83
					_ = v96
					// let binding "mm-name"
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.Apply(tmp99, []any{v5, v96})
					var v101 any = tmp100
					_ = v101
					var tmp102 any
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("="))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("count"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.Apply(tmp108, []any{v76})
					tmp110 := lang.Apply(tmp105, []any{tmp109, int64(1)})
					if lang.IsTruthy(tmp110) {
						tmp111 := lang.Apply(lang.NewError, []any{"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)"})
						panic(tmp111)
					} else {
					}
					_ = tmp102
					var tmp112 any
					{ // let
						// let binding "options"
						tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp114 := tmp113.FindInternedVar(lang.NewSymbol("apply"))
						if tmp114.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
						}
						tmp115 := tmp114.Get()
						tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp117 := tmp116.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp117.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
						}
						tmp118 := tmp117.Get()
						tmp119 := lang.Apply(tmp115, []any{tmp118, v76})
						var v120 any = tmp119
						_ = v120
						// let binding "default"
						tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp122 := tmp121.FindInternedVar(lang.NewSymbol("get"))
						if tmp122.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
						}
						tmp123 := tmp122.Get()
						tmp124 := lang.Apply(tmp123, []any{v120, lang.NewKeyword("default"), lang.NewKeyword("default")})
						var v125 any = tmp124
						_ = v125
						// let binding "hierarchy"
						tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp127 := tmp126.FindInternedVar(lang.NewSymbol("get"))
						if tmp127.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
						}
						tmp128 := tmp127.Get()
						tmp129 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
						tmp130 := lang.Apply(tmp128, []any{v120, lang.NewKeyword("hierarchy"), tmp129})
						var v131 any = tmp130
						_ = v131
						tmp132 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp133 := tmp132.FindInternedVar(lang.NewSymbol("check-valid-options"))
						if tmp133.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp133)))
						}
						tmp134 := tmp133.Get()
						tmp135 := lang.Apply(tmp134, []any{v120, lang.NewKeyword("default"), lang.NewKeyword("hierarchy")})
						_ = tmp135
						tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp137 := tmp136.FindInternedVar(lang.NewSymbol("seq"))
						if tmp137.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
						}
						tmp138 := tmp137.Get()
						tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp140 := tmp139.FindInternedVar(lang.NewSymbol("concat"))
						if tmp140.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
						}
						tmp141 := tmp140.Get()
						tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp143 := tmp142.FindInternedVar(lang.NewSymbol("list"))
						if tmp143.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
						}
						tmp144 := tmp143.Get()
						tmp145 := lang.Apply(tmp144, []any{lang.NewSymbol("glojure.core/let")})
						tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
						if tmp147.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
						}
						tmp148 := tmp147.Get()
						tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp150 := tmp149.FindInternedVar(lang.NewSymbol("apply"))
						if tmp150.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
						}
						tmp151 := tmp150.Get()
						tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp153 := tmp152.FindInternedVar(lang.NewSymbol("vector"))
						if tmp153.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
						}
						tmp154 := tmp153.Get()
						tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp156 := tmp155.FindInternedVar(lang.NewSymbol("seq"))
						if tmp156.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
						}
						tmp157 := tmp156.Get()
						tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp159 := tmp158.FindInternedVar(lang.NewSymbol("concat"))
						if tmp159.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
						}
						tmp160 := tmp159.Get()
						tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp162 := tmp161.FindInternedVar(lang.NewSymbol("list"))
						if tmp162.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
						}
						tmp163 := tmp162.Get()
						tmp164 := lang.Apply(tmp163, []any{lang.NewSymbol("v__0__auto__")})
						tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp166 := tmp165.FindInternedVar(lang.NewSymbol("list"))
						if tmp166.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
						}
						tmp167 := tmp166.Get()
						tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp169 := tmp168.FindInternedVar(lang.NewSymbol("seq"))
						if tmp169.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
						}
						tmp170 := tmp169.Get()
						tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp172 := tmp171.FindInternedVar(lang.NewSymbol("concat"))
						if tmp172.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
						}
						tmp173 := tmp172.Get()
						tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp175 := tmp174.FindInternedVar(lang.NewSymbol("list"))
						if tmp175.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
						}
						tmp176 := tmp175.Get()
						tmp177 := lang.Apply(tmp176, []any{lang.NewSymbol("def")})
						tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list"))
						if tmp179.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
						}
						tmp180 := tmp179.Get()
						tmp181 := lang.Apply(tmp180, []any{v101})
						tmp182 := lang.Apply(tmp173, []any{tmp177, tmp181})
						tmp183 := lang.Apply(tmp170, []any{tmp182})
						tmp184 := lang.Apply(tmp167, []any{tmp183})
						tmp185 := lang.Apply(tmp160, []any{tmp164, tmp184})
						tmp186 := lang.Apply(tmp157, []any{tmp185})
						tmp187 := lang.Apply(tmp151, []any{tmp154, tmp186})
						tmp188 := lang.Apply(tmp148, []any{tmp187})
						tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
						if tmp190.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
						}
						tmp191 := tmp190.Get()
						tmp192 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp193 := tmp192.FindInternedVar(lang.NewSymbol("seq"))
						if tmp193.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp193)))
						}
						tmp194 := tmp193.Get()
						tmp195 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp196 := tmp195.FindInternedVar(lang.NewSymbol("concat"))
						if tmp196.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp196)))
						}
						tmp197 := tmp196.Get()
						tmp198 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp199 := tmp198.FindInternedVar(lang.NewSymbol("list"))
						if tmp199.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp199)))
						}
						tmp200 := tmp199.Get()
						tmp201 := lang.Apply(tmp200, []any{lang.NewSymbol("glojure.core/when-not")})
						tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp203 := tmp202.FindInternedVar(lang.NewSymbol("list"))
						if tmp203.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
						}
						tmp204 := tmp203.Get()
						tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp206 := tmp205.FindInternedVar(lang.NewSymbol("seq"))
						if tmp206.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
						}
						tmp207 := tmp206.Get()
						tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp209 := tmp208.FindInternedVar(lang.NewSymbol("concat"))
						if tmp209.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
						}
						tmp210 := tmp209.Get()
						tmp211 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp212 := tmp211.FindInternedVar(lang.NewSymbol("list"))
						if tmp212.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp212)))
						}
						tmp213 := tmp212.Get()
						tmp214 := lang.Apply(tmp213, []any{lang.NewSymbol("glojure.core/and")})
						tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp216 := tmp215.FindInternedVar(lang.NewSymbol("list"))
						if tmp216.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
						}
						tmp217 := tmp216.Get()
						tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp219 := tmp218.FindInternedVar(lang.NewSymbol("seq"))
						if tmp219.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
						}
						tmp220 := tmp219.Get()
						tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp222 := tmp221.FindInternedVar(lang.NewSymbol("concat"))
						if tmp222.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
						}
						tmp223 := tmp222.Get()
						tmp224 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp225 := tmp224.FindInternedVar(lang.NewSymbol("list"))
						if tmp225.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp225)))
						}
						tmp226 := tmp225.Get()
						tmp227 := lang.Apply(tmp226, []any{lang.NewSymbol(".HasRoot")})
						tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp229 := tmp228.FindInternedVar(lang.NewSymbol("list"))
						if tmp229.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
						}
						tmp230 := tmp229.Get()
						tmp231 := lang.Apply(tmp230, []any{lang.NewSymbol("v__0__auto__")})
						tmp232 := lang.Apply(tmp223, []any{tmp227, tmp231})
						tmp233 := lang.Apply(tmp220, []any{tmp232})
						tmp234 := lang.Apply(tmp217, []any{tmp233})
						tmp235 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp236 := tmp235.FindInternedVar(lang.NewSymbol("list"))
						if tmp236.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp236)))
						}
						tmp237 := tmp236.Get()
						tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp239 := tmp238.FindInternedVar(lang.NewSymbol("seq"))
						if tmp239.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
						}
						tmp240 := tmp239.Get()
						tmp241 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp242 := tmp241.FindInternedVar(lang.NewSymbol("concat"))
						if tmp242.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp242)))
						}
						tmp243 := tmp242.Get()
						tmp244 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp245 := tmp244.FindInternedVar(lang.NewSymbol("list"))
						if tmp245.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp245)))
						}
						tmp246 := tmp245.Get()
						tmp247 := lang.Apply(tmp246, []any{lang.NewSymbol("glojure.core/instance?")})
						tmp248 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp249 := tmp248.FindInternedVar(lang.NewSymbol("list"))
						if tmp249.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp249)))
						}
						tmp250 := tmp249.Get()
						tmp251 := lang.Apply(tmp250, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*MultiFn")})
						tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp253 := tmp252.FindInternedVar(lang.NewSymbol("list"))
						if tmp253.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
						}
						tmp254 := tmp253.Get()
						tmp255 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp256 := tmp255.FindInternedVar(lang.NewSymbol("seq"))
						if tmp256.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp256)))
						}
						tmp257 := tmp256.Get()
						tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp259 := tmp258.FindInternedVar(lang.NewSymbol("concat"))
						if tmp259.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
						}
						tmp260 := tmp259.Get()
						tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp262 := tmp261.FindInternedVar(lang.NewSymbol("list"))
						if tmp262.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
						}
						tmp263 := tmp262.Get()
						tmp264 := lang.Apply(tmp263, []any{lang.NewSymbol("glojure.core/deref")})
						tmp265 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp266 := tmp265.FindInternedVar(lang.NewSymbol("list"))
						if tmp266.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp266)))
						}
						tmp267 := tmp266.Get()
						tmp268 := lang.Apply(tmp267, []any{lang.NewSymbol("v__0__auto__")})
						tmp269 := lang.Apply(tmp260, []any{tmp264, tmp268})
						tmp270 := lang.Apply(tmp257, []any{tmp269})
						tmp271 := lang.Apply(tmp254, []any{tmp270})
						tmp272 := lang.Apply(tmp243, []any{tmp247, tmp251, tmp271})
						tmp273 := lang.Apply(tmp240, []any{tmp272})
						tmp274 := lang.Apply(tmp237, []any{tmp273})
						tmp275 := lang.Apply(tmp210, []any{tmp214, tmp234, tmp274})
						tmp276 := lang.Apply(tmp207, []any{tmp275})
						tmp277 := lang.Apply(tmp204, []any{tmp276})
						tmp278 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp279 := tmp278.FindInternedVar(lang.NewSymbol("list"))
						if tmp279.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp279)))
						}
						tmp280 := tmp279.Get()
						tmp281 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp282 := tmp281.FindInternedVar(lang.NewSymbol("seq"))
						if tmp282.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp282)))
						}
						tmp283 := tmp282.Get()
						tmp284 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp285 := tmp284.FindInternedVar(lang.NewSymbol("concat"))
						if tmp285.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp285)))
						}
						tmp286 := tmp285.Get()
						tmp287 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp288 := tmp287.FindInternedVar(lang.NewSymbol("list"))
						if tmp288.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp288)))
						}
						tmp289 := tmp288.Get()
						tmp290 := lang.Apply(tmp289, []any{lang.NewSymbol("def")})
						tmp291 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp292 := tmp291.FindInternedVar(lang.NewSymbol("list"))
						if tmp292.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp292)))
						}
						tmp293 := tmp292.Get()
						tmp294 := lang.Apply(tmp293, []any{v101})
						tmp295 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp296 := tmp295.FindInternedVar(lang.NewSymbol("list"))
						if tmp296.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp296)))
						}
						tmp297 := tmp296.Get()
						tmp298 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp299 := tmp298.FindInternedVar(lang.NewSymbol("seq"))
						if tmp299.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp299)))
						}
						tmp300 := tmp299.Get()
						tmp301 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp302 := tmp301.FindInternedVar(lang.NewSymbol("concat"))
						if tmp302.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp302)))
						}
						tmp303 := tmp302.Get()
						tmp304 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp305 := tmp304.FindInternedVar(lang.NewSymbol("list"))
						if tmp305.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp305)))
						}
						tmp306 := tmp305.Get()
						tmp307 := lang.Apply(tmp306, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewMultiFn")})
						tmp308 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp309 := tmp308.FindInternedVar(lang.NewSymbol("list"))
						if tmp309.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp309)))
						}
						tmp310 := tmp309.Get()
						tmp311 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp312 := tmp311.FindInternedVar(lang.NewSymbol("name"))
						if tmp312.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp312)))
						}
						tmp313 := tmp312.Get()
						tmp314 := lang.Apply(tmp313, []any{v101})
						tmp315 := lang.Apply(tmp310, []any{tmp314})
						tmp316 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp317 := tmp316.FindInternedVar(lang.NewSymbol("list"))
						if tmp317.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp317)))
						}
						tmp318 := tmp317.Get()
						tmp319 := lang.Apply(tmp318, []any{v71})
						tmp320 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp321 := tmp320.FindInternedVar(lang.NewSymbol("list"))
						if tmp321.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp321)))
						}
						tmp322 := tmp321.Get()
						tmp323 := lang.Apply(tmp322, []any{v125})
						tmp324 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp325 := tmp324.FindInternedVar(lang.NewSymbol("list"))
						if tmp325.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp325)))
						}
						tmp326 := tmp325.Get()
						tmp327 := lang.Apply(tmp326, []any{v131})
						tmp328 := lang.Apply(tmp303, []any{tmp307, tmp315, tmp319, tmp323, tmp327})
						tmp329 := lang.Apply(tmp300, []any{tmp328})
						tmp330 := lang.Apply(tmp297, []any{tmp329})
						tmp331 := lang.Apply(tmp286, []any{tmp290, tmp294, tmp330})
						tmp332 := lang.Apply(tmp283, []any{tmp331})
						tmp333 := lang.Apply(tmp280, []any{tmp332})
						tmp334 := lang.Apply(tmp197, []any{tmp201, tmp277, tmp333})
						tmp335 := lang.Apply(tmp194, []any{tmp334})
						tmp336 := lang.Apply(tmp191, []any{tmp335})
						tmp337 := lang.Apply(tmp141, []any{tmp145, tmp188, tmp336})
						tmp338 := lang.Apply(tmp138, []any{tmp337})
						tmp112 = tmp338
					} // end let
					tmp7 = tmp112
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn
	{
		tmp0 := lang.NewSymbol("defn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("prepost-map?"), lang.NewSymbol("body")), lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("doc-string?"), lang.NewSymbol("attr-map?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("prepost-map?"), lang.NewSymbol("body")), lang.NewSymbol("+"), lang.NewSymbol("attr-map?"))), lang.NewKeyword("doc"), "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(284), lang.NewKeyword("end-line"), int(291))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function defn
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					v5 := args[1]
					_ = v5
					v6 := args[2]
					_ = v6
					var v7 any = lang.NewList(args[3:]...)
					_ = v7
					var tmp8 any
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := reflect.TypeOf((*lang.Symbol)(nil))
					tmp13 := lang.Apply(tmp11, []any{tmp12, v6})
					if lang.IsTruthy(tmp13) {
					} else {
						tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{"First argument to defn must be a symbol"})
						panic(tmp14)
					}
					_ = tmp8
					var tmp15 any
					{ // let
						// let binding "m"
						var tmp16 any
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("string?"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("first"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v7})
						tmp24 := lang.Apply(tmp19, []any{tmp23})
						if lang.IsTruthy(tmp24) {
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("first"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v7})
							tmp29 := lang.NewMap(lang.NewKeyword("doc"), tmp28)
							tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(297), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(297), lang.NewKeyword("end-column"), int(38))
							tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp31
						} else {
							tmp32 := lang.NewMap()
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(298), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(298), lang.NewKeyword("end-column"), int(20))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp16 = tmp34
						}
						var v35 any = tmp16
						_ = v35
						// let binding "fdecl"
						var tmp36 any
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("string?"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v7})
						tmp44 := lang.Apply(tmp39, []any{tmp43})
						if lang.IsTruthy(tmp44) {
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("next"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.Apply(tmp47, []any{v7})
							tmp36 = tmp48
						} else {
							tmp36 = v7
						}
						var v49 any = tmp36
						_ = v49
						// let binding "m"
						var tmp50 any
						tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp52 := tmp51.FindInternedVar(lang.NewSymbol("map?"))
						if tmp52.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
						}
						tmp53 := tmp52.Get()
						tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp55 := tmp54.FindInternedVar(lang.NewSymbol("first"))
						if tmp55.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
						}
						tmp56 := tmp55.Get()
						tmp57 := lang.Apply(tmp56, []any{v49})
						tmp58 := lang.Apply(tmp53, []any{tmp57})
						if lang.IsTruthy(tmp58) {
							tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp60 := tmp59.FindInternedVar(lang.NewSymbol("conj"))
							if tmp60.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
							}
							tmp61 := tmp60.Get()
							tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp63 := tmp62.FindInternedVar(lang.NewSymbol("first"))
							if tmp63.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
							}
							tmp64 := tmp63.Get()
							tmp65 := lang.Apply(tmp64, []any{v49})
							tmp66 := lang.Apply(tmp61, []any{v35, tmp65})
							tmp50 = tmp66
						} else {
							tmp50 = v35
						}
						var v67 any = tmp50
						_ = v67
						// let binding "fdecl"
						var tmp68 any
						tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp70 := tmp69.FindInternedVar(lang.NewSymbol("map?"))
						if tmp70.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
						}
						tmp71 := tmp70.Get()
						tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp73 := tmp72.FindInternedVar(lang.NewSymbol("first"))
						if tmp73.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
						}
						tmp74 := tmp73.Get()
						tmp75 := lang.Apply(tmp74, []any{v49})
						tmp76 := lang.Apply(tmp71, []any{tmp75})
						if lang.IsTruthy(tmp76) {
							tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp78 := tmp77.FindInternedVar(lang.NewSymbol("next"))
							if tmp78.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
							}
							tmp79 := tmp78.Get()
							tmp80 := lang.Apply(tmp79, []any{v49})
							tmp68 = tmp80
						} else {
							tmp68 = v49
						}
						var v81 any = tmp68
						_ = v81
						// let binding "fdecl"
						var tmp82 any
						tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp84 := tmp83.FindInternedVar(lang.NewSymbol("vector?"))
						if tmp84.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
						}
						tmp85 := tmp84.Get()
						tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp87 := tmp86.FindInternedVar(lang.NewSymbol("first"))
						if tmp87.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
						}
						tmp88 := tmp87.Get()
						tmp89 := lang.Apply(tmp88, []any{v81})
						tmp90 := lang.Apply(tmp85, []any{tmp89})
						if lang.IsTruthy(tmp90) {
							tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp92 := tmp91.FindInternedVar(lang.NewSymbol("list"))
							if tmp92.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
							}
							tmp93 := tmp92.Get()
							tmp94 := lang.Apply(tmp93, []any{v81})
							tmp82 = tmp94
						} else {
							tmp82 = v81
						}
						var v95 any = tmp82
						_ = v95
						// let binding "m"
						var tmp96 any
						tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp98 := tmp97.FindInternedVar(lang.NewSymbol("map?"))
						if tmp98.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
						}
						tmp99 := tmp98.Get()
						tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp101 := tmp100.FindInternedVar(lang.NewSymbol("last"))
						if tmp101.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
						}
						tmp102 := tmp101.Get()
						tmp103 := lang.Apply(tmp102, []any{v95})
						tmp104 := lang.Apply(tmp99, []any{tmp103})
						if lang.IsTruthy(tmp104) {
							tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp106 := tmp105.FindInternedVar(lang.NewSymbol("conj"))
							if tmp106.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
							}
							tmp107 := tmp106.Get()
							tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp109 := tmp108.FindInternedVar(lang.NewSymbol("last"))
							if tmp109.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
							}
							tmp110 := tmp109.Get()
							tmp111 := lang.Apply(tmp110, []any{v95})
							tmp112 := lang.Apply(tmp107, []any{v67, tmp111})
							tmp96 = tmp112
						} else {
							tmp96 = v67
						}
						var v113 any = tmp96
						_ = v113
						// let binding "fdecl"
						var tmp114 any
						tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp116 := tmp115.FindInternedVar(lang.NewSymbol("map?"))
						if tmp116.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
						}
						tmp117 := tmp116.Get()
						tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp119 := tmp118.FindInternedVar(lang.NewSymbol("last"))
						if tmp119.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
						}
						tmp120 := tmp119.Get()
						tmp121 := lang.Apply(tmp120, []any{v95})
						tmp122 := lang.Apply(tmp117, []any{tmp121})
						if lang.IsTruthy(tmp122) {
							tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp124 := tmp123.FindInternedVar(lang.NewSymbol("butlast"))
							if tmp124.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
							}
							tmp125 := tmp124.Get()
							tmp126 := lang.Apply(tmp125, []any{v95})
							tmp114 = tmp126
						} else {
							tmp114 = v95
						}
						var v127 any = tmp114
						_ = v127
						// let binding "m"
						tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp129 := tmp128.FindInternedVar(lang.NewSymbol("conj"))
						if tmp129.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
						}
						tmp130 := tmp129.Get()
						tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
						if tmp132.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
						}
						tmp133 := tmp132.Get()
						tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp135 := tmp134.FindInternedVar(lang.NewSymbol("sigs"))
						if tmp135.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
						}
						tmp136 := tmp135.Get()
						tmp137 := lang.Apply(tmp136, []any{v127})
						tmp138 := lang.Apply(tmp133, []any{lang.NewSymbol("quote"), tmp137})
						tmp139 := lang.NewMap(lang.NewKeyword("arglists"), tmp138)
						tmp140 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(317), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(317), lang.NewKeyword("end-column"), int(60))
						tmp141, err := lang.WithMeta(tmp139, tmp140.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp142 := lang.Apply(tmp130, []any{tmp141, v113})
						var v143 any = tmp142
						_ = v143
						// let binding "m"
						var tmp144 any
						{ // let
							// let binding "inline"
							tmp145 := lang.Apply(lang.NewKeyword("inline"), []any{v143})
							var v146 any = tmp145
							_ = v146
							// let binding "ifn"
							tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp148 := tmp147.FindInternedVar(lang.NewSymbol("first"))
							if tmp148.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
							}
							tmp149 := tmp148.Get()
							tmp150 := lang.Apply(tmp149, []any{v146})
							var v151 any = tmp150
							_ = v151
							// let binding "iname"
							tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp153 := tmp152.FindInternedVar(lang.NewSymbol("second"))
							if tmp153.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
							}
							tmp154 := tmp153.Get()
							tmp155 := lang.Apply(tmp154, []any{v146})
							var v156 any = tmp155
							_ = v156
							var tmp157 any
							var tmp158 any
							tmp159 := lang.Apply(lang.Equiv, []any{lang.NewSymbol("fn"), v151})
							if lang.IsTruthy(tmp159) {
								var tmp160 any
								tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp162 := tmp161.FindInternedVar(lang.NewSymbol("instance?"))
								if tmp162.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
								}
								tmp163 := tmp162.Get()
								tmp164 := reflect.TypeOf((*lang.Symbol)(nil))
								tmp165 := lang.Apply(tmp163, []any{tmp164, v156})
								if lang.IsTruthy(tmp165) {
									tmp160 = false
								} else {
									tmp160 = true
								}
								tmp158 = tmp160
							} else {
							}
							if lang.IsTruthy(tmp158) {
								tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp167 := tmp166.FindInternedVar(lang.NewSymbol("assoc"))
								if tmp167.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
								}
								tmp168 := tmp167.Get()
								tmp169 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp170 := tmp169.FindInternedVar(lang.NewSymbol("cons"))
								if tmp170.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp170)))
								}
								tmp171 := tmp170.Get()
								tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp173 := tmp172.FindInternedVar(lang.NewSymbol("cons"))
								if tmp173.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
								}
								tmp174 := tmp173.Get()
								tmp175, ok := lang.FieldOrMethod(v6, "Name")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v6, "Name")))
								}
								var tmp176 any
								switch reflect.TypeOf(tmp175).Kind() {
								case reflect.Func:
									tmp176 = lang.Apply(tmp175, nil)
								default:
									tmp176 = tmp175
								}
								tmp177 := lang.Apply(lang.ConcatStrings, []any{tmp176, "__inliner"})
								tmp178 := lang.Apply(lang.NewSymbol, []any{tmp177})
								tmp179 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp180 := tmp179.FindInternedVar(lang.NewSymbol("next"))
								if tmp180.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp180)))
								}
								tmp181 := tmp180.Get()
								tmp182 := lang.Apply(tmp181, []any{v146})
								tmp183 := lang.Apply(tmp174, []any{tmp178, tmp182})
								tmp184 := lang.Apply(tmp171, []any{v151, tmp183})
								tmp185 := lang.Apply(tmp168, []any{v143, lang.NewKeyword("inline"), tmp184})
								tmp157 = tmp185
							} else {
								tmp157 = v143
							}
							tmp144 = tmp157
						} // end let
						var v145 any = tmp144
						_ = v145
						// let binding "m"
						tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp147 := tmp146.FindInternedVar(lang.NewSymbol("conj"))
						if tmp147.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
						}
						tmp148 := tmp147.Get()
						var tmp149 any
						tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp151 := tmp150.FindInternedVar(lang.NewSymbol("meta"))
						if tmp151.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
						}
						tmp152 := tmp151.Get()
						tmp153 := lang.Apply(tmp152, []any{v6})
						if lang.IsTruthy(tmp153) {
							tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp155 := tmp154.FindInternedVar(lang.NewSymbol("meta"))
							if tmp155.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
							}
							tmp156 := tmp155.Get()
							tmp157 := lang.Apply(tmp156, []any{v6})
							tmp149 = tmp157
						} else {
							tmp158 := lang.NewMap()
							tmp159 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(328), lang.NewKeyword("column"), int(51), lang.NewKeyword("end-line"), int(328), lang.NewKeyword("end-column"), int(52))
							tmp160, err := lang.WithMeta(tmp158, tmp159.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp149 = tmp160
						}
						tmp161 := lang.Apply(tmp148, []any{tmp149, v145})
						var v162 any = tmp161
						_ = v162
						tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp164 := tmp163.FindInternedVar(lang.NewSymbol("list"))
						if tmp164.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
						}
						tmp165 := tmp164.Get()
						tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp167 := tmp166.FindInternedVar(lang.NewSymbol("with-meta"))
						if tmp167.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
						}
						tmp168 := tmp167.Get()
						tmp169 := lang.Apply(tmp168, []any{v6, v162})
						tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp171 := tmp170.FindInternedVar(lang.NewSymbol("with-meta"))
						if tmp171.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
						}
						tmp172 := tmp171.Get()
						tmp173 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp174 := tmp173.FindInternedVar(lang.NewSymbol("cons"))
						if tmp174.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp174)))
						}
						tmp175 := tmp174.Get()
						tmp176 := lang.Apply(tmp175, []any{lang.NewSymbol("glojure.core/fn"), v127})
						tmp177 := lang.Apply(lang.NewKeyword("tag"), []any{v162})
						tmp178 := lang.NewMap(lang.NewKeyword("rettag"), tmp177)
						tmp179 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(333), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(333), lang.NewKeyword("end-column"), int(54))
						tmp180, err := lang.WithMeta(tmp178, tmp179.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp181 := lang.Apply(tmp172, []any{tmp176, tmp180})
						tmp182 := lang.Apply(tmp165, []any{lang.NewSymbol("def"), tmp169, tmp181})
						tmp15 = tmp182
					} // end let
					return tmp15
				}
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(291), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(333), lang.NewKeyword("end-column"), int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defn-
	{
		tmp0 := lang.NewSymbol("defn-").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("decls"))), lang.NewKeyword("doc"), "same as defn, yielding non-public def", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4949), lang.NewKeyword("end-line"), int(4949))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("list*"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("with-meta"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("meta"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(tmp15, []any{tmp19, lang.NewKeyword("private"), true})
				tmp21 := lang.Apply(tmp12, []any{v5, tmp20})
				tmp22 := lang.Apply(tmp9, []any{lang.NewSymbol("glojure.core/defn"), tmp21, v6})
				return tmp22
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defonce
	{
		tmp0 := lang.NewSymbol("defonce").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5806), lang.NewKeyword("end-line"), int(5806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/let")})
			tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
			if tmp18.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
			}
			tmp19 := tmp18.Get()
			tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
			if tmp21.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
			}
			tmp22 := tmp21.Get()
			tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
			if tmp24.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
			}
			tmp25 := tmp24.Get()
			tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
			if tmp27.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
			}
			tmp28 := tmp27.Get()
			tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
			if tmp30.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
			}
			tmp31 := tmp30.Get()
			tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
			if tmp33.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
			}
			tmp34 := tmp33.Get()
			tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("v__0__auto__")})
			tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
			if tmp37.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
			}
			tmp38 := tmp37.Get()
			tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq"))
			if tmp40.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
			}
			tmp41 := tmp40.Get()
			tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp43 := tmp42.FindInternedVar(lang.NewSymbol("concat"))
			if tmp43.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
			}
			tmp44 := tmp43.Get()
			tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
			if tmp46.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
			}
			tmp47 := tmp46.Get()
			tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("def")})
			tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp50 := tmp49.FindInternedVar(lang.NewSymbol("list"))
			if tmp50.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
			}
			tmp51 := tmp50.Get()
			tmp52 := lang.Apply(tmp51, []any{v5})
			tmp53 := lang.Apply(tmp44, []any{tmp48, tmp52})
			tmp54 := lang.Apply(tmp41, []any{tmp53})
			tmp55 := lang.Apply(tmp38, []any{tmp54})
			tmp56 := lang.Apply(tmp31, []any{tmp35, tmp55})
			tmp57 := lang.Apply(tmp28, []any{tmp56})
			tmp58 := lang.Apply(tmp22, []any{tmp25, tmp57})
			tmp59 := lang.Apply(tmp19, []any{tmp58})
			tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp61 := tmp60.FindInternedVar(lang.NewSymbol("list"))
			if tmp61.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
			}
			tmp62 := tmp61.Get()
			tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
			if tmp64.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
			}
			tmp65 := tmp64.Get()
			tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp67 := tmp66.FindInternedVar(lang.NewSymbol("concat"))
			if tmp67.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
			}
			tmp68 := tmp67.Get()
			tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
			if tmp70.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
			}
			tmp71 := tmp70.Get()
			tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol("glojure.core/when-not")})
			tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp74 := tmp73.FindInternedVar(lang.NewSymbol("list"))
			if tmp74.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
			}
			tmp75 := tmp74.Get()
			tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp77 := tmp76.FindInternedVar(lang.NewSymbol("seq"))
			if tmp77.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
			}
			tmp78 := tmp77.Get()
			tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp80 := tmp79.FindInternedVar(lang.NewSymbol("concat"))
			if tmp80.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
			}
			tmp81 := tmp80.Get()
			tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp83 := tmp82.FindInternedVar(lang.NewSymbol("list"))
			if tmp83.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
			}
			tmp84 := tmp83.Get()
			tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol(".HasRoot")})
			tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp87 := tmp86.FindInternedVar(lang.NewSymbol("list"))
			if tmp87.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
			}
			tmp88 := tmp87.Get()
			tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("v__0__auto__")})
			tmp90 := lang.Apply(tmp81, []any{tmp85, tmp89})
			tmp91 := lang.Apply(tmp78, []any{tmp90})
			tmp92 := lang.Apply(tmp75, []any{tmp91})
			tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
			if tmp94.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
			}
			tmp95 := tmp94.Get()
			tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp97 := tmp96.FindInternedVar(lang.NewSymbol("seq"))
			if tmp97.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
			}
			tmp98 := tmp97.Get()
			tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp100 := tmp99.FindInternedVar(lang.NewSymbol("concat"))
			if tmp100.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
			}
			tmp101 := tmp100.Get()
			tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
			if tmp103.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
			}
			tmp104 := tmp103.Get()
			tmp105 := lang.Apply(tmp104, []any{lang.NewSymbol("def")})
			tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
			if tmp107.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
			}
			tmp108 := tmp107.Get()
			tmp109 := lang.Apply(tmp108, []any{v5})
			tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp111 := tmp110.FindInternedVar(lang.NewSymbol("list"))
			if tmp111.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
			}
			tmp112 := tmp111.Get()
			tmp113 := lang.Apply(tmp112, []any{v6})
			tmp114 := lang.Apply(tmp101, []any{tmp105, tmp109, tmp113})
			tmp115 := lang.Apply(tmp98, []any{tmp114})
			tmp116 := lang.Apply(tmp95, []any{tmp115})
			tmp117 := lang.Apply(tmp68, []any{tmp72, tmp92, tmp116})
			tmp118 := lang.Apply(tmp65, []any{tmp117})
			tmp119 := lang.Apply(tmp62, []any{tmp118})
			tmp120 := lang.Apply(tmp12, []any{tmp16, tmp59, tmp119})
			tmp121 := lang.Apply(tmp9, []any{tmp120})
			return tmp121
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defprotocol
	{
		tmp0 := lang.NewSymbol("defprotocol").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("opts+sigs"))), lang.NewKeyword("doc"), "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(28), lang.NewKeyword("end-line"), int(28))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "doc"
					var tmp8 any
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("string?"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp11, []any{tmp15})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v6})
						tmp8 = tmp20
					} else {
					}
					var v21 any = tmp8
					_ = v21
					// let binding "opts+sigs"
					var tmp22 any
					if lang.IsTruthy(v21) {
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("rest"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{v6})
						tmp22 = tmp26
					} else {
						tmp22 = v6
					}
					var v27 any = tmp22
					_ = v27
					// let binding "opts"
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("take-while"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					var tmp31 lang.FnFunc
					tmp31 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v32 := args[0]
						_ = v32
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("not"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.Apply(tmp38, []any{v32})
						tmp40 := lang.Apply(tmp35, []any{tmp39})
						return tmp40
					})
					tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(92), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(92), lang.NewKeyword("end-column"), int(40))
					tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp34 := lang.Apply(tmp30, []any{tmp33, v27})
					var v35 any = tmp34
					_ = v35
					// let binding "sigs"
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("drop-while"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					var tmp39 lang.FnFunc
					tmp39 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v40 := args[0]
						_ = v40
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("not"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v40})
						tmp48 := lang.Apply(tmp43, []any{tmp47})
						return tmp48
					})
					tmp40 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(93), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(93), lang.NewKeyword("end-column"), int(40))
					tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp42 := lang.Apply(tmp38, []any{tmp41, v27})
					var v43 any = tmp42
					_ = v43
					// let binding "opts"
					var tmp44 any
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("="))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.Apply(tmp47, []any{v43, v35})
					if lang.IsTruthy(tmp48) {
					} else {
						tmp44 = v35
					}
					var v49 any = tmp44
					_ = v49
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("seq"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp54 := tmp53.FindInternedVar(lang.NewSymbol("concat"))
					if tmp54.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
					}
					tmp55 := tmp54.Get()
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("list"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.Apply(tmp58, []any{lang.NewSymbol("do")})
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("list"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("concat"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
					if tmp70.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
					}
					tmp71 := tmp70.Get()
					tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol("def")})
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("list"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.Apply(tmp75, []any{v5})
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("list"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("seq"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp84 := tmp83.FindInternedVar(lang.NewSymbol("concat"))
					if tmp84.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
					}
					tmp85 := tmp84.Get()
					tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp87 := tmp86.FindInternedVar(lang.NewSymbol("list"))
					if tmp87.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
					}
					tmp88 := tmp87.Get()
					tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("glojure.core/atom")})
					tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp91 := tmp90.FindInternedVar(lang.NewSymbol("list"))
					if tmp91.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
					}
					tmp92 := tmp91.Get()
					tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp94 := tmp93.FindInternedVar(lang.NewSymbol("apply"))
					if tmp94.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
					}
					tmp95 := tmp94.Get()
					tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp97 := tmp96.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp97.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
					}
					tmp98 := tmp97.Get()
					tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp100 := tmp99.FindInternedVar(lang.NewSymbol("seq"))
					if tmp100.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
					}
					tmp101 := tmp100.Get()
					tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp103 := tmp102.FindInternedVar(lang.NewSymbol("concat"))
					if tmp103.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
					}
					tmp104 := tmp103.Get()
					tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp106 := tmp105.FindInternedVar(lang.NewSymbol("list"))
					if tmp106.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
					}
					tmp107 := tmp106.Get()
					tmp108 := lang.Apply(tmp107, []any{lang.NewKeyword("on-interface")})
					tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
					if tmp110.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
					}
					tmp111 := tmp110.Get()
					tmp112 := lang.Apply(tmp111, []any{true})
					tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp114 := tmp113.FindInternedVar(lang.NewSymbol("list"))
					if tmp114.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
					}
					tmp115 := tmp114.Get()
					tmp116 := lang.Apply(tmp115, []any{lang.NewKeyword("sigs")})
					tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp118 := tmp117.FindInternedVar(lang.NewSymbol("list"))
					if tmp118.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
					}
					tmp119 := tmp118.Get()
					tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp121 := tmp120.FindInternedVar(lang.NewSymbol("seq"))
					if tmp121.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
					}
					tmp122 := tmp121.Get()
					tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp124 := tmp123.FindInternedVar(lang.NewSymbol("concat"))
					if tmp124.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
					}
					tmp125 := tmp124.Get()
					tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
					if tmp127.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
					}
					tmp128 := tmp127.Get()
					tmp129 := lang.Apply(tmp128, []any{lang.NewSymbol("quote")})
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{v43})
					tmp134 := lang.Apply(tmp125, []any{tmp129, tmp133})
					tmp135 := lang.Apply(tmp122, []any{tmp134})
					tmp136 := lang.Apply(tmp119, []any{tmp135})
					tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp138 := tmp137.FindInternedVar(lang.NewSymbol("list"))
					if tmp138.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
					}
					tmp139 := tmp138.Get()
					tmp140 := lang.Apply(tmp139, []any{lang.NewKeyword("multis")})
					tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp142 := tmp141.FindInternedVar(lang.NewSymbol("list"))
					if tmp142.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
					}
					tmp143 := tmp142.Get()
					tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp145 := tmp144.FindInternedVar(lang.NewSymbol("apply"))
					if tmp145.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
					}
					tmp146 := tmp145.Get()
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp151 := tmp150.FindInternedVar(lang.NewSymbol("seq"))
					if tmp151.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
					}
					tmp152 := tmp151.Get()
					tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp154 := tmp153.FindInternedVar(lang.NewSymbol("concat"))
					if tmp154.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
					}
					tmp155 := tmp154.Get()
					tmp156 := lang.Apply(tmp155, nil)
					tmp157 := lang.Apply(tmp152, []any{tmp156})
					tmp158 := lang.Apply(tmp146, []any{tmp149, tmp157})
					tmp159 := lang.Apply(tmp143, []any{tmp158})
					tmp160 := lang.Apply(tmp104, []any{tmp108, tmp112, tmp116, tmp136, tmp140, tmp159})
					tmp161 := lang.Apply(tmp101, []any{tmp160})
					tmp162 := lang.Apply(tmp95, []any{tmp98, tmp161})
					tmp163 := lang.Apply(tmp92, []any{tmp162})
					tmp164 := lang.Apply(tmp85, []any{tmp89, tmp163})
					tmp165 := lang.Apply(tmp82, []any{tmp164})
					tmp166 := lang.Apply(tmp79, []any{tmp165})
					tmp167 := lang.Apply(tmp68, []any{tmp72, tmp76, tmp166})
					tmp168 := lang.Apply(tmp65, []any{tmp167})
					tmp169 := lang.Apply(tmp62, []any{tmp168})
					tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp171 := tmp170.FindInternedVar(lang.NewSymbol("list"))
					if tmp171.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
					}
					tmp172 := tmp171.Get()
					tmp173 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp174 := tmp173.FindInternedVar(lang.NewSymbol("seq"))
					if tmp174.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp174)))
					}
					tmp175 := tmp174.Get()
					tmp176 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp177 := tmp176.FindInternedVar(lang.NewSymbol("concat"))
					if tmp177.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp177)))
					}
					tmp178 := tmp177.Get()
					tmp179 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp180 := tmp179.FindInternedVar(lang.NewSymbol("list"))
					if tmp180.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp180)))
					}
					tmp181 := tmp180.Get()
					tmp182 := lang.Apply(tmp181, []any{lang.NewSymbol("glojure.core/swap!")})
					tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp184 := tmp183.FindInternedVar(lang.NewSymbol("list"))
					if tmp184.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
					}
					tmp185 := tmp184.Get()
					tmp186 := lang.Apply(tmp185, []any{lang.NewSymbol("glojure.core/-protocols")})
					tmp187 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp188 := tmp187.FindInternedVar(lang.NewSymbol("list"))
					if tmp188.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp188)))
					}
					tmp189 := tmp188.Get()
					tmp190 := lang.Apply(tmp189, []any{lang.NewSymbol("glojure.core/assoc")})
					tmp191 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp192 := tmp191.FindInternedVar(lang.NewSymbol("list"))
					if tmp192.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp192)))
					}
					tmp193 := tmp192.Get()
					tmp194 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp195 := tmp194.FindInternedVar(lang.NewSymbol("seq"))
					if tmp195.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp195)))
					}
					tmp196 := tmp195.Get()
					tmp197 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp198 := tmp197.FindInternedVar(lang.NewSymbol("concat"))
					if tmp198.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp198)))
					}
					tmp199 := tmp198.Get()
					tmp200 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp201 := tmp200.FindInternedVar(lang.NewSymbol("list"))
					if tmp201.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp201)))
					}
					tmp202 := tmp201.Get()
					tmp203 := lang.Apply(tmp202, []any{lang.NewSymbol("quote")})
					tmp204 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp205 := tmp204.FindInternedVar(lang.NewSymbol("list"))
					if tmp205.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp205)))
					}
					tmp206 := tmp205.Get()
					tmp207 := lang.Apply(tmp206, []any{v5})
					tmp208 := lang.Apply(tmp199, []any{tmp203, tmp207})
					tmp209 := lang.Apply(tmp196, []any{tmp208})
					tmp210 := lang.Apply(tmp193, []any{tmp209})
					tmp211 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp212 := tmp211.FindInternedVar(lang.NewSymbol("list"))
					if tmp212.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp212)))
					}
					tmp213 := tmp212.Get()
					tmp214 := lang.Apply(tmp213, []any{v5})
					tmp215 := lang.Apply(tmp178, []any{tmp182, tmp186, tmp190, tmp210, tmp214})
					tmp216 := lang.Apply(tmp175, []any{tmp215})
					tmp217 := lang.Apply(tmp172, []any{tmp216})
					tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp219 := tmp218.FindInternedVar(lang.NewSymbol("map"))
					if tmp219.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
					}
					tmp220 := tmp219.Get()
					var tmp221 lang.FnFunc
					tmp221 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v222 := args[0]
						_ = v222
						tmp223 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp224 := tmp223.FindInternedVar(lang.NewSymbol("seq"))
						if tmp224.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp224)))
						}
						tmp225 := tmp224.Get()
						tmp226 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp227 := tmp226.FindInternedVar(lang.NewSymbol("concat"))
						if tmp227.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp227)))
						}
						tmp228 := tmp227.Get()
						tmp229 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp230 := tmp229.FindInternedVar(lang.NewSymbol("list"))
						if tmp230.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp230)))
						}
						tmp231 := tmp230.Get()
						tmp232 := lang.Apply(tmp231, []any{lang.NewSymbol("do")})
						tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp234 := tmp233.FindInternedVar(lang.NewSymbol("list"))
						if tmp234.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
						}
						tmp235 := tmp234.Get()
						tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp237 := tmp236.FindInternedVar(lang.NewSymbol("seq"))
						if tmp237.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
						}
						tmp238 := tmp237.Get()
						tmp239 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp240 := tmp239.FindInternedVar(lang.NewSymbol("concat"))
						if tmp240.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp240)))
						}
						tmp241 := tmp240.Get()
						tmp242 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp243 := tmp242.FindInternedVar(lang.NewSymbol("list"))
						if tmp243.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp243)))
						}
						tmp244 := tmp243.Get()
						tmp245 := lang.Apply(tmp244, []any{lang.NewSymbol("glojure.core/defmulti")})
						tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp247 := tmp246.FindInternedVar(lang.NewSymbol("list"))
						if tmp247.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
						}
						tmp248 := tmp247.Get()
						tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp250 := tmp249.FindInternedVar(lang.NewSymbol("first"))
						if tmp250.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
						}
						tmp251 := tmp250.Get()
						tmp252 := lang.Apply(tmp251, []any{v222})
						tmp253 := lang.Apply(tmp248, []any{tmp252})
						tmp254 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp255 := tmp254.FindInternedVar(lang.NewSymbol("list"))
						if tmp255.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp255)))
						}
						tmp256 := tmp255.Get()
						tmp257 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp258 := tmp257.FindInternedVar(lang.NewSymbol("seq"))
						if tmp258.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp258)))
						}
						tmp259 := tmp258.Get()
						tmp260 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp261 := tmp260.FindInternedVar(lang.NewSymbol("concat"))
						if tmp261.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp261)))
						}
						tmp262 := tmp261.Get()
						tmp263 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp264 := tmp263.FindInternedVar(lang.NewSymbol("list"))
						if tmp264.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp264)))
						}
						tmp265 := tmp264.Get()
						tmp266 := lang.Apply(tmp265, []any{lang.NewSymbol("glojure.core/fn")})
						tmp267 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp268 := tmp267.FindInternedVar(lang.NewSymbol("list"))
						if tmp268.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp268)))
						}
						tmp269 := tmp268.Get()
						tmp270 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp271 := tmp270.FindInternedVar(lang.NewSymbol("apply"))
						if tmp271.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp271)))
						}
						tmp272 := tmp271.Get()
						tmp273 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp274 := tmp273.FindInternedVar(lang.NewSymbol("vector"))
						if tmp274.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp274)))
						}
						tmp275 := tmp274.Get()
						tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp277 := tmp276.FindInternedVar(lang.NewSymbol("seq"))
						if tmp277.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
						}
						tmp278 := tmp277.Get()
						tmp279 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp280 := tmp279.FindInternedVar(lang.NewSymbol("concat"))
						if tmp280.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp280)))
						}
						tmp281 := tmp280.Get()
						tmp282 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp283 := tmp282.FindInternedVar(lang.NewSymbol("list"))
						if tmp283.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp283)))
						}
						tmp284 := tmp283.Get()
						tmp285 := lang.Apply(tmp284, []any{lang.NewSymbol("this")})
						tmp286 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp287 := tmp286.FindInternedVar(lang.NewSymbol("list"))
						if tmp287.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp287)))
						}
						tmp288 := tmp287.Get()
						tmp289 := lang.Apply(tmp288, []any{lang.NewSymbol("&")})
						tmp290 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp291 := tmp290.FindInternedVar(lang.NewSymbol("list"))
						if tmp291.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp291)))
						}
						tmp292 := tmp291.Get()
						tmp293 := lang.Apply(tmp292, []any{lang.NewSymbol("args")})
						tmp294 := lang.Apply(tmp281, []any{tmp285, tmp289, tmp293})
						tmp295 := lang.Apply(tmp278, []any{tmp294})
						tmp296 := lang.Apply(tmp272, []any{tmp275, tmp295})
						tmp297 := lang.Apply(tmp269, []any{tmp296})
						tmp298 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp299 := tmp298.FindInternedVar(lang.NewSymbol("list"))
						if tmp299.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp299)))
						}
						tmp300 := tmp299.Get()
						tmp301 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp302 := tmp301.FindInternedVar(lang.NewSymbol("seq"))
						if tmp302.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp302)))
						}
						tmp303 := tmp302.Get()
						tmp304 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp305 := tmp304.FindInternedVar(lang.NewSymbol("concat"))
						if tmp305.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp305)))
						}
						tmp306 := tmp305.Get()
						tmp307 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp308 := tmp307.FindInternedVar(lang.NewSymbol("list"))
						if tmp308.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp308)))
						}
						tmp309 := tmp308.Get()
						tmp310 := lang.Apply(tmp309, []any{lang.NewSymbol("glojure.core/class")})
						tmp311 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp312 := tmp311.FindInternedVar(lang.NewSymbol("list"))
						if tmp312.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp312)))
						}
						tmp313 := tmp312.Get()
						tmp314 := lang.Apply(tmp313, []any{lang.NewSymbol("this")})
						tmp315 := lang.Apply(tmp306, []any{tmp310, tmp314})
						tmp316 := lang.Apply(tmp303, []any{tmp315})
						tmp317 := lang.Apply(tmp300, []any{tmp316})
						tmp318 := lang.Apply(tmp262, []any{tmp266, tmp297, tmp317})
						tmp319 := lang.Apply(tmp259, []any{tmp318})
						tmp320 := lang.Apply(tmp256, []any{tmp319})
						tmp321 := lang.Apply(tmp241, []any{tmp245, tmp253, tmp320})
						tmp322 := lang.Apply(tmp238, []any{tmp321})
						tmp323 := lang.Apply(tmp235, []any{tmp322})
						tmp324 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp325 := tmp324.FindInternedVar(lang.NewSymbol("list"))
						if tmp325.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp325)))
						}
						tmp326 := tmp325.Get()
						tmp327 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp328 := tmp327.FindInternedVar(lang.NewSymbol("seq"))
						if tmp328.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp328)))
						}
						tmp329 := tmp328.Get()
						tmp330 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp331 := tmp330.FindInternedVar(lang.NewSymbol("concat"))
						if tmp331.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp331)))
						}
						tmp332 := tmp331.Get()
						tmp333 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp334 := tmp333.FindInternedVar(lang.NewSymbol("list"))
						if tmp334.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp334)))
						}
						tmp335 := tmp334.Get()
						tmp336 := lang.Apply(tmp335, []any{lang.NewSymbol("glojure.core/swap!")})
						tmp337 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp338 := tmp337.FindInternedVar(lang.NewSymbol("list"))
						if tmp338.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp338)))
						}
						tmp339 := tmp338.Get()
						tmp340 := lang.Apply(tmp339, []any{v5})
						tmp341 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp342 := tmp341.FindInternedVar(lang.NewSymbol("list"))
						if tmp342.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp342)))
						}
						tmp343 := tmp342.Get()
						tmp344 := lang.Apply(tmp343, []any{lang.NewSymbol("glojure.core/assoc-in")})
						tmp345 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp346 := tmp345.FindInternedVar(lang.NewSymbol("list"))
						if tmp346.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp346)))
						}
						tmp347 := tmp346.Get()
						tmp348 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp349 := tmp348.FindInternedVar(lang.NewSymbol("apply"))
						if tmp349.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp349)))
						}
						tmp350 := tmp349.Get()
						tmp351 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp352 := tmp351.FindInternedVar(lang.NewSymbol("vector"))
						if tmp352.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp352)))
						}
						tmp353 := tmp352.Get()
						tmp354 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp355 := tmp354.FindInternedVar(lang.NewSymbol("seq"))
						if tmp355.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp355)))
						}
						tmp356 := tmp355.Get()
						tmp357 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp358 := tmp357.FindInternedVar(lang.NewSymbol("concat"))
						if tmp358.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp358)))
						}
						tmp359 := tmp358.Get()
						tmp360 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp361 := tmp360.FindInternedVar(lang.NewSymbol("list"))
						if tmp361.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp361)))
						}
						tmp362 := tmp361.Get()
						tmp363 := lang.Apply(tmp362, []any{lang.NewKeyword("multis")})
						tmp364 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp365 := tmp364.FindInternedVar(lang.NewSymbol("list"))
						if tmp365.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp365)))
						}
						tmp366 := tmp365.Get()
						tmp367 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp368 := tmp367.FindInternedVar(lang.NewSymbol("seq"))
						if tmp368.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp368)))
						}
						tmp369 := tmp368.Get()
						tmp370 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp371 := tmp370.FindInternedVar(lang.NewSymbol("concat"))
						if tmp371.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp371)))
						}
						tmp372 := tmp371.Get()
						tmp373 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp374 := tmp373.FindInternedVar(lang.NewSymbol("list"))
						if tmp374.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp374)))
						}
						tmp375 := tmp374.Get()
						tmp376 := lang.Apply(tmp375, []any{lang.NewSymbol("glojure.core/keyword")})
						tmp377 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp378 := tmp377.FindInternedVar(lang.NewSymbol("list"))
						if tmp378.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp378)))
						}
						tmp379 := tmp378.Get()
						tmp380 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp381 := tmp380.FindInternedVar(lang.NewSymbol("seq"))
						if tmp381.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp381)))
						}
						tmp382 := tmp381.Get()
						tmp383 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp384 := tmp383.FindInternedVar(lang.NewSymbol("concat"))
						if tmp384.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp384)))
						}
						tmp385 := tmp384.Get()
						tmp386 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp387 := tmp386.FindInternedVar(lang.NewSymbol("list"))
						if tmp387.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp387)))
						}
						tmp388 := tmp387.Get()
						tmp389 := lang.Apply(tmp388, []any{lang.NewSymbol("quote")})
						tmp390 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp391 := tmp390.FindInternedVar(lang.NewSymbol("list"))
						if tmp391.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp391)))
						}
						tmp392 := tmp391.Get()
						tmp393 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp394 := tmp393.FindInternedVar(lang.NewSymbol("first"))
						if tmp394.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp394)))
						}
						tmp395 := tmp394.Get()
						tmp396 := lang.Apply(tmp395, []any{v222})
						tmp397 := lang.Apply(tmp392, []any{tmp396})
						tmp398 := lang.Apply(tmp385, []any{tmp389, tmp397})
						tmp399 := lang.Apply(tmp382, []any{tmp398})
						tmp400 := lang.Apply(tmp379, []any{tmp399})
						tmp401 := lang.Apply(tmp372, []any{tmp376, tmp400})
						tmp402 := lang.Apply(tmp369, []any{tmp401})
						tmp403 := lang.Apply(tmp366, []any{tmp402})
						tmp404 := lang.Apply(tmp359, []any{tmp363, tmp403})
						tmp405 := lang.Apply(tmp356, []any{tmp404})
						tmp406 := lang.Apply(tmp350, []any{tmp353, tmp405})
						tmp407 := lang.Apply(tmp347, []any{tmp406})
						tmp408 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp409 := tmp408.FindInternedVar(lang.NewSymbol("list"))
						if tmp409.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp409)))
						}
						tmp410 := tmp409.Get()
						tmp411 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp412 := tmp411.FindInternedVar(lang.NewSymbol("first"))
						if tmp412.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp412)))
						}
						tmp413 := tmp412.Get()
						tmp414 := lang.Apply(tmp413, []any{v222})
						tmp415 := lang.Apply(tmp410, []any{tmp414})
						tmp416 := lang.Apply(tmp332, []any{tmp336, tmp340, tmp344, tmp407, tmp415})
						tmp417 := lang.Apply(tmp329, []any{tmp416})
						tmp418 := lang.Apply(tmp326, []any{tmp417})
						tmp419 := lang.Apply(tmp228, []any{tmp232, tmp323, tmp418})
						tmp420 := lang.Apply(tmp225, []any{tmp419})
						return tmp420
					})
					tmp222 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(104), lang.NewKeyword("end-column"), int(90))
					tmp223, err := lang.WithMeta(tmp221, tmp222.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp224 := lang.Apply(tmp220, []any{tmp223, v43})
					tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp226 := tmp225.FindInternedVar(lang.NewSymbol("list"))
					if tmp226.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
					}
					tmp227 := tmp226.Get()
					tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp229 := tmp228.FindInternedVar(lang.NewSymbol("seq"))
					if tmp229.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
					}
					tmp230 := tmp229.Get()
					tmp231 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp232 := tmp231.FindInternedVar(lang.NewSymbol("concat"))
					if tmp232.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp232)))
					}
					tmp233 := tmp232.Get()
					tmp234 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp235 := tmp234.FindInternedVar(lang.NewSymbol("list"))
					if tmp235.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp235)))
					}
					tmp236 := tmp235.Get()
					tmp237 := lang.Apply(tmp236, []any{lang.NewSymbol("var")})
					tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp239 := tmp238.FindInternedVar(lang.NewSymbol("list"))
					if tmp239.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
					}
					tmp240 := tmp239.Get()
					tmp241 := lang.Apply(tmp240, []any{v5})
					tmp242 := lang.Apply(tmp233, []any{tmp237, tmp241})
					tmp243 := lang.Apply(tmp230, []any{tmp242})
					tmp244 := lang.Apply(tmp227, []any{tmp243})
					tmp245 := lang.Apply(tmp55, []any{tmp59, tmp169, tmp217, tmp224, tmp244})
					tmp246 := lang.Apply(tmp52, []any{tmp245})
					tmp7 = tmp246
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// defstruct
	{
		tmp0 := lang.NewSymbol("defstruct").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Same as (def name (create-struct keys...))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4044), lang.NewKeyword("end-line"), int(4044))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("def")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("concat"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("list"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/create-struct")})
				tmp34 := lang.Apply(tmp29, []any{tmp33, v6})
				tmp35 := lang.Apply(tmp26, []any{tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp37})
				return tmp38
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay
	{
		tmp0 := lang.NewSymbol("delay").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(739), lang.NewKeyword("end-line"), int(739))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("list"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("list*"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.NewVector()
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(746), lang.NewKeyword("column"), int(62), lang.NewKeyword("end-line"), int(746), lang.NewKeyword("end-column"), int(63))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := lang.Apply(tmp11, []any{lang.NewSymbol("fn*"), tmp14, v5})
				tmp16 := lang.Apply(tmp8, []any{lang.NewSymbol("new"), lang.NewSymbol("glojure.lang.Delay"), tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// delay?
	{
		tmp0 := lang.NewSymbol("delay?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "returns true if x is a Delay created with delay", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(748), lang.NewKeyword("end-line"), int(748))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deliver
	{
		tmp0 := lang.NewSymbol("deliver").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("promise"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7109), lang.NewKeyword("end-line"), int(7109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(v3, []any{v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// denominator
	{
		tmp1 := reflect.TypeOf((*big6.Int)(nil))
		tmp0 := lang.NewSymbol("denominator").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"))), lang.NewKeyword("doc"), "Returns the denominator part of a Ratio.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3591), lang.NewKeyword("end-line"), int(3591))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "denominator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "denominator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big6.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref
	{
		tmp0 := lang.NewSymbol("deref").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("timeout-ms"), lang.NewSymbol("timeout-val"))), lang.NewKeyword("doc"), "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2304), lang.NewKeyword("end-line"), int(2304))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
				if lang.IsTruthy(tmp9) {
					tmp10, ok := lang.FieldOrMethod(v3, "Deref")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Deref")))
					}
					var tmp11 any
					switch reflect.TypeOf(tmp10).Kind() {
					case reflect.Func:
						tmp11 = lang.Apply(tmp10, nil)
					default:
						tmp11 = tmp10
					}
					tmp4 = tmp11
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("deref-future"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{v3})
					tmp4 = tmp15
				}
				return tmp4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					tmp12, _ := lang.FieldOrMethod(v3, "DerefWithTimeout")
					if reflect.TypeOf(tmp12).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("DerefWithTimeout is not a function")))
					}
					tmp13 := lang.Apply(tmp12, []any{v4, v5})
					tmp6 = tmp13
				} else {
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("deref-future"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v3, v4, v5})
					tmp6 = tmp17
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-as-map
	{
		tmp0 := lang.NewSymbol("deref-as-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(408), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(408), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "pending"
				var tmp5 any
				{ // let
					// let binding "and__0__auto__"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
					tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("not"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16, ok := lang.FieldOrMethod(v3, "isRealized")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
						}
						var tmp17 any
						switch reflect.TypeOf(tmp16).Kind() {
						case reflect.Func:
							tmp17 = lang.Apply(tmp16, nil)
						default:
							tmp17 = tmp16
						}
						tmp18 := lang.Apply(tmp15, []any{tmp17})
						tmp12 = tmp18
					} else {
						tmp12 = v11
					}
					tmp5 = tmp12
				} // end let
				var v6 any = tmp5
				_ = v6
				// let binding "vec__250"
				var tmp7 any
				if lang.IsTruthy(v6) {
				} else {
					var tmp8 any
					func() {
						defer func() {
							if r := recover(); r != nil {
								if lang.CatchMatches(r, lang.Throwable) {
									v9 := r
									_ = v9
									tmp10 := lang.NewVector(true, v9)
									tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(415), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(415), lang.NewKeyword("end-column"), int(25))
									tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp8 = tmp12
								} else {
									panic(r)
								}
							}
						}()
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("deref"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v3})
						tmp13 := lang.NewVector(false, tmp12)
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(413), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(413), lang.NewKeyword("end-column"), int(32))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp15
					}()
					tmp7 = tmp8
				}
				var v16 any = tmp7
				_ = v16
				// let binding "ex"
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("nth"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v16, int64(0), nil})
				var v21 any = tmp20
				_ = v21
				// let binding "val"
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("nth"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v16, int64(1), nil})
				var v26 any = tmp25
				_ = v26
				var tmp27 any
				var tmp28 any
				{ // let
					// let binding "or__0__auto__"
					var v29 any = v21
					_ = v29
					var tmp30 any
					if lang.IsTruthy(v29) {
						tmp30 = v29
					} else {
						var tmp31 any
						{ // let
							// let binding "and__0__auto__"
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("instance?"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := reflect.TypeOf((*lang.Agent)(nil))
							tmp36 := lang.Apply(tmp34, []any{tmp35, v3})
							var v37 any = tmp36
							_ = v37
							var tmp38 any
							if lang.IsTruthy(v37) {
								tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp40 := tmp39.FindInternedVar(lang.NewSymbol("agent-error"))
								if tmp40.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
								}
								tmp41 := tmp40.Get()
								tmp42 := lang.Apply(tmp41, []any{v3})
								tmp38 = tmp42
							} else {
								tmp38 = v37
							}
							tmp31 = tmp38
						} // end let
						tmp30 = tmp31
					}
					tmp28 = tmp30
				} // end let
				if lang.IsTruthy(tmp28) {
					tmp27 = lang.NewKeyword("failed")
				} else {
					var tmp29 any
					if lang.IsTruthy(v6) {
						tmp29 = lang.NewKeyword("pending")
					} else {
						var tmp30 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp30 = lang.NewKeyword("ready")
						} else {
						}
						tmp29 = tmp30
					}
					tmp27 = tmp29
				}
				tmp31 := lang.NewMap(lang.NewKeyword("status"), tmp27, lang.NewKeyword("val"), v26)
				tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(416), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(429), lang.NewKeyword("end-column"), int(14))
				tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp33
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// deref-future
	{
		tmp0 := lang.NewSymbol("deref-future").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2296), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2296), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fut")), lang.NewVector(lang.NewSymbol("fut"), lang.NewSymbol("timeout-ms"), lang.NewSymbol("timeout-val"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "Get")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Get")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							tmp7 := reflect.TypeOf((*lang.TimeoutError)(nil)).Elem()
							if lang.CatchMatches(r, tmp7) {
								v8 := r
								_ = v8
								tmp6 = v5
							} else {
								panic(r)
							}
						}
					}()
					tmp8, _ := lang.FieldOrMethod(v3, "Get")
					if reflect.TypeOf(tmp8).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
					}
					tmp9 := lang.Apply(tmp8, []any{v4, time7.Millisecond})
					tmp6 = tmp9
				}()
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// derive
	{
		tmp0 := lang.NewSymbol("derive").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5605), lang.NewKeyword("end-line"), int(5605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("alter-var-root"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("derive"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp7, []any{tmp8, tmp11, v3, v4})
				_ = tmp12
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "tp"
					tmp7 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "td"
					tmp9 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
					var v10 any = tmp9
					_ = v10
					// let binding "ta"
					tmp11 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
					var v12 any = tmp11
					_ = v12
					// let binding "tf"
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 5 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v14 := args[0]
						_ = v14
						v15 := args[1]
						_ = v15
						v16 := args[2]
						_ = v16
						v17 := args[3]
						_ = v17
						v18 := args[4]
						_ = v18
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("reduce1"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						var tmp22 lang.FnFunc
						tmp22 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v23 := args[0]
							_ = v23
							v24 := args[1]
							_ = v24
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("assoc"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("conj"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("get"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5628), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(5628), lang.NewKeyword("end-column"), int(63))
							tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp40 := lang.Apply(tmp36, []any{v18, v24, tmp39})
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("cons"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(v18, []any{v17})
							tmp45 := lang.Apply(tmp43, []any{v17, tmp44})
							tmp46 := lang.Apply(tmp30, []any{tmp33, tmp40, tmp45})
							tmp47 := lang.Apply(tmp27, []any{v23, v24, tmp46})
							return tmp47
						})
						tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5626), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(5628), lang.NewKeyword("end-column"), int(98))
						tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("cons"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(v16, []any{v15})
						tmp29 := lang.Apply(tmp27, []any{v15, tmp28})
						tmp30 := lang.Apply(tmp21, []any{tmp24, v14, tmp29})
						return tmp30
					})
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5625), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(5629), lang.NewKeyword("end-column"), int(56))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v16 any = tmp15
					_ = v16
					var tmp17 any
					{ // let
						// let binding "or__0__auto__"
						var tmp18 any
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("contains?"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(v8, []any{v4})
						tmp23 := lang.Apply(tmp21, []any{tmp22, v5})
						if lang.IsTruthy(tmp23) {
						} else {
							var tmp24 any
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("contains?"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(v12, []any{v4})
							tmp29 := lang.Apply(tmp27, []any{tmp28, v5})
							if lang.IsTruthy(tmp29) {
								tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp31 := tmp30.FindInternedVar(lang.NewSymbol("print-str"))
								if tmp31.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
								}
								tmp32 := tmp31.Get()
								tmp33 := lang.Apply(tmp32, []any{v4, "already has", v5, "as ancestor"})
								tmp34 := lang.Apply(lang.NewError, []any{tmp33})
								panic(tmp34)
							} else {
							}
							_ = tmp24
							var tmp35 any
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("contains?"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(v12, []any{v5})
							tmp40 := lang.Apply(tmp38, []any{tmp39, v4})
							if lang.IsTruthy(tmp40) {
								tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp42 := tmp41.FindInternedVar(lang.NewSymbol("print-str"))
								if tmp42.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
								}
								tmp43 := tmp42.Get()
								tmp44 := lang.Apply(tmp43, []any{"Cyclic derivation:", v5, "has", v4, "as ancestor"})
								tmp45 := lang.Apply(lang.NewError, []any{tmp44})
								panic(tmp45)
							} else {
							}
							_ = tmp35
							tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp47 := tmp46.FindInternedVar(lang.NewSymbol("assoc"))
							if tmp47.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
							}
							tmp48 := tmp47.Get()
							tmp49 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
							tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp51 := tmp50.FindInternedVar(lang.NewSymbol("conj"))
							if tmp51.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
							}
							tmp52 := tmp51.Get()
							tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp54 := tmp53.FindInternedVar(lang.NewSymbol("get"))
							if tmp54.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
							}
							tmp55 := tmp54.Get()
							tmp56 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp57 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5636), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(5636), lang.NewKeyword("end-column"), int(63))
							tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp59 := lang.Apply(tmp55, []any{v8, v4, tmp58})
							tmp60 := lang.Apply(tmp52, []any{tmp59, v5})
							tmp61 := lang.Apply(tmp48, []any{tmp49, v4, tmp60})
							tmp62 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
							tmp63 := lang.Apply(v16, []any{tmp62, v4, v10, v5, v12})
							tmp64 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
							tmp65 := lang.Apply(v16, []any{tmp64, v5, v12, v4, v10})
							tmp66 := lang.NewMap(lang.NewKeyword("parents"), tmp61, lang.NewKeyword("ancestors"), tmp63, lang.NewKeyword("descendants"), tmp65)
							tmp67 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5636), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(5638), lang.NewKeyword("end-column"), int(61))
							tmp68, err := lang.WithMeta(tmp66, tmp67.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp18 = tmp68
						}
						var v69 any = tmp18
						_ = v69
						var tmp70 any
						if lang.IsTruthy(v69) {
							tmp70 = v69
						} else {
							tmp70 = v3
						}
						tmp17 = tmp70
					} // end let
					tmp6 = tmp17
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// descendants
	{
		tmp0 := lang.NewSymbol("descendants").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5593), lang.NewKeyword("end-line"), int(5593))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("descendants"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("global-hierarchy"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("class?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp10 := lang.Apply(lang.NewUnsupportedOperationError, []any{"Can't get descendants of classes"})
					panic(tmp10)
				} else {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("not-empty"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("get"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(lang.NewKeyword("descendants"), []any{v3})
					tmp18 := lang.Apply(tmp16, []any{tmp17, v4})
					tmp19 := lang.Apply(tmp13, []any{tmp18})
					tmp5 = tmp19
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// destructure
	{
		tmp0 := lang.NewSymbol("destructure").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4400), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4400), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "bents"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("partition"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{int64(2), v3})
				var v9 any = tmp8
				_ = v9
				// let binding "pb"
				var tmp10 lang.FnFunc
				{ // function pb
					var v11 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v12 := args[0]
						_ = v12
						v13 := args[1]
						_ = v13
						v14 := args[2]
						_ = v14
						var tmp15 any
						{ // let
							// let binding "pvec"
							var tmp16 lang.FnFunc
							tmp16 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v17 := args[0]
								_ = v17
								v18 := args[1]
								_ = v18
								v19 := args[2]
								_ = v19
								var tmp20 any
								{ // let
									// let binding "gvec"
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.Apply(tmp23, []any{"vec__"})
									var v25 any = tmp24
									_ = v25
									// let binding "gseq"
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29 := lang.Apply(tmp28, []any{"seq__"})
									var v30 any = tmp29
									_ = v30
									// let binding "gfirst"
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.Apply(tmp33, []any{"first__"})
									var v35 any = tmp34
									_ = v35
									// let binding "has-rest"
									tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp37 := tmp36.FindInternedVar(lang.NewSymbol("some"))
									if tmp37.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
									}
									tmp38 := tmp37.Get()
									tmp39 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{lang.NewSymbol("&")}))
									tmp40 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4408), lang.NewKeyword("column"), int(43), lang.NewKeyword("end-line"), int(4408), lang.NewKeyword("end-column"), int(47))
									tmp41, err := lang.WithMeta(tmp39, tmp40.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp42 := lang.Apply(tmp38, []any{tmp41, v18})
									var v43 any = tmp42
									_ = v43
									var tmp44 any
									{ // let
										// let binding "ret"
										var tmp45 any
										{ // let
											// let binding "ret"
											tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp47 := tmp46.FindInternedVar(lang.NewSymbol("conj"))
											if tmp47.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
											}
											tmp48 := tmp47.Get()
											tmp49 := lang.Apply(tmp48, []any{v17, v25, v19})
											var v50 any = tmp49
											_ = v50
											var tmp51 any
											if lang.IsTruthy(v43) {
												tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp53 := tmp52.FindInternedVar(lang.NewSymbol("conj"))
												if tmp53.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
												}
												tmp54 := tmp53.Get()
												tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp56 := tmp55.FindInternedVar(lang.NewSymbol("list"))
												if tmp56.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
												}
												tmp57 := tmp56.Get()
												tmp58 := lang.Apply(tmp57, []any{lang.NewSymbol("glojure.core/seq"), v25})
												tmp59 := lang.Apply(tmp54, []any{v50, v30, tmp58})
												tmp51 = tmp59
											} else {
												tmp51 = v50
											}
											tmp45 = tmp51
										} // end let
										var v46 any = tmp45
										_ = v46
										// let binding "n"
										var v47 any = int64(0)
										_ = v47
										// let binding "bs"
										var v48 any = v18
										_ = v48
										// let binding "seen-rest?"
										var v49 any = false
										_ = v49
										for {
											var tmp50 any
											tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp52 := tmp51.FindInternedVar(lang.NewSymbol("seq"))
											if tmp52.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
											}
											tmp53 := tmp52.Get()
											tmp54 := lang.Apply(tmp53, []any{v48})
											if lang.IsTruthy(tmp54) {
												var tmp55 any
												{ // let
													// let binding "firstb"
													tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp57 := tmp56.FindInternedVar(lang.NewSymbol("first"))
													if tmp57.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
													}
													tmp58 := tmp57.Get()
													tmp59 := lang.Apply(tmp58, []any{v48})
													var v60 any = tmp59
													_ = v60
													var tmp61 any
													tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp63 := tmp62.FindInternedVar(lang.NewSymbol("="))
													if tmp63.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
													}
													tmp64 := tmp63.Get()
													tmp65 := lang.Apply(tmp64, []any{v60, lang.NewSymbol("&")})
													if lang.IsTruthy(tmp65) {
														tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp68 := tmp67.FindInternedVar(lang.NewSymbol("second"))
														if tmp68.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
														}
														tmp69 := tmp68.Get()
														tmp70 := lang.Apply(tmp69, []any{v48})
														tmp71 := lang.Apply(v11, []any{v46, tmp70, v30})
														var tmp66 any = tmp71
														var tmp72 any = v47
														tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp75 := tmp74.FindInternedVar(lang.NewSymbol("nnext"))
														if tmp75.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
														}
														tmp76 := tmp75.Get()
														tmp77 := lang.Apply(tmp76, []any{v48})
														var tmp73 any = tmp77
														var tmp78 any = true
														v46 = tmp66
														v47 = tmp72
														v48 = tmp73
														v49 = tmp78
														continue
													} else {
														var tmp79 any
														tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp81 := tmp80.FindInternedVar(lang.NewSymbol("="))
														if tmp81.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
														}
														tmp82 := tmp81.Get()
														tmp83 := lang.Apply(tmp82, []any{v60, lang.NewKeyword("as")})
														if lang.IsTruthy(tmp83) {
															tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp85 := tmp84.FindInternedVar(lang.NewSymbol("second"))
															if tmp85.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
															}
															tmp86 := tmp85.Get()
															tmp87 := lang.Apply(tmp86, []any{v48})
															tmp88 := lang.Apply(v11, []any{v46, tmp87, v25})
															tmp79 = tmp88
														} else {
															var tmp89 any
															if lang.IsTruthy(lang.NewKeyword("else")) {
																var tmp90 any
																if lang.IsTruthy(v49) {
																	tmp91 := lang.Apply(errors5.New, []any{"Unsupported binding form, only :as can follow & parameter"})
																	panic(tmp91)
																} else {
																	var tmp93 any
																	if lang.IsTruthy(v43) {
																		tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp95 := tmp94.FindInternedVar(lang.NewSymbol("conj"))
																		if tmp95.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
																		}
																		tmp96 := tmp95.Get()
																		tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp98 := tmp97.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp98.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
																		}
																		tmp99 := tmp98.Get()
																		tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp101 := tmp100.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp101.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
																		}
																		tmp102 := tmp101.Get()
																		tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp104 := tmp103.FindInternedVar(lang.NewSymbol("list"))
																		if tmp104.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
																		}
																		tmp105 := tmp104.Get()
																		tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("glojure.core/first")})
																		tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
																		if tmp108.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
																		}
																		tmp109 := tmp108.Get()
																		tmp110 := lang.Apply(tmp109, []any{v30})
																		tmp111 := lang.Apply(tmp102, []any{tmp106, tmp110})
																		tmp112 := lang.Apply(tmp99, []any{tmp111})
																		tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp114 := tmp113.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp114.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
																		}
																		tmp115 := tmp114.Get()
																		tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp117 := tmp116.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp117.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
																		}
																		tmp118 := tmp117.Get()
																		tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp120 := tmp119.FindInternedVar(lang.NewSymbol("list"))
																		if tmp120.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
																		}
																		tmp121 := tmp120.Get()
																		tmp122 := lang.Apply(tmp121, []any{lang.NewSymbol("glojure.core/next")})
																		tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp124 := tmp123.FindInternedVar(lang.NewSymbol("list"))
																		if tmp124.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
																		}
																		tmp125 := tmp124.Get()
																		tmp126 := lang.Apply(tmp125, []any{v30})
																		tmp127 := lang.Apply(tmp118, []any{tmp122, tmp126})
																		tmp128 := lang.Apply(tmp115, []any{tmp127})
																		tmp129 := lang.Apply(tmp96, []any{v46, v35, tmp112, v30, tmp128})
																		tmp93 = tmp129
																	} else {
																		tmp93 = v46
																	}
																	var tmp130 any
																	if lang.IsTruthy(v43) {
																		tmp130 = v35
																	} else {
																		tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
																		if tmp132.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
																		}
																		tmp133 := tmp132.Get()
																		tmp134 := lang.Apply(tmp133, []any{lang.NewSymbol("glojure.core/nth"), v25, v47, nil})
																		tmp130 = tmp134
																	}
																	tmp135 := lang.Apply(v11, []any{tmp93, v60, tmp130})
																	var tmp92 any = tmp135
																	tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp138 := tmp137.FindInternedVar(lang.NewSymbol("inc"))
																	if tmp138.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
																	}
																	tmp139 := tmp138.Get()
																	tmp140 := lang.Apply(tmp139, []any{v47})
																	var tmp136 any = tmp140
																	tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp143 := tmp142.FindInternedVar(lang.NewSymbol("next"))
																	if tmp143.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
																	}
																	tmp144 := tmp143.Get()
																	tmp145 := lang.Apply(tmp144, []any{v48})
																	var tmp141 any = tmp145
																	var tmp146 any = v49
																	v46 = tmp92
																	v47 = tmp136
																	v48 = tmp141
																	v49 = tmp146
																	continue
																}
																tmp89 = tmp90
															} else {
															}
															tmp79 = tmp89
														}
														tmp61 = tmp79
													}
													tmp55 = tmp61
												} // end let
												tmp50 = tmp55
											} else {
												tmp50 = v46
											}
											tmp44 = tmp50
											break
										}
									} // end let
									tmp20 = tmp44
								} // end let
								return tmp20
							})
							tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4404), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4438), lang.NewKeyword("end-column"), int(34))
							tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v19 any = tmp18
							_ = v19
							// let binding "pmap"
							var tmp20 lang.FnFunc
							tmp20 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v21 := args[0]
								_ = v21
								v22 := args[1]
								_ = v22
								v23 := args[2]
								_ = v23
								var tmp24 any
								{ // let
									// let binding "gmap"
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.Apply(tmp27, []any{"map__"})
									var v29 any = tmp28
									_ = v29
									// let binding "gmapseq"
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("with-meta"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.ISeq"))
									tmp34 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4442), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(4442), lang.NewKeyword("end-column"), int(103))
									tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp36 := lang.Apply(tmp32, []any{v29, tmp35})
									var v37 any = tmp36
									_ = v37
									// let binding "defaults"
									tmp38 := lang.Apply(lang.NewKeyword("or"), []any{v22})
									var v39 any = tmp38
									_ = v39
									var tmp40 any
									{ // let
										// let binding "ret"
										var tmp41 lang.FnFunc
										tmp41 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v42 := args[0]
											_ = v42
											var tmp43 any
											tmp44 := lang.Apply(lang.NewKeyword("as"), []any{v22})
											if lang.IsTruthy(tmp44) {
												tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp46 := tmp45.FindInternedVar(lang.NewSymbol("conj"))
												if tmp46.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
												}
												tmp47 := tmp46.Get()
												tmp48 := lang.Apply(lang.NewKeyword("as"), []any{v22})
												tmp49 := lang.Apply(tmp47, []any{v42, tmp48, v29})
												tmp43 = tmp49
											} else {
												tmp43 = v42
											}
											return tmp43
										})
										tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4450), lang.NewKeyword("column"), int(40), lang.NewKeyword("end-line"), int(4453), lang.NewKeyword("end-column"), int(48))
										tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("conj"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp48 := tmp47.FindInternedVar(lang.NewSymbol("conj"))
										if tmp48.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
										}
										tmp49 := tmp48.Get()
										tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp51 := tmp50.FindInternedVar(lang.NewSymbol("conj"))
										if tmp51.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
										}
										tmp52 := tmp51.Get()
										tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp54 := tmp53.FindInternedVar(lang.NewSymbol("conj"))
										if tmp54.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
										}
										tmp55 := tmp54.Get()
										tmp56 := lang.Apply(tmp55, []any{v21, v29})
										tmp57 := lang.Apply(tmp52, []any{tmp56, v23})
										tmp58 := lang.Apply(tmp49, []any{tmp57, v29})
										tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp60 := tmp59.FindInternedVar(lang.NewSymbol("seq"))
										if tmp60.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
										}
										tmp61 := tmp60.Get()
										tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp63 := tmp62.FindInternedVar(lang.NewSymbol("concat"))
										if tmp63.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
										}
										tmp64 := tmp63.Get()
										tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
										if tmp66.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
										}
										tmp67 := tmp66.Get()
										tmp68 := lang.Apply(tmp67, []any{lang.NewSymbol("if")})
										tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
										if tmp70.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
										}
										tmp71 := tmp70.Get()
										tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp73 := tmp72.FindInternedVar(lang.NewSymbol("seq"))
										if tmp73.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
										}
										tmp74 := tmp73.Get()
										tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp76 := tmp75.FindInternedVar(lang.NewSymbol("concat"))
										if tmp76.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
										}
										tmp77 := tmp76.Get()
										tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp79 := tmp78.FindInternedVar(lang.NewSymbol("list"))
										if tmp79.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
										}
										tmp80 := tmp79.Get()
										tmp81 := lang.Apply(tmp80, []any{lang.NewSymbol("glojure.core/seq?")})
										tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp83 := tmp82.FindInternedVar(lang.NewSymbol("list"))
										if tmp83.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
										}
										tmp84 := tmp83.Get()
										tmp85 := lang.Apply(tmp84, []any{v29})
										tmp86 := lang.Apply(tmp77, []any{tmp81, tmp85})
										tmp87 := lang.Apply(tmp74, []any{tmp86})
										tmp88 := lang.Apply(tmp71, []any{tmp87})
										tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
										if tmp90.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
										}
										tmp91 := tmp90.Get()
										tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp93 := tmp92.FindInternedVar(lang.NewSymbol("seq"))
										if tmp93.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
										}
										tmp94 := tmp93.Get()
										tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp96 := tmp95.FindInternedVar(lang.NewSymbol("concat"))
										if tmp96.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
										}
										tmp97 := tmp96.Get()
										tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp99 := tmp98.FindInternedVar(lang.NewSymbol("list"))
										if tmp99.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
										}
										tmp100 := tmp99.Get()
										tmp101 := lang.Apply(tmp100, []any{lang.NewSymbol("if")})
										tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp103 := tmp102.FindInternedVar(lang.NewSymbol("list"))
										if tmp103.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
										}
										tmp104 := tmp103.Get()
										tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp106 := tmp105.FindInternedVar(lang.NewSymbol("seq"))
										if tmp106.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
										}
										tmp107 := tmp106.Get()
										tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp109 := tmp108.FindInternedVar(lang.NewSymbol("concat"))
										if tmp109.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
										}
										tmp110 := tmp109.Get()
										tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp112 := tmp111.FindInternedVar(lang.NewSymbol("list"))
										if tmp112.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
										}
										tmp113 := tmp112.Get()
										tmp114 := lang.Apply(tmp113, []any{lang.NewSymbol("glojure.core/next")})
										tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp116 := tmp115.FindInternedVar(lang.NewSymbol("list"))
										if tmp116.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
										}
										tmp117 := tmp116.Get()
										tmp118 := lang.Apply(tmp117, []any{v37})
										tmp119 := lang.Apply(tmp110, []any{tmp114, tmp118})
										tmp120 := lang.Apply(tmp107, []any{tmp119})
										tmp121 := lang.Apply(tmp104, []any{tmp120})
										tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
										if tmp123.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
										}
										tmp124 := tmp123.Get()
										tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp126 := tmp125.FindInternedVar(lang.NewSymbol("seq"))
										if tmp126.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
										}
										tmp127 := tmp126.Get()
										tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp129 := tmp128.FindInternedVar(lang.NewSymbol("concat"))
										if tmp129.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
										}
										tmp130 := tmp129.Get()
										tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
										if tmp132.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
										}
										tmp133 := tmp132.Get()
										tmp134 := lang.Apply(tmp133, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewPersistentArrayMapAsIfByAssoc")})
										tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp136 := tmp135.FindInternedVar(lang.NewSymbol("list"))
										if tmp136.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
										}
										tmp137 := tmp136.Get()
										tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp139 := tmp138.FindInternedVar(lang.NewSymbol("seq"))
										if tmp139.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
										}
										tmp140 := tmp139.Get()
										tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp142 := tmp141.FindInternedVar(lang.NewSymbol("concat"))
										if tmp142.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
										}
										tmp143 := tmp142.Get()
										tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp145 := tmp144.FindInternedVar(lang.NewSymbol("list"))
										if tmp145.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
										}
										tmp146 := tmp145.Get()
										tmp147 := lang.Apply(tmp146, []any{lang.NewSymbol("glojure.core/to-array")})
										tmp148 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp149 := tmp148.FindInternedVar(lang.NewSymbol("list"))
										if tmp149.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp149)))
										}
										tmp150 := tmp149.Get()
										tmp151 := lang.Apply(tmp150, []any{v37})
										tmp152 := lang.Apply(tmp143, []any{tmp147, tmp151})
										tmp153 := lang.Apply(tmp140, []any{tmp152})
										tmp154 := lang.Apply(tmp137, []any{tmp153})
										tmp155 := lang.Apply(tmp130, []any{tmp134, tmp154})
										tmp156 := lang.Apply(tmp127, []any{tmp155})
										tmp157 := lang.Apply(tmp124, []any{tmp156})
										tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp159 := tmp158.FindInternedVar(lang.NewSymbol("list"))
										if tmp159.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
										}
										tmp160 := tmp159.Get()
										tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp162 := tmp161.FindInternedVar(lang.NewSymbol("seq"))
										if tmp162.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
										}
										tmp163 := tmp162.Get()
										tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp165 := tmp164.FindInternedVar(lang.NewSymbol("concat"))
										if tmp165.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
										}
										tmp166 := tmp165.Get()
										tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp168 := tmp167.FindInternedVar(lang.NewSymbol("list"))
										if tmp168.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
										}
										tmp169 := tmp168.Get()
										tmp170 := lang.Apply(tmp169, []any{lang.NewSymbol("if")})
										tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
										if tmp172.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
										}
										tmp173 := tmp172.Get()
										tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp175 := tmp174.FindInternedVar(lang.NewSymbol("seq"))
										if tmp175.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
										}
										tmp176 := tmp175.Get()
										tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp178 := tmp177.FindInternedVar(lang.NewSymbol("concat"))
										if tmp178.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
										}
										tmp179 := tmp178.Get()
										tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp181 := tmp180.FindInternedVar(lang.NewSymbol("list"))
										if tmp181.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
										}
										tmp182 := tmp181.Get()
										tmp183 := lang.Apply(tmp182, []any{lang.NewSymbol("glojure.core/seq")})
										tmp184 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp185 := tmp184.FindInternedVar(lang.NewSymbol("list"))
										if tmp185.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp185)))
										}
										tmp186 := tmp185.Get()
										tmp187 := lang.Apply(tmp186, []any{v37})
										tmp188 := lang.Apply(tmp179, []any{tmp183, tmp187})
										tmp189 := lang.Apply(tmp176, []any{tmp188})
										tmp190 := lang.Apply(tmp173, []any{tmp189})
										tmp191 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp192 := tmp191.FindInternedVar(lang.NewSymbol("list"))
										if tmp192.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp192)))
										}
										tmp193 := tmp192.Get()
										tmp194 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp195 := tmp194.FindInternedVar(lang.NewSymbol("seq"))
										if tmp195.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp195)))
										}
										tmp196 := tmp195.Get()
										tmp197 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp198 := tmp197.FindInternedVar(lang.NewSymbol("concat"))
										if tmp198.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp198)))
										}
										tmp199 := tmp198.Get()
										tmp200 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp201 := tmp200.FindInternedVar(lang.NewSymbol("list"))
										if tmp201.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp201)))
										}
										tmp202 := tmp201.Get()
										tmp203 := lang.Apply(tmp202, []any{lang.NewSymbol("glojure.core/first")})
										tmp204 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp205 := tmp204.FindInternedVar(lang.NewSymbol("list"))
										if tmp205.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp205)))
										}
										tmp206 := tmp205.Get()
										tmp207 := lang.Apply(tmp206, []any{v37})
										tmp208 := lang.Apply(tmp199, []any{tmp203, tmp207})
										tmp209 := lang.Apply(tmp196, []any{tmp208})
										tmp210 := lang.Apply(tmp193, []any{tmp209})
										tmp211 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp212 := tmp211.FindInternedVar(lang.NewSymbol("list"))
										if tmp212.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp212)))
										}
										tmp213 := tmp212.Get()
										tmp214 := lang.Apply(tmp213, []any{lang.NewSymbol("glojure.lang.PersistentArrayMap/EMPTY")})
										tmp215 := lang.Apply(tmp166, []any{tmp170, tmp190, tmp210, tmp214})
										tmp216 := lang.Apply(tmp163, []any{tmp215})
										tmp217 := lang.Apply(tmp160, []any{tmp216})
										tmp218 := lang.Apply(tmp97, []any{tmp101, tmp121, tmp157, tmp217})
										tmp219 := lang.Apply(tmp94, []any{tmp218})
										tmp220 := lang.Apply(tmp91, []any{tmp219})
										tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp222 := tmp221.FindInternedVar(lang.NewSymbol("list"))
										if tmp222.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
										}
										tmp223 := tmp222.Get()
										tmp224 := lang.Apply(tmp223, []any{v29})
										tmp225 := lang.Apply(tmp64, []any{tmp68, tmp88, tmp220, tmp224})
										tmp226 := lang.Apply(tmp61, []any{tmp225})
										tmp227 := lang.Apply(tmp46, []any{tmp58, tmp226})
										tmp228 := lang.Apply(tmp43, []any{tmp227})
										var v229 any = tmp228
										_ = v229
										// let binding "bes"
										var tmp230 any
										{ // let
											// let binding "transforms"
											tmp231 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp232 := tmp231.FindInternedVar(lang.NewSymbol("reduce1"))
											if tmp232.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp232)))
											}
											tmp233 := tmp232.Get()
											var tmp234 lang.FnFunc
											tmp234 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 2 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v235 := args[0]
												_ = v235
												v236 := args[1]
												_ = v236
												var tmp237 any
												tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp239 := tmp238.FindInternedVar(lang.NewSymbol("keyword?"))
												if tmp239.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
												}
												tmp240 := tmp239.Get()
												tmp241 := lang.Apply(tmp240, []any{v236})
												if lang.IsTruthy(tmp241) {
													var tmp242 any
													{ // let
														// let binding "mkns"
														tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp244 := tmp243.FindInternedVar(lang.NewSymbol("namespace"))
														if tmp244.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
														}
														tmp245 := tmp244.Get()
														tmp246 := lang.Apply(tmp245, []any{v236})
														var v247 any = tmp246
														_ = v247
														// let binding "mkn"
														tmp248 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp249 := tmp248.FindInternedVar(lang.NewSymbol("name"))
														if tmp249.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp249)))
														}
														tmp250 := tmp249.Get()
														tmp251 := lang.Apply(tmp250, []any{v236})
														var v252 any = tmp251
														_ = v252
														var tmp253 any
														tmp254 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp255 := tmp254.FindInternedVar(lang.NewSymbol("="))
														if tmp255.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp255)))
														}
														tmp256 := tmp255.Get()
														tmp257 := lang.Apply(tmp256, []any{v252, "keys"})
														if lang.IsTruthy(tmp257) {
															tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp259 := tmp258.FindInternedVar(lang.NewSymbol("assoc"))
															if tmp259.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
															}
															tmp260 := tmp259.Get()
															var tmp261 lang.FnFunc
															tmp261 = lang.NewFnFunc(func(args ...any) any {
																if len(args) != 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v262 := args[0]
																_ = v262
																tmp263 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp264 := tmp263.FindInternedVar(lang.NewSymbol("keyword"))
																if tmp264.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp264)))
																}
																tmp265 := tmp264.Get()
																var tmp266 any
																{ // let
																	// let binding "or__0__auto__"
																	var v267 any = v247
																	_ = v267
																	var tmp268 any
																	if lang.IsTruthy(v267) {
																		tmp268 = v267
																	} else {
																		tmp269 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp270 := tmp269.FindInternedVar(lang.NewSymbol("namespace"))
																		if tmp270.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp270)))
																		}
																		tmp271 := tmp270.Get()
																		tmp272 := lang.Apply(tmp271, []any{v262})
																		tmp268 = tmp272
																	}
																	tmp266 = tmp268
																} // end let
																tmp267 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp268 := tmp267.FindInternedVar(lang.NewSymbol("name"))
																if tmp268.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp268)))
																}
																tmp269 := tmp268.Get()
																tmp270 := lang.Apply(tmp269, []any{v262})
																tmp271 := lang.Apply(tmp265, []any{tmp266, tmp270})
																return tmp271
															})
															tmp262 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4460), lang.NewKeyword("column"), int(93), lang.NewKeyword("end-line"), int(4460), lang.NewKeyword("end-column"), int(135))
															tmp263, err := lang.WithMeta(tmp261, tmp262.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp264 := lang.Apply(tmp260, []any{v235, v236, tmp263})
															tmp253 = tmp264
														} else {
															var tmp265 any
															tmp266 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp267 := tmp266.FindInternedVar(lang.NewSymbol("="))
															if tmp267.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp267)))
															}
															tmp268 := tmp267.Get()
															tmp269 := lang.Apply(tmp268, []any{v252, "syms"})
															if lang.IsTruthy(tmp269) {
																tmp270 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp271 := tmp270.FindInternedVar(lang.NewSymbol("assoc"))
																if tmp271.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp271)))
																}
																tmp272 := tmp271.Get()
																var tmp273 lang.FnFunc
																tmp273 = lang.NewFnFunc(func(args ...any) any {
																	if len(args) != 1 {
																		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																	}
																	v274 := args[0]
																	_ = v274
																	tmp275 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp276 := tmp275.FindInternedVar(lang.NewSymbol("list"))
																	if tmp276.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp276)))
																	}
																	tmp277 := tmp276.Get()
																	tmp278 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp279 := tmp278.FindInternedVar(lang.NewSymbol("symbol"))
																	if tmp279.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp279)))
																	}
																	tmp280 := tmp279.Get()
																	var tmp281 any
																	{ // let
																		// let binding "or__0__auto__"
																		var v282 any = v247
																		_ = v282
																		var tmp283 any
																		if lang.IsTruthy(v282) {
																			tmp283 = v282
																		} else {
																			tmp284 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp285 := tmp284.FindInternedVar(lang.NewSymbol("namespace"))
																			if tmp285.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp285)))
																			}
																			tmp286 := tmp285.Get()
																			tmp287 := lang.Apply(tmp286, []any{v274})
																			tmp283 = tmp287
																		}
																		tmp281 = tmp283
																	} // end let
																	tmp282 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp283 := tmp282.FindInternedVar(lang.NewSymbol("name"))
																	if tmp283.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp283)))
																	}
																	tmp284 := tmp283.Get()
																	tmp285 := lang.Apply(tmp284, []any{v274})
																	tmp286 := lang.Apply(tmp280, []any{tmp281, tmp285})
																	tmp287 := lang.Apply(tmp277, []any{lang.NewSymbol("quote"), tmp286})
																	return tmp287
																})
																tmp274 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4461), lang.NewKeyword("column"), int(93), lang.NewKeyword("end-line"), int(4461), lang.NewKeyword("end-column"), int(148))
																tmp275, err := lang.WithMeta(tmp273, tmp274.(lang.IPersistentMap))
																if err != nil {
																	panic(err)
																}
																tmp276 := lang.Apply(tmp272, []any{v235, v236, tmp275})
																tmp265 = tmp276
															} else {
																var tmp277 any
																tmp278 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp279 := tmp278.FindInternedVar(lang.NewSymbol("="))
																if tmp279.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp279)))
																}
																tmp280 := tmp279.Get()
																tmp281 := lang.Apply(tmp280, []any{v252, "strs"})
																if lang.IsTruthy(tmp281) {
																	tmp282 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp283 := tmp282.FindInternedVar(lang.NewSymbol("assoc"))
																	if tmp283.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp283)))
																	}
																	tmp284 := tmp283.Get()
																	tmp285 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp286 := tmp285.FindInternedVar(lang.NewSymbol("str"))
																	if tmp286.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp286)))
																	}
																	tmp287 := tmp286.Get()
																	tmp288 := lang.Apply(tmp284, []any{v235, v236, tmp287})
																	tmp277 = tmp288
																} else {
																	var tmp289 any
																	if lang.IsTruthy(lang.NewKeyword("else")) {
																		tmp289 = v235
																	} else {
																	}
																	tmp277 = tmp289
																}
																tmp265 = tmp277
															}
															tmp253 = tmp265
														}
														tmp242 = tmp253
													} // end let
													tmp237 = tmp242
												} else {
													tmp237 = v235
												}
												return tmp237
											})
											tmp235 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4456), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(4464), lang.NewKeyword("end-column"), int(60))
											tmp236, err := lang.WithMeta(tmp234, tmp235.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp237 := lang.NewMap()
											tmp238 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4465), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(4465), lang.NewKeyword("end-column"), int(46))
											tmp239, err := lang.WithMeta(tmp237, tmp238.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp240 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp241 := tmp240.FindInternedVar(lang.NewSymbol("keys"))
											if tmp241.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp241)))
											}
											tmp242 := tmp241.Get()
											tmp243 := lang.Apply(tmp242, []any{v22})
											tmp244 := lang.Apply(tmp233, []any{tmp236, tmp239, tmp243})
											var v245 any = tmp244
											_ = v245
											tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp247 := tmp246.FindInternedVar(lang.NewSymbol("reduce1"))
											if tmp247.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
											}
											tmp248 := tmp247.Get()
											var tmp249 lang.FnFunc
											tmp249 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 2 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v250 := args[0]
												_ = v250
												v251 := args[1]
												_ = v251
												tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp253 := tmp252.FindInternedVar(lang.NewSymbol("reduce1"))
												if tmp253.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
												}
												tmp254 := tmp253.Get()
												var tmp255 lang.FnFunc
												tmp255 = lang.NewFnFunc(func(args ...any) any {
													if len(args) != 2 {
														panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
													}
													v256 := args[0]
													_ = v256
													v257 := args[1]
													_ = v257
													tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp259 := tmp258.FindInternedVar(lang.NewSymbol("assoc"))
													if tmp259.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
													}
													tmp260 := tmp259.Get()
													tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp262 := tmp261.FindInternedVar(lang.NewSymbol("val"))
													if tmp262.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
													}
													tmp263 := tmp262.Get()
													tmp264 := lang.Apply(tmp263, []any{v251})
													tmp265 := lang.Apply(tmp264, []any{v257})
													tmp266 := lang.Apply(tmp260, []any{v256, v257, tmp265})
													return tmp266
												})
												tmp256 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4469), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(4469), lang.NewKeyword("end-column"), int(82))
												tmp257, err := lang.WithMeta(tmp255, tmp256.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp259 := tmp258.FindInternedVar(lang.NewSymbol("dissoc"))
												if tmp259.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
												}
												tmp260 := tmp259.Get()
												tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp262 := tmp261.FindInternedVar(lang.NewSymbol("key"))
												if tmp262.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
												}
												tmp263 := tmp262.Get()
												tmp264 := lang.Apply(tmp263, []any{v251})
												tmp265 := lang.Apply(tmp260, []any{v250, tmp264})
												tmp266 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp267 := tmp266.FindInternedVar(lang.NewSymbol("key"))
												if tmp267.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp267)))
												}
												tmp268 := tmp267.Get()
												tmp269 := lang.Apply(tmp268, []any{v251})
												tmp270 := lang.Apply(tmp269, []any{v250})
												tmp271 := lang.Apply(tmp254, []any{tmp257, tmp265, tmp270})
												return tmp271
											})
											tmp250 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4468), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(4471), lang.NewKeyword("end-column"), int(70))
											tmp251, err := lang.WithMeta(tmp249, tmp250.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp253 := tmp252.FindInternedVar(lang.NewSymbol("dissoc"))
											if tmp253.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
											}
											tmp254 := tmp253.Get()
											tmp255 := lang.Apply(tmp254, []any{v22, lang.NewKeyword("as"), lang.NewKeyword("or")})
											tmp256 := lang.Apply(tmp248, []any{tmp251, tmp255, v245})
											tmp230 = tmp256
										} // end let
										var v231 any = tmp230
										_ = v231
										for {
											var tmp232 any
											tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp234 := tmp233.FindInternedVar(lang.NewSymbol("seq"))
											if tmp234.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
											}
											tmp235 := tmp234.Get()
											tmp236 := lang.Apply(tmp235, []any{v231})
											if lang.IsTruthy(tmp236) {
												var tmp237 any
												{ // let
													// let binding "bb"
													tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp239 := tmp238.FindInternedVar(lang.NewSymbol("key"))
													if tmp239.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
													}
													tmp240 := tmp239.Get()
													tmp241 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp242 := tmp241.FindInternedVar(lang.NewSymbol("first"))
													if tmp242.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp242)))
													}
													tmp243 := tmp242.Get()
													tmp244 := lang.Apply(tmp243, []any{v231})
													tmp245 := lang.Apply(tmp240, []any{tmp244})
													var v246 any = tmp245
													_ = v246
													// let binding "bk"
													tmp247 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp248 := tmp247.FindInternedVar(lang.NewSymbol("val"))
													if tmp248.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp248)))
													}
													tmp249 := tmp248.Get()
													tmp250 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp251 := tmp250.FindInternedVar(lang.NewSymbol("first"))
													if tmp251.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp251)))
													}
													tmp252 := tmp251.Get()
													tmp253 := lang.Apply(tmp252, []any{v231})
													tmp254 := lang.Apply(tmp249, []any{tmp253})
													var v255 any = tmp254
													_ = v255
													// let binding "local"
													var tmp256 any
													tmp257 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp258 := tmp257.FindInternedVar(lang.NewSymbol("instance?"))
													if tmp258.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp258)))
													}
													tmp259 := tmp258.Get()
													tmp260 := reflect.TypeOf((*lang.Named)(nil)).Elem()
													tmp261 := lang.Apply(tmp259, []any{tmp260, v246})
													if lang.IsTruthy(tmp261) {
														tmp262 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp263 := tmp262.FindInternedVar(lang.NewSymbol("with-meta"))
														if tmp263.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp263)))
														}
														tmp264 := tmp263.Get()
														tmp265 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp266 := tmp265.FindInternedVar(lang.NewSymbol("symbol"))
														if tmp266.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp266)))
														}
														tmp267 := tmp266.Get()
														tmp268 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp269 := tmp268.FindInternedVar(lang.NewSymbol("name"))
														if tmp269.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp269)))
														}
														tmp270 := tmp269.Get()
														tmp271 := lang.Apply(tmp270, []any{v246})
														tmp272 := lang.Apply(tmp267, []any{nil, tmp271})
														tmp273 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp274 := tmp273.FindInternedVar(lang.NewSymbol("meta"))
														if tmp274.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp274)))
														}
														tmp275 := tmp274.Get()
														tmp276 := lang.Apply(tmp275, []any{v246})
														tmp277 := lang.Apply(tmp264, []any{tmp272, tmp276})
														tmp256 = tmp277
													} else {
														tmp256 = v246
													}
													var v278 any = tmp256
													_ = v278
													// let binding "bv"
													var tmp279 any
													tmp280 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp281 := tmp280.FindInternedVar(lang.NewSymbol("contains?"))
													if tmp281.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp281)))
													}
													tmp282 := tmp281.Get()
													tmp283 := lang.Apply(tmp282, []any{v39, v278})
													if lang.IsTruthy(tmp283) {
														tmp284 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp285 := tmp284.FindInternedVar(lang.NewSymbol("list"))
														if tmp285.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp285)))
														}
														tmp286 := tmp285.Get()
														tmp287 := lang.Apply(v39, []any{v278})
														tmp288 := lang.Apply(tmp286, []any{lang.NewSymbol("glojure.core/get"), v29, v255, tmp287})
														tmp279 = tmp288
													} else {
														tmp289 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp290 := tmp289.FindInternedVar(lang.NewSymbol("list"))
														if tmp290.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp290)))
														}
														tmp291 := tmp290.Get()
														tmp292 := lang.Apply(tmp291, []any{lang.NewSymbol("glojure.core/get"), v29, v255})
														tmp279 = tmp292
													}
													var v293 any = tmp279
													_ = v293
													var tmp295 any
													tmp296 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp297 := tmp296.FindInternedVar(lang.NewSymbol("ident?"))
													if tmp297.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp297)))
													}
													tmp298 := tmp297.Get()
													tmp299 := lang.Apply(tmp298, []any{v246})
													if lang.IsTruthy(tmp299) {
														tmp300 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp301 := tmp300.FindInternedVar(lang.NewSymbol("conj"))
														if tmp301.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp301)))
														}
														tmp302 := tmp301.Get()
														tmp303 := lang.Apply(tmp302, []any{v229, v278, v293})
														tmp295 = tmp303
													} else {
														tmp304 := lang.Apply(v11, []any{v229, v246, v293})
														tmp295 = tmp304
													}
													var tmp294 any = tmp295
													tmp306 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp307 := tmp306.FindInternedVar(lang.NewSymbol("next"))
													if tmp307.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp307)))
													}
													tmp308 := tmp307.Get()
													tmp309 := lang.Apply(tmp308, []any{v231})
													var tmp305 any = tmp309
													v229 = tmp294
													v231 = tmp305
													continue
												} // end let
												tmp232 = tmp237
											} else {
												tmp232 = v229
											}
											tmp40 = tmp232
											break
										}
									} // end let
									tmp24 = tmp40
								} // end let
								return tmp24
							})
							tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4440), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4485), lang.NewKeyword("end-column"), int(34))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							var v23 any = tmp22
							_ = v23
							var tmp24 any
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("symbol?"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v13})
							if lang.IsTruthy(tmp28) {
								tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp30 := tmp29.FindInternedVar(lang.NewSymbol("conj"))
								if tmp30.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
								}
								tmp31 := tmp30.Get()
								tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp33 := tmp32.FindInternedVar(lang.NewSymbol("conj"))
								if tmp33.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
								}
								tmp34 := tmp33.Get()
								tmp35 := lang.Apply(tmp34, []any{v12, v13})
								tmp36 := lang.Apply(tmp31, []any{tmp35, v14})
								tmp24 = tmp36
							} else {
								var tmp37 any
								tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp39 := tmp38.FindInternedVar(lang.NewSymbol("vector?"))
								if tmp39.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
								}
								tmp40 := tmp39.Get()
								tmp41 := lang.Apply(tmp40, []any{v13})
								if lang.IsTruthy(tmp41) {
									tmp42 := lang.Apply(v19, []any{v12, v13, v14})
									tmp37 = tmp42
								} else {
									var tmp43 any
									tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp45 := tmp44.FindInternedVar(lang.NewSymbol("map?"))
									if tmp45.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
									}
									tmp46 := tmp45.Get()
									tmp47 := lang.Apply(tmp46, []any{v13})
									if lang.IsTruthy(tmp47) {
										tmp48 := lang.Apply(v23, []any{v12, v13, v14})
										tmp43 = tmp48
									} else {
										var tmp49 any
										if lang.IsTruthy(lang.NewKeyword("else")) {
											tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp51 := tmp50.FindInternedVar(lang.NewSymbol("str"))
											if tmp51.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
											}
											tmp52 := tmp51.Get()
											tmp53 := lang.Apply(tmp52, []any{"Unsupported binding form: ", v13})
											tmp54 := lang.Apply(errors5.New, []any{tmp53})
											panic(tmp54)
										} else {
										}
										tmp43 = tmp49
									}
									tmp37 = tmp43
								}
								tmp24 = tmp37
							}
							tmp15 = tmp24
						} // end let
						return tmp15
					})
					v11 = tmp10
					_ = v11
				}
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4402), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(4490), lang.NewKeyword("end-column"), int(82))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v13 any = tmp12
				_ = v13
				// let binding "process-entry"
				var tmp14 lang.FnFunc
				tmp14 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v15 := args[0]
					_ = v15
					v16 := args[1]
					_ = v16
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v16})
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("second"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v16})
					tmp25 := lang.Apply(v13, []any{v15, tmp20, tmp24})
					return tmp25
				})
				tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4491), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(4491), lang.NewKeyword("end-column"), int(66))
				tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v17 any = tmp16
				_ = v17
				var tmp18 any
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("every?"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("symbol?"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("map"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("first"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp27, []any{tmp30, v9})
				tmp32 := lang.Apply(tmp21, []any{tmp24, tmp31})
				if lang.IsTruthy(tmp32) {
					tmp18 = v3
				} else {
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.NewVector()
					tmp37 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4494), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(4494), lang.NewKeyword("end-column"), int(31))
					tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp39 := lang.Apply(tmp35, []any{v17, tmp38, v9})
					tmp18 = tmp39
				}
				tmp4 = tmp18
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj
	{
		tmp0 := lang.NewSymbol("disj").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("set")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1514), lang.NewKeyword("end-line"), int(1514))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				if lang.IsTruthy(v3) {
					tmp6, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp6).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp7 := lang.Apply(tmp6, []any{v4})
					tmp5 = tmp7
				} else {
				}
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_304:
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "ret"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("disj"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v3, v4})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v5) {
							var tmp14 any = v12
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.Apply(tmp18, []any{v5})
							var tmp15 any = tmp19
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("next"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.Apply(tmp23, []any{v5})
							var tmp20 any = tmp24
							v3 = tmp14
							v4 = tmp15
							v5 = tmp20
							goto recur_loop_304
						} else {
							tmp13 = v12
						}
						tmp7 = tmp13
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// disj!
	{
		tmp0 := lang.NewSymbol("disj!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("set")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("set"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3401), lang.NewKeyword("end-line"), int(3401))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "Disjoin")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_615:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "Disjoin")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Disjoin is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("first"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v5})
						var tmp12 any = tmp16
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("next"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v5})
						var tmp17 any = tmp21
						v3 = tmp11
						v4 = tmp12
						v5 = tmp17
						goto recur_loop_615
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc
	{
		tmp0 := lang.NewSymbol("dissoc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1500), lang.NewKeyword("end-line"), int(1500))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Dissoc")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Dissoc is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v3, v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_301:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("dissoc"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3, v4})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v5) {
						var tmp13 any = v11
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v5})
						var tmp14 any = tmp18
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("next"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v5})
						var tmp19 any = tmp23
						v3 = tmp13
						v4 = tmp14
						v5 = tmp19
						goto recur_loop_301
					} else {
						tmp12 = v11
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dissoc!
	{
		tmp0 := lang.NewSymbol("dissoc!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("&"), lang.NewSymbol("ks"))), lang.NewKeyword("doc"), "Returns a transient map that doesn't contain a mapping for key(s).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3382), lang.NewKeyword("end-line"), int(3382))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "without")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
			recur_loop_611:
				var tmp6 any
				{ // let
					// let binding "ret"
					tmp7, _ := lang.FieldOrMethod(v3, "without")
					if reflect.TypeOf(tmp7).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("without is not a function")))
					}
					tmp8 := lang.Apply(tmp7, []any{v4})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v5) {
						var tmp11 any = v9
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("first"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v5})
						var tmp12 any = tmp16
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("next"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v5})
						var tmp17 any = tmp21
						v3 = tmp11
						v4 = tmp12
						v5 = tmp17
						goto recur_loop_611
					} else {
						tmp10 = v9
					}
					tmp6 = tmp10
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct
	{
		tmp0 := lang.NewSymbol("distinct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5053), lang.NewKeyword("end-line"), int(5053))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				var tmp3 lang.FnFunc
				tmp3 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v4 := args[0]
					_ = v4
					var tmp5 any
					{ // let
						// let binding "seen"
						tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp7 := tmp6.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp7.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
						}
						tmp8 := tmp7.Get()
						tmp9 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5060), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5060), lang.NewKeyword("end-column"), int(30))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 := lang.Apply(tmp8, []any{tmp11})
						var v13 any = tmp12
						_ = v13
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp15 := lang.Apply(v4, nil)
								return tmp15
							case 1:
								v15 := args[0]
								_ = v15
								tmp16 := lang.Apply(v4, []any{v15})
								return tmp16
							case 2:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								var tmp17 any
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("contains?"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("deref"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(tmp23, []any{v13})
								tmp25 := lang.Apply(tmp20, []any{tmp24, v16})
								if lang.IsTruthy(tmp25) {
									tmp17 = v15
								} else {
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("conj"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29, ok := lang.FieldOrMethod(v13, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v13, "Deref")))
									}
									var tmp30 any
									switch reflect.TypeOf(tmp29).Kind() {
									case reflect.Func:
										tmp30 = lang.Apply(tmp29, nil)
									default:
										tmp30 = tmp29
									}
									tmp31 := lang.Apply(tmp28, []any{tmp30, v16})
									tmp32, _ := lang.FieldOrMethod(v13, "reset")
									if reflect.TypeOf(tmp32).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp33 := lang.Apply(tmp32, []any{tmp31})
									_ = tmp33
									tmp34 := lang.Apply(v4, []any{v15, v16})
									tmp17 = tmp34
								}
								return tmp17
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5061), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(5068), lang.NewKeyword("end-column"), int(37))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp5 = tmp16
					} // end let
					return tmp5
				})
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5059), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(5068), lang.NewKeyword("end-column"), int(39))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "step"
					var tmp5 lang.FnFunc
					{ // function step
						var v6 lang.FnFunc
						tmp5 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 lang.FnFunc
							tmp9 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp10 lang.FnFunc
								tmp10 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v11 := args[0]
									_ = v11
									v12 := args[1]
									_ = v12
								recur_loop_877:
									var tmp13 any
									{ // let
										// let binding "vec__62"
										var v14 any = v11
										_ = v14
										// let binding "f"
										tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp16 := tmp15.FindInternedVar(lang.NewSymbol("nth"))
										if tmp16.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
										}
										tmp17 := tmp16.Get()
										tmp18 := lang.Apply(tmp17, []any{v14, int64(0), nil})
										var v19 any = tmp18
										_ = v19
										// let binding "xs"
										var v20 any = v14
										_ = v20
										var tmp21 any
										{ // let
											// let binding "temp__0__auto__"
											tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
											if tmp23.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
											}
											tmp24 := tmp23.Get()
											tmp25 := lang.Apply(tmp24, []any{v20})
											var v26 any = tmp25
											_ = v26
											var tmp27 any
											if lang.IsTruthy(v26) {
												var tmp28 any
												{ // let
													// let binding "s"
													var v29 any = v26
													_ = v29
													var tmp30 any
													tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp32 := tmp31.FindInternedVar(lang.NewSymbol("contains?"))
													if tmp32.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
													}
													tmp33 := tmp32.Get()
													tmp34 := lang.Apply(tmp33, []any{v12, v19})
													if lang.IsTruthy(tmp34) {
														tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp37 := tmp36.FindInternedVar(lang.NewSymbol("rest"))
														if tmp37.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
														}
														tmp38 := tmp37.Get()
														tmp39 := lang.Apply(tmp38, []any{v29})
														var tmp35 any = tmp39
														var tmp40 any = v12
														v11 = tmp35
														v12 = tmp40
														goto recur_loop_877
													} else {
														tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp42 := tmp41.FindInternedVar(lang.NewSymbol("cons"))
														if tmp42.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
														}
														tmp43 := tmp42.Get()
														tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp45 := tmp44.FindInternedVar(lang.NewSymbol("rest"))
														if tmp45.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
														}
														tmp46 := tmp45.Get()
														tmp47 := lang.Apply(tmp46, []any{v29})
														tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp49 := tmp48.FindInternedVar(lang.NewSymbol("conj"))
														if tmp49.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
														}
														tmp50 := tmp49.Get()
														tmp51 := lang.Apply(tmp50, []any{v12, v19})
														tmp52 := lang.Apply(v6, []any{tmp47, tmp51})
														tmp53 := lang.Apply(tmp43, []any{v19, tmp52})
														tmp30 = tmp53
													}
													tmp28 = tmp30
												} // end let
												tmp27 = tmp28
											} else {
											}
											tmp21 = tmp27
										} // end let
										tmp13 = tmp21
									} // end let
									return tmp13
								})
								tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5072), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(5076), lang.NewKeyword("end-column"), int(66))
								tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp13 := lang.Apply(tmp12, []any{v7, v8})
								return tmp13
							})
							tmp10 := lang.Apply(lang.NewLazySeq, []any{tmp9})
							return tmp10
						})
						v6 = tmp5
						_ = v6
					}
					tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5070), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5077), lang.NewKeyword("end-column"), int(29))
					tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v8 any = tmp7
					_ = v8
					tmp9 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5078), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(5078), lang.NewKeyword("end-column"), int(19))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp12 := lang.Apply(v8, []any{v3, tmp11})
					tmp4 = tmp12
				} // end let
				return tmp4
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// distinct?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("distinct?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns true if no two of the arguments are =", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5664), lang.NewKeyword("end-line"), int(5664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return true
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("not"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("="))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v4, v5})
				tmp13 := lang.Apply(tmp8, []any{tmp12})
				return tmp13
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("not="))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4, v5})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					{ // let
						// let binding "s"
						tmp13 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{v4, v5}))
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5673), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5673), lang.NewKeyword("end-column"), int(20))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						// let binding "G__99"
						var v17 any = v6
						_ = v17
						// let binding "vec__100"
						var v18 any = v17
						_ = v18
						// let binding "seq__101"
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v18})
						var v23 any = tmp22
						_ = v23
						// let binding "first__102"
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("first"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v23})
						var v28 any = tmp27
						_ = v28
						// let binding "seq__101"
						tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp30 := tmp29.FindInternedVar(lang.NewSymbol("next"))
						if tmp30.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
						}
						tmp31 := tmp30.Get()
						tmp32 := lang.Apply(tmp31, []any{v23})
						var v33 any = tmp32
						_ = v33
						// let binding "x"
						var v34 any = v28
						_ = v34
						// let binding "etc"
						var v35 any = v33
						_ = v35
						// let binding "xs"
						var v36 any = v18
						_ = v36
						var tmp37 any
						{ // let
							// let binding "s"
							var v38 any = v16
							_ = v38
							// let binding "G__99"
							var v39 any = v17
							_ = v39
							for {
								var tmp40 any
								{ // let
									// let binding "s"
									var v41 any = v38
									_ = v41
									// let binding "vec__103"
									var v42 any = v39
									_ = v42
									// let binding "seq__104"
									tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
									if tmp44.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
									}
									tmp45 := tmp44.Get()
									tmp46 := lang.Apply(tmp45, []any{v42})
									var v47 any = tmp46
									_ = v47
									// let binding "first__105"
									tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp49 := tmp48.FindInternedVar(lang.NewSymbol("first"))
									if tmp49.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
									}
									tmp50 := tmp49.Get()
									tmp51 := lang.Apply(tmp50, []any{v47})
									var v52 any = tmp51
									_ = v52
									// let binding "seq__104"
									tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp54 := tmp53.FindInternedVar(lang.NewSymbol("next"))
									if tmp54.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
									}
									tmp55 := tmp54.Get()
									tmp56 := lang.Apply(tmp55, []any{v47})
									var v57 any = tmp56
									_ = v57
									// let binding "x"
									var v58 any = v52
									_ = v58
									// let binding "etc"
									var v59 any = v57
									_ = v59
									// let binding "xs"
									var v60 any = v42
									_ = v60
									var tmp61 any
									if lang.IsTruthy(v60) {
										var tmp62 any
										tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp64 := tmp63.FindInternedVar(lang.NewSymbol("contains?"))
										if tmp64.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
										}
										tmp65 := tmp64.Get()
										tmp66 := lang.Apply(tmp65, []any{v41, v58})
										if lang.IsTruthy(tmp66) {
											tmp62 = false
										} else {
											tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp69 := tmp68.FindInternedVar(lang.NewSymbol("conj"))
											if tmp69.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
											}
											tmp70 := tmp69.Get()
											tmp71 := lang.Apply(tmp70, []any{v41, v58})
											var tmp67 any = tmp71
											var tmp72 any = v59
											v38 = tmp67
											v39 = tmp72
											continue
										}
										tmp61 = tmp62
									} else {
										tmp61 = true
									}
									tmp40 = tmp61
								} // end let
								tmp37 = tmp40
								break
							}
						} // end let
						tmp12 = tmp37
					} // end let
					tmp7 = tmp12
				} else {
					tmp7 = false
				}
				return tmp7
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doall
	{
		tmp0 := lang.NewSymbol("doall").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3131), lang.NewKeyword("end-line"), int(3131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("dorun"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3})
				_ = tmp7
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("dorun"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				_ = tmp8
				return v4
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dorun
	{
		tmp0 := lang.NewSymbol("dorun").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3116), lang.NewKeyword("end-line"), int(3116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_579:
				var tmp4 any
				{ // let
					// let binding "temp__0__auto__"
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.Apply(tmp7, []any{v3})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						var tmp11 any
						{ // let
							// let binding "s"
							var v12 any = v9
							_ = v12
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("next"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.Apply(tmp16, []any{v12})
							var tmp13 any = tmp17
							v3 = tmp13
							goto recur_loop_579
						} // end let
						tmp10 = tmp11
					} else {
					}
					tmp4 = tmp10
				} // end let
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
			recur_loop_580:
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v4})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v3})
						tmp12 = tmp16
					} else {
						tmp12 = v11
					}
					tmp6 = tmp12
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("dec"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v3})
					var tmp7 any = tmp11
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v4})
					var tmp12 any = tmp16
					v3 = tmp7
					v4 = tmp12
					goto recur_loop_580
				} else {
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doseq
	{
		tmp0 := lang.NewSymbol("doseq").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("seq-exprs"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3209), lang.NewKeyword("end-line"), int(3209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "step"
					var tmp56 lang.FnFunc
					{ // function step
						var v57 lang.FnFunc
						tmp56 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v58 := args[0]
							_ = v58
							v59 := args[1]
							_ = v59
							var tmp60 any
							tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp62 := tmp61.FindInternedVar(lang.NewSymbol("not"))
							if tmp62.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
							}
							tmp63 := tmp62.Get()
							tmp64 := lang.Apply(tmp63, []any{v59})
							if lang.IsTruthy(tmp64) {
								tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp66 := tmp65.FindInternedVar(lang.NewSymbol("seq"))
								if tmp66.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
								}
								tmp67 := tmp66.Get()
								tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp69 := tmp68.FindInternedVar(lang.NewSymbol("concat"))
								if tmp69.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
								}
								tmp70 := tmp69.Get()
								tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
								if tmp72.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
								}
								tmp73 := tmp72.Get()
								tmp74 := lang.Apply(tmp73, []any{lang.NewSymbol("do")})
								tmp75 := lang.Apply(tmp70, []any{tmp74, v6})
								tmp76 := lang.Apply(tmp67, []any{tmp75})
								tmp77 := lang.NewVector(true, tmp76)
								tmp78 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3220), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3220), lang.NewKeyword("end-column"), int(36))
								tmp79, err := lang.WithMeta(tmp77, tmp78.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp60 = tmp79
							} else {
								var tmp80 any
								{ // let
									// let binding "k"
									tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp82 := tmp81.FindInternedVar(lang.NewSymbol("first"))
									if tmp82.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
									}
									tmp83 := tmp82.Get()
									tmp84 := lang.Apply(tmp83, []any{v59})
									var v85 any = tmp84
									_ = v85
									// let binding "v"
									tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp87 := tmp86.FindInternedVar(lang.NewSymbol("second"))
									if tmp87.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
									}
									tmp88 := tmp87.Get()
									tmp89 := lang.Apply(tmp88, []any{v59})
									var v90 any = tmp89
									_ = v90
									var tmp91 any
									tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp93 := tmp92.FindInternedVar(lang.NewSymbol("keyword?"))
									if tmp93.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
									}
									tmp94 := tmp93.Get()
									tmp95 := lang.Apply(tmp94, []any{v85})
									if lang.IsTruthy(tmp95) {
										var tmp96 any
										{ // let
											// let binding "steppair"
											tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp98 := tmp97.FindInternedVar(lang.NewSymbol("nnext"))
											if tmp98.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
											}
											tmp99 := tmp98.Get()
											tmp100 := lang.Apply(tmp99, []any{v59})
											tmp101 := lang.Apply(v57, []any{v58, tmp100})
											var v102 any = tmp101
											_ = v102
											// let binding "needrec"
											tmp103 := lang.Apply(v102, []any{int64(0)})
											var v104 any = tmp103
											_ = v104
											// let binding "subform"
											tmp105 := lang.Apply(v102, []any{int64(1)})
											var v106 any = tmp105
											_ = v106
											var tmp107 any
											tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp109 := tmp108.FindInternedVar(lang.NewSymbol("="))
											if tmp109.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
											}
											tmp110 := tmp109.Get()
											tmp111 := lang.Apply(tmp110, []any{v85, lang.NewKeyword("let")})
											if lang.IsTruthy(tmp111) {
												tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp113 := tmp112.FindInternedVar(lang.NewSymbol("seq"))
												if tmp113.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
												}
												tmp114 := tmp113.Get()
												tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp116 := tmp115.FindInternedVar(lang.NewSymbol("concat"))
												if tmp116.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
												}
												tmp117 := tmp116.Get()
												tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp119 := tmp118.FindInternedVar(lang.NewSymbol("list"))
												if tmp119.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
												}
												tmp120 := tmp119.Get()
												tmp121 := lang.Apply(tmp120, []any{lang.NewSymbol("glojure.core/let")})
												tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
												if tmp123.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
												}
												tmp124 := tmp123.Get()
												tmp125 := lang.Apply(tmp124, []any{v90})
												tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
												if tmp127.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
												}
												tmp128 := tmp127.Get()
												tmp129 := lang.Apply(tmp128, []any{v106})
												tmp130 := lang.Apply(tmp117, []any{tmp121, tmp125, tmp129})
												tmp131 := lang.Apply(tmp114, []any{tmp130})
												tmp132 := lang.NewVector(v104, tmp131)
												tmp133 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3228), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(3228), lang.NewKeyword("end-column"), int(64))
												tmp134, err := lang.WithMeta(tmp132, tmp133.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp107 = tmp134
											} else {
												var tmp135 any
												tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp137 := tmp136.FindInternedVar(lang.NewSymbol("="))
												if tmp137.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
												}
												tmp138 := tmp137.Get()
												tmp139 := lang.Apply(tmp138, []any{v85, lang.NewKeyword("while")})
												if lang.IsTruthy(tmp139) {
													tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp141 := tmp140.FindInternedVar(lang.NewSymbol("seq"))
													if tmp141.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
													}
													tmp142 := tmp141.Get()
													tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp144 := tmp143.FindInternedVar(lang.NewSymbol("concat"))
													if tmp144.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
													}
													tmp145 := tmp144.Get()
													tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
													if tmp147.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
													}
													tmp148 := tmp147.Get()
													tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("glojure.core/when")})
													tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp151 := tmp150.FindInternedVar(lang.NewSymbol("list"))
													if tmp151.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
													}
													tmp152 := tmp151.Get()
													tmp153 := lang.Apply(tmp152, []any{v90})
													tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp155 := tmp154.FindInternedVar(lang.NewSymbol("list"))
													if tmp155.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
													}
													tmp156 := tmp155.Get()
													tmp157 := lang.Apply(tmp156, []any{v106})
													var tmp158 any
													if lang.IsTruthy(v104) {
														tmp159 := lang.NewVector(v58)
														tmp160 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3231), lang.NewKeyword("column"), int(65), lang.NewKeyword("end-line"), int(3231), lang.NewKeyword("end-column"), int(73))
														tmp161, err := lang.WithMeta(tmp159, tmp160.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp158 = tmp161
													} else {
													}
													tmp162 := lang.Apply(tmp145, []any{tmp149, tmp153, tmp157, tmp158})
													tmp163 := lang.Apply(tmp142, []any{tmp162})
													tmp164 := lang.NewVector(false, tmp163)
													tmp165 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3229), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(3231), lang.NewKeyword("end-column"), int(76))
													tmp166, err := lang.WithMeta(tmp164, tmp165.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp135 = tmp166
												} else {
													var tmp167 any
													tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp169 := tmp168.FindInternedVar(lang.NewSymbol("="))
													if tmp169.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
													}
													tmp170 := tmp169.Get()
													tmp171 := lang.Apply(tmp170, []any{v85, lang.NewKeyword("when")})
													if lang.IsTruthy(tmp171) {
														tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp173 := tmp172.FindInternedVar(lang.NewSymbol("seq"))
														if tmp173.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
														}
														tmp174 := tmp173.Get()
														tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp176 := tmp175.FindInternedVar(lang.NewSymbol("concat"))
														if tmp176.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
														}
														tmp177 := tmp176.Get()
														tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list"))
														if tmp179.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
														}
														tmp180 := tmp179.Get()
														tmp181 := lang.Apply(tmp180, []any{lang.NewSymbol("if")})
														tmp182 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp183 := tmp182.FindInternedVar(lang.NewSymbol("list"))
														if tmp183.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp183)))
														}
														tmp184 := tmp183.Get()
														tmp185 := lang.Apply(tmp184, []any{v90})
														tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp187 := tmp186.FindInternedVar(lang.NewSymbol("list"))
														if tmp187.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
														}
														tmp188 := tmp187.Get()
														tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp190 := tmp189.FindInternedVar(lang.NewSymbol("seq"))
														if tmp190.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
														}
														tmp191 := tmp190.Get()
														tmp192 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp193 := tmp192.FindInternedVar(lang.NewSymbol("concat"))
														if tmp193.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp193)))
														}
														tmp194 := tmp193.Get()
														tmp195 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp196 := tmp195.FindInternedVar(lang.NewSymbol("list"))
														if tmp196.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp196)))
														}
														tmp197 := tmp196.Get()
														tmp198 := lang.Apply(tmp197, []any{lang.NewSymbol("do")})
														tmp199 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp200 := tmp199.FindInternedVar(lang.NewSymbol("list"))
														if tmp200.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp200)))
														}
														tmp201 := tmp200.Get()
														tmp202 := lang.Apply(tmp201, []any{v106})
														var tmp203 any
														if lang.IsTruthy(v104) {
															tmp204 := lang.NewVector(v58)
															tmp205 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3235), lang.NewKeyword("column"), int(66), lang.NewKeyword("end-line"), int(3235), lang.NewKeyword("end-column"), int(74))
															tmp206, err := lang.WithMeta(tmp204, tmp205.(lang.IPersistentMap))
															if err != nil {
																panic(err)
															}
															tmp203 = tmp206
														} else {
														}
														tmp207 := lang.Apply(tmp194, []any{tmp198, tmp202, tmp203})
														tmp208 := lang.Apply(tmp191, []any{tmp207})
														tmp209 := lang.Apply(tmp188, []any{tmp208})
														tmp210 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp211 := tmp210.FindInternedVar(lang.NewSymbol("list"))
														if tmp211.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp211)))
														}
														tmp212 := tmp211.Get()
														tmp213 := lang.Apply(tmp212, []any{v58})
														tmp214 := lang.Apply(tmp177, []any{tmp181, tmp185, tmp209, tmp213})
														tmp215 := lang.Apply(tmp174, []any{tmp214})
														tmp216 := lang.NewVector(false, tmp215)
														tmp217 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3232), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(3236), lang.NewKeyword("end-column"), int(57))
														tmp218, err := lang.WithMeta(tmp216, tmp217.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp167 = tmp218
													} else {
													}
													tmp135 = tmp167
												}
												tmp107 = tmp135
											}
											tmp96 = tmp107
										} // end let
										tmp91 = tmp96
									} else {
										var tmp97 any
										{ // let
											// let binding "seq-"
											tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp99 := tmp98.FindInternedVar(lang.NewSymbol("gensym"))
											if tmp99.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
											}
											tmp100 := tmp99.Get()
											tmp101 := lang.Apply(tmp100, []any{"seq_"})
											var v102 any = tmp101
											_ = v102
											// let binding "chunk-"
											tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp104 := tmp103.FindInternedVar(lang.NewSymbol("with-meta"))
											if tmp104.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
											}
											tmp105 := tmp104.Get()
											tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp107 := tmp106.FindInternedVar(lang.NewSymbol("gensym"))
											if tmp107.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
											}
											tmp108 := tmp107.Get()
											tmp109 := lang.Apply(tmp108, []any{"chunk_"})
											tmp110 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("glojure.lang.IChunk"))
											tmp111 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3239), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(3239), lang.NewKeyword("end-column"), int(72))
											tmp112, err := lang.WithMeta(tmp110, tmp111.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp113 := lang.Apply(tmp105, []any{tmp109, tmp112})
											var v114 any = tmp113
											_ = v114
											// let binding "count-"
											tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp116 := tmp115.FindInternedVar(lang.NewSymbol("gensym"))
											if tmp116.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
											}
											tmp117 := tmp116.Get()
											tmp118 := lang.Apply(tmp117, []any{"count_"})
											var v119 any = tmp118
											_ = v119
											// let binding "i-"
											tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp121 := tmp120.FindInternedVar(lang.NewSymbol("gensym"))
											if tmp121.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
											}
											tmp122 := tmp121.Get()
											tmp123 := lang.Apply(tmp122, []any{"i_"})
											var v124 any = tmp123
											_ = v124
											// let binding "recform"
											tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp126 := tmp125.FindInternedVar(lang.NewSymbol("seq"))
											if tmp126.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
											}
											tmp127 := tmp126.Get()
											tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp129 := tmp128.FindInternedVar(lang.NewSymbol("concat"))
											if tmp129.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
											}
											tmp130 := tmp129.Get()
											tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
											if tmp132.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
											}
											tmp133 := tmp132.Get()
											tmp134 := lang.Apply(tmp133, []any{lang.NewSymbol("recur")})
											tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp136 := tmp135.FindInternedVar(lang.NewSymbol("list"))
											if tmp136.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
											}
											tmp137 := tmp136.Get()
											tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp139 := tmp138.FindInternedVar(lang.NewSymbol("seq"))
											if tmp139.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
											}
											tmp140 := tmp139.Get()
											tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp142 := tmp141.FindInternedVar(lang.NewSymbol("concat"))
											if tmp142.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
											}
											tmp143 := tmp142.Get()
											tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp145 := tmp144.FindInternedVar(lang.NewSymbol("list"))
											if tmp145.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
											}
											tmp146 := tmp145.Get()
											tmp147 := lang.Apply(tmp146, []any{lang.NewSymbol("glojure.core/next")})
											tmp148 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp149 := tmp148.FindInternedVar(lang.NewSymbol("list"))
											if tmp149.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp149)))
											}
											tmp150 := tmp149.Get()
											tmp151 := lang.Apply(tmp150, []any{v102})
											tmp152 := lang.Apply(tmp143, []any{tmp147, tmp151})
											tmp153 := lang.Apply(tmp140, []any{tmp152})
											tmp154 := lang.Apply(tmp137, []any{tmp153})
											tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp156 := tmp155.FindInternedVar(lang.NewSymbol("list"))
											if tmp156.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
											}
											tmp157 := tmp156.Get()
											tmp158 := lang.Apply(tmp157, []any{nil})
											tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp160 := tmp159.FindInternedVar(lang.NewSymbol("list"))
											if tmp160.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
											}
											tmp161 := tmp160.Get()
											tmp162 := lang.Apply(tmp161, []any{int64(0)})
											tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp164 := tmp163.FindInternedVar(lang.NewSymbol("list"))
											if tmp164.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
											}
											tmp165 := tmp164.Get()
											tmp166 := lang.Apply(tmp165, []any{int64(0)})
											tmp167 := lang.Apply(tmp130, []any{tmp134, tmp154, tmp158, tmp162, tmp166})
											tmp168 := lang.Apply(tmp127, []any{tmp167})
											var v169 any = tmp168
											_ = v169
											// let binding "steppair"
											tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp171 := tmp170.FindInternedVar(lang.NewSymbol("nnext"))
											if tmp171.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
											}
											tmp172 := tmp171.Get()
											tmp173 := lang.Apply(tmp172, []any{v59})
											tmp174 := lang.Apply(v57, []any{v169, tmp173})
											var v175 any = tmp174
											_ = v175
											// let binding "needrec"
											tmp176 := lang.Apply(v175, []any{int64(0)})
											var v177 any = tmp176
											_ = v177
											// let binding "subform"
											tmp178 := lang.Apply(v175, []any{int64(1)})
											var v179 any = tmp178
											_ = v179
											// let binding "recform-chunk"
											tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp181 := tmp180.FindInternedVar(lang.NewSymbol("seq"))
											if tmp181.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
											}
											tmp182 := tmp181.Get()
											tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp184 := tmp183.FindInternedVar(lang.NewSymbol("concat"))
											if tmp184.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
											}
											tmp185 := tmp184.Get()
											tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp187 := tmp186.FindInternedVar(lang.NewSymbol("list"))
											if tmp187.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
											}
											tmp188 := tmp187.Get()
											tmp189 := lang.Apply(tmp188, []any{lang.NewSymbol("recur")})
											tmp190 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp191 := tmp190.FindInternedVar(lang.NewSymbol("list"))
											if tmp191.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp191)))
											}
											tmp192 := tmp191.Get()
											tmp193 := lang.Apply(tmp192, []any{v102})
											tmp194 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp195 := tmp194.FindInternedVar(lang.NewSymbol("list"))
											if tmp195.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp195)))
											}
											tmp196 := tmp195.Get()
											tmp197 := lang.Apply(tmp196, []any{v114})
											tmp198 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp199 := tmp198.FindInternedVar(lang.NewSymbol("list"))
											if tmp199.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp199)))
											}
											tmp200 := tmp199.Get()
											tmp201 := lang.Apply(tmp200, []any{v119})
											tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp203 := tmp202.FindInternedVar(lang.NewSymbol("list"))
											if tmp203.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
											}
											tmp204 := tmp203.Get()
											tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp206 := tmp205.FindInternedVar(lang.NewSymbol("seq"))
											if tmp206.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
											}
											tmp207 := tmp206.Get()
											tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp209 := tmp208.FindInternedVar(lang.NewSymbol("concat"))
											if tmp209.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
											}
											tmp210 := tmp209.Get()
											tmp211 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp212 := tmp211.FindInternedVar(lang.NewSymbol("list"))
											if tmp212.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp212)))
											}
											tmp213 := tmp212.Get()
											tmp214 := lang.Apply(tmp213, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
											tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp216 := tmp215.FindInternedVar(lang.NewSymbol("list"))
											if tmp216.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
											}
											tmp217 := tmp216.Get()
											tmp218 := lang.Apply(tmp217, []any{v124})
											tmp219 := lang.Apply(tmp210, []any{tmp214, tmp218})
											tmp220 := lang.Apply(tmp207, []any{tmp219})
											tmp221 := lang.Apply(tmp204, []any{tmp220})
											tmp222 := lang.Apply(tmp185, []any{tmp189, tmp193, tmp197, tmp201, tmp221})
											tmp223 := lang.Apply(tmp182, []any{tmp222})
											var v224 any = tmp223
											_ = v224
											// let binding "steppair-chunk"
											tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp226 := tmp225.FindInternedVar(lang.NewSymbol("nnext"))
											if tmp226.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
											}
											tmp227 := tmp226.Get()
											tmp228 := lang.Apply(tmp227, []any{v59})
											tmp229 := lang.Apply(v57, []any{v224, tmp228})
											var v230 any = tmp229
											_ = v230
											// let binding "subform-chunk"
											tmp231 := lang.Apply(v230, []any{int64(1)})
											var v232 any = tmp231
											_ = v232
											tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp234 := tmp233.FindInternedVar(lang.NewSymbol("seq"))
											if tmp234.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
											}
											tmp235 := tmp234.Get()
											tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp237 := tmp236.FindInternedVar(lang.NewSymbol("concat"))
											if tmp237.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
											}
											tmp238 := tmp237.Get()
											tmp239 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp240 := tmp239.FindInternedVar(lang.NewSymbol("list"))
											if tmp240.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp240)))
											}
											tmp241 := tmp240.Get()
											tmp242 := lang.Apply(tmp241, []any{lang.NewSymbol("glojure.core/loop")})
											tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp244 := tmp243.FindInternedVar(lang.NewSymbol("list"))
											if tmp244.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
											}
											tmp245 := tmp244.Get()
											tmp246 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp247 := tmp246.FindInternedVar(lang.NewSymbol("apply"))
											if tmp247.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp247)))
											}
											tmp248 := tmp247.Get()
											tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp250 := tmp249.FindInternedVar(lang.NewSymbol("vector"))
											if tmp250.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
											}
											tmp251 := tmp250.Get()
											tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp253 := tmp252.FindInternedVar(lang.NewSymbol("seq"))
											if tmp253.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
											}
											tmp254 := tmp253.Get()
											tmp255 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp256 := tmp255.FindInternedVar(lang.NewSymbol("concat"))
											if tmp256.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp256)))
											}
											tmp257 := tmp256.Get()
											tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp259 := tmp258.FindInternedVar(lang.NewSymbol("list"))
											if tmp259.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
											}
											tmp260 := tmp259.Get()
											tmp261 := lang.Apply(tmp260, []any{v102})
											tmp262 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp263 := tmp262.FindInternedVar(lang.NewSymbol("list"))
											if tmp263.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp263)))
											}
											tmp264 := tmp263.Get()
											tmp265 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp266 := tmp265.FindInternedVar(lang.NewSymbol("seq"))
											if tmp266.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp266)))
											}
											tmp267 := tmp266.Get()
											tmp268 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp269 := tmp268.FindInternedVar(lang.NewSymbol("concat"))
											if tmp269.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp269)))
											}
											tmp270 := tmp269.Get()
											tmp271 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp272 := tmp271.FindInternedVar(lang.NewSymbol("list"))
											if tmp272.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp272)))
											}
											tmp273 := tmp272.Get()
											tmp274 := lang.Apply(tmp273, []any{lang.NewSymbol("glojure.core/seq")})
											tmp275 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp276 := tmp275.FindInternedVar(lang.NewSymbol("list"))
											if tmp276.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp276)))
											}
											tmp277 := tmp276.Get()
											tmp278 := lang.Apply(tmp277, []any{v90})
											tmp279 := lang.Apply(tmp270, []any{tmp274, tmp278})
											tmp280 := lang.Apply(tmp267, []any{tmp279})
											tmp281 := lang.Apply(tmp264, []any{tmp280})
											tmp282 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp283 := tmp282.FindInternedVar(lang.NewSymbol("list"))
											if tmp283.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp283)))
											}
											tmp284 := tmp283.Get()
											tmp285 := lang.Apply(tmp284, []any{v114})
											tmp286 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp287 := tmp286.FindInternedVar(lang.NewSymbol("list"))
											if tmp287.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp287)))
											}
											tmp288 := tmp287.Get()
											tmp289 := lang.Apply(tmp288, []any{nil})
											tmp290 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp291 := tmp290.FindInternedVar(lang.NewSymbol("list"))
											if tmp291.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp291)))
											}
											tmp292 := tmp291.Get()
											tmp293 := lang.Apply(tmp292, []any{v119})
											tmp294 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp295 := tmp294.FindInternedVar(lang.NewSymbol("list"))
											if tmp295.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp295)))
											}
											tmp296 := tmp295.Get()
											tmp297 := lang.Apply(tmp296, []any{int64(0)})
											tmp298 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp299 := tmp298.FindInternedVar(lang.NewSymbol("list"))
											if tmp299.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp299)))
											}
											tmp300 := tmp299.Get()
											tmp301 := lang.Apply(tmp300, []any{v124})
											tmp302 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp303 := tmp302.FindInternedVar(lang.NewSymbol("list"))
											if tmp303.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp303)))
											}
											tmp304 := tmp303.Get()
											tmp305 := lang.Apply(tmp304, []any{int64(0)})
											tmp306 := lang.Apply(tmp257, []any{tmp261, tmp281, tmp285, tmp289, tmp293, tmp297, tmp301, tmp305})
											tmp307 := lang.Apply(tmp254, []any{tmp306})
											tmp308 := lang.Apply(tmp248, []any{tmp251, tmp307})
											tmp309 := lang.Apply(tmp245, []any{tmp308})
											tmp310 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp311 := tmp310.FindInternedVar(lang.NewSymbol("list"))
											if tmp311.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp311)))
											}
											tmp312 := tmp311.Get()
											tmp313 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp314 := tmp313.FindInternedVar(lang.NewSymbol("seq"))
											if tmp314.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp314)))
											}
											tmp315 := tmp314.Get()
											tmp316 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp317 := tmp316.FindInternedVar(lang.NewSymbol("concat"))
											if tmp317.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp317)))
											}
											tmp318 := tmp317.Get()
											tmp319 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp320 := tmp319.FindInternedVar(lang.NewSymbol("list"))
											if tmp320.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp320)))
											}
											tmp321 := tmp320.Get()
											tmp322 := lang.Apply(tmp321, []any{lang.NewSymbol("if")})
											tmp323 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp324 := tmp323.FindInternedVar(lang.NewSymbol("list"))
											if tmp324.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp324)))
											}
											tmp325 := tmp324.Get()
											tmp326 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp327 := tmp326.FindInternedVar(lang.NewSymbol("seq"))
											if tmp327.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp327)))
											}
											tmp328 := tmp327.Get()
											tmp329 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp330 := tmp329.FindInternedVar(lang.NewSymbol("concat"))
											if tmp330.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp330)))
											}
											tmp331 := tmp330.Get()
											tmp332 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp333 := tmp332.FindInternedVar(lang.NewSymbol("list"))
											if tmp333.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp333)))
											}
											tmp334 := tmp333.Get()
											tmp335 := lang.Apply(tmp334, []any{lang.NewSymbol("glojure.core/<")})
											tmp336 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp337 := tmp336.FindInternedVar(lang.NewSymbol("list"))
											if tmp337.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp337)))
											}
											tmp338 := tmp337.Get()
											tmp339 := lang.Apply(tmp338, []any{v124})
											tmp340 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp341 := tmp340.FindInternedVar(lang.NewSymbol("list"))
											if tmp341.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp341)))
											}
											tmp342 := tmp341.Get()
											tmp343 := lang.Apply(tmp342, []any{v119})
											tmp344 := lang.Apply(tmp331, []any{tmp335, tmp339, tmp343})
											tmp345 := lang.Apply(tmp328, []any{tmp344})
											tmp346 := lang.Apply(tmp325, []any{tmp345})
											tmp347 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp348 := tmp347.FindInternedVar(lang.NewSymbol("list"))
											if tmp348.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp348)))
											}
											tmp349 := tmp348.Get()
											tmp350 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp351 := tmp350.FindInternedVar(lang.NewSymbol("seq"))
											if tmp351.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp351)))
											}
											tmp352 := tmp351.Get()
											tmp353 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp354 := tmp353.FindInternedVar(lang.NewSymbol("concat"))
											if tmp354.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp354)))
											}
											tmp355 := tmp354.Get()
											tmp356 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp357 := tmp356.FindInternedVar(lang.NewSymbol("list"))
											if tmp357.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp357)))
											}
											tmp358 := tmp357.Get()
											tmp359 := lang.Apply(tmp358, []any{lang.NewSymbol("glojure.core/let")})
											tmp360 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp361 := tmp360.FindInternedVar(lang.NewSymbol("list"))
											if tmp361.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp361)))
											}
											tmp362 := tmp361.Get()
											tmp363 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp364 := tmp363.FindInternedVar(lang.NewSymbol("apply"))
											if tmp364.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp364)))
											}
											tmp365 := tmp364.Get()
											tmp366 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp367 := tmp366.FindInternedVar(lang.NewSymbol("vector"))
											if tmp367.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp367)))
											}
											tmp368 := tmp367.Get()
											tmp369 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp370 := tmp369.FindInternedVar(lang.NewSymbol("seq"))
											if tmp370.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp370)))
											}
											tmp371 := tmp370.Get()
											tmp372 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp373 := tmp372.FindInternedVar(lang.NewSymbol("concat"))
											if tmp373.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp373)))
											}
											tmp374 := tmp373.Get()
											tmp375 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp376 := tmp375.FindInternedVar(lang.NewSymbol("list"))
											if tmp376.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp376)))
											}
											tmp377 := tmp376.Get()
											tmp378 := lang.Apply(tmp377, []any{v85})
											tmp379 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp380 := tmp379.FindInternedVar(lang.NewSymbol("list"))
											if tmp380.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp380)))
											}
											tmp381 := tmp380.Get()
											tmp382 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp383 := tmp382.FindInternedVar(lang.NewSymbol("seq"))
											if tmp383.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp383)))
											}
											tmp384 := tmp383.Get()
											tmp385 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp386 := tmp385.FindInternedVar(lang.NewSymbol("concat"))
											if tmp386.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp386)))
											}
											tmp387 := tmp386.Get()
											tmp388 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp389 := tmp388.FindInternedVar(lang.NewSymbol("list"))
											if tmp389.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp389)))
											}
											tmp390 := tmp389.Get()
											tmp391 := lang.Apply(tmp390, []any{lang.NewSymbol(".nth")})
											tmp392 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp393 := tmp392.FindInternedVar(lang.NewSymbol("list"))
											if tmp393.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp393)))
											}
											tmp394 := tmp393.Get()
											tmp395 := lang.Apply(tmp394, []any{v114})
											tmp396 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp397 := tmp396.FindInternedVar(lang.NewSymbol("list"))
											if tmp397.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp397)))
											}
											tmp398 := tmp397.Get()
											tmp399 := lang.Apply(tmp398, []any{v124})
											tmp400 := lang.Apply(tmp387, []any{tmp391, tmp395, tmp399})
											tmp401 := lang.Apply(tmp384, []any{tmp400})
											tmp402 := lang.Apply(tmp381, []any{tmp401})
											tmp403 := lang.Apply(tmp374, []any{tmp378, tmp402})
											tmp404 := lang.Apply(tmp371, []any{tmp403})
											tmp405 := lang.Apply(tmp365, []any{tmp368, tmp404})
											tmp406 := lang.Apply(tmp362, []any{tmp405})
											tmp407 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp408 := tmp407.FindInternedVar(lang.NewSymbol("list"))
											if tmp408.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp408)))
											}
											tmp409 := tmp408.Get()
											tmp410 := lang.Apply(tmp409, []any{v232})
											var tmp411 any
											if lang.IsTruthy(v177) {
												tmp412 := lang.NewVector(v224)
												tmp413 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3256), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(3256), lang.NewKeyword("end-column"), int(62))
												tmp414, err := lang.WithMeta(tmp412, tmp413.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp411 = tmp414
											} else {
											}
											tmp415 := lang.Apply(tmp355, []any{tmp359, tmp406, tmp410, tmp411})
											tmp416 := lang.Apply(tmp352, []any{tmp415})
											tmp417 := lang.Apply(tmp349, []any{tmp416})
											tmp418 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp419 := tmp418.FindInternedVar(lang.NewSymbol("list"))
											if tmp419.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp419)))
											}
											tmp420 := tmp419.Get()
											tmp421 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp422 := tmp421.FindInternedVar(lang.NewSymbol("seq"))
											if tmp422.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp422)))
											}
											tmp423 := tmp422.Get()
											tmp424 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp425 := tmp424.FindInternedVar(lang.NewSymbol("concat"))
											if tmp425.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp425)))
											}
											tmp426 := tmp425.Get()
											tmp427 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp428 := tmp427.FindInternedVar(lang.NewSymbol("list"))
											if tmp428.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp428)))
											}
											tmp429 := tmp428.Get()
											tmp430 := lang.Apply(tmp429, []any{lang.NewSymbol("glojure.core/when-let")})
											tmp431 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp432 := tmp431.FindInternedVar(lang.NewSymbol("list"))
											if tmp432.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp432)))
											}
											tmp433 := tmp432.Get()
											tmp434 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp435 := tmp434.FindInternedVar(lang.NewSymbol("apply"))
											if tmp435.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp435)))
											}
											tmp436 := tmp435.Get()
											tmp437 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp438 := tmp437.FindInternedVar(lang.NewSymbol("vector"))
											if tmp438.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp438)))
											}
											tmp439 := tmp438.Get()
											tmp440 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp441 := tmp440.FindInternedVar(lang.NewSymbol("seq"))
											if tmp441.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp441)))
											}
											tmp442 := tmp441.Get()
											tmp443 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp444 := tmp443.FindInternedVar(lang.NewSymbol("concat"))
											if tmp444.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp444)))
											}
											tmp445 := tmp444.Get()
											tmp446 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp447 := tmp446.FindInternedVar(lang.NewSymbol("list"))
											if tmp447.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp447)))
											}
											tmp448 := tmp447.Get()
											tmp449 := lang.Apply(tmp448, []any{v102})
											tmp450 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp451 := tmp450.FindInternedVar(lang.NewSymbol("list"))
											if tmp451.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp451)))
											}
											tmp452 := tmp451.Get()
											tmp453 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp454 := tmp453.FindInternedVar(lang.NewSymbol("seq"))
											if tmp454.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp454)))
											}
											tmp455 := tmp454.Get()
											tmp456 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp457 := tmp456.FindInternedVar(lang.NewSymbol("concat"))
											if tmp457.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp457)))
											}
											tmp458 := tmp457.Get()
											tmp459 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp460 := tmp459.FindInternedVar(lang.NewSymbol("list"))
											if tmp460.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp460)))
											}
											tmp461 := tmp460.Get()
											tmp462 := lang.Apply(tmp461, []any{lang.NewSymbol("glojure.core/seq")})
											tmp463 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp464 := tmp463.FindInternedVar(lang.NewSymbol("list"))
											if tmp464.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp464)))
											}
											tmp465 := tmp464.Get()
											tmp466 := lang.Apply(tmp465, []any{v102})
											tmp467 := lang.Apply(tmp458, []any{tmp462, tmp466})
											tmp468 := lang.Apply(tmp455, []any{tmp467})
											tmp469 := lang.Apply(tmp452, []any{tmp468})
											tmp470 := lang.Apply(tmp445, []any{tmp449, tmp469})
											tmp471 := lang.Apply(tmp442, []any{tmp470})
											tmp472 := lang.Apply(tmp436, []any{tmp439, tmp471})
											tmp473 := lang.Apply(tmp433, []any{tmp472})
											tmp474 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp475 := tmp474.FindInternedVar(lang.NewSymbol("list"))
											if tmp475.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp475)))
											}
											tmp476 := tmp475.Get()
											tmp477 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp478 := tmp477.FindInternedVar(lang.NewSymbol("seq"))
											if tmp478.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp478)))
											}
											tmp479 := tmp478.Get()
											tmp480 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp481 := tmp480.FindInternedVar(lang.NewSymbol("concat"))
											if tmp481.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp481)))
											}
											tmp482 := tmp481.Get()
											tmp483 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp484 := tmp483.FindInternedVar(lang.NewSymbol("list"))
											if tmp484.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp484)))
											}
											tmp485 := tmp484.Get()
											tmp486 := lang.Apply(tmp485, []any{lang.NewSymbol("if")})
											tmp487 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp488 := tmp487.FindInternedVar(lang.NewSymbol("list"))
											if tmp488.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp488)))
											}
											tmp489 := tmp488.Get()
											tmp490 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp491 := tmp490.FindInternedVar(lang.NewSymbol("seq"))
											if tmp491.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp491)))
											}
											tmp492 := tmp491.Get()
											tmp493 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp494 := tmp493.FindInternedVar(lang.NewSymbol("concat"))
											if tmp494.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp494)))
											}
											tmp495 := tmp494.Get()
											tmp496 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp497 := tmp496.FindInternedVar(lang.NewSymbol("list"))
											if tmp497.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp497)))
											}
											tmp498 := tmp497.Get()
											tmp499 := lang.Apply(tmp498, []any{lang.NewSymbol("glojure.core/chunked-seq?")})
											tmp500 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp501 := tmp500.FindInternedVar(lang.NewSymbol("list"))
											if tmp501.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp501)))
											}
											tmp502 := tmp501.Get()
											tmp503 := lang.Apply(tmp502, []any{v102})
											tmp504 := lang.Apply(tmp495, []any{tmp499, tmp503})
											tmp505 := lang.Apply(tmp492, []any{tmp504})
											tmp506 := lang.Apply(tmp489, []any{tmp505})
											tmp507 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp508 := tmp507.FindInternedVar(lang.NewSymbol("list"))
											if tmp508.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp508)))
											}
											tmp509 := tmp508.Get()
											tmp510 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp511 := tmp510.FindInternedVar(lang.NewSymbol("seq"))
											if tmp511.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp511)))
											}
											tmp512 := tmp511.Get()
											tmp513 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp514 := tmp513.FindInternedVar(lang.NewSymbol("concat"))
											if tmp514.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp514)))
											}
											tmp515 := tmp514.Get()
											tmp516 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp517 := tmp516.FindInternedVar(lang.NewSymbol("list"))
											if tmp517.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp517)))
											}
											tmp518 := tmp517.Get()
											tmp519 := lang.Apply(tmp518, []any{lang.NewSymbol("glojure.core/let")})
											tmp520 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp521 := tmp520.FindInternedVar(lang.NewSymbol("list"))
											if tmp521.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp521)))
											}
											tmp522 := tmp521.Get()
											tmp523 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp524 := tmp523.FindInternedVar(lang.NewSymbol("apply"))
											if tmp524.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp524)))
											}
											tmp525 := tmp524.Get()
											tmp526 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp527 := tmp526.FindInternedVar(lang.NewSymbol("vector"))
											if tmp527.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp527)))
											}
											tmp528 := tmp527.Get()
											tmp529 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp530 := tmp529.FindInternedVar(lang.NewSymbol("seq"))
											if tmp530.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp530)))
											}
											tmp531 := tmp530.Get()
											tmp532 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp533 := tmp532.FindInternedVar(lang.NewSymbol("concat"))
											if tmp533.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp533)))
											}
											tmp534 := tmp533.Get()
											tmp535 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp536 := tmp535.FindInternedVar(lang.NewSymbol("list"))
											if tmp536.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp536)))
											}
											tmp537 := tmp536.Get()
											tmp538 := lang.Apply(tmp537, []any{lang.NewSymbol("c__0__auto__")})
											tmp539 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp540 := tmp539.FindInternedVar(lang.NewSymbol("list"))
											if tmp540.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp540)))
											}
											tmp541 := tmp540.Get()
											tmp542 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp543 := tmp542.FindInternedVar(lang.NewSymbol("seq"))
											if tmp543.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp543)))
											}
											tmp544 := tmp543.Get()
											tmp545 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp546 := tmp545.FindInternedVar(lang.NewSymbol("concat"))
											if tmp546.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp546)))
											}
											tmp547 := tmp546.Get()
											tmp548 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp549 := tmp548.FindInternedVar(lang.NewSymbol("list"))
											if tmp549.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp549)))
											}
											tmp550 := tmp549.Get()
											tmp551 := lang.Apply(tmp550, []any{lang.NewSymbol("glojure.core/chunk-first")})
											tmp552 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp553 := tmp552.FindInternedVar(lang.NewSymbol("list"))
											if tmp553.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp553)))
											}
											tmp554 := tmp553.Get()
											tmp555 := lang.Apply(tmp554, []any{v102})
											tmp556 := lang.Apply(tmp547, []any{tmp551, tmp555})
											tmp557 := lang.Apply(tmp544, []any{tmp556})
											tmp558 := lang.Apply(tmp541, []any{tmp557})
											tmp559 := lang.Apply(tmp534, []any{tmp538, tmp558})
											tmp560 := lang.Apply(tmp531, []any{tmp559})
											tmp561 := lang.Apply(tmp525, []any{tmp528, tmp560})
											tmp562 := lang.Apply(tmp522, []any{tmp561})
											tmp563 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp564 := tmp563.FindInternedVar(lang.NewSymbol("list"))
											if tmp564.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp564)))
											}
											tmp565 := tmp564.Get()
											tmp566 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp567 := tmp566.FindInternedVar(lang.NewSymbol("seq"))
											if tmp567.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp567)))
											}
											tmp568 := tmp567.Get()
											tmp569 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp570 := tmp569.FindInternedVar(lang.NewSymbol("concat"))
											if tmp570.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp570)))
											}
											tmp571 := tmp570.Get()
											tmp572 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp573 := tmp572.FindInternedVar(lang.NewSymbol("list"))
											if tmp573.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp573)))
											}
											tmp574 := tmp573.Get()
											tmp575 := lang.Apply(tmp574, []any{lang.NewSymbol("recur")})
											tmp576 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp577 := tmp576.FindInternedVar(lang.NewSymbol("list"))
											if tmp577.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp577)))
											}
											tmp578 := tmp577.Get()
											tmp579 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp580 := tmp579.FindInternedVar(lang.NewSymbol("seq"))
											if tmp580.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp580)))
											}
											tmp581 := tmp580.Get()
											tmp582 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp583 := tmp582.FindInternedVar(lang.NewSymbol("concat"))
											if tmp583.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp583)))
											}
											tmp584 := tmp583.Get()
											tmp585 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp586 := tmp585.FindInternedVar(lang.NewSymbol("list"))
											if tmp586.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp586)))
											}
											tmp587 := tmp586.Get()
											tmp588 := lang.Apply(tmp587, []any{lang.NewSymbol("glojure.core/chunk-rest")})
											tmp589 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp590 := tmp589.FindInternedVar(lang.NewSymbol("list"))
											if tmp590.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp590)))
											}
											tmp591 := tmp590.Get()
											tmp592 := lang.Apply(tmp591, []any{v102})
											tmp593 := lang.Apply(tmp584, []any{tmp588, tmp592})
											tmp594 := lang.Apply(tmp581, []any{tmp593})
											tmp595 := lang.Apply(tmp578, []any{tmp594})
											tmp596 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp597 := tmp596.FindInternedVar(lang.NewSymbol("list"))
											if tmp597.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp597)))
											}
											tmp598 := tmp597.Get()
											tmp599 := lang.Apply(tmp598, []any{lang.NewSymbol("c__0__auto__")})
											tmp600 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp601 := tmp600.FindInternedVar(lang.NewSymbol("list"))
											if tmp601.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp601)))
											}
											tmp602 := tmp601.Get()
											tmp603 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp604 := tmp603.FindInternedVar(lang.NewSymbol("seq"))
											if tmp604.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp604)))
											}
											tmp605 := tmp604.Get()
											tmp606 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp607 := tmp606.FindInternedVar(lang.NewSymbol("concat"))
											if tmp607.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp607)))
											}
											tmp608 := tmp607.Get()
											tmp609 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp610 := tmp609.FindInternedVar(lang.NewSymbol("list"))
											if tmp610.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp610)))
											}
											tmp611 := tmp610.Get()
											tmp612 := lang.Apply(tmp611, []any{lang.NewSymbol("glojure.core/int")})
											tmp613 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp614 := tmp613.FindInternedVar(lang.NewSymbol("list"))
											if tmp614.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp614)))
											}
											tmp615 := tmp614.Get()
											tmp616 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp617 := tmp616.FindInternedVar(lang.NewSymbol("seq"))
											if tmp617.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp617)))
											}
											tmp618 := tmp617.Get()
											tmp619 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp620 := tmp619.FindInternedVar(lang.NewSymbol("concat"))
											if tmp620.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp620)))
											}
											tmp621 := tmp620.Get()
											tmp622 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp623 := tmp622.FindInternedVar(lang.NewSymbol("list"))
											if tmp623.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp623)))
											}
											tmp624 := tmp623.Get()
											tmp625 := lang.Apply(tmp624, []any{lang.NewSymbol("glojure.core/count")})
											tmp626 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp627 := tmp626.FindInternedVar(lang.NewSymbol("list"))
											if tmp627.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp627)))
											}
											tmp628 := tmp627.Get()
											tmp629 := lang.Apply(tmp628, []any{lang.NewSymbol("c__0__auto__")})
											tmp630 := lang.Apply(tmp621, []any{tmp625, tmp629})
											tmp631 := lang.Apply(tmp618, []any{tmp630})
											tmp632 := lang.Apply(tmp615, []any{tmp631})
											tmp633 := lang.Apply(tmp608, []any{tmp612, tmp632})
											tmp634 := lang.Apply(tmp605, []any{tmp633})
											tmp635 := lang.Apply(tmp602, []any{tmp634})
											tmp636 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp637 := tmp636.FindInternedVar(lang.NewSymbol("list"))
											if tmp637.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp637)))
											}
											tmp638 := tmp637.Get()
											tmp639 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp640 := tmp639.FindInternedVar(lang.NewSymbol("seq"))
											if tmp640.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp640)))
											}
											tmp641 := tmp640.Get()
											tmp642 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp643 := tmp642.FindInternedVar(lang.NewSymbol("concat"))
											if tmp643.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp643)))
											}
											tmp644 := tmp643.Get()
											tmp645 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp646 := tmp645.FindInternedVar(lang.NewSymbol("list"))
											if tmp646.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp646)))
											}
											tmp647 := tmp646.Get()
											tmp648 := lang.Apply(tmp647, []any{lang.NewSymbol("glojure.core/int")})
											tmp649 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp650 := tmp649.FindInternedVar(lang.NewSymbol("list"))
											if tmp650.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp650)))
											}
											tmp651 := tmp650.Get()
											tmp652 := lang.Apply(tmp651, []any{int64(0)})
											tmp653 := lang.Apply(tmp644, []any{tmp648, tmp652})
											tmp654 := lang.Apply(tmp641, []any{tmp653})
											tmp655 := lang.Apply(tmp638, []any{tmp654})
											tmp656 := lang.Apply(tmp571, []any{tmp575, tmp595, tmp599, tmp635, tmp655})
											tmp657 := lang.Apply(tmp568, []any{tmp656})
											tmp658 := lang.Apply(tmp565, []any{tmp657})
											tmp659 := lang.Apply(tmp515, []any{tmp519, tmp562, tmp658})
											tmp660 := lang.Apply(tmp512, []any{tmp659})
											tmp661 := lang.Apply(tmp509, []any{tmp660})
											tmp662 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp663 := tmp662.FindInternedVar(lang.NewSymbol("list"))
											if tmp663.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp663)))
											}
											tmp664 := tmp663.Get()
											tmp665 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp666 := tmp665.FindInternedVar(lang.NewSymbol("seq"))
											if tmp666.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp666)))
											}
											tmp667 := tmp666.Get()
											tmp668 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp669 := tmp668.FindInternedVar(lang.NewSymbol("concat"))
											if tmp669.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp669)))
											}
											tmp670 := tmp669.Get()
											tmp671 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp672 := tmp671.FindInternedVar(lang.NewSymbol("list"))
											if tmp672.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp672)))
											}
											tmp673 := tmp672.Get()
											tmp674 := lang.Apply(tmp673, []any{lang.NewSymbol("glojure.core/let")})
											tmp675 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp676 := tmp675.FindInternedVar(lang.NewSymbol("list"))
											if tmp676.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp676)))
											}
											tmp677 := tmp676.Get()
											tmp678 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp679 := tmp678.FindInternedVar(lang.NewSymbol("apply"))
											if tmp679.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp679)))
											}
											tmp680 := tmp679.Get()
											tmp681 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp682 := tmp681.FindInternedVar(lang.NewSymbol("vector"))
											if tmp682.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp682)))
											}
											tmp683 := tmp682.Get()
											tmp684 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp685 := tmp684.FindInternedVar(lang.NewSymbol("seq"))
											if tmp685.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp685)))
											}
											tmp686 := tmp685.Get()
											tmp687 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp688 := tmp687.FindInternedVar(lang.NewSymbol("concat"))
											if tmp688.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp688)))
											}
											tmp689 := tmp688.Get()
											tmp690 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp691 := tmp690.FindInternedVar(lang.NewSymbol("list"))
											if tmp691.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp691)))
											}
											tmp692 := tmp691.Get()
											tmp693 := lang.Apply(tmp692, []any{v85})
											tmp694 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp695 := tmp694.FindInternedVar(lang.NewSymbol("list"))
											if tmp695.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp695)))
											}
											tmp696 := tmp695.Get()
											tmp697 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp698 := tmp697.FindInternedVar(lang.NewSymbol("seq"))
											if tmp698.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp698)))
											}
											tmp699 := tmp698.Get()
											tmp700 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp701 := tmp700.FindInternedVar(lang.NewSymbol("concat"))
											if tmp701.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp701)))
											}
											tmp702 := tmp701.Get()
											tmp703 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp704 := tmp703.FindInternedVar(lang.NewSymbol("list"))
											if tmp704.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp704)))
											}
											tmp705 := tmp704.Get()
											tmp706 := lang.Apply(tmp705, []any{lang.NewSymbol("glojure.core/first")})
											tmp707 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp708 := tmp707.FindInternedVar(lang.NewSymbol("list"))
											if tmp708.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp708)))
											}
											tmp709 := tmp708.Get()
											tmp710 := lang.Apply(tmp709, []any{v102})
											tmp711 := lang.Apply(tmp702, []any{tmp706, tmp710})
											tmp712 := lang.Apply(tmp699, []any{tmp711})
											tmp713 := lang.Apply(tmp696, []any{tmp712})
											tmp714 := lang.Apply(tmp689, []any{tmp693, tmp713})
											tmp715 := lang.Apply(tmp686, []any{tmp714})
											tmp716 := lang.Apply(tmp680, []any{tmp683, tmp715})
											tmp717 := lang.Apply(tmp677, []any{tmp716})
											tmp718 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp719 := tmp718.FindInternedVar(lang.NewSymbol("list"))
											if tmp719.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp719)))
											}
											tmp720 := tmp719.Get()
											tmp721 := lang.Apply(tmp720, []any{v179})
											var tmp722 any
											if lang.IsTruthy(v177) {
												tmp723 := lang.NewVector(v169)
												tmp724 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3264), lang.NewKeyword("column"), int(52), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(60))
												tmp725, err := lang.WithMeta(tmp723, tmp724.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp722 = tmp725
											} else {
											}
											tmp726 := lang.Apply(tmp670, []any{tmp674, tmp717, tmp721, tmp722})
											tmp727 := lang.Apply(tmp667, []any{tmp726})
											tmp728 := lang.Apply(tmp664, []any{tmp727})
											tmp729 := lang.Apply(tmp482, []any{tmp486, tmp506, tmp661, tmp728})
											tmp730 := lang.Apply(tmp479, []any{tmp729})
											tmp731 := lang.Apply(tmp476, []any{tmp730})
											tmp732 := lang.Apply(tmp426, []any{tmp430, tmp473, tmp731})
											tmp733 := lang.Apply(tmp423, []any{tmp732})
											tmp734 := lang.Apply(tmp420, []any{tmp733})
											tmp735 := lang.Apply(tmp318, []any{tmp322, tmp346, tmp417, tmp734})
											tmp736 := lang.Apply(tmp315, []any{tmp735})
											tmp737 := lang.Apply(tmp312, []any{tmp736})
											tmp738 := lang.Apply(tmp238, []any{tmp242, tmp309, tmp737})
											tmp739 := lang.Apply(tmp235, []any{tmp738})
											tmp740 := lang.NewVector(true, tmp739)
											tmp741 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3250), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(67))
											tmp742, err := lang.WithMeta(tmp740, tmp741.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp97 = tmp742
										} // end let
										tmp91 = tmp97
									}
									tmp80 = tmp91
								} // end let
								tmp60 = tmp80
							}
							return tmp60
						})
						v57 = tmp56
						_ = v57
					}
					tmp57 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3218), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(3264), lang.NewKeyword("end-column"), int(72))
					tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v59 any = tmp58
					_ = v59
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("nth"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.Apply(tmp65, []any{v5})
					tmp67 := lang.Apply(v59, []any{nil, tmp66})
					tmp68 := lang.Apply(tmp62, []any{tmp67, int64(1)})
					tmp55 = tmp68
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dosync
	{
		tmp0 := lang.NewSymbol("dosync").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5100), lang.NewKeyword("end-line"), int(5100))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/sync")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp18, []any{nil})
				tmp20 := lang.Apply(tmp11, []any{tmp15, tmp19, v5})
				tmp21 := lang.Apply(tmp8, []any{tmp20})
				return tmp21
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// dotimes
	{
		tmp0 := lang.NewSymbol("dotimes").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3306), lang.NewKeyword("end-line"), int(3306))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "exactly 2 forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "i"
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("first"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.Apply(tmp58, []any{v5})
					var v60 any = tmp59
					_ = v60
					// let binding "n"
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("second"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.Apply(tmp63, []any{v5})
					var v65 any = tmp64
					_ = v65
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("seq"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp70 := tmp69.FindInternedVar(lang.NewSymbol("concat"))
					if tmp70.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
					}
					tmp71 := tmp70.Get()
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("list"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("glojure.core/let")})
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("list"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("apply"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp83 := tmp82.FindInternedVar(lang.NewSymbol("vector"))
					if tmp83.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
					}
					tmp84 := tmp83.Get()
					tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp86 := tmp85.FindInternedVar(lang.NewSymbol("seq"))
					if tmp86.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
					}
					tmp87 := tmp86.Get()
					tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp89 := tmp88.FindInternedVar(lang.NewSymbol("concat"))
					if tmp89.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
					}
					tmp90 := tmp89.Get()
					tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp92 := tmp91.FindInternedVar(lang.NewSymbol("list"))
					if tmp92.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
					}
					tmp93 := tmp92.Get()
					tmp94 := lang.Apply(tmp93, []any{lang.NewSymbol("n__0__auto__")})
					tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp96 := tmp95.FindInternedVar(lang.NewSymbol("list"))
					if tmp96.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
					}
					tmp97 := tmp96.Get()
					tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp99 := tmp98.FindInternedVar(lang.NewSymbol("seq"))
					if tmp99.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
					}
					tmp100 := tmp99.Get()
					tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp102 := tmp101.FindInternedVar(lang.NewSymbol("concat"))
					if tmp102.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
					}
					tmp103 := tmp102.Get()
					tmp104 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp105 := tmp104.FindInternedVar(lang.NewSymbol("list"))
					if tmp105.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp105)))
					}
					tmp106 := tmp105.Get()
					tmp107 := lang.Apply(tmp106, []any{lang.NewSymbol("glojure.core/long")})
					tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp109 := tmp108.FindInternedVar(lang.NewSymbol("list"))
					if tmp109.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
					}
					tmp110 := tmp109.Get()
					tmp111 := lang.Apply(tmp110, []any{v65})
					tmp112 := lang.Apply(tmp103, []any{tmp107, tmp111})
					tmp113 := lang.Apply(tmp100, []any{tmp112})
					tmp114 := lang.Apply(tmp97, []any{tmp113})
					tmp115 := lang.Apply(tmp90, []any{tmp94, tmp114})
					tmp116 := lang.Apply(tmp87, []any{tmp115})
					tmp117 := lang.Apply(tmp81, []any{tmp84, tmp116})
					tmp118 := lang.Apply(tmp78, []any{tmp117})
					tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp120 := tmp119.FindInternedVar(lang.NewSymbol("list"))
					if tmp120.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
					}
					tmp121 := tmp120.Get()
					tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp123 := tmp122.FindInternedVar(lang.NewSymbol("seq"))
					if tmp123.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
					}
					tmp124 := tmp123.Get()
					tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp126 := tmp125.FindInternedVar(lang.NewSymbol("concat"))
					if tmp126.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
					}
					tmp127 := tmp126.Get()
					tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp129 := tmp128.FindInternedVar(lang.NewSymbol("list"))
					if tmp129.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
					}
					tmp130 := tmp129.Get()
					tmp131 := lang.Apply(tmp130, []any{lang.NewSymbol("glojure.core/loop")})
					tmp132 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp133 := tmp132.FindInternedVar(lang.NewSymbol("list"))
					if tmp133.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp133)))
					}
					tmp134 := tmp133.Get()
					tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp136 := tmp135.FindInternedVar(lang.NewSymbol("apply"))
					if tmp136.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
					}
					tmp137 := tmp136.Get()
					tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp139 := tmp138.FindInternedVar(lang.NewSymbol("vector"))
					if tmp139.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
					}
					tmp140 := tmp139.Get()
					tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp142 := tmp141.FindInternedVar(lang.NewSymbol("seq"))
					if tmp142.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
					}
					tmp143 := tmp142.Get()
					tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp145 := tmp144.FindInternedVar(lang.NewSymbol("concat"))
					if tmp145.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
					}
					tmp146 := tmp145.Get()
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.Apply(tmp149, []any{v60})
					tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp152 := tmp151.FindInternedVar(lang.NewSymbol("list"))
					if tmp152.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
					}
					tmp153 := tmp152.Get()
					tmp154 := lang.Apply(tmp153, []any{int64(0)})
					tmp155 := lang.Apply(tmp146, []any{tmp150, tmp154})
					tmp156 := lang.Apply(tmp143, []any{tmp155})
					tmp157 := lang.Apply(tmp137, []any{tmp140, tmp156})
					tmp158 := lang.Apply(tmp134, []any{tmp157})
					tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp160 := tmp159.FindInternedVar(lang.NewSymbol("list"))
					if tmp160.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
					}
					tmp161 := tmp160.Get()
					tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp163 := tmp162.FindInternedVar(lang.NewSymbol("seq"))
					if tmp163.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
					}
					tmp164 := tmp163.Get()
					tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp166 := tmp165.FindInternedVar(lang.NewSymbol("concat"))
					if tmp166.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
					}
					tmp167 := tmp166.Get()
					tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp169 := tmp168.FindInternedVar(lang.NewSymbol("list"))
					if tmp169.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
					}
					tmp170 := tmp169.Get()
					tmp171 := lang.Apply(tmp170, []any{lang.NewSymbol("glojure.core/when")})
					tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp173 := tmp172.FindInternedVar(lang.NewSymbol("list"))
					if tmp173.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
					}
					tmp174 := tmp173.Get()
					tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp176 := tmp175.FindInternedVar(lang.NewSymbol("seq"))
					if tmp176.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
					}
					tmp177 := tmp176.Get()
					tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp179 := tmp178.FindInternedVar(lang.NewSymbol("concat"))
					if tmp179.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
					}
					tmp180 := tmp179.Get()
					tmp181 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp182 := tmp181.FindInternedVar(lang.NewSymbol("list"))
					if tmp182.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp182)))
					}
					tmp183 := tmp182.Get()
					tmp184 := lang.Apply(tmp183, []any{lang.NewSymbol("glojure.core/<")})
					tmp185 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp186 := tmp185.FindInternedVar(lang.NewSymbol("list"))
					if tmp186.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp186)))
					}
					tmp187 := tmp186.Get()
					tmp188 := lang.Apply(tmp187, []any{v60})
					tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
					if tmp190.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
					}
					tmp191 := tmp190.Get()
					tmp192 := lang.Apply(tmp191, []any{lang.NewSymbol("n__0__auto__")})
					tmp193 := lang.Apply(tmp180, []any{tmp184, tmp188, tmp192})
					tmp194 := lang.Apply(tmp177, []any{tmp193})
					tmp195 := lang.Apply(tmp174, []any{tmp194})
					tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp197 := tmp196.FindInternedVar(lang.NewSymbol("list"))
					if tmp197.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
					}
					tmp198 := tmp197.Get()
					tmp199 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp200 := tmp199.FindInternedVar(lang.NewSymbol("seq"))
					if tmp200.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp200)))
					}
					tmp201 := tmp200.Get()
					tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp203 := tmp202.FindInternedVar(lang.NewSymbol("concat"))
					if tmp203.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
					}
					tmp204 := tmp203.Get()
					tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp206 := tmp205.FindInternedVar(lang.NewSymbol("list"))
					if tmp206.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
					}
					tmp207 := tmp206.Get()
					tmp208 := lang.Apply(tmp207, []any{lang.NewSymbol("recur")})
					tmp209 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp210 := tmp209.FindInternedVar(lang.NewSymbol("list"))
					if tmp210.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp210)))
					}
					tmp211 := tmp210.Get()
					tmp212 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp213 := tmp212.FindInternedVar(lang.NewSymbol("seq"))
					if tmp213.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp213)))
					}
					tmp214 := tmp213.Get()
					tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp216 := tmp215.FindInternedVar(lang.NewSymbol("concat"))
					if tmp216.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
					}
					tmp217 := tmp216.Get()
					tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp219 := tmp218.FindInternedVar(lang.NewSymbol("list"))
					if tmp219.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
					}
					tmp220 := tmp219.Get()
					tmp221 := lang.Apply(tmp220, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
					tmp222 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp223 := tmp222.FindInternedVar(lang.NewSymbol("list"))
					if tmp223.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp223)))
					}
					tmp224 := tmp223.Get()
					tmp225 := lang.Apply(tmp224, []any{v60})
					tmp226 := lang.Apply(tmp217, []any{tmp221, tmp225})
					tmp227 := lang.Apply(tmp214, []any{tmp226})
					tmp228 := lang.Apply(tmp211, []any{tmp227})
					tmp229 := lang.Apply(tmp204, []any{tmp208, tmp228})
					tmp230 := lang.Apply(tmp201, []any{tmp229})
					tmp231 := lang.Apply(tmp198, []any{tmp230})
					tmp232 := lang.Apply(tmp167, []any{tmp171, tmp195, v6, tmp231})
					tmp233 := lang.Apply(tmp164, []any{tmp232})
					tmp234 := lang.Apply(tmp161, []any{tmp233})
					tmp235 := lang.Apply(tmp127, []any{tmp131, tmp158, tmp234})
					tmp236 := lang.Apply(tmp124, []any{tmp235})
					tmp237 := lang.Apply(tmp121, []any{tmp236})
					tmp238 := lang.Apply(tmp71, []any{tmp75, tmp118, tmp237})
					tmp239 := lang.Apply(tmp68, []any{tmp238})
					tmp55 = tmp239
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doto
	{
		tmp0 := lang.NewSymbol("doto").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3853), lang.NewKeyword("end-line"), int(3853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "gx"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, nil)
					var v12 any = tmp11
					_ = v12
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("concat"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/let")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("apply"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("vector"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("seq"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("concat"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("list"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp40, []any{v12})
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("list"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.Apply(tmp44, []any{v5})
					tmp46 := lang.Apply(tmp37, []any{tmp41, tmp45})
					tmp47 := lang.Apply(tmp34, []any{tmp46})
					tmp48 := lang.Apply(tmp28, []any{tmp31, tmp47})
					tmp49 := lang.Apply(tmp25, []any{tmp48})
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("map"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					var tmp53 lang.FnFunc
					tmp53 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v54 := args[0]
						_ = v54
						tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp56 := tmp55.FindInternedVar(lang.NewSymbol("with-meta"))
						if tmp56.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
						}
						tmp57 := tmp56.Get()
						var tmp58 any
						tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp60 := tmp59.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp60.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
						}
						tmp61 := tmp60.Get()
						tmp62 := lang.Apply(tmp61, []any{v54})
						if lang.IsTruthy(tmp62) {
							tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
							if tmp64.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
							}
							tmp65 := tmp64.Get()
							tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp67 := tmp66.FindInternedVar(lang.NewSymbol("concat"))
							if tmp67.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
							}
							tmp68 := tmp67.Get()
							tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
							if tmp70.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
							}
							tmp71 := tmp70.Get()
							tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp73 := tmp72.FindInternedVar(lang.NewSymbol("first"))
							if tmp73.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
							}
							tmp74 := tmp73.Get()
							tmp75 := lang.Apply(tmp74, []any{v54})
							tmp76 := lang.Apply(tmp71, []any{tmp75})
							tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp78 := tmp77.FindInternedVar(lang.NewSymbol("list"))
							if tmp78.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
							}
							tmp79 := tmp78.Get()
							tmp80 := lang.Apply(tmp79, []any{v12})
							tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp82 := tmp81.FindInternedVar(lang.NewSymbol("next"))
							if tmp82.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
							}
							tmp83 := tmp82.Get()
							tmp84 := lang.Apply(tmp83, []any{v54})
							tmp85 := lang.Apply(tmp68, []any{tmp76, tmp80, tmp84})
							tmp86 := lang.Apply(tmp65, []any{tmp85})
							tmp58 = tmp86
						} else {
							tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp88 := tmp87.FindInternedVar(lang.NewSymbol("seq"))
							if tmp88.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
							}
							tmp89 := tmp88.Get()
							tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp91 := tmp90.FindInternedVar(lang.NewSymbol("concat"))
							if tmp91.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
							}
							tmp92 := tmp91.Get()
							tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
							if tmp94.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
							}
							tmp95 := tmp94.Get()
							tmp96 := lang.Apply(tmp95, []any{v54})
							tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
							if tmp98.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
							}
							tmp99 := tmp98.Get()
							tmp100 := lang.Apply(tmp99, []any{v12})
							tmp101 := lang.Apply(tmp92, []any{tmp96, tmp100})
							tmp102 := lang.Apply(tmp89, []any{tmp101})
							tmp58 = tmp102
						}
						tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp104 := tmp103.FindInternedVar(lang.NewSymbol("meta"))
						if tmp104.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
						}
						tmp105 := tmp104.Get()
						tmp106 := lang.Apply(tmp105, []any{v54})
						tmp107 := lang.Apply(tmp57, []any{tmp58, tmp106})
						return tmp107
					})
					tmp54 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3863), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(3868), lang.NewKeyword("end-column"), int(30))
					tmp55, err := lang.WithMeta(tmp53, tmp54.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp56 := lang.Apply(tmp52, []any{tmp55, v6})
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v12})
					tmp61 := lang.Apply(tmp18, []any{tmp22, tmp49, tmp56, tmp60})
					tmp62 := lang.Apply(tmp15, []any{tmp61})
					tmp7 = tmp62
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double
	{
		var tmp1 lang.FnFunc
		{ // function double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/DoubleCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to double", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3493), lang.NewKeyword("end-line"), int(3493))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double-array
	{
		var tmp1 lang.FnFunc
		{ // function double-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/DoubleArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("double-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of doubles", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5341), lang.NewKeyword("end-line"), int(5341))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "DoubleArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("DoubleArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// double?
	{
		tmp0 := lang.NewSymbol("double?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Double", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1421), lang.NewKeyword("end-line"), int(1421))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{lang.Builtins["float64"], v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// doubles
	{
		var tmp1 lang.FnFunc
		{ // function doubles
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Doubles")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("doubles").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to double[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5402), lang.NewKeyword("end-line"), int(5402))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Doubles")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Doubles is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop
	{
		tmp0 := lang.NewSymbol("drop").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a laziness-preserving sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2901), lang.NewKeyword("end-line"), int(2901))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "n"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("deref"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19 := lang.Apply(tmp18, []any{v11})
									var v20 any = tmp19
									_ = v20
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("dec"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp25 any
									switch reflect.TypeOf(tmp24).Kind() {
									case reflect.Func:
										tmp25 = lang.Apply(tmp24, nil)
									default:
										tmp25 = tmp24
									}
									tmp26 := lang.Apply(tmp23, []any{tmp25})
									tmp27, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp27).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp28 := lang.Apply(tmp27, []any{tmp26})
									_ = tmp28
									var tmp29 any
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("pos?"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v20})
									if lang.IsTruthy(tmp33) {
										tmp29 = v13
									} else {
										tmp34 := lang.Apply(v5, []any{v13, v14})
										tmp29 = tmp34
									}
									tmp15 = tmp29
								} // end let
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2909), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2917), lang.NewKeyword("end-column"), int(39))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2907), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2917), lang.NewKeyword("end-column"), int(41))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
				if lang.IsTruthy(tmp10) {
					var tmp11 any
					{ // let
						// let binding "or__0__auto__"
						var tmp12 any
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v3})
						if lang.IsTruthy(tmp16) {
							var tmp17 any
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("int?"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.Apply(tmp20, []any{v3})
							if lang.IsTruthy(tmp21) {
								tmp17 = v3
							} else {
								tmp22 := lang.Apply(nil, []any{v3})
								tmp17 = tmp22
							}
							tmp23, _ := lang.FieldOrMethod(v4, "drop")
							if reflect.TypeOf(tmp23).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
							}
							tmp24 := lang.Apply(tmp23, []any{tmp17})
							tmp12 = tmp24
						} else {
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v4})
							tmp12 = tmp28
						}
						var v29 any = tmp12
						_ = v29
						var tmp30 any
						if lang.IsTruthy(v29) {
							tmp30 = v29
						} else {
							tmp30 = lang.NewList()
						}
						tmp11 = tmp30
					} // end let
					tmp5 = tmp11
				} else {
					var tmp12 any
					{ // let
						// let binding "step"
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v14 := args[0]
							_ = v14
							v15 := args[1]
							_ = v15
						recur_loop_539:
							var tmp16 any
							{ // let
								// let binding "s"
								tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
								if tmp18.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
								}
								tmp19 := tmp18.Get()
								tmp20 := lang.Apply(tmp19, []any{v15})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								var tmp23 any
								{ // let
									// let binding "and__0__auto__"
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("pos?"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v14})
									var v28 any = tmp27
									_ = v28
									var tmp29 any
									if lang.IsTruthy(v28) {
										tmp29 = v21
									} else {
										tmp29 = v28
									}
									tmp23 = tmp29
								} // end let
								if lang.IsTruthy(tmp23) {
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("dec"))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.Apply(tmp27, []any{v14})
									var tmp24 any = tmp28
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("rest"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v21})
									var tmp29 any = tmp33
									v14 = tmp24
									v15 = tmp29
									goto recur_loop_539
								} else {
									tmp22 = v21
								}
								tmp16 = tmp22
							} // end let
							return tmp16
						})
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2925), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(2929), lang.NewKeyword("end-column"), int(28))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v16 any = tmp15
						_ = v16
						var tmp17 lang.FnFunc
						tmp17 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp18 := lang.Apply(v16, []any{v3, v4})
							return tmp18
						})
						tmp18 := lang.Apply(lang.NewLazySeq, []any{tmp17})
						tmp12 = tmp18
					} // end let
					tmp5 = tmp12
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-last
	{
		tmp0 := lang.NewSymbol("drop-last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a lazy sequence of all but the last n (default 1) items in coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2932), lang.NewKeyword("end-line"), int(2932))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("drop-last"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{int64(1), v3})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("map"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v9 := args[0]
					_ = v9
					v10 := args[1]
					_ = v10
					return v9
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2937), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(2937), lang.NewKeyword("end-column"), int(29))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("drop"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v3, v4})
				tmp15 := lang.Apply(tmp7, []any{tmp10, v4, tmp14})
				return tmp15
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// drop-while
	{
		tmp0 := lang.NewSymbol("drop-while").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2950), lang.NewKeyword("end-line"), int(2950))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "dv"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{true})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "drop?"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("deref"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19 := lang.Apply(tmp18, []any{v11})
									var v20 any = tmp19
									_ = v20
									var tmp21 any
									var tmp22 any
									{ // let
										// let binding "and__0__auto__"
										var v23 any = v20
										_ = v23
										var tmp24 any
										if lang.IsTruthy(v23) {
											tmp25 := lang.Apply(v3, []any{v14})
											tmp24 = tmp25
										} else {
											tmp24 = v23
										}
										tmp22 = tmp24
									} // end let
									if lang.IsTruthy(tmp22) {
										tmp21 = v13
									} else {
										tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vreset!"))
										if tmp24.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
										}
										tmp25 := tmp24.Get()
										tmp26 := lang.Apply(tmp25, []any{v11, nil})
										_ = tmp26
										tmp27 := lang.Apply(v5, []any{v13, v14})
										tmp21 = tmp27
									}
									tmp15 = tmp21
								} // end let
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2959), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2968), lang.NewKeyword("end-column"), int(42))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2957), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2968), lang.NewKeyword("end-column"), int(44))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "step"
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
					recur_loop_552:
						var tmp9 any
						{ // let
							// let binding "s"
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							tmp13 := lang.Apply(tmp12, []any{v8})
							var v14 any = tmp13
							_ = v14
							var tmp15 any
							var tmp16 any
							{ // let
								// let binding "and__0__auto__"
								var v17 any = v14
								_ = v17
								var tmp18 any
								if lang.IsTruthy(v17) {
									tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
									if tmp20.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
									}
									tmp21 := tmp20.Get()
									tmp22 := lang.Apply(tmp21, []any{v14})
									tmp23 := lang.Apply(v7, []any{tmp22})
									tmp18 = tmp23
								} else {
									tmp18 = v17
								}
								tmp16 = tmp18
							} // end let
							if lang.IsTruthy(tmp16) {
								var tmp17 any = v7
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("rest"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.Apply(tmp21, []any{v14})
								var tmp18 any = tmp22
								v7 = tmp17
								v8 = tmp18
								goto recur_loop_552
							} else {
								tmp15 = v14
							}
							tmp9 = tmp15
						} // end let
						return tmp9
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2970), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2974), lang.NewKeyword("end-column"), int(26))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v9 any = tmp8
					_ = v9
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						tmp11 := lang.Apply(v9, []any{v3, v4})
						return tmp11
					})
					tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
					tmp5 = tmp11
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// elide-top-frames
	{
		tmp0 := lang.NewSymbol("elide-top-frames").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4794), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4794), lang.NewKeyword("end-column"), int(32), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"), lang.NewSymbol("class-name"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "tr"
				tmp6, ok := lang.FieldOrMethod(v3, "getStackTrace")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getStackTrace")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				var v8 any = tmp7
				_ = v8
				var tmp9 any
				{ // let
					// let binding "G__54"
					var v10 any = v3
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v8) {
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("into-array"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("drop-while"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						var tmp18 lang.FnFunc
						tmp18 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v19 := args[0]
							_ = v19
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("="))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23, ok := lang.FieldOrMethod(v19, "getClassName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v19, "getClassName")))
							}
							var tmp24 any
							switch reflect.TypeOf(tmp23).Kind() {
							case reflect.Func:
								tmp24 = lang.Apply(tmp23, nil)
							default:
								tmp24 = tmp23
							}
							tmp25 := lang.Apply(tmp22, []any{v4, tmp24})
							return tmp25
						})
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4801), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(4801), lang.NewKeyword("end-column"), int(77))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp21 := lang.Apply(tmp17, []any{tmp20, v8})
						tmp22 := lang.Apply(tmp14, []any{nil, tmp21})
						tmp11 = tmp22
					} else {
					}
					tmp23, _ := lang.FieldOrMethod(v10, "setStackTrace")
					if reflect.TypeOf(tmp23).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
					}
					tmp24 := lang.Apply(tmp23, []any{tmp11})
					_ = tmp24
					tmp9 = v10
				} // end let
				tmp5 = tmp9
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-protocol
	{
		tmp0 := lang.NewSymbol("emit-extend-protocol").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(205), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(205), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("parse-impls"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("concat"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("do")})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("map"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				var tmp24 lang.FnFunc
				tmp24 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v25 := args[0]
					_ = v25
					var tmp26 any
					{ // let
						// let binding "vec__292"
						var v27 any = v25
						_ = v27
						// let binding "t"
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("nth"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.Apply(tmp30, []any{v27, int64(0), nil})
						var v32 any = tmp31
						_ = v32
						// let binding "fs"
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("nth"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.Apply(tmp35, []any{v27, int64(1), nil})
						var v37 any = tmp36
						_ = v37
						tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
						if tmp39.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
						}
						tmp40 := tmp39.Get()
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{lang.NewSymbol("glojure.core/extend-type")})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v32})
						tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
						if tmp53.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
						}
						tmp54 := tmp53.Get()
						tmp55 := lang.Apply(tmp54, []any{v3})
						tmp56 := lang.Apply(tmp43, []any{tmp47, tmp51, tmp55, v37})
						tmp57 := lang.Apply(tmp40, []any{tmp56})
						tmp26 = tmp57
					} // end let
					return tmp26
				})
				tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(208), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(209), lang.NewKeyword("end-column"), int(42))
				tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp27 := lang.Apply(tmp23, []any{tmp26, v10})
				tmp28 := lang.Apply(tmp16, []any{tmp20, tmp27})
				tmp29 := lang.Apply(tmp13, []any{tmp28})
				tmp5 = tmp29
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-extend-type
	{
		tmp0 := lang.NewSymbol("emit-extend-type").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(175), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(175), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "impls"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("parse-impls"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("concat"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("glojure.core/extend")})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v3})
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("mapcat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("partial"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("emit-hinted-impl"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp30, []any{tmp33, v3})
				tmp35 := lang.Apply(tmp27, []any{tmp34, v10})
				tmp36 := lang.Apply(tmp16, []any{tmp20, tmp24, tmp35})
				tmp37 := lang.Apply(tmp13, []any{tmp36})
				tmp5 = tmp37
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// emit-hinted-impl
	{
		tmp0 := lang.NewSymbol("emit-hinted-impl").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(163), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(163), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("fs")))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "vec__281"
				var v6 any = v4
				_ = v6
				// let binding "p"
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("nth"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v6, int64(0), nil})
				var v11 any = tmp10
				_ = v11
				// let binding "fs"
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("nth"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v6, int64(1), nil})
				var v16 any = tmp15
				_ = v16
				var tmp17 any
				{ // let
					// let binding "hint"
					var tmp18 lang.FnFunc
					tmp18 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v19 := args[0]
						_ = v19
						var tmp20 any
						{ // let
							// let binding "specs"
							var tmp21 any
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("vector?"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("first"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v19})
							tmp29 := lang.Apply(tmp24, []any{tmp28})
							if lang.IsTruthy(tmp29) {
								tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp31 := tmp30.FindInternedVar(lang.NewSymbol("list"))
								if tmp31.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
								}
								tmp32 := tmp31.Get()
								tmp33 := lang.Apply(tmp32, []any{v19})
								tmp21 = tmp33
							} else {
								tmp21 = v19
							}
							var v34 any = tmp21
							_ = v34
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("map"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							var tmp38 lang.FnFunc
							tmp38 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v39 := args[0]
								_ = v39
								var tmp40 any
								{ // let
									// let binding "vec__285"
									var v41 any = v39
									_ = v41
									// let binding "seq__286"
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("seq"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									tmp45 := lang.Apply(tmp44, []any{v41})
									var v46 any = tmp45
									_ = v46
									// let binding "first__287"
									tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp48 := tmp47.FindInternedVar(lang.NewSymbol("first"))
									if tmp48.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
									}
									tmp49 := tmp48.Get()
									tmp50 := lang.Apply(tmp49, []any{v46})
									var v51 any = tmp50
									_ = v51
									// let binding "seq__286"
									tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp53 := tmp52.FindInternedVar(lang.NewSymbol("next"))
									if tmp53.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
									}
									tmp54 := tmp53.Get()
									tmp55 := lang.Apply(tmp54, []any{v46})
									var v56 any = tmp55
									_ = v56
									// let binding "vec__288"
									var v57 any = v51
									_ = v57
									// let binding "seq__289"
									tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp59 := tmp58.FindInternedVar(lang.NewSymbol("seq"))
									if tmp59.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
									}
									tmp60 := tmp59.Get()
									tmp61 := lang.Apply(tmp60, []any{v57})
									var v62 any = tmp61
									_ = v62
									// let binding "first__290"
									tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp64 := tmp63.FindInternedVar(lang.NewSymbol("first"))
									if tmp64.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
									}
									tmp65 := tmp64.Get()
									tmp66 := lang.Apply(tmp65, []any{v62})
									var v67 any = tmp66
									_ = v67
									// let binding "seq__289"
									tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp69 := tmp68.FindInternedVar(lang.NewSymbol("next"))
									if tmp69.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
									}
									tmp70 := tmp69.Get()
									tmp71 := lang.Apply(tmp70, []any{v62})
									var v72 any = tmp71
									_ = v72
									// let binding "target"
									var v73 any = v67
									_ = v73
									// let binding "args"
									var v74 any = v72
									_ = v74
									// let binding "body"
									var v75 any = v56
									_ = v75
									tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp77 := tmp76.FindInternedVar(lang.NewSymbol("cons"))
									if tmp77.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
									}
									tmp78 := tmp77.Get()
									tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp80 := tmp79.FindInternedVar(lang.NewSymbol("apply"))
									if tmp80.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
									}
									tmp81 := tmp80.Get()
									tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp83 := tmp82.FindInternedVar(lang.NewSymbol("vector"))
									if tmp83.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
									}
									tmp84 := tmp83.Get()
									tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp86 := tmp85.FindInternedVar(lang.NewSymbol("vary-meta"))
									if tmp86.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
									}
									tmp87 := tmp86.Get()
									tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp89 := tmp88.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp89.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
									}
									tmp90 := tmp89.Get()
									tmp91 := lang.Apply(tmp87, []any{v73, tmp90, lang.NewKeyword("tag"), v3})
									tmp92 := lang.Apply(tmp81, []any{tmp84, tmp91, v74})
									tmp93 := lang.Apply(tmp78, []any{tmp92, v75})
									tmp40 = tmp93
								} // end let
								return tmp40
							})
							tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(168), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(170), lang.NewKeyword("end-column"), int(36))
							tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp41 := lang.Apply(tmp37, []any{tmp40, v34})
							tmp20 = tmp41
						} // end let
						return tmp20
					})
					tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(164), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(171), lang.NewKeyword("end-column"), int(30))
					tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v21 any = tmp20
					_ = v21
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("zipmap"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("map"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v29 := args[0]
						_ = v29
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("keyword"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("name"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("first"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.Apply(tmp38, []any{v29})
						tmp40 := lang.Apply(tmp35, []any{tmp39})
						tmp41 := lang.Apply(tmp32, []any{tmp40})
						return tmp41
					})
					tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(172), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(172), lang.NewKeyword("end-column"), int(46))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.Apply(tmp27, []any{tmp30, v16})
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("map"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					var tmp35 lang.FnFunc
					tmp35 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v36 := args[0]
						_ = v36
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("cons"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("drop"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{int64(1), v36})
						tmp44 := lang.Apply(v21, []any{tmp43})
						tmp45 := lang.Apply(tmp39, []any{lang.NewSymbol("glojure.core/fn"), tmp44})
						return tmp45
					})
					tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(173), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(173), lang.NewKeyword("end-column"), int(49))
					tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp38 := lang.Apply(tmp34, []any{tmp37, v16})
					tmp39 := lang.Apply(tmp24, []any{tmp31, tmp38})
					tmp40 := lang.NewVector(v11, tmp39)
					tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(172), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(173), lang.NewKeyword("end-column"), int(55))
					tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 = tmp42
				} // end let
				tmp5 = tmp17
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty
	{
		tmp0 := lang.NewSymbol("empty").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns an empty collection of the same category as coll, or nil", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5265), lang.NewKeyword("end-line"), int(5265))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := reflect.TypeOf((*lang.IPersistentCollection)(nil)).Elem()
			tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
			if lang.IsTruthy(tmp9) {
				tmp10, ok := lang.FieldOrMethod(v3, "empty")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "empty")))
				}
				var tmp11 any
				switch reflect.TypeOf(tmp10).Kind() {
				case reflect.Func:
					tmp11 = lang.Apply(tmp10, nil)
				default:
					tmp11 = tmp10
				}
				tmp4 = tmp11
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// empty?
	{
		tmp0 := lang.NewSymbol("empty?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll has no items. To check the emptiness of a seq,\n  please use the idiom (seq x) rather than (not (empty? x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6247), lang.NewKeyword("end-line"), int(6247))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("counted?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("zero?"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("count"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16 := lang.Apply(tmp11, []any{tmp15})
				tmp4 = tmp16
			} else {
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("not"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("seq"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.Apply(tmp22, []any{v3})
				tmp24 := lang.Apply(tmp19, []any{tmp23})
				tmp4 = tmp24
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure
	{
		tmp0 := lang.NewSymbol("ensure").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"))), lang.NewKeyword("doc"), "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2480), lang.NewKeyword("end-line"), int(2480))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "touch")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("touch is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			_ = tmp5
			tmp6, _ := lang.FieldOrMethod(v3, "deref")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("deref is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ensure-reduced
	{
		tmp0 := lang.NewSymbol("ensure-reduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is already reduced?, returns it, else returns (reduced x)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2841), lang.NewKeyword("end-line"), int(2841))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("reduced?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp4 = v3
			} else {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("reduced"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp4 = tmp12
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// enumeration-seq
	{
		tmp0 := lang.NewSymbol("enumeration-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns a seq on a java.util.Enumeration", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5710), lang.NewKeyword("end-line"), int(5710))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-handler
	{
		tmp0 := lang.NewSymbol("error-handler").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2202), lang.NewKeyword("end-line"), int(2202))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorHandler")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorHandler")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// error-mode
	{
		tmp0 := lang.NewSymbol("error-mode").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"))), lang.NewKeyword("doc"), "Returns the error-mode of agent a.  See set-error-mode!", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2227), lang.NewKeyword("end-line"), int(2227))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getErrorMode")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getErrorMode")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// eval
	{
		tmp0 := lang.NewSymbol("eval").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Evaluates the form data structure (not text!) and returns the result.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3203), lang.NewKeyword("end-line"), int(3203))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.Compiler, "Eval")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Eval is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// even?
	{
		tmp0 := lang.NewSymbol("even?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is even, throws an exception if n is not an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1381), lang.NewKeyword("end-line"), int(1381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("integer?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("zero?"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("bit-and"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(lang.UncheckedLongCast, []any{v3})
				tmp16 := lang.Apply(tmp14, []any{tmp15, int64(1)})
				tmp17 := lang.Apply(tmp11, []any{tmp16})
				tmp4 = tmp17
			} else {
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("str"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{"Argument must be an integer: ", v3})
				tmp22 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp21})
				panic(tmp22)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every-pred
	{
		tmp0 := lang.NewSymbol("every-pred").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3"), lang.NewSymbol("&"), lang.NewSymbol("ps"))), lang.NewKeyword("doc"), "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7422), lang.NewKeyword("end-line"), int(7422))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function ep1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp8 := tmp7.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp8.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
							}
							tmp9 := tmp8.Get()
							tmp10 := lang.Apply(v3, []any{v6})
							tmp11 := lang.Apply(tmp9, []any{tmp10})
							return tmp11
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp9 := tmp8.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp9.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
							}
							tmp10 := tmp9.Get()
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v6})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := lang.Apply(v3, []any{v7})
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp10 := tmp9.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp10.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
							}
							tmp11 := tmp10.Get()
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v3, []any{v6})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := lang.Apply(v3, []any{v7})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											tmp20 := lang.Apply(v3, []any{v8})
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp16 = tmp19
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								tmp14 := lang.Apply(v5, []any{v6, v7, v8})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("every?"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.Apply(tmp19, []any{v3, v9})
									tmp16 = tmp20
								} else {
									tmp16 = v15
								}
								tmp13 = tmp16
							} // end let
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							return tmp14
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7429), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7435), lang.NewKeyword("end-column"), int(56))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function ep2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp9 := tmp8.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp9.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
							}
							tmp10 := tmp9.Get()
							var tmp11 any
							{ // let
								// let binding "and__0__auto__"
								tmp12 := lang.Apply(v3, []any{v7})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp15 := lang.Apply(v4, []any{v7})
									tmp14 = tmp15
								} else {
									tmp14 = v13
								}
								tmp11 = tmp14
							} // end let
							tmp12 := lang.Apply(tmp10, []any{tmp11})
							return tmp12
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp10 := tmp9.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp10.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
							}
							tmp11 := tmp10.Get()
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v3, []any{v7})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := lang.Apply(v3, []any{v8})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											var tmp20 any
											{ // let
												// let binding "and__0__auto__"
												tmp21 := lang.Apply(v4, []any{v7})
												var v22 any = tmp21
												_ = v22
												var tmp23 any
												if lang.IsTruthy(v22) {
													tmp24 := lang.Apply(v4, []any{v8})
													tmp23 = tmp24
												} else {
													tmp23 = v22
												}
												tmp20 = tmp23
											} // end let
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp16 = tmp19
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								tmp14 := lang.Apply(v3, []any{v7})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										tmp18 := lang.Apply(v3, []any{v8})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											var tmp21 any
											{ // let
												// let binding "and__0__auto__"
												tmp22 := lang.Apply(v3, []any{v9})
												var v23 any = tmp22
												_ = v23
												var tmp24 any
												if lang.IsTruthy(v23) {
													var tmp25 any
													{ // let
														// let binding "and__0__auto__"
														tmp26 := lang.Apply(v4, []any{v7})
														var v27 any = tmp26
														_ = v27
														var tmp28 any
														if lang.IsTruthy(v27) {
															var tmp29 any
															{ // let
																// let binding "and__0__auto__"
																tmp30 := lang.Apply(v4, []any{v8})
																var v31 any = tmp30
																_ = v31
																var tmp32 any
																if lang.IsTruthy(v31) {
																	tmp33 := lang.Apply(v4, []any{v9})
																	tmp32 = tmp33
																} else {
																	tmp32 = v31
																}
																tmp29 = tmp32
															} // end let
															tmp28 = tmp29
														} else {
															tmp28 = v27
														}
														tmp25 = tmp28
													} // end let
													tmp24 = tmp25
												} else {
													tmp24 = v23
												}
												tmp21 = tmp24
											} // end let
											tmp20 = tmp21
										} else {
											tmp20 = v19
										}
										tmp17 = tmp20
									} // end let
									tmp16 = tmp17
								} else {
									tmp16 = v15
								}
								tmp13 = tmp16
							} // end let
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							return tmp14
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp12 := tmp11.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp12.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
							}
							tmp13 := tmp12.Get()
							var tmp14 any
							{ // let
								// let binding "and__0__auto__"
								tmp15 := lang.Apply(v6, []any{v7, v8, v9})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								if lang.IsTruthy(v16) {
									tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp19 := tmp18.FindInternedVar(lang.NewSymbol("every?"))
									if tmp19.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
									}
									tmp20 := tmp19.Get()
									var tmp21 lang.FnFunc
									tmp21 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v22 := args[0]
										_ = v22
										var tmp23 any
										{ // let
											// let binding "and__0__auto__"
											tmp24 := lang.Apply(v3, []any{v22})
											var v25 any = tmp24
											_ = v25
											var tmp26 any
											if lang.IsTruthy(v25) {
												tmp27 := lang.Apply(v4, []any{v22})
												tmp26 = tmp27
											} else {
												tmp26 = v25
											}
											tmp23 = tmp26
										} // end let
										return tmp23
									})
									tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7443), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(7443), lang.NewKeyword("end-column"), int(65))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp24 := lang.Apply(tmp20, []any{tmp23, v10})
									tmp17 = tmp24
								} else {
									tmp17 = v16
								}
								tmp14 = tmp17
							} // end let
							tmp15 := lang.Apply(tmp13, []any{tmp14})
							return tmp15
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7437), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7443), lang.NewKeyword("end-column"), int(75))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function ep3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return true
						case 1:
							v8 := args[0]
							_ = v8
							tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp10 := tmp9.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp10.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
							}
							tmp11 := tmp10.Get()
							var tmp12 any
							{ // let
								// let binding "and__0__auto__"
								tmp13 := lang.Apply(v3, []any{v8})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									var tmp16 any
									{ // let
										// let binding "and__0__auto__"
										tmp17 := lang.Apply(v4, []any{v8})
										var v18 any = tmp17
										_ = v18
										var tmp19 any
										if lang.IsTruthy(v18) {
											tmp20 := lang.Apply(v5, []any{v8})
											tmp19 = tmp20
										} else {
											tmp19 = v18
										}
										tmp16 = tmp19
									} // end let
									tmp15 = tmp16
								} else {
									tmp15 = v14
								}
								tmp12 = tmp15
							} // end let
							tmp13 := lang.Apply(tmp11, []any{tmp12})
							return tmp13
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							var tmp13 any
							{ // let
								// let binding "and__0__auto__"
								tmp14 := lang.Apply(v3, []any{v8})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									var tmp17 any
									{ // let
										// let binding "and__0__auto__"
										tmp18 := lang.Apply(v3, []any{v9})
										var v19 any = tmp18
										_ = v19
										var tmp20 any
										if lang.IsTruthy(v19) {
											var tmp21 any
											{ // let
												// let binding "and__0__auto__"
												tmp22 := lang.Apply(v4, []any{v8})
												var v23 any = tmp22
												_ = v23
												var tmp24 any
												if lang.IsTruthy(v23) {
													var tmp25 any
													{ // let
														// let binding "and__0__auto__"
														tmp26 := lang.Apply(v4, []any{v9})
														var v27 any = tmp26
														_ = v27
														var tmp28 any
														if lang.IsTruthy(v27) {
															var tmp29 any
															{ // let
																// let binding "and__0__auto__"
																tmp30 := lang.Apply(v5, []any{v8})
																var v31 any = tmp30
																_ = v31
																var tmp32 any
																if lang.IsTruthy(v31) {
																	tmp33 := lang.Apply(v5, []any{v9})
																	tmp32 = tmp33
																} else {
																	tmp32 = v31
																}
																tmp29 = tmp32
															} // end let
															tmp28 = tmp29
														} else {
															tmp28 = v27
														}
														tmp25 = tmp28
													} // end let
													tmp24 = tmp25
												} else {
													tmp24 = v23
												}
												tmp21 = tmp24
											} // end let
											tmp20 = tmp21
										} else {
											tmp20 = v19
										}
										tmp17 = tmp20
									} // end let
									tmp16 = tmp17
								} else {
									tmp16 = v15
								}
								tmp13 = tmp16
							} // end let
							tmp14 := lang.Apply(tmp12, []any{tmp13})
							return tmp14
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp12 := tmp11.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp12.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
							}
							tmp13 := tmp12.Get()
							var tmp14 any
							{ // let
								// let binding "and__0__auto__"
								tmp15 := lang.Apply(v3, []any{v8})
								var v16 any = tmp15
								_ = v16
								var tmp17 any
								if lang.IsTruthy(v16) {
									var tmp18 any
									{ // let
										// let binding "and__0__auto__"
										tmp19 := lang.Apply(v3, []any{v9})
										var v20 any = tmp19
										_ = v20
										var tmp21 any
										if lang.IsTruthy(v20) {
											var tmp22 any
											{ // let
												// let binding "and__0__auto__"
												tmp23 := lang.Apply(v3, []any{v10})
												var v24 any = tmp23
												_ = v24
												var tmp25 any
												if lang.IsTruthy(v24) {
													var tmp26 any
													{ // let
														// let binding "and__0__auto__"
														tmp27 := lang.Apply(v4, []any{v8})
														var v28 any = tmp27
														_ = v28
														var tmp29 any
														if lang.IsTruthy(v28) {
															var tmp30 any
															{ // let
																// let binding "and__0__auto__"
																tmp31 := lang.Apply(v4, []any{v9})
																var v32 any = tmp31
																_ = v32
																var tmp33 any
																if lang.IsTruthy(v32) {
																	var tmp34 any
																	{ // let
																		// let binding "and__0__auto__"
																		tmp35 := lang.Apply(v4, []any{v10})
																		var v36 any = tmp35
																		_ = v36
																		var tmp37 any
																		if lang.IsTruthy(v36) {
																			var tmp38 any
																			{ // let
																				// let binding "and__0__auto__"
																				tmp39 := lang.Apply(v5, []any{v8})
																				var v40 any = tmp39
																				_ = v40
																				var tmp41 any
																				if lang.IsTruthy(v40) {
																					var tmp42 any
																					{ // let
																						// let binding "and__0__auto__"
																						tmp43 := lang.Apply(v5, []any{v9})
																						var v44 any = tmp43
																						_ = v44
																						var tmp45 any
																						if lang.IsTruthy(v44) {
																							tmp46 := lang.Apply(v5, []any{v10})
																							tmp45 = tmp46
																						} else {
																							tmp45 = v44
																						}
																						tmp42 = tmp45
																					} // end let
																					tmp41 = tmp42
																				} else {
																					tmp41 = v40
																				}
																				tmp38 = tmp41
																			} // end let
																			tmp37 = tmp38
																		} else {
																			tmp37 = v36
																		}
																		tmp34 = tmp37
																	} // end let
																	tmp33 = tmp34
																} else {
																	tmp33 = v32
																}
																tmp30 = tmp33
															} // end let
															tmp29 = tmp30
														} else {
															tmp29 = v28
														}
														tmp26 = tmp29
													} // end let
													tmp25 = tmp26
												} else {
													tmp25 = v24
												}
												tmp22 = tmp25
											} // end let
											tmp21 = tmp22
										} else {
											tmp21 = v20
										}
										tmp18 = tmp21
									} // end let
									tmp17 = tmp18
								} else {
									tmp17 = v16
								}
								tmp14 = tmp17
							} // end let
							tmp15 := lang.Apply(tmp13, []any{tmp14})
							return tmp15
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp13 := tmp12.FindInternedVar(lang.NewSymbol("boolean"))
							if tmp13.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
							}
							tmp14 := tmp13.Get()
							var tmp15 any
							{ // let
								// let binding "and__0__auto__"
								tmp16 := lang.Apply(v7, []any{v8, v9, v10})
								var v17 any = tmp16
								_ = v17
								var tmp18 any
								if lang.IsTruthy(v17) {
									tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp20 := tmp19.FindInternedVar(lang.NewSymbol("every?"))
									if tmp20.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
									}
									tmp21 := tmp20.Get()
									var tmp22 lang.FnFunc
									tmp22 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v23 := args[0]
										_ = v23
										var tmp24 any
										{ // let
											// let binding "and__0__auto__"
											tmp25 := lang.Apply(v3, []any{v23})
											var v26 any = tmp25
											_ = v26
											var tmp27 any
											if lang.IsTruthy(v26) {
												var tmp28 any
												{ // let
													// let binding "and__0__auto__"
													tmp29 := lang.Apply(v4, []any{v23})
													var v30 any = tmp29
													_ = v30
													var tmp31 any
													if lang.IsTruthy(v30) {
														tmp32 := lang.Apply(v5, []any{v23})
														tmp31 = tmp32
													} else {
														tmp31 = v30
													}
													tmp28 = tmp31
												} // end let
												tmp27 = tmp28
											} else {
												tmp27 = v26
											}
											tmp24 = tmp27
										} // end let
										return tmp24
									})
									tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7451), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(7451), lang.NewKeyword("end-column"), int(72))
									tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp25 := lang.Apply(tmp21, []any{tmp24, v11})
									tmp18 = tmp25
								} else {
									tmp18 = v17
								}
								tmp15 = tmp18
							} // end let
							tmp16 := lang.Apply(tmp14, []any{tmp15})
							return tmp16
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7445), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7451), lang.NewKeyword("end-column"), int(82))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("list*"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v3, v4, v5, v6})
					var v12 any = tmp11
					_ = v12
					var tmp13 lang.FnFunc
					{ // function epn
						var v14 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return true
							case 1:
								v15 := args[0]
								_ = v15
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("every?"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								var tmp19 lang.FnFunc
								tmp19 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v20 := args[0]
									_ = v20
									tmp21 := lang.Apply(v20, []any{v15})
									return tmp21
								})
								tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7456), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7456), lang.NewKeyword("end-column"), int(28))
								tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp22 := lang.Apply(tmp18, []any{tmp21, v12})
								return tmp22
							case 2:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp18 := tmp17.FindInternedVar(lang.NewSymbol("every?"))
								if tmp18.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
								}
								tmp19 := tmp18.Get()
								var tmp20 lang.FnFunc
								tmp20 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v21 := args[0]
									_ = v21
									var tmp22 any
									{ // let
										// let binding "and__0__auto__"
										tmp23 := lang.Apply(v21, []any{v15})
										var v24 any = tmp23
										_ = v24
										var tmp25 any
										if lang.IsTruthy(v24) {
											tmp26 := lang.Apply(v21, []any{v16})
											tmp25 = tmp26
										} else {
											tmp25 = v24
										}
										tmp22 = tmp25
									} // end let
									return tmp22
								})
								tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7457), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7457), lang.NewKeyword("end-column"), int(42))
								tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp23 := lang.Apply(tmp19, []any{tmp22, v12})
								return tmp23
							case 3:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("every?"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								var tmp21 lang.FnFunc
								tmp21 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v22 := args[0]
									_ = v22
									var tmp23 any
									{ // let
										// let binding "and__0__auto__"
										tmp24 := lang.Apply(v22, []any{v15})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										if lang.IsTruthy(v25) {
											var tmp27 any
											{ // let
												// let binding "and__0__auto__"
												tmp28 := lang.Apply(v22, []any{v16})
												var v29 any = tmp28
												_ = v29
												var tmp30 any
												if lang.IsTruthy(v29) {
													tmp31 := lang.Apply(v22, []any{v17})
													tmp30 = tmp31
												} else {
													tmp30 = v29
												}
												tmp27 = tmp30
											} // end let
											tmp26 = tmp27
										} else {
											tmp26 = v25
										}
										tmp23 = tmp26
									} // end let
									return tmp23
								})
								tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7458), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(7458), lang.NewKeyword("end-column"), int(50))
								tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp24 := lang.Apply(tmp20, []any{tmp23, v12})
								return tmp24
							default:
								if len(args) < 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								var v18 any = lang.NewList(args[3:]...)
								_ = v18
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("boolean"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								var tmp22 any
								{ // let
									// let binding "and__0__auto__"
									tmp23 := lang.Apply(v14, []any{v15, v16, v17})
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp27 := tmp26.FindInternedVar(lang.NewSymbol("every?"))
										if tmp27.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
										}
										tmp28 := tmp27.Get()
										var tmp29 lang.FnFunc
										tmp29 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v30 := args[0]
											_ = v30
											tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp32 := tmp31.FindInternedVar(lang.NewSymbol("every?"))
											if tmp32.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
											}
											tmp33 := tmp32.Get()
											tmp34 := lang.Apply(tmp33, []any{v30, v18})
											return tmp34
										})
										tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7460), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(7460), lang.NewKeyword("end-column"), int(63))
										tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp32 := lang.Apply(tmp28, []any{tmp31, v12})
										tmp25 = tmp32
									} else {
										tmp25 = v24
									}
									tmp22 = tmp25
								} // end let
								tmp23 := lang.Apply(tmp21, []any{tmp22})
								return tmp23
							}
						})
						v14 = tmp13
						_ = v14
					}
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7454), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7460), lang.NewKeyword("end-column"), int(71))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp15
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("every?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if (pred x) is logical true for every x in coll, else\n  false.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2664), lang.NewKeyword("end-line"), int(2664))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
		recur_loop_480:
			var tmp6 any
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp12, []any{v5})
			tmp14 := lang.Apply(tmp9, []any{tmp13})
			if lang.IsTruthy(tmp14) {
				tmp6 = true
			} else {
				var tmp15 any
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp18, []any{v5})
				tmp20 := lang.Apply(v4, []any{tmp19})
				if lang.IsTruthy(tmp20) {
					var tmp21 any = v4
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("next"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{v5})
					var tmp22 any = tmp26
					v4 = tmp21
					v5 = tmp22
					goto recur_loop_480
				} else {
					var tmp27 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp27 = false
					} else {
					}
					tmp15 = tmp27
				}
				tmp6 = tmp15
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-cause
	{
		tmp0 := lang.NewSymbol("ex-cause").WithMeta(lang.NewMap(lang.NewKeyword("tag"), nil, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4828), lang.NewKeyword("end-line"), int(4828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp8) {
				tmp9, ok := lang.FieldOrMethod(v3, "getCause")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getCause")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp4 = tmp10
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-data
	{
		tmp0 := lang.NewSymbol("ex-data").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4812), lang.NewKeyword("end-line"), int(4812))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{nil, v3})
			if lang.IsTruthy(tmp8) {
				tmp9, ok := lang.FieldOrMethod(v3, "getData")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getData")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp4 = tmp10
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-info
	{
		tmp0 := lang.NewSymbol("ex-info").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("msg"), lang.NewSymbol("map")), lang.NewVector(lang.NewSymbol("msg"), lang.NewSymbol("map"), lang.NewSymbol("cause"))), lang.NewKeyword("doc"), "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4803), lang.NewKeyword("end-line"), int(4803))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("elide-top-frames"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(nil, []any{v3, v4})
				tmp9 := lang.Apply(tmp7, []any{tmp8, "glojure.core$ex_info"})
				return tmp9
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("elide-top-frames"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(nil, []any{v3, v4, v5})
				tmp10 := lang.Apply(tmp8, []any{tmp9, "glojure.core$ex_info"})
				return tmp10
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ex-message
	{
		tmp0 := lang.NewSymbol("ex-message").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ex"))), lang.NewKeyword("doc"), "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4820), lang.NewKeyword("end-line"), int(4820))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{lang.Throwable, v3})
			if lang.IsTruthy(tmp8) {
				tmp9, ok := lang.FieldOrMethod(v3, "getMessage")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMessage")))
				}
				var tmp10 any
				switch reflect.TypeOf(tmp9).Kind() {
				case reflect.Func:
					tmp10 = lang.Apply(tmp9, nil)
				default:
					tmp10 = tmp9
				}
				tmp4 = tmp10
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend
	{
		tmp0 := lang.NewSymbol("extend").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atype"), lang.NewSymbol("&"), lang.NewSymbol("proto+mmaps"))), lang.NewKeyword("doc"), "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(116), lang.NewKeyword("end-line"), int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "seq_262"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("partition"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{int64(2), v4})
					tmp13 := lang.Apply(tmp8, []any{tmp12})
					var v14 any = tmp13
					_ = v14
					// let binding "chunk_263"
					var v15 any = nil
					_ = v15
					// let binding "count_264"
					var v16 any = int64(0)
					_ = v16
					// let binding "i_265"
					var v17 any = int64(0)
					_ = v17
					for {
						var tmp18 any
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("<"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v17, v16})
						if lang.IsTruthy(tmp22) {
							var tmp23 any
							{ // let
								// let binding "vec__266"
								tmp24, _ := lang.FieldOrMethod(v15, "nth")
								if reflect.TypeOf(tmp24).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp25 := lang.Apply(tmp24, []any{v17})
								var v26 any = tmp25
								_ = v26
								// let binding "proto"
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("nth"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{v26, int64(0), nil})
								var v31 any = tmp30
								_ = v31
								// let binding "mmap"
								tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp33 := tmp32.FindInternedVar(lang.NewSymbol("nth"))
								if tmp33.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
								}
								tmp34 := tmp33.Get()
								tmp35 := lang.Apply(tmp34, []any{v26, int64(1), nil})
								var v36 any = tmp35
								_ = v36
								var tmp37 any
								tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp39 := tmp38.FindInternedVar(lang.NewSymbol("protocol?"))
								if tmp39.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
								}
								tmp40 := tmp39.Get()
								tmp41 := lang.Apply(tmp40, []any{v31})
								if lang.IsTruthy(tmp41) {
								} else {
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("str"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									tmp45 := lang.Apply(tmp44, []any{v31, " is not a protocol"})
									tmp46 := lang.Apply(errors5.New, []any{tmp45})
									panic(tmp46)
								}
								_ = tmp37
								tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp48 := tmp47.FindInternedVar(lang.NewSymbol("reduce1"))
								if tmp48.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
								}
								tmp49 := tmp48.Get()
								var tmp50 lang.FnFunc
								tmp50 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v51 := args[0]
									_ = v51
									v52 := args[1]
									_ = v52
									var tmp53 any
									{ // let
										// let binding "vec__270"
										var v54 any = v52
										_ = v54
										// let binding "k"
										tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp56 := tmp55.FindInternedVar(lang.NewSymbol("nth"))
										if tmp56.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
										}
										tmp57 := tmp56.Get()
										tmp58 := lang.Apply(tmp57, []any{v54, int64(0), nil})
										var v59 any = tmp58
										_ = v59
										// let binding "v"
										tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp61 := tmp60.FindInternedVar(lang.NewSymbol("nth"))
										if tmp61.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
										}
										tmp62 := tmp61.Get()
										tmp63 := lang.Apply(tmp62, []any{v54, int64(1), nil})
										var v64 any = tmp63
										_ = v64
										tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp66 := tmp65.FindInternedVar(lang.NewSymbol("get-in"))
										if tmp66.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
										}
										tmp67 := tmp66.Get()
										tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp69 := tmp68.FindInternedVar(lang.NewSymbol("deref"))
										if tmp69.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
										}
										tmp70 := tmp69.Get()
										tmp71 := lang.Apply(tmp70, []any{v31})
										tmp72 := lang.NewVector(lang.NewKeyword("multis"), v59)
										tmp73 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(158), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(158), lang.NewKeyword("end-column"), int(43))
										tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp75 := lang.Apply(tmp67, []any{tmp71, tmp74})
										var tmp76 lang.FnFunc
										tmp76 = lang.NewFnFunc(func(args ...any) any {
											switch len(args) {
											default:
												if len(args) < 1 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v77 := args[0]
												_ = v77
												var v78 any = lang.NewList(args[1:]...)
												_ = v78
												tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp80 := tmp79.FindInternedVar(lang.NewSymbol("apply"))
												if tmp80.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
												}
												tmp81 := tmp80.Get()
												tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp83 := tmp82.FindInternedVar(lang.NewSymbol("cons"))
												if tmp83.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
												}
												tmp84 := tmp83.Get()
												tmp85 := lang.Apply(tmp84, []any{v77, v78})
												tmp86 := lang.Apply(tmp81, []any{v64, tmp85})
												return tmp86
											}
										})
										tmp77, _ := lang.FieldOrMethod(tmp75, "AddMethod")
										if reflect.TypeOf(tmp77).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
										}
										tmp78 := lang.Apply(tmp77, []any{v3, tmp76})
										tmp53 = tmp78
									} // end let
									return tmp53
								})
								tmp51 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(156), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(160), lang.NewKeyword("end-column"), int(45))
								tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp53 := lang.Apply(tmp49, []any{tmp52, nil, v36})
								_ = tmp53
								var tmp54 any = v14
								var tmp55 any = v15
								var tmp56 any = v16
								tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp59 := tmp58.FindInternedVar(lang.NewSymbol("unchecked-inc"))
								if tmp59.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
								}
								tmp60 := tmp59.Get()
								tmp61 := lang.Apply(tmp60, []any{v17})
								var tmp57 any = tmp61
								v14 = tmp54
								v15 = tmp55
								v16 = tmp56
								v17 = tmp57
								continue
							} // end let
							tmp18 = tmp23
						} else {
							var tmp24 any
							{ // let
								// let binding "temp__0__auto__"
								tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
								if tmp26.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
								}
								tmp27 := tmp26.Get()
								tmp28 := lang.Apply(tmp27, []any{v14})
								var v29 any = tmp28
								_ = v29
								var tmp30 any
								if lang.IsTruthy(v29) {
									var tmp31 any
									{ // let
										// let binding "seq_262"
										var v32 any = v29
										_ = v32
										var tmp33 any
										tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp35 := tmp34.FindInternedVar(lang.NewSymbol("chunked-seq?"))
										if tmp35.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
										}
										tmp36 := tmp35.Get()
										tmp37 := lang.Apply(tmp36, []any{v32})
										if lang.IsTruthy(tmp37) {
											var tmp38 any
											{ // let
												// let binding "c__0__auto__"
												tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp40 := tmp39.FindInternedVar(lang.NewSymbol("chunk-first"))
												if tmp40.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
												}
												tmp41 := tmp40.Get()
												tmp42 := lang.Apply(tmp41, []any{v32})
												var v43 any = tmp42
												_ = v43
												tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp46 := tmp45.FindInternedVar(lang.NewSymbol("chunk-rest"))
												if tmp46.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
												}
												tmp47 := tmp46.Get()
												tmp48 := lang.Apply(tmp47, []any{v32})
												var tmp44 any = tmp48
												var tmp49 any = v43
												tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp52 := tmp51.FindInternedVar(lang.NewSymbol("int"))
												if tmp52.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
												}
												tmp53 := tmp52.Get()
												tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp55 := tmp54.FindInternedVar(lang.NewSymbol("count"))
												if tmp55.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
												}
												tmp56 := tmp55.Get()
												tmp57 := lang.Apply(tmp56, []any{v43})
												tmp58 := lang.Apply(tmp53, []any{tmp57})
												var tmp50 any = tmp58
												tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp61 := tmp60.FindInternedVar(lang.NewSymbol("int"))
												if tmp61.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
												}
												tmp62 := tmp61.Get()
												tmp63 := lang.Apply(tmp62, []any{int64(0)})
												var tmp59 any = tmp63
												v14 = tmp44
												v15 = tmp49
												v16 = tmp50
												v17 = tmp59
												continue
											} // end let
											tmp33 = tmp38
										} else {
											var tmp39 any
											{ // let
												// let binding "vec__273"
												tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
												if tmp41.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
												}
												tmp42 := tmp41.Get()
												tmp43 := lang.Apply(tmp42, []any{v32})
												var v44 any = tmp43
												_ = v44
												// let binding "proto"
												tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp46 := tmp45.FindInternedVar(lang.NewSymbol("nth"))
												if tmp46.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
												}
												tmp47 := tmp46.Get()
												tmp48 := lang.Apply(tmp47, []any{v44, int64(0), nil})
												var v49 any = tmp48
												_ = v49
												// let binding "mmap"
												tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp51 := tmp50.FindInternedVar(lang.NewSymbol("nth"))
												if tmp51.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
												}
												tmp52 := tmp51.Get()
												tmp53 := lang.Apply(tmp52, []any{v44, int64(1), nil})
												var v54 any = tmp53
												_ = v54
												var tmp55 any
												tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp57 := tmp56.FindInternedVar(lang.NewSymbol("protocol?"))
												if tmp57.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
												}
												tmp58 := tmp57.Get()
												tmp59 := lang.Apply(tmp58, []any{v49})
												if lang.IsTruthy(tmp59) {
												} else {
													tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp61 := tmp60.FindInternedVar(lang.NewSymbol("str"))
													if tmp61.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
													}
													tmp62 := tmp61.Get()
													tmp63 := lang.Apply(tmp62, []any{v49, " is not a protocol"})
													tmp64 := lang.Apply(errors5.New, []any{tmp63})
													panic(tmp64)
												}
												_ = tmp55
												tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp66 := tmp65.FindInternedVar(lang.NewSymbol("reduce1"))
												if tmp66.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
												}
												tmp67 := tmp66.Get()
												var tmp68 lang.FnFunc
												tmp68 = lang.NewFnFunc(func(args ...any) any {
													if len(args) != 2 {
														panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
													}
													v69 := args[0]
													_ = v69
													v70 := args[1]
													_ = v70
													var tmp71 any
													{ // let
														// let binding "vec__277"
														var v72 any = v70
														_ = v72
														// let binding "k"
														tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp74 := tmp73.FindInternedVar(lang.NewSymbol("nth"))
														if tmp74.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
														}
														tmp75 := tmp74.Get()
														tmp76 := lang.Apply(tmp75, []any{v72, int64(0), nil})
														var v77 any = tmp76
														_ = v77
														// let binding "v"
														tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp79 := tmp78.FindInternedVar(lang.NewSymbol("nth"))
														if tmp79.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
														}
														tmp80 := tmp79.Get()
														tmp81 := lang.Apply(tmp80, []any{v72, int64(1), nil})
														var v82 any = tmp81
														_ = v82
														tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp84 := tmp83.FindInternedVar(lang.NewSymbol("get-in"))
														if tmp84.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
														}
														tmp85 := tmp84.Get()
														tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp87 := tmp86.FindInternedVar(lang.NewSymbol("deref"))
														if tmp87.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
														}
														tmp88 := tmp87.Get()
														tmp89 := lang.Apply(tmp88, []any{v49})
														tmp90 := lang.NewVector(lang.NewKeyword("multis"), v77)
														tmp91 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(158), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(158), lang.NewKeyword("end-column"), int(43))
														tmp92, err := lang.WithMeta(tmp90, tmp91.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp93 := lang.Apply(tmp85, []any{tmp89, tmp92})
														var tmp94 lang.FnFunc
														tmp94 = lang.NewFnFunc(func(args ...any) any {
															switch len(args) {
															default:
																if len(args) < 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v95 := args[0]
																_ = v95
																var v96 any = lang.NewList(args[1:]...)
																_ = v96
																tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp98 := tmp97.FindInternedVar(lang.NewSymbol("apply"))
																if tmp98.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
																}
																tmp99 := tmp98.Get()
																tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp101 := tmp100.FindInternedVar(lang.NewSymbol("cons"))
																if tmp101.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
																}
																tmp102 := tmp101.Get()
																tmp103 := lang.Apply(tmp102, []any{v95, v96})
																tmp104 := lang.Apply(tmp99, []any{v82, tmp103})
																return tmp104
															}
														})
														tmp95, _ := lang.FieldOrMethod(tmp93, "AddMethod")
														if reflect.TypeOf(tmp95).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("AddMethod is not a function")))
														}
														tmp96 := lang.Apply(tmp95, []any{v3, tmp94})
														tmp71 = tmp96
													} // end let
													return tmp71
												})
												tmp69 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(156), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(160), lang.NewKeyword("end-column"), int(45))
												tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp71 := lang.Apply(tmp67, []any{tmp70, nil, v54})
												_ = tmp71
												tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp74 := tmp73.FindInternedVar(lang.NewSymbol("next"))
												if tmp74.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
												}
												tmp75 := tmp74.Get()
												tmp76 := lang.Apply(tmp75, []any{v32})
												var tmp72 any = tmp76
												var tmp77 any = nil
												var tmp78 any = int64(0)
												var tmp79 any = int64(0)
												v14 = tmp72
												v15 = tmp77
												v16 = tmp78
												v17 = tmp79
												continue
											} // end let
											tmp33 = tmp39
										}
										tmp31 = tmp33
									} // end let
									tmp30 = tmp31
								} else {
								}
								tmp24 = tmp30
							} // end let
							tmp18 = tmp24
						}
						tmp5 = tmp18
						break
					}
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-protocol
	{
		tmp0 := lang.NewSymbol("extend-protocol").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p"), lang.NewSymbol("&"), lang.NewSymbol("specs"))), lang.NewKeyword("doc"), "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types.\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(212), lang.NewKeyword("end-line"), int(212))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("emit-extend-protocol"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v5, v6})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// extend-type
	{
		tmp0 := lang.NewSymbol("extend-type").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("t"), lang.NewSymbol("&"), lang.NewSymbol("specs"))), lang.NewKeyword("doc"), "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(180), lang.NewKeyword("end-line"), int(180))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("emit-extend-type"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v5, v6})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// false?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("false?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is the value false, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(504), lang.NewKeyword("end-line"), int(504))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, false})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ffirst
	{
		tmp0 := lang.NewSymbol("ffirst").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (first x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(98), lang.NewKeyword("end-line"), int(102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function ffirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("first"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("first"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				return tmp12
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(102), lang.NewKeyword("end-column"), int(50))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// file-seq
	{
		tmp0 := lang.NewSymbol("file-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("dir"))), lang.NewKeyword("doc"), "A tree seq on java.io.Files", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4972), lang.NewKeyword("end-line"), int(4972))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("tree-seq"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v8 := args[0]
				_ = v8
				tmp9, _ := lang.FieldOrMethod(v8, "isDirectory")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("isDirectory is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{})
				return tmp10
			})
			tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4978), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4978), lang.NewKeyword("end-column"), int(47))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v11 := args[0]
				_ = v11
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("seq"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15, _ := lang.FieldOrMethod(v11, "listFiles")
				if reflect.TypeOf(tmp15).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("listFiles is not a function")))
				}
				tmp16 := lang.Apply(tmp15, []any{})
				tmp17 := lang.Apply(tmp14, []any{tmp16})
				return tmp17
			})
			tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4979), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4979), lang.NewKeyword("end-column"), int(51))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.Apply(tmp6, []any{tmp9, tmp12, v3})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter
	{
		tmp0 := lang.NewSymbol("filter").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2785), lang.NewKeyword("end-line"), int(2785))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp9 = v7
							}
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2793), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2799), lang.NewKeyword("end-column"), int(22))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2792), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2799), lang.NewKeyword("end-column"), int(23))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("chunked-seq?"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v14})
								if lang.IsTruthy(tmp19) {
									var tmp20 any
									{ // let
										// let binding "c"
										tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp22 := tmp21.FindInternedVar(lang.NewSymbol("chunk-first"))
										if tmp22.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
										}
										tmp23 := tmp22.Get()
										tmp24 := lang.Apply(tmp23, []any{v14})
										var v25 any = tmp24
										_ = v25
										// let binding "size"
										tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp27 := tmp26.FindInternedVar(lang.NewSymbol("count"))
										if tmp27.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
										}
										tmp28 := tmp27.Get()
										tmp29 := lang.Apply(tmp28, []any{v25})
										var v30 any = tmp29
										_ = v30
										// let binding "b"
										tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp32 := tmp31.FindInternedVar(lang.NewSymbol("chunk-buffer"))
										if tmp32.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
										}
										tmp33 := tmp32.Get()
										tmp34 := lang.Apply(tmp33, []any{v30})
										var v35 any = tmp34
										_ = v35
										var tmp36 any
										{ // let
											// let binding "n__0__auto__"
											tmp37 := lang.Apply(lang.LongCast, []any{v30})
											var v38 any = tmp37
											_ = v38
											var tmp39 any
											{ // let
												// let binding "i"
												var v40 any = int64(0)
												_ = v40
												for {
													var tmp41 any
													tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp43 := tmp42.FindInternedVar(lang.NewSymbol("<"))
													if tmp43.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
													}
													tmp44 := tmp43.Get()
													tmp45 := lang.Apply(tmp44, []any{v40, v38})
													if lang.IsTruthy(tmp45) {
														var tmp46 any
														{ // let
															// let binding "v"
															tmp47, _ := lang.FieldOrMethod(v25, "nth")
															if reflect.TypeOf(tmp47).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp48 := lang.Apply(tmp47, []any{v40})
															var v49 any = tmp48
															_ = v49
															var tmp50 any
															tmp51 := lang.Apply(v3, []any{v49})
															if lang.IsTruthy(tmp51) {
																tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp53 := tmp52.FindInternedVar(lang.NewSymbol("chunk-append"))
																if tmp53.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
																}
																tmp54 := tmp53.Get()
																tmp55 := lang.Apply(tmp54, []any{v35, v49})
																tmp50 = tmp55
															} else {
															}
															tmp46 = tmp50
														} // end let
														_ = tmp46
														tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp49 := tmp48.FindInternedVar(lang.NewSymbol("unchecked-inc"))
														if tmp49.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
														}
														tmp50 := tmp49.Get()
														tmp51 := lang.Apply(tmp50, []any{v40})
														var tmp47 any = tmp51
														v40 = tmp47
														continue
													} else {
													}
													tmp39 = tmp41
													break
												}
											} // end let
											tmp36 = tmp39
										} // end let
										_ = tmp36
										tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp38 := tmp37.FindInternedVar(lang.NewSymbol("chunk-cons"))
										if tmp38.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
										}
										tmp39 := tmp38.Get()
										tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp41 := tmp40.FindInternedVar(lang.NewSymbol("chunk"))
										if tmp41.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
										}
										tmp42 := tmp41.Get()
										tmp43 := lang.Apply(tmp42, []any{v35})
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("filter"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp48 := tmp47.FindInternedVar(lang.NewSymbol("chunk-rest"))
										if tmp48.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
										}
										tmp49 := tmp48.Get()
										tmp50 := lang.Apply(tmp49, []any{v14})
										tmp51 := lang.Apply(tmp46, []any{v3, tmp50})
										tmp52 := lang.Apply(tmp39, []any{tmp43, tmp51})
										tmp20 = tmp52
									} // end let
									tmp15 = tmp20
								} else {
									var tmp21 any
									{ // let
										// let binding "f"
										tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp23 := tmp22.FindInternedVar(lang.NewSymbol("first"))
										if tmp23.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
										}
										tmp24 := tmp23.Get()
										tmp25 := lang.Apply(tmp24, []any{v14})
										var v26 any = tmp25
										_ = v26
										// let binding "r"
										tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp28 := tmp27.FindInternedVar(lang.NewSymbol("rest"))
										if tmp28.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
										}
										tmp29 := tmp28.Get()
										tmp30 := lang.Apply(tmp29, []any{v14})
										var v31 any = tmp30
										_ = v31
										var tmp32 any
										tmp33 := lang.Apply(v3, []any{v26})
										if lang.IsTruthy(tmp33) {
											tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp35 := tmp34.FindInternedVar(lang.NewSymbol("cons"))
											if tmp35.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
											}
											tmp36 := tmp35.Get()
											tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp38 := tmp37.FindInternedVar(lang.NewSymbol("filter"))
											if tmp38.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
											}
											tmp39 := tmp38.Get()
											tmp40 := lang.Apply(tmp39, []any{v3, v31})
											tmp41 := lang.Apply(tmp36, []any{v26, tmp40})
											tmp32 = tmp41
										} else {
											tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp43 := tmp42.FindInternedVar(lang.NewSymbol("filter"))
											if tmp43.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
											}
											tmp44 := tmp43.Get()
											tmp45 := lang.Apply(tmp44, []any{v3, v31})
											tmp32 = tmp45
										}
										tmp21 = tmp32
									} // end let
									tmp15 = tmp21
								}
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filter-key
	{
		tmp0 := lang.NewSymbol("filter-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("pred"), lang.NewSymbol("amap"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4115), lang.NewKeyword("end-line"), int(4117), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "ret"
				tmp7 := lang.NewMap()
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4118), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(4118), lang.NewKeyword("end-column"), int(17))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				// let binding "es"
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v5})
				var v15 any = tmp14
				_ = v15
				for {
					var tmp16 any
					if lang.IsTruthy(v15) {
						var tmp17 any
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("first"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v15})
						tmp22 := lang.Apply(v3, []any{tmp21})
						tmp23 := lang.Apply(v4, []any{tmp22})
						if lang.IsTruthy(tmp23) {
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("assoc"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("key"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.Apply(tmp33, []any{v15})
							tmp35 := lang.Apply(tmp30, []any{tmp34})
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("val"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp40 := tmp39.FindInternedVar(lang.NewSymbol("first"))
							if tmp40.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
							}
							tmp41 := tmp40.Get()
							tmp42 := lang.Apply(tmp41, []any{v15})
							tmp43 := lang.Apply(tmp38, []any{tmp42})
							tmp44 := lang.Apply(tmp27, []any{v10, tmp35, tmp43})
							var tmp24 any = tmp44
							tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp47 := tmp46.FindInternedVar(lang.NewSymbol("next"))
							if tmp47.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
							}
							tmp48 := tmp47.Get()
							tmp49 := lang.Apply(tmp48, []any{v15})
							var tmp45 any = tmp49
							v10 = tmp24
							v15 = tmp45
							continue
						} else {
							var tmp50 any = v10
							tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp53 := tmp52.FindInternedVar(lang.NewSymbol("next"))
							if tmp53.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
							}
							tmp54 := tmp53.Get()
							tmp55 := lang.Apply(tmp54, []any{v15})
							var tmp51 any = tmp55
							v10 = tmp50
							v15 = tmp51
							continue
						}
						tmp16 = tmp17
					} else {
						tmp16 = v10
					}
					tmp6 = tmp16
					break
				}
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// filterv
	{
		tmp0 := lang.NewSymbol("filterv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6961), lang.NewKeyword("end-line"), int(6961))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("persistent!"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			var tmp11 lang.FnFunc
			tmp11 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v12 := args[0]
				_ = v12
				v13 := args[1]
				_ = v13
				var tmp14 any
				tmp15 := lang.Apply(v3, []any{v13})
				if lang.IsTruthy(tmp15) {
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v12, v13})
					tmp14 = tmp19
				} else {
					tmp14 = v12
				}
				return tmp14
			})
			tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6967), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6967), lang.NewKeyword("end-column"), int(52))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("transient"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.NewVector()
			tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6968), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(6968), lang.NewKeyword("end-column"), int(27))
			tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp20 := lang.Apply(tmp16, []any{tmp19})
			tmp21 := lang.Apply(tmp10, []any{tmp13, tmp20, v4})
			tmp22 := lang.Apply(tmp7, []any{tmp21})
			return tmp22
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find
	{
		tmp0 := lang.NewSymbol("find").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Returns the map entry for key, or nil if key not present.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1530), lang.NewKeyword("end-line"), int(1530))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Find")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v3, v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := lang.NewSymbol("find-keyword").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(618), lang.NewKeyword("end-line"), int(618))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("keyword?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp5 = v4
				} else {
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("symbol?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v4})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(nil, []any{v4})
						tmp10 = tmp15
					} else {
						var tmp16 any
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("string?"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v4})
						if lang.IsTruthy(tmp20) {
							tmp21 := lang.Apply(nil, []any{v4})
							tmp16 = tmp21
						} else {
						}
						tmp10 = tmp16
					}
					tmp5 = tmp10
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(nil, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-ns
	{
		tmp0 := lang.NewSymbol("find-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the namespace named by the symbol or nil if it doesn't exist.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4125), lang.NewKeyword("end-line"), int(4125))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.FindNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// find-var
	{
		tmp0 := lang.NewSymbol("find-var").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2013), lang.NewKeyword("end-line"), int(2013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.RT, "FindVar")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("FindVar is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// first
	{
		tmp0 := lang.NewSymbol("first").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(47), lang.NewKeyword("end-line"), int(52))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function first
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(lang.First, []any{v4})
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(52), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(52), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fits-table?
	{
		tmp0 := lang.NewSymbol("fits-table?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ints"))), lang.NewKeyword("doc"), "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6625), lang.NewKeyword("end-line"), int(6625), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("<"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("-"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("max"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp17 := tmp16.FindInternedVar(lang.NewSymbol("seq"))
			if tmp17.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
			}
			tmp18 := tmp17.Get()
			tmp19 := lang.Apply(tmp18, []any{v3})
			tmp20 := lang.Apply(tmp12, []any{tmp15, tmp19})
			tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp22 := tmp21.FindInternedVar(lang.NewSymbol("apply"))
			if tmp22.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
			}
			tmp23 := tmp22.Get()
			tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp25 := tmp24.FindInternedVar(lang.NewSymbol("min"))
			if tmp25.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
			}
			tmp26 := tmp25.Get()
			tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
			if tmp28.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
			}
			tmp29 := tmp28.Get()
			tmp30 := lang.Apply(tmp29, []any{v3})
			tmp31 := lang.Apply(tmp23, []any{tmp26, tmp30})
			tmp32 := lang.Apply(tmp9, []any{tmp20, tmp31})
			tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp34 := tmp33.FindInternedVar(lang.NewSymbol("max-switch-table-size"))
			if tmp34.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
			}
			tmp35 := tmp34.Get()
			tmp36 := lang.Apply(tmp6, []any{tmp32, tmp35})
			return tmp36
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flatten
	{
		tmp0 := lang.NewSymbol("flatten").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7118), lang.NewKeyword("end-line"), int(7118))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("filter"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("complement"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("sequential?"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("rest"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp18 := tmp17.FindInternedVar(lang.NewSymbol("tree-seq"))
			if tmp18.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
			}
			tmp19 := tmp18.Get()
			tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp21 := tmp20.FindInternedVar(lang.NewSymbol("sequential?"))
			if tmp21.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
			}
			tmp22 := tmp21.Get()
			tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
			if tmp24.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
			}
			tmp25 := tmp24.Get()
			tmp26 := lang.Apply(tmp19, []any{tmp22, tmp25, v3})
			tmp27 := lang.Apply(tmp16, []any{tmp26})
			tmp28 := lang.Apply(tmp6, []any{tmp13, tmp27})
			return tmp28
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float
	{
		var tmp1 lang.FnFunc
		{ // function float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("uncheckedFloatCast")
				} else {
					tmp30 = lang.NewSymbol("floatCast")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to float", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3487), lang.NewKeyword("end-line"), int(3487))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.FloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float-array
	{
		var tmp1 lang.FnFunc
		{ // function float-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/FloatArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("float-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of floats", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5301), lang.NewKeyword("end-line"), int(5301))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "FloatArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "FloatArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("FloatArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// float?
	{
		tmp0 := lang.NewSymbol("float?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a floating point number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3605), lang.NewKeyword("end-line"), int(3605))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{lang.Builtins["float64"], v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{lang.Builtins["float32"], v3})
					tmp10 = tmp14
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// floats
	{
		var tmp1 lang.FnFunc
		{ // function floats
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Floats")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("floats").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to float[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5392), lang.NewKeyword("end-line"), int(5392))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Floats")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Floats is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// flush
	{
		tmp0 := lang.NewSymbol("flush").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Flushes the output stream that is the current value of\n  *out*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3706), lang.NewKeyword("end-line"), int(3706))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp4 := tmp3.FindInternedVar(lang.NewSymbol("*out*"))
			if tmp4.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
			}
			tmp5 := tmp4.Get()
			tmp6, _ := lang.FieldOrMethod(tmp5, "Sync")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Sync is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{})
			_ = tmp7
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn
	{
		tmp0 := lang.NewSymbol("fn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("sigs"))), lang.NewKeyword("doc"), "params => positional-params*, or positional-params* & rest-param\n  positional-param => binding-form\n  rest-param => binding-form\n  binding-form => name, or destructuring-form\n\n  Defines a function.\n\n  See https://glojure.org/reference/special_forms#fn for more information", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("fn"), lang.NewSymbol("name?"), lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("exprs*")), lang.NewList(lang.NewSymbol("fn"), lang.NewSymbol("name?"), lang.NewList(lang.NewVector(lang.NewSymbol("params*")), lang.NewSymbol("exprs*")), lang.NewSymbol("+"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4533), lang.NewKeyword("end-line"), int(4533), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "name"
					var tmp7 any
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("symbol?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("first"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := lang.Apply(tmp10, []any{tmp14})
					if lang.IsTruthy(tmp15) {
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v5})
						tmp7 = tmp19
					} else {
					}
					var v20 any = tmp7
					_ = v20
					// let binding "sigs"
					var tmp21 any
					if lang.IsTruthy(v20) {
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v5})
						tmp21 = tmp25
					} else {
						tmp21 = v5
					}
					var v26 any = tmp21
					_ = v26
					// let binding "sigs"
					var tmp27 any
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("vector?"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{v26})
					tmp35 := lang.Apply(tmp30, []any{tmp34})
					if lang.IsTruthy(tmp35) {
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.Apply(tmp38, []any{v26})
						tmp27 = tmp39
					} else {
						var tmp40 any
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("first"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v26})
						tmp48 := lang.Apply(tmp43, []any{tmp47})
						if lang.IsTruthy(tmp48) {
							tmp40 = v26
						} else {
							var tmp49 any
							tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp51 := tmp50.FindInternedVar(lang.NewSymbol("seq"))
							if tmp51.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
							}
							tmp52 := tmp51.Get()
							tmp53 := lang.Apply(tmp52, []any{v26})
							if lang.IsTruthy(tmp53) {
								tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp55 := tmp54.FindInternedVar(lang.NewSymbol("str"))
								if tmp55.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
								}
								tmp56 := tmp55.Get()
								tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp58 := tmp57.FindInternedVar(lang.NewSymbol("first"))
								if tmp58.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
								}
								tmp59 := tmp58.Get()
								tmp60 := lang.Apply(tmp59, []any{v26})
								tmp61 := lang.Apply(tmp56, []any{"Parameter declaration ", tmp60, " should be a vector"})
								tmp49 = tmp61
							} else {
								tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp63 := tmp62.FindInternedVar(lang.NewSymbol("str"))
								if tmp63.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
								}
								tmp64 := tmp63.Get()
								tmp65 := lang.Apply(tmp64, []any{"Parameter declaration missing"})
								tmp49 = tmp65
							}
							tmp66 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp49})
							panic(tmp66)
						}
						tmp27 = tmp40
					}
					var v67 any = tmp27
					_ = v67
					// let binding "psig"
					var tmp68 lang.FnFunc
					tmp68 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v69 := args[0]
						_ = v69
						var tmp70 any
						tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp72 := tmp71.FindInternedVar(lang.NewSymbol("not"))
						if tmp72.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
						}
						tmp73 := tmp72.Get()
						tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp75.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
						}
						tmp76 := tmp75.Get()
						tmp77 := lang.Apply(tmp76, []any{v69})
						tmp78 := lang.Apply(tmp73, []any{tmp77})
						if lang.IsTruthy(tmp78) {
							tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp80 := tmp79.FindInternedVar(lang.NewSymbol("str"))
							if tmp80.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
							}
							tmp81 := tmp80.Get()
							tmp82 := lang.Apply(tmp81, []any{"Invalid signature ", v69, " should be a list"})
							tmp83 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp82})
							panic(tmp83)
						} else {
						}
						_ = tmp70
						var tmp84 any
						{ // let
							// let binding "vec__13"
							var v85 any = v69
							_ = v85
							// let binding "seq__14"
							tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp87 := tmp86.FindInternedVar(lang.NewSymbol("seq"))
							if tmp87.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
							}
							tmp88 := tmp87.Get()
							tmp89 := lang.Apply(tmp88, []any{v85})
							var v90 any = tmp89
							_ = v90
							// let binding "first__15"
							tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp92 := tmp91.FindInternedVar(lang.NewSymbol("first"))
							if tmp92.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
							}
							tmp93 := tmp92.Get()
							tmp94 := lang.Apply(tmp93, []any{v90})
							var v95 any = tmp94
							_ = v95
							// let binding "seq__14"
							tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp97 := tmp96.FindInternedVar(lang.NewSymbol("next"))
							if tmp97.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
							}
							tmp98 := tmp97.Get()
							tmp99 := lang.Apply(tmp98, []any{v90})
							var v100 any = tmp99
							_ = v100
							// let binding "params"
							var v101 any = v95
							_ = v101
							// let binding "body"
							var v102 any = v100
							_ = v102
							// let binding "_"
							var tmp103 any
							tmp104 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp105 := tmp104.FindInternedVar(lang.NewSymbol("not"))
							if tmp105.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp105)))
							}
							tmp106 := tmp105.Get()
							tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp108 := tmp107.FindInternedVar(lang.NewSymbol("vector?"))
							if tmp108.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
							}
							tmp109 := tmp108.Get()
							tmp110 := lang.Apply(tmp109, []any{v101})
							tmp111 := lang.Apply(tmp106, []any{tmp110})
							if lang.IsTruthy(tmp111) {
								var tmp112 any
								tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp114 := tmp113.FindInternedVar(lang.NewSymbol("seq?"))
								if tmp114.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
								}
								tmp115 := tmp114.Get()
								tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp117 := tmp116.FindInternedVar(lang.NewSymbol("first"))
								if tmp117.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
								}
								tmp118 := tmp117.Get()
								tmp119 := lang.Apply(tmp118, []any{v67})
								tmp120 := lang.Apply(tmp115, []any{tmp119})
								if lang.IsTruthy(tmp120) {
									tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp122 := tmp121.FindInternedVar(lang.NewSymbol("str"))
									if tmp122.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
									}
									tmp123 := tmp122.Get()
									tmp124 := lang.Apply(tmp123, []any{"Parameter declaration ", v101, " should be a vector"})
									tmp112 = tmp124
								} else {
									tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp126 := tmp125.FindInternedVar(lang.NewSymbol("str"))
									if tmp126.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
									}
									tmp127 := tmp126.Get()
									tmp128 := lang.Apply(tmp127, []any{"Invalid signature ", v69, " should be a list"})
									tmp112 = tmp128
								}
								tmp129 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp112})
								panic(tmp129)
							} else {
							}
							var v130 any = tmp103
							_ = v130
							// let binding "conds"
							var tmp131 any
							var tmp132 any
							{ // let
								// let binding "and__0__auto__"
								tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp134 := tmp133.FindInternedVar(lang.NewSymbol("next"))
								if tmp134.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
								}
								tmp135 := tmp134.Get()
								tmp136 := lang.Apply(tmp135, []any{v102})
								var v137 any = tmp136
								_ = v137
								var tmp138 any
								if lang.IsTruthy(v137) {
									tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp140 := tmp139.FindInternedVar(lang.NewSymbol("map?"))
									if tmp140.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
									}
									tmp141 := tmp140.Get()
									tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp143 := tmp142.FindInternedVar(lang.NewSymbol("first"))
									if tmp143.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
									}
									tmp144 := tmp143.Get()
									tmp145 := lang.Apply(tmp144, []any{v102})
									tmp146 := lang.Apply(tmp141, []any{tmp145})
									tmp138 = tmp146
								} else {
									tmp138 = v137
								}
								tmp132 = tmp138
							} // end let
							if lang.IsTruthy(tmp132) {
								tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp134 := tmp133.FindInternedVar(lang.NewSymbol("first"))
								if tmp134.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
								}
								tmp135 := tmp134.Get()
								tmp136 := lang.Apply(tmp135, []any{v102})
								tmp131 = tmp136
							} else {
							}
							var v137 any = tmp131
							_ = v137
							// let binding "body"
							var tmp138 any
							if lang.IsTruthy(v137) {
								tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp140 := tmp139.FindInternedVar(lang.NewSymbol("next"))
								if tmp140.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
								}
								tmp141 := tmp140.Get()
								tmp142 := lang.Apply(tmp141, []any{v102})
								tmp138 = tmp142
							} else {
								tmp138 = v102
							}
							var v143 any = tmp138
							_ = v143
							// let binding "conds"
							var tmp144 any
							{ // let
								// let binding "or__0__auto__"
								var v145 any = v137
								_ = v145
								var tmp146 any
								if lang.IsTruthy(v145) {
									tmp146 = v145
								} else {
									tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp148 := tmp147.FindInternedVar(lang.NewSymbol("meta"))
									if tmp148.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
									}
									tmp149 := tmp148.Get()
									tmp150 := lang.Apply(tmp149, []any{v101})
									tmp146 = tmp150
								}
								tmp144 = tmp146
							} // end let
							var v145 any = tmp144
							_ = v145
							// let binding "pre"
							tmp146 := lang.Apply(lang.NewKeyword("pre"), []any{v145})
							var v147 any = tmp146
							_ = v147
							// let binding "post"
							tmp148 := lang.Apply(lang.NewKeyword("post"), []any{v145})
							var v149 any = tmp148
							_ = v149
							// let binding "body"
							var tmp150 any
							if lang.IsTruthy(v149) {
								tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp152 := tmp151.FindInternedVar(lang.NewSymbol("seq"))
								if tmp152.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
								}
								tmp153 := tmp152.Get()
								tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp155 := tmp154.FindInternedVar(lang.NewSymbol("concat"))
								if tmp155.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
								}
								tmp156 := tmp155.Get()
								tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp158 := tmp157.FindInternedVar(lang.NewSymbol("list"))
								if tmp158.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
								}
								tmp159 := tmp158.Get()
								tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp161 := tmp160.FindInternedVar(lang.NewSymbol("seq"))
								if tmp161.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
								}
								tmp162 := tmp161.Get()
								tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp164 := tmp163.FindInternedVar(lang.NewSymbol("concat"))
								if tmp164.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
								}
								tmp165 := tmp164.Get()
								tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp167 := tmp166.FindInternedVar(lang.NewSymbol("list"))
								if tmp167.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
								}
								tmp168 := tmp167.Get()
								tmp169 := lang.Apply(tmp168, []any{lang.NewSymbol("glojure.core/let")})
								tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp171 := tmp170.FindInternedVar(lang.NewSymbol("list"))
								if tmp171.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
								}
								tmp172 := tmp171.Get()
								tmp173 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp174 := tmp173.FindInternedVar(lang.NewSymbol("apply"))
								if tmp174.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp174)))
								}
								tmp175 := tmp174.Get()
								tmp176 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp177 := tmp176.FindInternedVar(lang.NewSymbol("vector"))
								if tmp177.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp177)))
								}
								tmp178 := tmp177.Get()
								tmp179 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp180 := tmp179.FindInternedVar(lang.NewSymbol("seq"))
								if tmp180.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp180)))
								}
								tmp181 := tmp180.Get()
								tmp182 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp183 := tmp182.FindInternedVar(lang.NewSymbol("concat"))
								if tmp183.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp183)))
								}
								tmp184 := tmp183.Get()
								tmp185 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp186 := tmp185.FindInternedVar(lang.NewSymbol("list"))
								if tmp186.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp186)))
								}
								tmp187 := tmp186.Get()
								tmp188 := lang.Apply(tmp187, []any{lang.NewSymbol("%")})
								tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
								if tmp190.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
								}
								tmp191 := tmp190.Get()
								var tmp192 any
								tmp193 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp194 := tmp193.FindInternedVar(lang.NewSymbol("<"))
								if tmp194.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp194)))
								}
								tmp195 := tmp194.Get()
								tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp197 := tmp196.FindInternedVar(lang.NewSymbol("count"))
								if tmp197.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
								}
								tmp198 := tmp197.Get()
								tmp199 := lang.Apply(tmp198, []any{v143})
								tmp200 := lang.Apply(tmp195, []any{int64(1), tmp199})
								if lang.IsTruthy(tmp200) {
									tmp201 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp202 := tmp201.FindInternedVar(lang.NewSymbol("seq"))
									if tmp202.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp202)))
									}
									tmp203 := tmp202.Get()
									tmp204 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp205 := tmp204.FindInternedVar(lang.NewSymbol("concat"))
									if tmp205.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp205)))
									}
									tmp206 := tmp205.Get()
									tmp207 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp208 := tmp207.FindInternedVar(lang.NewSymbol("list"))
									if tmp208.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp208)))
									}
									tmp209 := tmp208.Get()
									tmp210 := lang.Apply(tmp209, []any{lang.NewSymbol("do")})
									tmp211 := lang.Apply(tmp206, []any{tmp210, v143})
									tmp212 := lang.Apply(tmp203, []any{tmp211})
									tmp192 = tmp212
								} else {
									tmp213 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp214 := tmp213.FindInternedVar(lang.NewSymbol("first"))
									if tmp214.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp214)))
									}
									tmp215 := tmp214.Get()
									tmp216 := lang.Apply(tmp215, []any{v143})
									tmp192 = tmp216
								}
								tmp217 := lang.Apply(tmp191, []any{tmp192})
								tmp218 := lang.Apply(tmp184, []any{tmp188, tmp217})
								tmp219 := lang.Apply(tmp181, []any{tmp218})
								tmp220 := lang.Apply(tmp175, []any{tmp178, tmp219})
								tmp221 := lang.Apply(tmp172, []any{tmp220})
								tmp222 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp223 := tmp222.FindInternedVar(lang.NewSymbol("map"))
								if tmp223.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp223)))
								}
								tmp224 := tmp223.Get()
								var tmp225 lang.FnFunc
								tmp225 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v226 := args[0]
									_ = v226
									tmp227 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp228 := tmp227.FindInternedVar(lang.NewSymbol("seq"))
									if tmp228.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp228)))
									}
									tmp229 := tmp228.Get()
									tmp230 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp231 := tmp230.FindInternedVar(lang.NewSymbol("concat"))
									if tmp231.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp231)))
									}
									tmp232 := tmp231.Get()
									tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp234 := tmp233.FindInternedVar(lang.NewSymbol("list"))
									if tmp234.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
									}
									tmp235 := tmp234.Get()
									tmp236 := lang.Apply(tmp235, []any{lang.NewSymbol("glojure.core/assert")})
									tmp237 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp238 := tmp237.FindInternedVar(lang.NewSymbol("list"))
									if tmp238.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp238)))
									}
									tmp239 := tmp238.Get()
									tmp240 := lang.Apply(tmp239, []any{v226})
									tmp241 := lang.Apply(tmp232, []any{tmp236, tmp240})
									tmp242 := lang.Apply(tmp229, []any{tmp241})
									return tmp242
								})
								tmp226 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4582), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(4582), lang.NewKeyword("end-column"), int(62))
								tmp227, err := lang.WithMeta(tmp225, tmp226.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp228 := lang.Apply(tmp224, []any{tmp227, v149})
								tmp229 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp230 := tmp229.FindInternedVar(lang.NewSymbol("list"))
								if tmp230.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp230)))
								}
								tmp231 := tmp230.Get()
								tmp232 := lang.Apply(tmp231, []any{lang.NewSymbol("%")})
								tmp233 := lang.Apply(tmp165, []any{tmp169, tmp221, tmp228, tmp232})
								tmp234 := lang.Apply(tmp162, []any{tmp233})
								tmp235 := lang.Apply(tmp159, []any{tmp234})
								tmp236 := lang.Apply(tmp156, []any{tmp235})
								tmp237 := lang.Apply(tmp153, []any{tmp236})
								tmp150 = tmp237
							} else {
								tmp150 = v143
							}
							var v238 any = tmp150
							_ = v238
							// let binding "body"
							var tmp239 any
							if lang.IsTruthy(v147) {
								tmp240 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp241 := tmp240.FindInternedVar(lang.NewSymbol("concat"))
								if tmp241.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp241)))
								}
								tmp242 := tmp241.Get()
								tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp244 := tmp243.FindInternedVar(lang.NewSymbol("map"))
								if tmp244.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
								}
								tmp245 := tmp244.Get()
								var tmp246 lang.FnFunc
								tmp246 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v247 := args[0]
									_ = v247
									tmp248 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp249 := tmp248.FindInternedVar(lang.NewSymbol("seq"))
									if tmp249.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp249)))
									}
									tmp250 := tmp249.Get()
									tmp251 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp252 := tmp251.FindInternedVar(lang.NewSymbol("concat"))
									if tmp252.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp252)))
									}
									tmp253 := tmp252.Get()
									tmp254 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp255 := tmp254.FindInternedVar(lang.NewSymbol("list"))
									if tmp255.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp255)))
									}
									tmp256 := tmp255.Get()
									tmp257 := lang.Apply(tmp256, []any{lang.NewSymbol("glojure.core/assert")})
									tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp259 := tmp258.FindInternedVar(lang.NewSymbol("list"))
									if tmp259.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
									}
									tmp260 := tmp259.Get()
									tmp261 := lang.Apply(tmp260, []any{v247})
									tmp262 := lang.Apply(tmp253, []any{tmp257, tmp261})
									tmp263 := lang.Apply(tmp250, []any{tmp262})
									return tmp263
								})
								tmp247 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4586), lang.NewKeyword("column"), int(44), lang.NewKeyword("end-line"), int(4586), lang.NewKeyword("end-column"), int(65))
								tmp248, err := lang.WithMeta(tmp246, tmp247.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp249 := lang.Apply(tmp245, []any{tmp248, v147})
								tmp250 := lang.Apply(tmp242, []any{tmp249, v238})
								tmp239 = tmp250
							} else {
								tmp239 = v238
							}
							var v251 any = tmp239
							_ = v251
							tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp253 := tmp252.FindInternedVar(lang.NewSymbol("maybe-destructured"))
							if tmp253.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
							}
							tmp254 := tmp253.Get()
							tmp255 := lang.Apply(tmp254, []any{v101, v251})
							tmp84 = tmp255
						} // end let
						return tmp84
					})
					tmp69 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4558), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(4589), lang.NewKeyword("end-column"), int(53))
					tmp70, err := lang.WithMeta(tmp68, tmp69.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v71 any = tmp70
					_ = v71
					// let binding "new-sigs"
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("map"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{v71, v67})
					var v76 any = tmp75
					_ = v76
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					var tmp80 any
					if lang.IsTruthy(v20) {
						tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp82 := tmp81.FindInternedVar(lang.NewSymbol("list*"))
						if tmp82.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
						}
						tmp83 := tmp82.Get()
						tmp84 := lang.Apply(tmp83, []any{lang.NewSymbol("fn*"), v20, v76})
						tmp80 = tmp84
					} else {
						tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp86 := tmp85.FindInternedVar(lang.NewSymbol("cons"))
						if tmp86.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
						}
						tmp87 := tmp86.Get()
						tmp88 := lang.Apply(tmp87, []any{lang.NewSymbol("fn*"), v76})
						tmp80 = tmp88
					}
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("meta"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.Apply(tmp91, []any{v3})
					tmp93 := lang.Apply(tmp79, []any{tmp80, tmp92})
					tmp6 = tmp93
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fn?
	{
		tmp0 := lang.NewSymbol("fn?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements Fn, i.e. is an object created via fn.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6216), lang.NewKeyword("end-line"), int(6216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*runtime4.Fn)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnext
	{
		tmp0 := lang.NewSymbol("fnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(112), lang.NewKeyword("end-line"), int(116))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function fnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("first"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("next"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				return tmp12
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(116), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(116), lang.NewKeyword("end-column"), int(47))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// fnil
	{
		tmp0 := lang.NewSymbol("fnil").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"))), lang.NewKeyword("doc"), "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6558), lang.NewKeyword("end-line"), int(6558))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v6})
						if lang.IsTruthy(tmp11) {
							tmp7 = v4
						} else {
							tmp7 = v6
						}
						tmp12 := lang.Apply(v3, []any{tmp7})
						return tmp12
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v6})
						if lang.IsTruthy(tmp12) {
							tmp8 = v4
						} else {
							tmp8 = v6
						}
						tmp13 := lang.Apply(v3, []any{tmp8, v7})
						return tmp13
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var tmp9 any
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v6})
						if lang.IsTruthy(tmp13) {
							tmp9 = v4
						} else {
							tmp9 = v6
						}
						tmp14 := lang.Apply(v3, []any{tmp9, v7, v8})
						return tmp14
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						var tmp13 any
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v6})
						if lang.IsTruthy(tmp17) {
							tmp13 = v4
						} else {
							tmp13 = v6
						}
						tmp18 := lang.Apply(tmp12, []any{v3, tmp13, v7, v8, v9})
						return tmp18
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6567), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6571), lang.NewKeyword("end-column"), int(55))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						var tmp9 any
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v7})
						if lang.IsTruthy(tmp13) {
							tmp9 = v4
						} else {
							tmp9 = v7
						}
						var tmp14 any
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v8})
						if lang.IsTruthy(tmp18) {
							tmp14 = v5
						} else {
							tmp14 = v8
						}
						tmp19 := lang.Apply(v3, []any{tmp9, tmp14})
						return tmp19
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var tmp10 any
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v7})
						if lang.IsTruthy(tmp14) {
							tmp10 = v4
						} else {
							tmp10 = v7
						}
						var tmp15 any
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v8})
						if lang.IsTruthy(tmp19) {
							tmp15 = v5
						} else {
							tmp15 = v8
						}
						tmp20 := lang.Apply(v3, []any{tmp10, tmp15, v9})
						return tmp20
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("apply"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						var tmp14 any
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v7})
						if lang.IsTruthy(tmp18) {
							tmp14 = v4
						} else {
							tmp14 = v7
						}
						var tmp19 any
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v8})
						if lang.IsTruthy(tmp23) {
							tmp19 = v5
						} else {
							tmp19 = v8
						}
						tmp24 := lang.Apply(tmp13, []any{v3, tmp14, tmp19, v9, v10})
						return tmp24
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6573), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6576), lang.NewKeyword("end-column"), int(71))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						var tmp10 any
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v8})
						if lang.IsTruthy(tmp14) {
							tmp10 = v4
						} else {
							tmp10 = v8
						}
						var tmp15 any
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v9})
						if lang.IsTruthy(tmp19) {
							tmp15 = v5
						} else {
							tmp15 = v9
						}
						tmp20 := lang.Apply(v3, []any{tmp10, tmp15})
						return tmp20
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var tmp11 any
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v8})
						if lang.IsTruthy(tmp15) {
							tmp11 = v4
						} else {
							tmp11 = v8
						}
						var tmp16 any
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v9})
						if lang.IsTruthy(tmp20) {
							tmp16 = v5
						} else {
							tmp16 = v9
						}
						var tmp21 any
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v10})
						if lang.IsTruthy(tmp25) {
							tmp21 = v6
						} else {
							tmp21 = v10
						}
						tmp26 := lang.Apply(v3, []any{tmp11, tmp16, tmp21})
						return tmp26
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("apply"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						var tmp15 any
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v8})
						if lang.IsTruthy(tmp19) {
							tmp15 = v4
						} else {
							tmp15 = v8
						}
						var tmp20 any
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v9})
						if lang.IsTruthy(tmp24) {
							tmp20 = v5
						} else {
							tmp20 = v9
						}
						var tmp25 any
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("nil?"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.Apply(tmp28, []any{v10})
						if lang.IsTruthy(tmp29) {
							tmp25 = v6
						} else {
							tmp25 = v10
						}
						tmp30 := lang.Apply(tmp14, []any{v3, tmp15, tmp20, tmp25, v11})
						return tmp30
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6578), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(6581), lang.NewKeyword("end-column"), int(87))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// for
	{
		tmp0 := lang.NewSymbol("for").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("seq-exprs"), lang.NewSymbol("body-expr"))), lang.NewKeyword("doc"), "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4646), lang.NewKeyword("end-line"), int(4646))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v5})
			if lang.IsTruthy(tmp11) {
			} else {
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{v3})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
				tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
				tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
				panic(tmp28)
			}
			_ = tmp7
			var tmp29 any
			tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
			if tmp31.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
			}
			tmp32 := tmp31.Get()
			tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
			if tmp34.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
			}
			tmp35 := tmp34.Get()
			tmp36 := lang.Apply(tmp35, []any{v5})
			tmp37 := lang.Apply(tmp32, []any{tmp36})
			if lang.IsTruthy(tmp37) {
			} else {
				tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
				if tmp39.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
				}
				tmp40 := tmp39.Get()
				tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
				if tmp42.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
				}
				tmp43 := tmp42.Get()
				tmp44 := lang.Apply(tmp43, []any{v3})
				tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
				if tmp46.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
				}
				tmp47 := tmp46.Get()
				tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
				if tmp49.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
				}
				tmp50 := tmp49.Get()
				tmp51 := lang.Apply(tmp50, []any{v3})
				tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
				tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
				tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
				panic(tmp54)
			}
			_ = tmp29
			var tmp55 any
			{ // let
				// let binding "to-groups"
				var tmp56 lang.FnFunc
				tmp56 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v57 := args[0]
					_ = v57
					tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp59 := tmp58.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp59.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
					}
					tmp60 := tmp59.Get()
					var tmp61 lang.FnFunc
					tmp61 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v62 := args[0]
						_ = v62
						v63 := args[1]
						_ = v63
						var tmp64 any
						{ // let
							// let binding "vec__24"
							var v65 any = v63
							_ = v65
							// let binding "k"
							tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp67 := tmp66.FindInternedVar(lang.NewSymbol("nth"))
							if tmp67.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
							}
							tmp68 := tmp67.Get()
							tmp69 := lang.Apply(tmp68, []any{v65, int64(0), nil})
							var v70 any = tmp69
							_ = v70
							// let binding "v"
							tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp72 := tmp71.FindInternedVar(lang.NewSymbol("nth"))
							if tmp72.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
							}
							tmp73 := tmp72.Get()
							tmp74 := lang.Apply(tmp73, []any{v65, int64(1), nil})
							var v75 any = tmp74
							_ = v75
							var tmp76 any
							tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp78 := tmp77.FindInternedVar(lang.NewSymbol("keyword?"))
							if tmp78.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
							}
							tmp79 := tmp78.Get()
							tmp80 := lang.Apply(tmp79, []any{v70})
							if lang.IsTruthy(tmp80) {
								tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp82 := tmp81.FindInternedVar(lang.NewSymbol("conj"))
								if tmp82.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
								}
								tmp83 := tmp82.Get()
								tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp85 := tmp84.FindInternedVar(lang.NewSymbol("pop"))
								if tmp85.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
								}
								tmp86 := tmp85.Get()
								tmp87 := lang.Apply(tmp86, []any{v62})
								tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp89 := tmp88.FindInternedVar(lang.NewSymbol("conj"))
								if tmp89.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
								}
								tmp90 := tmp89.Get()
								tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp92 := tmp91.FindInternedVar(lang.NewSymbol("peek"))
								if tmp92.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
								}
								tmp93 := tmp92.Get()
								tmp94 := lang.Apply(tmp93, []any{v62})
								tmp95 := lang.NewVector(v70, v75)
								tmp96 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4664), lang.NewKeyword("column"), int(72), lang.NewKeyword("end-line"), int(4664), lang.NewKeyword("end-column"), int(76))
								tmp97, err := lang.WithMeta(tmp95, tmp96.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp98 := lang.Apply(tmp90, []any{tmp94, tmp97})
								tmp99 := lang.Apply(tmp83, []any{tmp87, tmp98})
								tmp76 = tmp99
							} else {
								tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp101 := tmp100.FindInternedVar(lang.NewSymbol("conj"))
								if tmp101.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
								}
								tmp102 := tmp101.Get()
								tmp103 := lang.NewVector(v70, v75)
								tmp104 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4665), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(4665), lang.NewKeyword("end-column"), int(50))
								tmp105, err := lang.WithMeta(tmp103, tmp104.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp106 := lang.Apply(tmp102, []any{v62, tmp105})
								tmp76 = tmp106
							}
							tmp64 = tmp76
						} // end let
						return tmp64
					})
					tmp62 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4662), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(4665), lang.NewKeyword("end-column"), int(53))
					tmp63, err := lang.WithMeta(tmp61, tmp62.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp64 := lang.NewVector()
					tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4666), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(4666), lang.NewKeyword("end-column"), int(30))
					tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("partition"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.Apply(tmp69, []any{int64(2), v57})
					tmp71 := lang.Apply(tmp60, []any{tmp63, tmp66, tmp70})
					return tmp71
				})
				tmp57 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4661), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4666), lang.NewKeyword("end-column"), int(56))
				tmp58, err := lang.WithMeta(tmp56, tmp57.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v59 any = tmp58
				_ = v59
				// let binding "err"
				var tmp60 lang.FnFunc
				tmp60 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v61 any = lang.NewList(args[0:]...)
						_ = v61
						tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp63 := tmp62.FindInternedVar(lang.NewSymbol("apply"))
						if tmp63.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
						}
						tmp64 := tmp63.Get()
						tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp66 := tmp65.FindInternedVar(lang.NewSymbol("str"))
						if tmp66.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
						}
						tmp67 := tmp66.Get()
						tmp68 := lang.Apply(tmp64, []any{tmp67, v61})
						tmp69 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp68})
						panic(tmp69)
					}
				})
				tmp61 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4667), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(4667), lang.NewKeyword("end-column"), int(125))
				tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v63 any = tmp62
				_ = v63
				// let binding "emit-bind"
				var tmp64 lang.FnFunc
				{ // function emit-bind
					var v65 lang.FnFunc
					tmp64 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v66 := args[0]
						_ = v66
						var tmp67 any
						{ // let
							// let binding "vec__28"
							var v68 any = v66
							_ = v68
							// let binding "seq__29"
							tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp70 := tmp69.FindInternedVar(lang.NewSymbol("seq"))
							if tmp70.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
							}
							tmp71 := tmp70.Get()
							tmp72 := lang.Apply(tmp71, []any{v68})
							var v73 any = tmp72
							_ = v73
							// let binding "first__30"
							tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp75 := tmp74.FindInternedVar(lang.NewSymbol("first"))
							if tmp75.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
							}
							tmp76 := tmp75.Get()
							tmp77 := lang.Apply(tmp76, []any{v73})
							var v78 any = tmp77
							_ = v78
							// let binding "seq__29"
							tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp80 := tmp79.FindInternedVar(lang.NewSymbol("next"))
							if tmp80.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
							}
							tmp81 := tmp80.Get()
							tmp82 := lang.Apply(tmp81, []any{v73})
							var v83 any = tmp82
							_ = v83
							// let binding "vec__31"
							var v84 any = v78
							_ = v84
							// let binding "seq__32"
							tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp86 := tmp85.FindInternedVar(lang.NewSymbol("seq"))
							if tmp86.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
							}
							tmp87 := tmp86.Get()
							tmp88 := lang.Apply(tmp87, []any{v84})
							var v89 any = tmp88
							_ = v89
							// let binding "first__33"
							tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp91 := tmp90.FindInternedVar(lang.NewSymbol("first"))
							if tmp91.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
							}
							tmp92 := tmp91.Get()
							tmp93 := lang.Apply(tmp92, []any{v89})
							var v94 any = tmp93
							_ = v94
							// let binding "seq__32"
							tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp96 := tmp95.FindInternedVar(lang.NewSymbol("next"))
							if tmp96.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
							}
							tmp97 := tmp96.Get()
							tmp98 := lang.Apply(tmp97, []any{v89})
							var v99 any = tmp98
							_ = v99
							// let binding "bind"
							var v100 any = v94
							_ = v100
							// let binding "first__33"
							tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp102 := tmp101.FindInternedVar(lang.NewSymbol("first"))
							if tmp102.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
							}
							tmp103 := tmp102.Get()
							tmp104 := lang.Apply(tmp103, []any{v99})
							var v105 any = tmp104
							_ = v105
							// let binding "seq__32"
							tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp107 := tmp106.FindInternedVar(lang.NewSymbol("next"))
							if tmp107.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
							}
							tmp108 := tmp107.Get()
							tmp109 := lang.Apply(tmp108, []any{v99})
							var v110 any = tmp109
							_ = v110
							// let binding "expr"
							var v111 any = v105
							_ = v111
							// let binding "mod-pairs"
							var v112 any = v110
							_ = v112
							// let binding "vec__34"
							var v113 any = v83
							_ = v113
							// let binding "vec__37"
							tmp114 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp115 := tmp114.FindInternedVar(lang.NewSymbol("nth"))
							if tmp115.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp115)))
							}
							tmp116 := tmp115.Get()
							tmp117 := lang.Apply(tmp116, []any{v113, int64(0), nil})
							var v118 any = tmp117
							_ = v118
							// let binding "_"
							tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp120 := tmp119.FindInternedVar(lang.NewSymbol("nth"))
							if tmp120.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
							}
							tmp121 := tmp120.Get()
							tmp122 := lang.Apply(tmp121, []any{v118, int64(0), nil})
							var v123 any = tmp122
							_ = v123
							// let binding "next-expr"
							tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp125 := tmp124.FindInternedVar(lang.NewSymbol("nth"))
							if tmp125.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
							}
							tmp126 := tmp125.Get()
							tmp127 := lang.Apply(tmp126, []any{v118, int64(1), nil})
							var v128 any = tmp127
							_ = v128
							// let binding "next-groups"
							var v129 any = v113
							_ = v129
							var tmp130 any
							{ // let
								// let binding "giter"
								tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp132 := tmp131.FindInternedVar(lang.NewSymbol("gensym"))
								if tmp132.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
								}
								tmp133 := tmp132.Get()
								tmp134 := lang.Apply(tmp133, []any{"iter__"})
								var v135 any = tmp134
								_ = v135
								// let binding "gxs"
								tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp137 := tmp136.FindInternedVar(lang.NewSymbol("gensym"))
								if tmp137.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
								}
								tmp138 := tmp137.Get()
								tmp139 := lang.Apply(tmp138, []any{"s__"})
								var v140 any = tmp139
								_ = v140
								// let binding "do-mod"
								var tmp141 lang.FnFunc
								{ // function do-mod
									var v142 lang.FnFunc
									tmp141 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v143 := args[0]
										_ = v143
										var tmp144 any
										{ // let
											// let binding "vec__41"
											var v145 any = v143
											_ = v145
											// let binding "seq__42"
											tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp147 := tmp146.FindInternedVar(lang.NewSymbol("seq"))
											if tmp147.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
											}
											tmp148 := tmp147.Get()
											tmp149 := lang.Apply(tmp148, []any{v145})
											var v150 any = tmp149
											_ = v150
											// let binding "first__43"
											tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp152 := tmp151.FindInternedVar(lang.NewSymbol("first"))
											if tmp152.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
											}
											tmp153 := tmp152.Get()
											tmp154 := lang.Apply(tmp153, []any{v150})
											var v155 any = tmp154
											_ = v155
											// let binding "seq__42"
											tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp157 := tmp156.FindInternedVar(lang.NewSymbol("next"))
											if tmp157.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
											}
											tmp158 := tmp157.Get()
											tmp159 := lang.Apply(tmp158, []any{v150})
											var v160 any = tmp159
											_ = v160
											// let binding "vec__44"
											var v161 any = v155
											_ = v161
											// let binding "k"
											tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp163 := tmp162.FindInternedVar(lang.NewSymbol("nth"))
											if tmp163.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
											}
											tmp164 := tmp163.Get()
											tmp165 := lang.Apply(tmp164, []any{v161, int64(0), nil})
											var v166 any = tmp165
											_ = v166
											// let binding "v"
											tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp168 := tmp167.FindInternedVar(lang.NewSymbol("nth"))
											if tmp168.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
											}
											tmp169 := tmp168.Get()
											tmp170 := lang.Apply(tmp169, []any{v161, int64(1), nil})
											var v171 any = tmp170
											_ = v171
											// let binding "pair"
											var v172 any = v161
											_ = v172
											// let binding "etc"
											var v173 any = v160
											_ = v173
											var tmp174 any
											tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp176 := tmp175.FindInternedVar(lang.NewSymbol("="))
											if tmp176.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
											}
											tmp177 := tmp176.Get()
											tmp178 := lang.Apply(tmp177, []any{v166, lang.NewKeyword("let")})
											if lang.IsTruthy(tmp178) {
												tmp179 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp180 := tmp179.FindInternedVar(lang.NewSymbol("seq"))
												if tmp180.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp180)))
												}
												tmp181 := tmp180.Get()
												tmp182 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp183 := tmp182.FindInternedVar(lang.NewSymbol("concat"))
												if tmp183.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp183)))
												}
												tmp184 := tmp183.Get()
												tmp185 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp186 := tmp185.FindInternedVar(lang.NewSymbol("list"))
												if tmp186.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp186)))
												}
												tmp187 := tmp186.Get()
												tmp188 := lang.Apply(tmp187, []any{lang.NewSymbol("glojure.core/let")})
												tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp190 := tmp189.FindInternedVar(lang.NewSymbol("list"))
												if tmp190.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
												}
												tmp191 := tmp190.Get()
												tmp192 := lang.Apply(tmp191, []any{v171})
												tmp193 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp194 := tmp193.FindInternedVar(lang.NewSymbol("list"))
												if tmp194.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp194)))
												}
												tmp195 := tmp194.Get()
												tmp196 := lang.Apply(v142, []any{v173})
												tmp197 := lang.Apply(tmp195, []any{tmp196})
												tmp198 := lang.Apply(tmp184, []any{tmp188, tmp192, tmp197})
												tmp199 := lang.Apply(tmp181, []any{tmp198})
												tmp174 = tmp199
											} else {
												var tmp200 any
												tmp201 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp202 := tmp201.FindInternedVar(lang.NewSymbol("="))
												if tmp202.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp202)))
												}
												tmp203 := tmp202.Get()
												tmp204 := lang.Apply(tmp203, []any{v166, lang.NewKeyword("while")})
												if lang.IsTruthy(tmp204) {
													tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp206 := tmp205.FindInternedVar(lang.NewSymbol("seq"))
													if tmp206.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
													}
													tmp207 := tmp206.Get()
													tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp209 := tmp208.FindInternedVar(lang.NewSymbol("concat"))
													if tmp209.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
													}
													tmp210 := tmp209.Get()
													tmp211 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp212 := tmp211.FindInternedVar(lang.NewSymbol("list"))
													if tmp212.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp212)))
													}
													tmp213 := tmp212.Get()
													tmp214 := lang.Apply(tmp213, []any{lang.NewSymbol("glojure.core/when")})
													tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp216 := tmp215.FindInternedVar(lang.NewSymbol("list"))
													if tmp216.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
													}
													tmp217 := tmp216.Get()
													tmp218 := lang.Apply(tmp217, []any{v171})
													tmp219 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp220 := tmp219.FindInternedVar(lang.NewSymbol("list"))
													if tmp220.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp220)))
													}
													tmp221 := tmp220.Get()
													tmp222 := lang.Apply(v142, []any{v173})
													tmp223 := lang.Apply(tmp221, []any{tmp222})
													tmp224 := lang.Apply(tmp210, []any{tmp214, tmp218, tmp223})
													tmp225 := lang.Apply(tmp207, []any{tmp224})
													tmp200 = tmp225
												} else {
													var tmp226 any
													tmp227 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp228 := tmp227.FindInternedVar(lang.NewSymbol("="))
													if tmp228.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp228)))
													}
													tmp229 := tmp228.Get()
													tmp230 := lang.Apply(tmp229, []any{v166, lang.NewKeyword("when")})
													if lang.IsTruthy(tmp230) {
														tmp231 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp232 := tmp231.FindInternedVar(lang.NewSymbol("seq"))
														if tmp232.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp232)))
														}
														tmp233 := tmp232.Get()
														tmp234 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp235 := tmp234.FindInternedVar(lang.NewSymbol("concat"))
														if tmp235.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp235)))
														}
														tmp236 := tmp235.Get()
														tmp237 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp238 := tmp237.FindInternedVar(lang.NewSymbol("list"))
														if tmp238.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp238)))
														}
														tmp239 := tmp238.Get()
														tmp240 := lang.Apply(tmp239, []any{lang.NewSymbol("if")})
														tmp241 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp242 := tmp241.FindInternedVar(lang.NewSymbol("list"))
														if tmp242.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp242)))
														}
														tmp243 := tmp242.Get()
														tmp244 := lang.Apply(tmp243, []any{v171})
														tmp245 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp246 := tmp245.FindInternedVar(lang.NewSymbol("list"))
														if tmp246.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp246)))
														}
														tmp247 := tmp246.Get()
														tmp248 := lang.Apply(v142, []any{v173})
														tmp249 := lang.Apply(tmp247, []any{tmp248})
														tmp250 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp251 := tmp250.FindInternedVar(lang.NewSymbol("list"))
														if tmp251.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp251)))
														}
														tmp252 := tmp251.Get()
														tmp253 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp254 := tmp253.FindInternedVar(lang.NewSymbol("seq"))
														if tmp254.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp254)))
														}
														tmp255 := tmp254.Get()
														tmp256 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp257 := tmp256.FindInternedVar(lang.NewSymbol("concat"))
														if tmp257.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp257)))
														}
														tmp258 := tmp257.Get()
														tmp259 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp260 := tmp259.FindInternedVar(lang.NewSymbol("list"))
														if tmp260.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp260)))
														}
														tmp261 := tmp260.Get()
														tmp262 := lang.Apply(tmp261, []any{lang.NewSymbol("recur")})
														tmp263 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp264 := tmp263.FindInternedVar(lang.NewSymbol("list"))
														if tmp264.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp264)))
														}
														tmp265 := tmp264.Get()
														tmp266 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp267 := tmp266.FindInternedVar(lang.NewSymbol("seq"))
														if tmp267.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp267)))
														}
														tmp268 := tmp267.Get()
														tmp269 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp270 := tmp269.FindInternedVar(lang.NewSymbol("concat"))
														if tmp270.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp270)))
														}
														tmp271 := tmp270.Get()
														tmp272 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp273 := tmp272.FindInternedVar(lang.NewSymbol("list"))
														if tmp273.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp273)))
														}
														tmp274 := tmp273.Get()
														tmp275 := lang.Apply(tmp274, []any{lang.NewSymbol("glojure.core/rest")})
														tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp277 := tmp276.FindInternedVar(lang.NewSymbol("list"))
														if tmp277.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
														}
														tmp278 := tmp277.Get()
														tmp279 := lang.Apply(tmp278, []any{v140})
														tmp280 := lang.Apply(tmp271, []any{tmp275, tmp279})
														tmp281 := lang.Apply(tmp268, []any{tmp280})
														tmp282 := lang.Apply(tmp265, []any{tmp281})
														tmp283 := lang.Apply(tmp258, []any{tmp262, tmp282})
														tmp284 := lang.Apply(tmp255, []any{tmp283})
														tmp285 := lang.Apply(tmp252, []any{tmp284})
														tmp286 := lang.Apply(tmp236, []any{tmp240, tmp244, tmp249, tmp285})
														tmp287 := lang.Apply(tmp233, []any{tmp286})
														tmp226 = tmp287
													} else {
														var tmp288 any
														tmp289 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp290 := tmp289.FindInternedVar(lang.NewSymbol("keyword?"))
														if tmp290.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp290)))
														}
														tmp291 := tmp290.Get()
														tmp292 := lang.Apply(tmp291, []any{v166})
														if lang.IsTruthy(tmp292) {
															tmp293 := lang.Apply(v63, []any{"Invalid 'for' keyword ", v166})
															tmp288 = tmp293
														} else {
															var tmp294 any
															if lang.IsTruthy(v129) {
																tmp295 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp296 := tmp295.FindInternedVar(lang.NewSymbol("seq"))
																if tmp296.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp296)))
																}
																tmp297 := tmp296.Get()
																tmp298 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp299 := tmp298.FindInternedVar(lang.NewSymbol("concat"))
																if tmp299.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp299)))
																}
																tmp300 := tmp299.Get()
																tmp301 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp302 := tmp301.FindInternedVar(lang.NewSymbol("list"))
																if tmp302.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp302)))
																}
																tmp303 := tmp302.Get()
																tmp304 := lang.Apply(tmp303, []any{lang.NewSymbol("glojure.core/let")})
																tmp305 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp306 := tmp305.FindInternedVar(lang.NewSymbol("list"))
																if tmp306.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp306)))
																}
																tmp307 := tmp306.Get()
																tmp308 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp309 := tmp308.FindInternedVar(lang.NewSymbol("apply"))
																if tmp309.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp309)))
																}
																tmp310 := tmp309.Get()
																tmp311 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp312 := tmp311.FindInternedVar(lang.NewSymbol("vector"))
																if tmp312.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp312)))
																}
																tmp313 := tmp312.Get()
																tmp314 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp315 := tmp314.FindInternedVar(lang.NewSymbol("seq"))
																if tmp315.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp315)))
																}
																tmp316 := tmp315.Get()
																tmp317 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp318 := tmp317.FindInternedVar(lang.NewSymbol("concat"))
																if tmp318.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp318)))
																}
																tmp319 := tmp318.Get()
																tmp320 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp321 := tmp320.FindInternedVar(lang.NewSymbol("list"))
																if tmp321.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp321)))
																}
																tmp322 := tmp321.Get()
																tmp323 := lang.Apply(tmp322, []any{lang.NewSymbol("iterys__0__auto__")})
																tmp324 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp325 := tmp324.FindInternedVar(lang.NewSymbol("list"))
																if tmp325.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp325)))
																}
																tmp326 := tmp325.Get()
																tmp327 := lang.Apply(v65, []any{v129})
																tmp328 := lang.Apply(tmp326, []any{tmp327})
																tmp329 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp330 := tmp329.FindInternedVar(lang.NewSymbol("list"))
																if tmp330.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp330)))
																}
																tmp331 := tmp330.Get()
																tmp332 := lang.Apply(tmp331, []any{lang.NewSymbol("fs__1__auto__")})
																tmp333 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp334 := tmp333.FindInternedVar(lang.NewSymbol("list"))
																if tmp334.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp334)))
																}
																tmp335 := tmp334.Get()
																tmp336 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp337 := tmp336.FindInternedVar(lang.NewSymbol("seq"))
																if tmp337.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp337)))
																}
																tmp338 := tmp337.Get()
																tmp339 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp340 := tmp339.FindInternedVar(lang.NewSymbol("concat"))
																if tmp340.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp340)))
																}
																tmp341 := tmp340.Get()
																tmp342 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp343 := tmp342.FindInternedVar(lang.NewSymbol("list"))
																if tmp343.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp343)))
																}
																tmp344 := tmp343.Get()
																tmp345 := lang.Apply(tmp344, []any{lang.NewSymbol("glojure.core/seq")})
																tmp346 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp347 := tmp346.FindInternedVar(lang.NewSymbol("list"))
																if tmp347.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp347)))
																}
																tmp348 := tmp347.Get()
																tmp349 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp350 := tmp349.FindInternedVar(lang.NewSymbol("seq"))
																if tmp350.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp350)))
																}
																tmp351 := tmp350.Get()
																tmp352 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp353 := tmp352.FindInternedVar(lang.NewSymbol("concat"))
																if tmp353.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp353)))
																}
																tmp354 := tmp353.Get()
																tmp355 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp356 := tmp355.FindInternedVar(lang.NewSymbol("list"))
																if tmp356.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp356)))
																}
																tmp357 := tmp356.Get()
																tmp358 := lang.Apply(tmp357, []any{lang.NewSymbol("iterys__0__auto__")})
																tmp359 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp360 := tmp359.FindInternedVar(lang.NewSymbol("list"))
																if tmp360.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp360)))
																}
																tmp361 := tmp360.Get()
																tmp362 := lang.Apply(tmp361, []any{v128})
																tmp363 := lang.Apply(tmp354, []any{tmp358, tmp362})
																tmp364 := lang.Apply(tmp351, []any{tmp363})
																tmp365 := lang.Apply(tmp348, []any{tmp364})
																tmp366 := lang.Apply(tmp341, []any{tmp345, tmp365})
																tmp367 := lang.Apply(tmp338, []any{tmp366})
																tmp368 := lang.Apply(tmp335, []any{tmp367})
																tmp369 := lang.Apply(tmp319, []any{tmp323, tmp328, tmp332, tmp368})
																tmp370 := lang.Apply(tmp316, []any{tmp369})
																tmp371 := lang.Apply(tmp310, []any{tmp313, tmp370})
																tmp372 := lang.Apply(tmp307, []any{tmp371})
																tmp373 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp374 := tmp373.FindInternedVar(lang.NewSymbol("list"))
																if tmp374.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp374)))
																}
																tmp375 := tmp374.Get()
																tmp376 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp377 := tmp376.FindInternedVar(lang.NewSymbol("seq"))
																if tmp377.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp377)))
																}
																tmp378 := tmp377.Get()
																tmp379 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp380 := tmp379.FindInternedVar(lang.NewSymbol("concat"))
																if tmp380.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp380)))
																}
																tmp381 := tmp380.Get()
																tmp382 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp383 := tmp382.FindInternedVar(lang.NewSymbol("list"))
																if tmp383.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp383)))
																}
																tmp384 := tmp383.Get()
																tmp385 := lang.Apply(tmp384, []any{lang.NewSymbol("if")})
																tmp386 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp387 := tmp386.FindInternedVar(lang.NewSymbol("list"))
																if tmp387.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp387)))
																}
																tmp388 := tmp387.Get()
																tmp389 := lang.Apply(tmp388, []any{lang.NewSymbol("fs__1__auto__")})
																tmp390 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp391 := tmp390.FindInternedVar(lang.NewSymbol("list"))
																if tmp391.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp391)))
																}
																tmp392 := tmp391.Get()
																tmp393 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp394 := tmp393.FindInternedVar(lang.NewSymbol("seq"))
																if tmp394.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp394)))
																}
																tmp395 := tmp394.Get()
																tmp396 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp397 := tmp396.FindInternedVar(lang.NewSymbol("concat"))
																if tmp397.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp397)))
																}
																tmp398 := tmp397.Get()
																tmp399 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp400 := tmp399.FindInternedVar(lang.NewSymbol("list"))
																if tmp400.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp400)))
																}
																tmp401 := tmp400.Get()
																tmp402 := lang.Apply(tmp401, []any{lang.NewSymbol("glojure.core/concat")})
																tmp403 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp404 := tmp403.FindInternedVar(lang.NewSymbol("list"))
																if tmp404.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp404)))
																}
																tmp405 := tmp404.Get()
																tmp406 := lang.Apply(tmp405, []any{lang.NewSymbol("fs__1__auto__")})
																tmp407 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp408 := tmp407.FindInternedVar(lang.NewSymbol("list"))
																if tmp408.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp408)))
																}
																tmp409 := tmp408.Get()
																tmp410 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp411 := tmp410.FindInternedVar(lang.NewSymbol("seq"))
																if tmp411.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp411)))
																}
																tmp412 := tmp411.Get()
																tmp413 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp414 := tmp413.FindInternedVar(lang.NewSymbol("concat"))
																if tmp414.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp414)))
																}
																tmp415 := tmp414.Get()
																tmp416 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp417 := tmp416.FindInternedVar(lang.NewSymbol("list"))
																if tmp417.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp417)))
																}
																tmp418 := tmp417.Get()
																tmp419 := lang.Apply(tmp418, []any{v135})
																tmp420 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp421 := tmp420.FindInternedVar(lang.NewSymbol("list"))
																if tmp421.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp421)))
																}
																tmp422 := tmp421.Get()
																tmp423 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp424 := tmp423.FindInternedVar(lang.NewSymbol("seq"))
																if tmp424.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp424)))
																}
																tmp425 := tmp424.Get()
																tmp426 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp427 := tmp426.FindInternedVar(lang.NewSymbol("concat"))
																if tmp427.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp427)))
																}
																tmp428 := tmp427.Get()
																tmp429 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp430 := tmp429.FindInternedVar(lang.NewSymbol("list"))
																if tmp430.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp430)))
																}
																tmp431 := tmp430.Get()
																tmp432 := lang.Apply(tmp431, []any{lang.NewSymbol("glojure.core/rest")})
																tmp433 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp434 := tmp433.FindInternedVar(lang.NewSymbol("list"))
																if tmp434.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp434)))
																}
																tmp435 := tmp434.Get()
																tmp436 := lang.Apply(tmp435, []any{v140})
																tmp437 := lang.Apply(tmp428, []any{tmp432, tmp436})
																tmp438 := lang.Apply(tmp425, []any{tmp437})
																tmp439 := lang.Apply(tmp422, []any{tmp438})
																tmp440 := lang.Apply(tmp415, []any{tmp419, tmp439})
																tmp441 := lang.Apply(tmp412, []any{tmp440})
																tmp442 := lang.Apply(tmp409, []any{tmp441})
																tmp443 := lang.Apply(tmp398, []any{tmp402, tmp406, tmp442})
																tmp444 := lang.Apply(tmp395, []any{tmp443})
																tmp445 := lang.Apply(tmp392, []any{tmp444})
																tmp446 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp447 := tmp446.FindInternedVar(lang.NewSymbol("list"))
																if tmp447.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp447)))
																}
																tmp448 := tmp447.Get()
																tmp449 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp450 := tmp449.FindInternedVar(lang.NewSymbol("seq"))
																if tmp450.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp450)))
																}
																tmp451 := tmp450.Get()
																tmp452 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp453 := tmp452.FindInternedVar(lang.NewSymbol("concat"))
																if tmp453.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp453)))
																}
																tmp454 := tmp453.Get()
																tmp455 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp456 := tmp455.FindInternedVar(lang.NewSymbol("list"))
																if tmp456.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp456)))
																}
																tmp457 := tmp456.Get()
																tmp458 := lang.Apply(tmp457, []any{lang.NewSymbol("recur")})
																tmp459 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp460 := tmp459.FindInternedVar(lang.NewSymbol("list"))
																if tmp460.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp460)))
																}
																tmp461 := tmp460.Get()
																tmp462 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp463 := tmp462.FindInternedVar(lang.NewSymbol("seq"))
																if tmp463.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp463)))
																}
																tmp464 := tmp463.Get()
																tmp465 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp466 := tmp465.FindInternedVar(lang.NewSymbol("concat"))
																if tmp466.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp466)))
																}
																tmp467 := tmp466.Get()
																tmp468 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp469 := tmp468.FindInternedVar(lang.NewSymbol("list"))
																if tmp469.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp469)))
																}
																tmp470 := tmp469.Get()
																tmp471 := lang.Apply(tmp470, []any{lang.NewSymbol("glojure.core/rest")})
																tmp472 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp473 := tmp472.FindInternedVar(lang.NewSymbol("list"))
																if tmp473.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp473)))
																}
																tmp474 := tmp473.Get()
																tmp475 := lang.Apply(tmp474, []any{v140})
																tmp476 := lang.Apply(tmp467, []any{tmp471, tmp475})
																tmp477 := lang.Apply(tmp464, []any{tmp476})
																tmp478 := lang.Apply(tmp461, []any{tmp477})
																tmp479 := lang.Apply(tmp454, []any{tmp458, tmp478})
																tmp480 := lang.Apply(tmp451, []any{tmp479})
																tmp481 := lang.Apply(tmp448, []any{tmp480})
																tmp482 := lang.Apply(tmp381, []any{tmp385, tmp389, tmp445, tmp481})
																tmp483 := lang.Apply(tmp378, []any{tmp482})
																tmp484 := lang.Apply(tmp375, []any{tmp483})
																tmp485 := lang.Apply(tmp300, []any{tmp304, tmp372, tmp484})
																tmp486 := lang.Apply(tmp297, []any{tmp485})
																tmp294 = tmp486
															} else {
																var tmp487 any
																if lang.IsTruthy(lang.NewKeyword("else")) {
																	tmp488 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp489 := tmp488.FindInternedVar(lang.NewSymbol("seq"))
																	if tmp489.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp489)))
																	}
																	tmp490 := tmp489.Get()
																	tmp491 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp492 := tmp491.FindInternedVar(lang.NewSymbol("concat"))
																	if tmp492.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp492)))
																	}
																	tmp493 := tmp492.Get()
																	tmp494 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp495 := tmp494.FindInternedVar(lang.NewSymbol("list"))
																	if tmp495.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp495)))
																	}
																	tmp496 := tmp495.Get()
																	tmp497 := lang.Apply(tmp496, []any{lang.NewSymbol("glojure.core/cons")})
																	tmp498 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp499 := tmp498.FindInternedVar(lang.NewSymbol("list"))
																	if tmp499.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp499)))
																	}
																	tmp500 := tmp499.Get()
																	tmp501 := lang.Apply(tmp500, []any{v6})
																	tmp502 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp503 := tmp502.FindInternedVar(lang.NewSymbol("list"))
																	if tmp503.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp503)))
																	}
																	tmp504 := tmp503.Get()
																	tmp505 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp506 := tmp505.FindInternedVar(lang.NewSymbol("seq"))
																	if tmp506.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp506)))
																	}
																	tmp507 := tmp506.Get()
																	tmp508 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp509 := tmp508.FindInternedVar(lang.NewSymbol("concat"))
																	if tmp509.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp509)))
																	}
																	tmp510 := tmp509.Get()
																	tmp511 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp512 := tmp511.FindInternedVar(lang.NewSymbol("list"))
																	if tmp512.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp512)))
																	}
																	tmp513 := tmp512.Get()
																	tmp514 := lang.Apply(tmp513, []any{v135})
																	tmp515 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp516 := tmp515.FindInternedVar(lang.NewSymbol("list"))
																	if tmp516.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp516)))
																	}
																	tmp517 := tmp516.Get()
																	tmp518 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp519 := tmp518.FindInternedVar(lang.NewSymbol("seq"))
																	if tmp519.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp519)))
																	}
																	tmp520 := tmp519.Get()
																	tmp521 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp522 := tmp521.FindInternedVar(lang.NewSymbol("concat"))
																	if tmp522.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp522)))
																	}
																	tmp523 := tmp522.Get()
																	tmp524 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp525 := tmp524.FindInternedVar(lang.NewSymbol("list"))
																	if tmp525.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp525)))
																	}
																	tmp526 := tmp525.Get()
																	tmp527 := lang.Apply(tmp526, []any{lang.NewSymbol("glojure.core/rest")})
																	tmp528 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp529 := tmp528.FindInternedVar(lang.NewSymbol("list"))
																	if tmp529.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp529)))
																	}
																	tmp530 := tmp529.Get()
																	tmp531 := lang.Apply(tmp530, []any{v140})
																	tmp532 := lang.Apply(tmp523, []any{tmp527, tmp531})
																	tmp533 := lang.Apply(tmp520, []any{tmp532})
																	tmp534 := lang.Apply(tmp517, []any{tmp533})
																	tmp535 := lang.Apply(tmp510, []any{tmp514, tmp534})
																	tmp536 := lang.Apply(tmp507, []any{tmp535})
																	tmp537 := lang.Apply(tmp504, []any{tmp536})
																	tmp538 := lang.Apply(tmp493, []any{tmp497, tmp501, tmp537})
																	tmp539 := lang.Apply(tmp490, []any{tmp538})
																	tmp487 = tmp539
																} else {
																}
																tmp294 = tmp487
															}
															tmp288 = tmp294
														}
														tmp226 = tmp288
													}
													tmp200 = tmp226
												}
												tmp174 = tmp200
											}
											tmp144 = tmp174
										} // end let
										return tmp144
									})
									v142 = tmp141
									_ = v142
								}
								tmp142 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4672), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(4687), lang.NewKeyword("end-column"), int(73))
								tmp143, err := lang.WithMeta(tmp141, tmp142.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								var v144 any = tmp143
								_ = v144
								var tmp145 any
								if lang.IsTruthy(v129) {
									tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp147 := tmp146.FindInternedVar(lang.NewSymbol("seq"))
									if tmp147.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
									}
									tmp148 := tmp147.Get()
									tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp150 := tmp149.FindInternedVar(lang.NewSymbol("concat"))
									if tmp150.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
									}
									tmp151 := tmp150.Get()
									tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp153 := tmp152.FindInternedVar(lang.NewSymbol("list"))
									if tmp153.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
									}
									tmp154 := tmp153.Get()
									tmp155 := lang.Apply(tmp154, []any{lang.NewSymbol("glojure.core/fn")})
									tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp157 := tmp156.FindInternedVar(lang.NewSymbol("list"))
									if tmp157.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
									}
									tmp158 := tmp157.Get()
									tmp159 := lang.Apply(tmp158, []any{v135})
									tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp161 := tmp160.FindInternedVar(lang.NewSymbol("list"))
									if tmp161.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
									}
									tmp162 := tmp161.Get()
									tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp164 := tmp163.FindInternedVar(lang.NewSymbol("apply"))
									if tmp164.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
									}
									tmp165 := tmp164.Get()
									tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp167 := tmp166.FindInternedVar(lang.NewSymbol("vector"))
									if tmp167.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
									}
									tmp168 := tmp167.Get()
									tmp169 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp170 := tmp169.FindInternedVar(lang.NewSymbol("seq"))
									if tmp170.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp170)))
									}
									tmp171 := tmp170.Get()
									tmp172 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp173 := tmp172.FindInternedVar(lang.NewSymbol("concat"))
									if tmp173.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp173)))
									}
									tmp174 := tmp173.Get()
									tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp176 := tmp175.FindInternedVar(lang.NewSymbol("list"))
									if tmp176.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
									}
									tmp177 := tmp176.Get()
									tmp178 := lang.Apply(tmp177, []any{v140})
									tmp179 := lang.Apply(tmp174, []any{tmp178})
									tmp180 := lang.Apply(tmp171, []any{tmp179})
									tmp181 := lang.Apply(tmp165, []any{tmp168, tmp180})
									tmp182 := lang.Apply(tmp162, []any{tmp181})
									tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp184 := tmp183.FindInternedVar(lang.NewSymbol("list"))
									if tmp184.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
									}
									tmp185 := tmp184.Get()
									tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp187 := tmp186.FindInternedVar(lang.NewSymbol("seq"))
									if tmp187.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
									}
									tmp188 := tmp187.Get()
									tmp189 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp190 := tmp189.FindInternedVar(lang.NewSymbol("concat"))
									if tmp190.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp190)))
									}
									tmp191 := tmp190.Get()
									tmp192 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp193 := tmp192.FindInternedVar(lang.NewSymbol("list"))
									if tmp193.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp193)))
									}
									tmp194 := tmp193.Get()
									tmp195 := lang.Apply(tmp194, []any{lang.NewSymbol("glojure.core/lazy-seq")})
									tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp197 := tmp196.FindInternedVar(lang.NewSymbol("list"))
									if tmp197.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
									}
									tmp198 := tmp197.Get()
									tmp199 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp200 := tmp199.FindInternedVar(lang.NewSymbol("seq"))
									if tmp200.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp200)))
									}
									tmp201 := tmp200.Get()
									tmp202 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp203 := tmp202.FindInternedVar(lang.NewSymbol("concat"))
									if tmp203.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp203)))
									}
									tmp204 := tmp203.Get()
									tmp205 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp206 := tmp205.FindInternedVar(lang.NewSymbol("list"))
									if tmp206.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp206)))
									}
									tmp207 := tmp206.Get()
									tmp208 := lang.Apply(tmp207, []any{lang.NewSymbol("glojure.core/loop")})
									tmp209 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp210 := tmp209.FindInternedVar(lang.NewSymbol("list"))
									if tmp210.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp210)))
									}
									tmp211 := tmp210.Get()
									tmp212 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp213 := tmp212.FindInternedVar(lang.NewSymbol("apply"))
									if tmp213.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp213)))
									}
									tmp214 := tmp213.Get()
									tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp216 := tmp215.FindInternedVar(lang.NewSymbol("vector"))
									if tmp216.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
									}
									tmp217 := tmp216.Get()
									tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp219 := tmp218.FindInternedVar(lang.NewSymbol("seq"))
									if tmp219.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
									}
									tmp220 := tmp219.Get()
									tmp221 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp222 := tmp221.FindInternedVar(lang.NewSymbol("concat"))
									if tmp222.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp222)))
									}
									tmp223 := tmp222.Get()
									tmp224 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp225 := tmp224.FindInternedVar(lang.NewSymbol("list"))
									if tmp225.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp225)))
									}
									tmp226 := tmp225.Get()
									tmp227 := lang.Apply(tmp226, []any{v140})
									tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp229 := tmp228.FindInternedVar(lang.NewSymbol("list"))
									if tmp229.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
									}
									tmp230 := tmp229.Get()
									tmp231 := lang.Apply(tmp230, []any{v140})
									tmp232 := lang.Apply(tmp223, []any{tmp227, tmp231})
									tmp233 := lang.Apply(tmp220, []any{tmp232})
									tmp234 := lang.Apply(tmp214, []any{tmp217, tmp233})
									tmp235 := lang.Apply(tmp211, []any{tmp234})
									tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp237 := tmp236.FindInternedVar(lang.NewSymbol("list"))
									if tmp237.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
									}
									tmp238 := tmp237.Get()
									tmp239 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp240 := tmp239.FindInternedVar(lang.NewSymbol("seq"))
									if tmp240.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp240)))
									}
									tmp241 := tmp240.Get()
									tmp242 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp243 := tmp242.FindInternedVar(lang.NewSymbol("concat"))
									if tmp243.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp243)))
									}
									tmp244 := tmp243.Get()
									tmp245 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp246 := tmp245.FindInternedVar(lang.NewSymbol("list"))
									if tmp246.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp246)))
									}
									tmp247 := tmp246.Get()
									tmp248 := lang.Apply(tmp247, []any{lang.NewSymbol("glojure.core/when-first")})
									tmp249 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp250 := tmp249.FindInternedVar(lang.NewSymbol("list"))
									if tmp250.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp250)))
									}
									tmp251 := tmp250.Get()
									tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp253 := tmp252.FindInternedVar(lang.NewSymbol("apply"))
									if tmp253.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
									}
									tmp254 := tmp253.Get()
									tmp255 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp256 := tmp255.FindInternedVar(lang.NewSymbol("vector"))
									if tmp256.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp256)))
									}
									tmp257 := tmp256.Get()
									tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp259 := tmp258.FindInternedVar(lang.NewSymbol("seq"))
									if tmp259.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
									}
									tmp260 := tmp259.Get()
									tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp262 := tmp261.FindInternedVar(lang.NewSymbol("concat"))
									if tmp262.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
									}
									tmp263 := tmp262.Get()
									tmp264 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp265 := tmp264.FindInternedVar(lang.NewSymbol("list"))
									if tmp265.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp265)))
									}
									tmp266 := tmp265.Get()
									tmp267 := lang.Apply(tmp266, []any{v100})
									tmp268 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp269 := tmp268.FindInternedVar(lang.NewSymbol("list"))
									if tmp269.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp269)))
									}
									tmp270 := tmp269.Get()
									tmp271 := lang.Apply(tmp270, []any{v140})
									tmp272 := lang.Apply(tmp263, []any{tmp267, tmp271})
									tmp273 := lang.Apply(tmp260, []any{tmp272})
									tmp274 := lang.Apply(tmp254, []any{tmp257, tmp273})
									tmp275 := lang.Apply(tmp251, []any{tmp274})
									tmp276 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp277 := tmp276.FindInternedVar(lang.NewSymbol("list"))
									if tmp277.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp277)))
									}
									tmp278 := tmp277.Get()
									tmp279 := lang.Apply(v144, []any{v112})
									tmp280 := lang.Apply(tmp278, []any{tmp279})
									tmp281 := lang.Apply(tmp244, []any{tmp248, tmp275, tmp280})
									tmp282 := lang.Apply(tmp241, []any{tmp281})
									tmp283 := lang.Apply(tmp238, []any{tmp282})
									tmp284 := lang.Apply(tmp204, []any{tmp208, tmp235, tmp283})
									tmp285 := lang.Apply(tmp201, []any{tmp284})
									tmp286 := lang.Apply(tmp198, []any{tmp285})
									tmp287 := lang.Apply(tmp191, []any{tmp195, tmp286})
									tmp288 := lang.Apply(tmp188, []any{tmp287})
									tmp289 := lang.Apply(tmp185, []any{tmp288})
									tmp290 := lang.Apply(tmp151, []any{tmp155, tmp159, tmp182, tmp289})
									tmp291 := lang.Apply(tmp148, []any{tmp290})
									tmp145 = tmp291
								} else {
									var tmp292 any
									{ // let
										// let binding "gi"
										tmp293 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp294 := tmp293.FindInternedVar(lang.NewSymbol("gensym"))
										if tmp294.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp294)))
										}
										tmp295 := tmp294.Get()
										tmp296 := lang.Apply(tmp295, []any{"i__"})
										var v297 any = tmp296
										_ = v297
										// let binding "gb"
										tmp298 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp299 := tmp298.FindInternedVar(lang.NewSymbol("gensym"))
										if tmp299.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp299)))
										}
										tmp300 := tmp299.Get()
										tmp301 := lang.Apply(tmp300, []any{"b__"})
										var v302 any = tmp301
										_ = v302
										// let binding "do-cmod"
										var tmp303 lang.FnFunc
										{ // function do-cmod
											var v304 lang.FnFunc
											tmp303 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 1 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												v305 := args[0]
												_ = v305
												var tmp306 any
												{ // let
													// let binding "vec__48"
													var v307 any = v305
													_ = v307
													// let binding "seq__49"
													tmp308 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp309 := tmp308.FindInternedVar(lang.NewSymbol("seq"))
													if tmp309.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp309)))
													}
													tmp310 := tmp309.Get()
													tmp311 := lang.Apply(tmp310, []any{v307})
													var v312 any = tmp311
													_ = v312
													// let binding "first__50"
													tmp313 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp314 := tmp313.FindInternedVar(lang.NewSymbol("first"))
													if tmp314.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp314)))
													}
													tmp315 := tmp314.Get()
													tmp316 := lang.Apply(tmp315, []any{v312})
													var v317 any = tmp316
													_ = v317
													// let binding "seq__49"
													tmp318 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp319 := tmp318.FindInternedVar(lang.NewSymbol("next"))
													if tmp319.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp319)))
													}
													tmp320 := tmp319.Get()
													tmp321 := lang.Apply(tmp320, []any{v312})
													var v322 any = tmp321
													_ = v322
													// let binding "vec__51"
													var v323 any = v317
													_ = v323
													// let binding "k"
													tmp324 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp325 := tmp324.FindInternedVar(lang.NewSymbol("nth"))
													if tmp325.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp325)))
													}
													tmp326 := tmp325.Get()
													tmp327 := lang.Apply(tmp326, []any{v323, int64(0), nil})
													var v328 any = tmp327
													_ = v328
													// let binding "v"
													tmp329 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp330 := tmp329.FindInternedVar(lang.NewSymbol("nth"))
													if tmp330.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp330)))
													}
													tmp331 := tmp330.Get()
													tmp332 := lang.Apply(tmp331, []any{v323, int64(1), nil})
													var v333 any = tmp332
													_ = v333
													// let binding "pair"
													var v334 any = v323
													_ = v334
													// let binding "etc"
													var v335 any = v322
													_ = v335
													var tmp336 any
													tmp337 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp338 := tmp337.FindInternedVar(lang.NewSymbol("="))
													if tmp338.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp338)))
													}
													tmp339 := tmp338.Get()
													tmp340 := lang.Apply(tmp339, []any{v328, lang.NewKeyword("let")})
													if lang.IsTruthy(tmp340) {
														tmp341 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp342 := tmp341.FindInternedVar(lang.NewSymbol("seq"))
														if tmp342.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp342)))
														}
														tmp343 := tmp342.Get()
														tmp344 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp345 := tmp344.FindInternedVar(lang.NewSymbol("concat"))
														if tmp345.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp345)))
														}
														tmp346 := tmp345.Get()
														tmp347 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp348 := tmp347.FindInternedVar(lang.NewSymbol("list"))
														if tmp348.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp348)))
														}
														tmp349 := tmp348.Get()
														tmp350 := lang.Apply(tmp349, []any{lang.NewSymbol("glojure.core/let")})
														tmp351 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp352 := tmp351.FindInternedVar(lang.NewSymbol("list"))
														if tmp352.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp352)))
														}
														tmp353 := tmp352.Get()
														tmp354 := lang.Apply(tmp353, []any{v333})
														tmp355 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp356 := tmp355.FindInternedVar(lang.NewSymbol("list"))
														if tmp356.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp356)))
														}
														tmp357 := tmp356.Get()
														tmp358 := lang.Apply(v304, []any{v335})
														tmp359 := lang.Apply(tmp357, []any{tmp358})
														tmp360 := lang.Apply(tmp346, []any{tmp350, tmp354, tmp359})
														tmp361 := lang.Apply(tmp343, []any{tmp360})
														tmp336 = tmp361
													} else {
														var tmp362 any
														tmp363 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp364 := tmp363.FindInternedVar(lang.NewSymbol("="))
														if tmp364.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp364)))
														}
														tmp365 := tmp364.Get()
														tmp366 := lang.Apply(tmp365, []any{v328, lang.NewKeyword("while")})
														if lang.IsTruthy(tmp366) {
															tmp367 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp368 := tmp367.FindInternedVar(lang.NewSymbol("seq"))
															if tmp368.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp368)))
															}
															tmp369 := tmp368.Get()
															tmp370 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp371 := tmp370.FindInternedVar(lang.NewSymbol("concat"))
															if tmp371.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp371)))
															}
															tmp372 := tmp371.Get()
															tmp373 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp374 := tmp373.FindInternedVar(lang.NewSymbol("list"))
															if tmp374.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp374)))
															}
															tmp375 := tmp374.Get()
															tmp376 := lang.Apply(tmp375, []any{lang.NewSymbol("glojure.core/when")})
															tmp377 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp378 := tmp377.FindInternedVar(lang.NewSymbol("list"))
															if tmp378.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp378)))
															}
															tmp379 := tmp378.Get()
															tmp380 := lang.Apply(tmp379, []any{v333})
															tmp381 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp382 := tmp381.FindInternedVar(lang.NewSymbol("list"))
															if tmp382.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp382)))
															}
															tmp383 := tmp382.Get()
															tmp384 := lang.Apply(v304, []any{v335})
															tmp385 := lang.Apply(tmp383, []any{tmp384})
															tmp386 := lang.Apply(tmp372, []any{tmp376, tmp380, tmp385})
															tmp387 := lang.Apply(tmp369, []any{tmp386})
															tmp362 = tmp387
														} else {
															var tmp388 any
															tmp389 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp390 := tmp389.FindInternedVar(lang.NewSymbol("="))
															if tmp390.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp390)))
															}
															tmp391 := tmp390.Get()
															tmp392 := lang.Apply(tmp391, []any{v328, lang.NewKeyword("when")})
															if lang.IsTruthy(tmp392) {
																tmp393 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp394 := tmp393.FindInternedVar(lang.NewSymbol("seq"))
																if tmp394.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp394)))
																}
																tmp395 := tmp394.Get()
																tmp396 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp397 := tmp396.FindInternedVar(lang.NewSymbol("concat"))
																if tmp397.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp397)))
																}
																tmp398 := tmp397.Get()
																tmp399 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp400 := tmp399.FindInternedVar(lang.NewSymbol("list"))
																if tmp400.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp400)))
																}
																tmp401 := tmp400.Get()
																tmp402 := lang.Apply(tmp401, []any{lang.NewSymbol("if")})
																tmp403 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp404 := tmp403.FindInternedVar(lang.NewSymbol("list"))
																if tmp404.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp404)))
																}
																tmp405 := tmp404.Get()
																tmp406 := lang.Apply(tmp405, []any{v333})
																tmp407 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp408 := tmp407.FindInternedVar(lang.NewSymbol("list"))
																if tmp408.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp408)))
																}
																tmp409 := tmp408.Get()
																tmp410 := lang.Apply(v304, []any{v335})
																tmp411 := lang.Apply(tmp409, []any{tmp410})
																tmp412 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp413 := tmp412.FindInternedVar(lang.NewSymbol("list"))
																if tmp413.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp413)))
																}
																tmp414 := tmp413.Get()
																tmp415 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp416 := tmp415.FindInternedVar(lang.NewSymbol("seq"))
																if tmp416.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp416)))
																}
																tmp417 := tmp416.Get()
																tmp418 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp419 := tmp418.FindInternedVar(lang.NewSymbol("concat"))
																if tmp419.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp419)))
																}
																tmp420 := tmp419.Get()
																tmp421 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp422 := tmp421.FindInternedVar(lang.NewSymbol("list"))
																if tmp422.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp422)))
																}
																tmp423 := tmp422.Get()
																tmp424 := lang.Apply(tmp423, []any{lang.NewSymbol("recur")})
																tmp425 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp426 := tmp425.FindInternedVar(lang.NewSymbol("list"))
																if tmp426.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp426)))
																}
																tmp427 := tmp426.Get()
																tmp428 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp429 := tmp428.FindInternedVar(lang.NewSymbol("seq"))
																if tmp429.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp429)))
																}
																tmp430 := tmp429.Get()
																tmp431 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp432 := tmp431.FindInternedVar(lang.NewSymbol("concat"))
																if tmp432.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp432)))
																}
																tmp433 := tmp432.Get()
																tmp434 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp435 := tmp434.FindInternedVar(lang.NewSymbol("list"))
																if tmp435.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp435)))
																}
																tmp436 := tmp435.Get()
																tmp437 := lang.Apply(tmp436, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
																tmp438 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp439 := tmp438.FindInternedVar(lang.NewSymbol("list"))
																if tmp439.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp439)))
																}
																tmp440 := tmp439.Get()
																tmp441 := lang.Apply(tmp440, []any{v297})
																tmp442 := lang.Apply(tmp433, []any{tmp437, tmp441})
																tmp443 := lang.Apply(tmp430, []any{tmp442})
																tmp444 := lang.Apply(tmp427, []any{tmp443})
																tmp445 := lang.Apply(tmp420, []any{tmp424, tmp444})
																tmp446 := lang.Apply(tmp417, []any{tmp445})
																tmp447 := lang.Apply(tmp414, []any{tmp446})
																tmp448 := lang.Apply(tmp398, []any{tmp402, tmp406, tmp411, tmp447})
																tmp449 := lang.Apply(tmp395, []any{tmp448})
																tmp388 = tmp449
															} else {
																var tmp450 any
																tmp451 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp452 := tmp451.FindInternedVar(lang.NewSymbol("keyword?"))
																if tmp452.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp452)))
																}
																tmp453 := tmp452.Get()
																tmp454 := lang.Apply(tmp453, []any{v328})
																if lang.IsTruthy(tmp454) {
																	tmp455 := lang.Apply(v63, []any{"Invalid 'for' keyword ", v328})
																	tmp450 = tmp455
																} else {
																	var tmp456 any
																	if lang.IsTruthy(lang.NewKeyword("else")) {
																		tmp457 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp458 := tmp457.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp458.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp458)))
																		}
																		tmp459 := tmp458.Get()
																		tmp460 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp461 := tmp460.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp461.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp461)))
																		}
																		tmp462 := tmp461.Get()
																		tmp463 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp464 := tmp463.FindInternedVar(lang.NewSymbol("list"))
																		if tmp464.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp464)))
																		}
																		tmp465 := tmp464.Get()
																		tmp466 := lang.Apply(tmp465, []any{lang.NewSymbol("do")})
																		tmp467 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp468 := tmp467.FindInternedVar(lang.NewSymbol("list"))
																		if tmp468.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp468)))
																		}
																		tmp469 := tmp468.Get()
																		tmp470 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp471 := tmp470.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp471.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp471)))
																		}
																		tmp472 := tmp471.Get()
																		tmp473 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp474 := tmp473.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp474.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp474)))
																		}
																		tmp475 := tmp474.Get()
																		tmp476 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp477 := tmp476.FindInternedVar(lang.NewSymbol("list"))
																		if tmp477.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp477)))
																		}
																		tmp478 := tmp477.Get()
																		tmp479 := lang.Apply(tmp478, []any{lang.NewSymbol("glojure.core/chunk-append")})
																		tmp480 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp481 := tmp480.FindInternedVar(lang.NewSymbol("list"))
																		if tmp481.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp481)))
																		}
																		tmp482 := tmp481.Get()
																		tmp483 := lang.Apply(tmp482, []any{v302})
																		tmp484 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp485 := tmp484.FindInternedVar(lang.NewSymbol("list"))
																		if tmp485.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp485)))
																		}
																		tmp486 := tmp485.Get()
																		tmp487 := lang.Apply(tmp486, []any{v6})
																		tmp488 := lang.Apply(tmp475, []any{tmp479, tmp483, tmp487})
																		tmp489 := lang.Apply(tmp472, []any{tmp488})
																		tmp490 := lang.Apply(tmp469, []any{tmp489})
																		tmp491 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp492 := tmp491.FindInternedVar(lang.NewSymbol("list"))
																		if tmp492.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp492)))
																		}
																		tmp493 := tmp492.Get()
																		tmp494 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp495 := tmp494.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp495.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp495)))
																		}
																		tmp496 := tmp495.Get()
																		tmp497 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp498 := tmp497.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp498.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp498)))
																		}
																		tmp499 := tmp498.Get()
																		tmp500 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp501 := tmp500.FindInternedVar(lang.NewSymbol("list"))
																		if tmp501.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp501)))
																		}
																		tmp502 := tmp501.Get()
																		tmp503 := lang.Apply(tmp502, []any{lang.NewSymbol("recur")})
																		tmp504 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp505 := tmp504.FindInternedVar(lang.NewSymbol("list"))
																		if tmp505.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp505)))
																		}
																		tmp506 := tmp505.Get()
																		tmp507 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp508 := tmp507.FindInternedVar(lang.NewSymbol("seq"))
																		if tmp508.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp508)))
																		}
																		tmp509 := tmp508.Get()
																		tmp510 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp511 := tmp510.FindInternedVar(lang.NewSymbol("concat"))
																		if tmp511.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp511)))
																		}
																		tmp512 := tmp511.Get()
																		tmp513 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp514 := tmp513.FindInternedVar(lang.NewSymbol("list"))
																		if tmp514.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp514)))
																		}
																		tmp515 := tmp514.Get()
																		tmp516 := lang.Apply(tmp515, []any{lang.NewSymbol("glojure.core/unchecked-inc")})
																		tmp517 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																		tmp518 := tmp517.FindInternedVar(lang.NewSymbol("list"))
																		if tmp518.IsMacro() {
																			panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp518)))
																		}
																		tmp519 := tmp518.Get()
																		tmp520 := lang.Apply(tmp519, []any{v297})
																		tmp521 := lang.Apply(tmp512, []any{tmp516, tmp520})
																		tmp522 := lang.Apply(tmp509, []any{tmp521})
																		tmp523 := lang.Apply(tmp506, []any{tmp522})
																		tmp524 := lang.Apply(tmp499, []any{tmp503, tmp523})
																		tmp525 := lang.Apply(tmp496, []any{tmp524})
																		tmp526 := lang.Apply(tmp493, []any{tmp525})
																		tmp527 := lang.Apply(tmp462, []any{tmp466, tmp490, tmp526})
																		tmp528 := lang.Apply(tmp459, []any{tmp527})
																		tmp456 = tmp528
																	} else {
																	}
																	tmp450 = tmp456
																}
																tmp388 = tmp450
															}
															tmp362 = tmp388
														}
														tmp336 = tmp362
													}
													tmp306 = tmp336
												} // end let
												return tmp306
											})
											v304 = tmp303
											_ = v304
										}
										tmp304 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4698), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(4710), lang.NewKeyword("end-column"), int(79))
										tmp305, err := lang.WithMeta(tmp303, tmp304.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										var v306 any = tmp305
										_ = v306
										tmp307 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp308 := tmp307.FindInternedVar(lang.NewSymbol("seq"))
										if tmp308.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp308)))
										}
										tmp309 := tmp308.Get()
										tmp310 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp311 := tmp310.FindInternedVar(lang.NewSymbol("concat"))
										if tmp311.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp311)))
										}
										tmp312 := tmp311.Get()
										tmp313 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp314 := tmp313.FindInternedVar(lang.NewSymbol("list"))
										if tmp314.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp314)))
										}
										tmp315 := tmp314.Get()
										tmp316 := lang.Apply(tmp315, []any{lang.NewSymbol("glojure.core/fn")})
										tmp317 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp318 := tmp317.FindInternedVar(lang.NewSymbol("list"))
										if tmp318.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp318)))
										}
										tmp319 := tmp318.Get()
										tmp320 := lang.Apply(tmp319, []any{v135})
										tmp321 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp322 := tmp321.FindInternedVar(lang.NewSymbol("list"))
										if tmp322.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp322)))
										}
										tmp323 := tmp322.Get()
										tmp324 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp325 := tmp324.FindInternedVar(lang.NewSymbol("apply"))
										if tmp325.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp325)))
										}
										tmp326 := tmp325.Get()
										tmp327 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp328 := tmp327.FindInternedVar(lang.NewSymbol("vector"))
										if tmp328.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp328)))
										}
										tmp329 := tmp328.Get()
										tmp330 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp331 := tmp330.FindInternedVar(lang.NewSymbol("seq"))
										if tmp331.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp331)))
										}
										tmp332 := tmp331.Get()
										tmp333 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp334 := tmp333.FindInternedVar(lang.NewSymbol("concat"))
										if tmp334.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp334)))
										}
										tmp335 := tmp334.Get()
										tmp336 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp337 := tmp336.FindInternedVar(lang.NewSymbol("list"))
										if tmp337.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp337)))
										}
										tmp338 := tmp337.Get()
										tmp339 := lang.Apply(tmp338, []any{v140})
										tmp340 := lang.Apply(tmp335, []any{tmp339})
										tmp341 := lang.Apply(tmp332, []any{tmp340})
										tmp342 := lang.Apply(tmp326, []any{tmp329, tmp341})
										tmp343 := lang.Apply(tmp323, []any{tmp342})
										tmp344 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp345 := tmp344.FindInternedVar(lang.NewSymbol("list"))
										if tmp345.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp345)))
										}
										tmp346 := tmp345.Get()
										tmp347 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp348 := tmp347.FindInternedVar(lang.NewSymbol("seq"))
										if tmp348.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp348)))
										}
										tmp349 := tmp348.Get()
										tmp350 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp351 := tmp350.FindInternedVar(lang.NewSymbol("concat"))
										if tmp351.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp351)))
										}
										tmp352 := tmp351.Get()
										tmp353 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp354 := tmp353.FindInternedVar(lang.NewSymbol("list"))
										if tmp354.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp354)))
										}
										tmp355 := tmp354.Get()
										tmp356 := lang.Apply(tmp355, []any{lang.NewSymbol("glojure.core/lazy-seq")})
										tmp357 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp358 := tmp357.FindInternedVar(lang.NewSymbol("list"))
										if tmp358.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp358)))
										}
										tmp359 := tmp358.Get()
										tmp360 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp361 := tmp360.FindInternedVar(lang.NewSymbol("seq"))
										if tmp361.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp361)))
										}
										tmp362 := tmp361.Get()
										tmp363 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp364 := tmp363.FindInternedVar(lang.NewSymbol("concat"))
										if tmp364.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp364)))
										}
										tmp365 := tmp364.Get()
										tmp366 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp367 := tmp366.FindInternedVar(lang.NewSymbol("list"))
										if tmp367.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp367)))
										}
										tmp368 := tmp367.Get()
										tmp369 := lang.Apply(tmp368, []any{lang.NewSymbol("glojure.core/loop")})
										tmp370 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp371 := tmp370.FindInternedVar(lang.NewSymbol("list"))
										if tmp371.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp371)))
										}
										tmp372 := tmp371.Get()
										tmp373 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp374 := tmp373.FindInternedVar(lang.NewSymbol("apply"))
										if tmp374.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp374)))
										}
										tmp375 := tmp374.Get()
										tmp376 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp377 := tmp376.FindInternedVar(lang.NewSymbol("vector"))
										if tmp377.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp377)))
										}
										tmp378 := tmp377.Get()
										tmp379 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp380 := tmp379.FindInternedVar(lang.NewSymbol("seq"))
										if tmp380.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp380)))
										}
										tmp381 := tmp380.Get()
										tmp382 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp383 := tmp382.FindInternedVar(lang.NewSymbol("concat"))
										if tmp383.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp383)))
										}
										tmp384 := tmp383.Get()
										tmp385 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp386 := tmp385.FindInternedVar(lang.NewSymbol("list"))
										if tmp386.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp386)))
										}
										tmp387 := tmp386.Get()
										tmp388 := lang.Apply(tmp387, []any{v140})
										tmp389 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp390 := tmp389.FindInternedVar(lang.NewSymbol("list"))
										if tmp390.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp390)))
										}
										tmp391 := tmp390.Get()
										tmp392 := lang.Apply(tmp391, []any{v140})
										tmp393 := lang.Apply(tmp384, []any{tmp388, tmp392})
										tmp394 := lang.Apply(tmp381, []any{tmp393})
										tmp395 := lang.Apply(tmp375, []any{tmp378, tmp394})
										tmp396 := lang.Apply(tmp372, []any{tmp395})
										tmp397 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp398 := tmp397.FindInternedVar(lang.NewSymbol("list"))
										if tmp398.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp398)))
										}
										tmp399 := tmp398.Get()
										tmp400 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp401 := tmp400.FindInternedVar(lang.NewSymbol("seq"))
										if tmp401.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp401)))
										}
										tmp402 := tmp401.Get()
										tmp403 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp404 := tmp403.FindInternedVar(lang.NewSymbol("concat"))
										if tmp404.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp404)))
										}
										tmp405 := tmp404.Get()
										tmp406 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp407 := tmp406.FindInternedVar(lang.NewSymbol("list"))
										if tmp407.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp407)))
										}
										tmp408 := tmp407.Get()
										tmp409 := lang.Apply(tmp408, []any{lang.NewSymbol("glojure.core/when-let")})
										tmp410 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp411 := tmp410.FindInternedVar(lang.NewSymbol("list"))
										if tmp411.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp411)))
										}
										tmp412 := tmp411.Get()
										tmp413 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp414 := tmp413.FindInternedVar(lang.NewSymbol("apply"))
										if tmp414.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp414)))
										}
										tmp415 := tmp414.Get()
										tmp416 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp417 := tmp416.FindInternedVar(lang.NewSymbol("vector"))
										if tmp417.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp417)))
										}
										tmp418 := tmp417.Get()
										tmp419 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp420 := tmp419.FindInternedVar(lang.NewSymbol("seq"))
										if tmp420.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp420)))
										}
										tmp421 := tmp420.Get()
										tmp422 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp423 := tmp422.FindInternedVar(lang.NewSymbol("concat"))
										if tmp423.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp423)))
										}
										tmp424 := tmp423.Get()
										tmp425 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp426 := tmp425.FindInternedVar(lang.NewSymbol("list"))
										if tmp426.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp426)))
										}
										tmp427 := tmp426.Get()
										tmp428 := lang.Apply(tmp427, []any{v140})
										tmp429 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp430 := tmp429.FindInternedVar(lang.NewSymbol("list"))
										if tmp430.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp430)))
										}
										tmp431 := tmp430.Get()
										tmp432 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp433 := tmp432.FindInternedVar(lang.NewSymbol("seq"))
										if tmp433.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp433)))
										}
										tmp434 := tmp433.Get()
										tmp435 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp436 := tmp435.FindInternedVar(lang.NewSymbol("concat"))
										if tmp436.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp436)))
										}
										tmp437 := tmp436.Get()
										tmp438 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp439 := tmp438.FindInternedVar(lang.NewSymbol("list"))
										if tmp439.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp439)))
										}
										tmp440 := tmp439.Get()
										tmp441 := lang.Apply(tmp440, []any{lang.NewSymbol("glojure.core/seq")})
										tmp442 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp443 := tmp442.FindInternedVar(lang.NewSymbol("list"))
										if tmp443.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp443)))
										}
										tmp444 := tmp443.Get()
										tmp445 := lang.Apply(tmp444, []any{v140})
										tmp446 := lang.Apply(tmp437, []any{tmp441, tmp445})
										tmp447 := lang.Apply(tmp434, []any{tmp446})
										tmp448 := lang.Apply(tmp431, []any{tmp447})
										tmp449 := lang.Apply(tmp424, []any{tmp428, tmp448})
										tmp450 := lang.Apply(tmp421, []any{tmp449})
										tmp451 := lang.Apply(tmp415, []any{tmp418, tmp450})
										tmp452 := lang.Apply(tmp412, []any{tmp451})
										tmp453 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp454 := tmp453.FindInternedVar(lang.NewSymbol("list"))
										if tmp454.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp454)))
										}
										tmp455 := tmp454.Get()
										tmp456 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp457 := tmp456.FindInternedVar(lang.NewSymbol("seq"))
										if tmp457.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp457)))
										}
										tmp458 := tmp457.Get()
										tmp459 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp460 := tmp459.FindInternedVar(lang.NewSymbol("concat"))
										if tmp460.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp460)))
										}
										tmp461 := tmp460.Get()
										tmp462 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp463 := tmp462.FindInternedVar(lang.NewSymbol("list"))
										if tmp463.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp463)))
										}
										tmp464 := tmp463.Get()
										tmp465 := lang.Apply(tmp464, []any{lang.NewSymbol("if")})
										tmp466 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp467 := tmp466.FindInternedVar(lang.NewSymbol("list"))
										if tmp467.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp467)))
										}
										tmp468 := tmp467.Get()
										tmp469 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp470 := tmp469.FindInternedVar(lang.NewSymbol("seq"))
										if tmp470.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp470)))
										}
										tmp471 := tmp470.Get()
										tmp472 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp473 := tmp472.FindInternedVar(lang.NewSymbol("concat"))
										if tmp473.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp473)))
										}
										tmp474 := tmp473.Get()
										tmp475 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp476 := tmp475.FindInternedVar(lang.NewSymbol("list"))
										if tmp476.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp476)))
										}
										tmp477 := tmp476.Get()
										tmp478 := lang.Apply(tmp477, []any{lang.NewSymbol("glojure.core/chunked-seq?")})
										tmp479 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp480 := tmp479.FindInternedVar(lang.NewSymbol("list"))
										if tmp480.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp480)))
										}
										tmp481 := tmp480.Get()
										tmp482 := lang.Apply(tmp481, []any{v140})
										tmp483 := lang.Apply(tmp474, []any{tmp478, tmp482})
										tmp484 := lang.Apply(tmp471, []any{tmp483})
										tmp485 := lang.Apply(tmp468, []any{tmp484})
										tmp486 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp487 := tmp486.FindInternedVar(lang.NewSymbol("list"))
										if tmp487.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp487)))
										}
										tmp488 := tmp487.Get()
										tmp489 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp490 := tmp489.FindInternedVar(lang.NewSymbol("seq"))
										if tmp490.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp490)))
										}
										tmp491 := tmp490.Get()
										tmp492 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp493 := tmp492.FindInternedVar(lang.NewSymbol("concat"))
										if tmp493.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp493)))
										}
										tmp494 := tmp493.Get()
										tmp495 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp496 := tmp495.FindInternedVar(lang.NewSymbol("list"))
										if tmp496.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp496)))
										}
										tmp497 := tmp496.Get()
										tmp498 := lang.Apply(tmp497, []any{lang.NewSymbol("glojure.core/let")})
										tmp499 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp500 := tmp499.FindInternedVar(lang.NewSymbol("list"))
										if tmp500.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp500)))
										}
										tmp501 := tmp500.Get()
										tmp502 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp503 := tmp502.FindInternedVar(lang.NewSymbol("apply"))
										if tmp503.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp503)))
										}
										tmp504 := tmp503.Get()
										tmp505 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp506 := tmp505.FindInternedVar(lang.NewSymbol("vector"))
										if tmp506.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp506)))
										}
										tmp507 := tmp506.Get()
										tmp508 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp509 := tmp508.FindInternedVar(lang.NewSymbol("seq"))
										if tmp509.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp509)))
										}
										tmp510 := tmp509.Get()
										tmp511 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp512 := tmp511.FindInternedVar(lang.NewSymbol("concat"))
										if tmp512.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp512)))
										}
										tmp513 := tmp512.Get()
										tmp514 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp515 := tmp514.FindInternedVar(lang.NewSymbol("list"))
										if tmp515.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp515)))
										}
										tmp516 := tmp515.Get()
										tmp517 := lang.Apply(tmp516, []any{lang.NewSymbol("c__0__auto__")})
										tmp518 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp519 := tmp518.FindInternedVar(lang.NewSymbol("list"))
										if tmp519.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp519)))
										}
										tmp520 := tmp519.Get()
										tmp521 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp522 := tmp521.FindInternedVar(lang.NewSymbol("seq"))
										if tmp522.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp522)))
										}
										tmp523 := tmp522.Get()
										tmp524 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp525 := tmp524.FindInternedVar(lang.NewSymbol("concat"))
										if tmp525.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp525)))
										}
										tmp526 := tmp525.Get()
										tmp527 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp528 := tmp527.FindInternedVar(lang.NewSymbol("list"))
										if tmp528.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp528)))
										}
										tmp529 := tmp528.Get()
										tmp530 := lang.Apply(tmp529, []any{lang.NewSymbol("glojure.core/chunk-first")})
										tmp531 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp532 := tmp531.FindInternedVar(lang.NewSymbol("list"))
										if tmp532.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp532)))
										}
										tmp533 := tmp532.Get()
										tmp534 := lang.Apply(tmp533, []any{v140})
										tmp535 := lang.Apply(tmp526, []any{tmp530, tmp534})
										tmp536 := lang.Apply(tmp523, []any{tmp535})
										tmp537 := lang.Apply(tmp520, []any{tmp536})
										tmp538 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp539 := tmp538.FindInternedVar(lang.NewSymbol("list"))
										if tmp539.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp539)))
										}
										tmp540 := tmp539.Get()
										tmp541 := lang.Apply(tmp540, []any{lang.NewSymbol("size__1__auto__")})
										tmp542 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp543 := tmp542.FindInternedVar(lang.NewSymbol("list"))
										if tmp543.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp543)))
										}
										tmp544 := tmp543.Get()
										tmp545 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp546 := tmp545.FindInternedVar(lang.NewSymbol("seq"))
										if tmp546.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp546)))
										}
										tmp547 := tmp546.Get()
										tmp548 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp549 := tmp548.FindInternedVar(lang.NewSymbol("concat"))
										if tmp549.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp549)))
										}
										tmp550 := tmp549.Get()
										tmp551 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp552 := tmp551.FindInternedVar(lang.NewSymbol("list"))
										if tmp552.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp552)))
										}
										tmp553 := tmp552.Get()
										tmp554 := lang.Apply(tmp553, []any{lang.NewSymbol("glojure.core/int")})
										tmp555 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp556 := tmp555.FindInternedVar(lang.NewSymbol("list"))
										if tmp556.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp556)))
										}
										tmp557 := tmp556.Get()
										tmp558 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp559 := tmp558.FindInternedVar(lang.NewSymbol("seq"))
										if tmp559.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp559)))
										}
										tmp560 := tmp559.Get()
										tmp561 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp562 := tmp561.FindInternedVar(lang.NewSymbol("concat"))
										if tmp562.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp562)))
										}
										tmp563 := tmp562.Get()
										tmp564 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp565 := tmp564.FindInternedVar(lang.NewSymbol("list"))
										if tmp565.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp565)))
										}
										tmp566 := tmp565.Get()
										tmp567 := lang.Apply(tmp566, []any{lang.NewSymbol("glojure.core/count")})
										tmp568 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp569 := tmp568.FindInternedVar(lang.NewSymbol("list"))
										if tmp569.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp569)))
										}
										tmp570 := tmp569.Get()
										tmp571 := lang.Apply(tmp570, []any{lang.NewSymbol("c__0__auto__")})
										tmp572 := lang.Apply(tmp563, []any{tmp567, tmp571})
										tmp573 := lang.Apply(tmp560, []any{tmp572})
										tmp574 := lang.Apply(tmp557, []any{tmp573})
										tmp575 := lang.Apply(tmp550, []any{tmp554, tmp574})
										tmp576 := lang.Apply(tmp547, []any{tmp575})
										tmp577 := lang.Apply(tmp544, []any{tmp576})
										tmp578 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp579 := tmp578.FindInternedVar(lang.NewSymbol("list"))
										if tmp579.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp579)))
										}
										tmp580 := tmp579.Get()
										tmp581 := lang.Apply(tmp580, []any{v302})
										tmp582 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp583 := tmp582.FindInternedVar(lang.NewSymbol("list"))
										if tmp583.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp583)))
										}
										tmp584 := tmp583.Get()
										tmp585 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp586 := tmp585.FindInternedVar(lang.NewSymbol("seq"))
										if tmp586.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp586)))
										}
										tmp587 := tmp586.Get()
										tmp588 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp589 := tmp588.FindInternedVar(lang.NewSymbol("concat"))
										if tmp589.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp589)))
										}
										tmp590 := tmp589.Get()
										tmp591 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp592 := tmp591.FindInternedVar(lang.NewSymbol("list"))
										if tmp592.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp592)))
										}
										tmp593 := tmp592.Get()
										tmp594 := lang.Apply(tmp593, []any{lang.NewSymbol("glojure.core/chunk-buffer")})
										tmp595 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp596 := tmp595.FindInternedVar(lang.NewSymbol("list"))
										if tmp596.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp596)))
										}
										tmp597 := tmp596.Get()
										tmp598 := lang.Apply(tmp597, []any{lang.NewSymbol("size__1__auto__")})
										tmp599 := lang.Apply(tmp590, []any{tmp594, tmp598})
										tmp600 := lang.Apply(tmp587, []any{tmp599})
										tmp601 := lang.Apply(tmp584, []any{tmp600})
										tmp602 := lang.Apply(tmp513, []any{tmp517, tmp537, tmp541, tmp577, tmp581, tmp601})
										tmp603 := lang.Apply(tmp510, []any{tmp602})
										tmp604 := lang.Apply(tmp504, []any{tmp507, tmp603})
										tmp605 := lang.Apply(tmp501, []any{tmp604})
										tmp606 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp607 := tmp606.FindInternedVar(lang.NewSymbol("list"))
										if tmp607.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp607)))
										}
										tmp608 := tmp607.Get()
										tmp609 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp610 := tmp609.FindInternedVar(lang.NewSymbol("seq"))
										if tmp610.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp610)))
										}
										tmp611 := tmp610.Get()
										tmp612 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp613 := tmp612.FindInternedVar(lang.NewSymbol("concat"))
										if tmp613.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp613)))
										}
										tmp614 := tmp613.Get()
										tmp615 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp616 := tmp615.FindInternedVar(lang.NewSymbol("list"))
										if tmp616.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp616)))
										}
										tmp617 := tmp616.Get()
										tmp618 := lang.Apply(tmp617, []any{lang.NewSymbol("if")})
										tmp619 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp620 := tmp619.FindInternedVar(lang.NewSymbol("list"))
										if tmp620.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp620)))
										}
										tmp621 := tmp620.Get()
										tmp622 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp623 := tmp622.FindInternedVar(lang.NewSymbol("seq"))
										if tmp623.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp623)))
										}
										tmp624 := tmp623.Get()
										tmp625 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp626 := tmp625.FindInternedVar(lang.NewSymbol("concat"))
										if tmp626.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp626)))
										}
										tmp627 := tmp626.Get()
										tmp628 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp629 := tmp628.FindInternedVar(lang.NewSymbol("list"))
										if tmp629.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp629)))
										}
										tmp630 := tmp629.Get()
										tmp631 := lang.Apply(tmp630, []any{lang.NewSymbol("glojure.core/loop")})
										tmp632 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp633 := tmp632.FindInternedVar(lang.NewSymbol("list"))
										if tmp633.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp633)))
										}
										tmp634 := tmp633.Get()
										tmp635 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp636 := tmp635.FindInternedVar(lang.NewSymbol("apply"))
										if tmp636.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp636)))
										}
										tmp637 := tmp636.Get()
										tmp638 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp639 := tmp638.FindInternedVar(lang.NewSymbol("vector"))
										if tmp639.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp639)))
										}
										tmp640 := tmp639.Get()
										tmp641 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp642 := tmp641.FindInternedVar(lang.NewSymbol("seq"))
										if tmp642.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp642)))
										}
										tmp643 := tmp642.Get()
										tmp644 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp645 := tmp644.FindInternedVar(lang.NewSymbol("concat"))
										if tmp645.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp645)))
										}
										tmp646 := tmp645.Get()
										tmp647 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp648 := tmp647.FindInternedVar(lang.NewSymbol("list"))
										if tmp648.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp648)))
										}
										tmp649 := tmp648.Get()
										tmp650 := lang.Apply(tmp649, []any{v297})
										tmp651 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp652 := tmp651.FindInternedVar(lang.NewSymbol("list"))
										if tmp652.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp652)))
										}
										tmp653 := tmp652.Get()
										tmp654 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp655 := tmp654.FindInternedVar(lang.NewSymbol("seq"))
										if tmp655.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp655)))
										}
										tmp656 := tmp655.Get()
										tmp657 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp658 := tmp657.FindInternedVar(lang.NewSymbol("concat"))
										if tmp658.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp658)))
										}
										tmp659 := tmp658.Get()
										tmp660 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp661 := tmp660.FindInternedVar(lang.NewSymbol("list"))
										if tmp661.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp661)))
										}
										tmp662 := tmp661.Get()
										tmp663 := lang.Apply(tmp662, []any{lang.NewSymbol("glojure.core/int")})
										tmp664 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp665 := tmp664.FindInternedVar(lang.NewSymbol("list"))
										if tmp665.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp665)))
										}
										tmp666 := tmp665.Get()
										tmp667 := lang.Apply(tmp666, []any{int64(0)})
										tmp668 := lang.Apply(tmp659, []any{tmp663, tmp667})
										tmp669 := lang.Apply(tmp656, []any{tmp668})
										tmp670 := lang.Apply(tmp653, []any{tmp669})
										tmp671 := lang.Apply(tmp646, []any{tmp650, tmp670})
										tmp672 := lang.Apply(tmp643, []any{tmp671})
										tmp673 := lang.Apply(tmp637, []any{tmp640, tmp672})
										tmp674 := lang.Apply(tmp634, []any{tmp673})
										tmp675 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp676 := tmp675.FindInternedVar(lang.NewSymbol("list"))
										if tmp676.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp676)))
										}
										tmp677 := tmp676.Get()
										tmp678 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp679 := tmp678.FindInternedVar(lang.NewSymbol("seq"))
										if tmp679.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp679)))
										}
										tmp680 := tmp679.Get()
										tmp681 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp682 := tmp681.FindInternedVar(lang.NewSymbol("concat"))
										if tmp682.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp682)))
										}
										tmp683 := tmp682.Get()
										tmp684 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp685 := tmp684.FindInternedVar(lang.NewSymbol("list"))
										if tmp685.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp685)))
										}
										tmp686 := tmp685.Get()
										tmp687 := lang.Apply(tmp686, []any{lang.NewSymbol("if")})
										tmp688 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp689 := tmp688.FindInternedVar(lang.NewSymbol("list"))
										if tmp689.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp689)))
										}
										tmp690 := tmp689.Get()
										tmp691 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp692 := tmp691.FindInternedVar(lang.NewSymbol("seq"))
										if tmp692.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp692)))
										}
										tmp693 := tmp692.Get()
										tmp694 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp695 := tmp694.FindInternedVar(lang.NewSymbol("concat"))
										if tmp695.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp695)))
										}
										tmp696 := tmp695.Get()
										tmp697 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp698 := tmp697.FindInternedVar(lang.NewSymbol("list"))
										if tmp698.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp698)))
										}
										tmp699 := tmp698.Get()
										tmp700 := lang.Apply(tmp699, []any{lang.NewSymbol("glojure.core/<")})
										tmp701 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp702 := tmp701.FindInternedVar(lang.NewSymbol("list"))
										if tmp702.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp702)))
										}
										tmp703 := tmp702.Get()
										tmp704 := lang.Apply(tmp703, []any{v297})
										tmp705 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp706 := tmp705.FindInternedVar(lang.NewSymbol("list"))
										if tmp706.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp706)))
										}
										tmp707 := tmp706.Get()
										tmp708 := lang.Apply(tmp707, []any{lang.NewSymbol("size__1__auto__")})
										tmp709 := lang.Apply(tmp696, []any{tmp700, tmp704, tmp708})
										tmp710 := lang.Apply(tmp693, []any{tmp709})
										tmp711 := lang.Apply(tmp690, []any{tmp710})
										tmp712 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp713 := tmp712.FindInternedVar(lang.NewSymbol("list"))
										if tmp713.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp713)))
										}
										tmp714 := tmp713.Get()
										tmp715 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp716 := tmp715.FindInternedVar(lang.NewSymbol("seq"))
										if tmp716.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp716)))
										}
										tmp717 := tmp716.Get()
										tmp718 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp719 := tmp718.FindInternedVar(lang.NewSymbol("concat"))
										if tmp719.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp719)))
										}
										tmp720 := tmp719.Get()
										tmp721 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp722 := tmp721.FindInternedVar(lang.NewSymbol("list"))
										if tmp722.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp722)))
										}
										tmp723 := tmp722.Get()
										tmp724 := lang.Apply(tmp723, []any{lang.NewSymbol("glojure.core/let")})
										tmp725 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp726 := tmp725.FindInternedVar(lang.NewSymbol("list"))
										if tmp726.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp726)))
										}
										tmp727 := tmp726.Get()
										tmp728 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp729 := tmp728.FindInternedVar(lang.NewSymbol("apply"))
										if tmp729.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp729)))
										}
										tmp730 := tmp729.Get()
										tmp731 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp732 := tmp731.FindInternedVar(lang.NewSymbol("vector"))
										if tmp732.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp732)))
										}
										tmp733 := tmp732.Get()
										tmp734 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp735 := tmp734.FindInternedVar(lang.NewSymbol("seq"))
										if tmp735.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp735)))
										}
										tmp736 := tmp735.Get()
										tmp737 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp738 := tmp737.FindInternedVar(lang.NewSymbol("concat"))
										if tmp738.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp738)))
										}
										tmp739 := tmp738.Get()
										tmp740 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp741 := tmp740.FindInternedVar(lang.NewSymbol("list"))
										if tmp741.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp741)))
										}
										tmp742 := tmp741.Get()
										tmp743 := lang.Apply(tmp742, []any{v100})
										tmp744 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp745 := tmp744.FindInternedVar(lang.NewSymbol("list"))
										if tmp745.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp745)))
										}
										tmp746 := tmp745.Get()
										tmp747 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp748 := tmp747.FindInternedVar(lang.NewSymbol("seq"))
										if tmp748.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp748)))
										}
										tmp749 := tmp748.Get()
										tmp750 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp751 := tmp750.FindInternedVar(lang.NewSymbol("concat"))
										if tmp751.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp751)))
										}
										tmp752 := tmp751.Get()
										tmp753 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp754 := tmp753.FindInternedVar(lang.NewSymbol("list"))
										if tmp754.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp754)))
										}
										tmp755 := tmp754.Get()
										tmp756 := lang.Apply(tmp755, []any{lang.NewSymbol(".nth")})
										tmp757 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp758 := tmp757.FindInternedVar(lang.NewSymbol("list"))
										if tmp758.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp758)))
										}
										tmp759 := tmp758.Get()
										tmp760 := lang.Apply(tmp759, []any{lang.NewSymbol("c__0__auto__")})
										tmp761 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp762 := tmp761.FindInternedVar(lang.NewSymbol("list"))
										if tmp762.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp762)))
										}
										tmp763 := tmp762.Get()
										tmp764 := lang.Apply(tmp763, []any{v297})
										tmp765 := lang.Apply(tmp752, []any{tmp756, tmp760, tmp764})
										tmp766 := lang.Apply(tmp749, []any{tmp765})
										tmp767 := lang.Apply(tmp746, []any{tmp766})
										tmp768 := lang.Apply(tmp739, []any{tmp743, tmp767})
										tmp769 := lang.Apply(tmp736, []any{tmp768})
										tmp770 := lang.Apply(tmp730, []any{tmp733, tmp769})
										tmp771 := lang.Apply(tmp727, []any{tmp770})
										tmp772 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp773 := tmp772.FindInternedVar(lang.NewSymbol("list"))
										if tmp773.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp773)))
										}
										tmp774 := tmp773.Get()
										tmp775 := lang.Apply(v306, []any{v112})
										tmp776 := lang.Apply(tmp774, []any{tmp775})
										tmp777 := lang.Apply(tmp720, []any{tmp724, tmp771, tmp776})
										tmp778 := lang.Apply(tmp717, []any{tmp777})
										tmp779 := lang.Apply(tmp714, []any{tmp778})
										tmp780 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp781 := tmp780.FindInternedVar(lang.NewSymbol("list"))
										if tmp781.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp781)))
										}
										tmp782 := tmp781.Get()
										tmp783 := lang.Apply(tmp782, []any{true})
										tmp784 := lang.Apply(tmp683, []any{tmp687, tmp711, tmp779, tmp783})
										tmp785 := lang.Apply(tmp680, []any{tmp784})
										tmp786 := lang.Apply(tmp677, []any{tmp785})
										tmp787 := lang.Apply(tmp627, []any{tmp631, tmp674, tmp786})
										tmp788 := lang.Apply(tmp624, []any{tmp787})
										tmp789 := lang.Apply(tmp621, []any{tmp788})
										tmp790 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp791 := tmp790.FindInternedVar(lang.NewSymbol("list"))
										if tmp791.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp791)))
										}
										tmp792 := tmp791.Get()
										tmp793 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp794 := tmp793.FindInternedVar(lang.NewSymbol("seq"))
										if tmp794.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp794)))
										}
										tmp795 := tmp794.Get()
										tmp796 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp797 := tmp796.FindInternedVar(lang.NewSymbol("concat"))
										if tmp797.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp797)))
										}
										tmp798 := tmp797.Get()
										tmp799 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp800 := tmp799.FindInternedVar(lang.NewSymbol("list"))
										if tmp800.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp800)))
										}
										tmp801 := tmp800.Get()
										tmp802 := lang.Apply(tmp801, []any{lang.NewSymbol("glojure.core/chunk-cons")})
										tmp803 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp804 := tmp803.FindInternedVar(lang.NewSymbol("list"))
										if tmp804.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp804)))
										}
										tmp805 := tmp804.Get()
										tmp806 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp807 := tmp806.FindInternedVar(lang.NewSymbol("seq"))
										if tmp807.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp807)))
										}
										tmp808 := tmp807.Get()
										tmp809 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp810 := tmp809.FindInternedVar(lang.NewSymbol("concat"))
										if tmp810.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp810)))
										}
										tmp811 := tmp810.Get()
										tmp812 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp813 := tmp812.FindInternedVar(lang.NewSymbol("list"))
										if tmp813.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp813)))
										}
										tmp814 := tmp813.Get()
										tmp815 := lang.Apply(tmp814, []any{lang.NewSymbol("glojure.core/chunk")})
										tmp816 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp817 := tmp816.FindInternedVar(lang.NewSymbol("list"))
										if tmp817.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp817)))
										}
										tmp818 := tmp817.Get()
										tmp819 := lang.Apply(tmp818, []any{v302})
										tmp820 := lang.Apply(tmp811, []any{tmp815, tmp819})
										tmp821 := lang.Apply(tmp808, []any{tmp820})
										tmp822 := lang.Apply(tmp805, []any{tmp821})
										tmp823 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp824 := tmp823.FindInternedVar(lang.NewSymbol("list"))
										if tmp824.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp824)))
										}
										tmp825 := tmp824.Get()
										tmp826 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp827 := tmp826.FindInternedVar(lang.NewSymbol("seq"))
										if tmp827.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp827)))
										}
										tmp828 := tmp827.Get()
										tmp829 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp830 := tmp829.FindInternedVar(lang.NewSymbol("concat"))
										if tmp830.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp830)))
										}
										tmp831 := tmp830.Get()
										tmp832 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp833 := tmp832.FindInternedVar(lang.NewSymbol("list"))
										if tmp833.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp833)))
										}
										tmp834 := tmp833.Get()
										tmp835 := lang.Apply(tmp834, []any{v135})
										tmp836 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp837 := tmp836.FindInternedVar(lang.NewSymbol("list"))
										if tmp837.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp837)))
										}
										tmp838 := tmp837.Get()
										tmp839 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp840 := tmp839.FindInternedVar(lang.NewSymbol("seq"))
										if tmp840.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp840)))
										}
										tmp841 := tmp840.Get()
										tmp842 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp843 := tmp842.FindInternedVar(lang.NewSymbol("concat"))
										if tmp843.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp843)))
										}
										tmp844 := tmp843.Get()
										tmp845 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp846 := tmp845.FindInternedVar(lang.NewSymbol("list"))
										if tmp846.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp846)))
										}
										tmp847 := tmp846.Get()
										tmp848 := lang.Apply(tmp847, []any{lang.NewSymbol("glojure.core/chunk-rest")})
										tmp849 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp850 := tmp849.FindInternedVar(lang.NewSymbol("list"))
										if tmp850.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp850)))
										}
										tmp851 := tmp850.Get()
										tmp852 := lang.Apply(tmp851, []any{v140})
										tmp853 := lang.Apply(tmp844, []any{tmp848, tmp852})
										tmp854 := lang.Apply(tmp841, []any{tmp853})
										tmp855 := lang.Apply(tmp838, []any{tmp854})
										tmp856 := lang.Apply(tmp831, []any{tmp835, tmp855})
										tmp857 := lang.Apply(tmp828, []any{tmp856})
										tmp858 := lang.Apply(tmp825, []any{tmp857})
										tmp859 := lang.Apply(tmp798, []any{tmp802, tmp822, tmp858})
										tmp860 := lang.Apply(tmp795, []any{tmp859})
										tmp861 := lang.Apply(tmp792, []any{tmp860})
										tmp862 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp863 := tmp862.FindInternedVar(lang.NewSymbol("list"))
										if tmp863.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp863)))
										}
										tmp864 := tmp863.Get()
										tmp865 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp866 := tmp865.FindInternedVar(lang.NewSymbol("seq"))
										if tmp866.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp866)))
										}
										tmp867 := tmp866.Get()
										tmp868 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp869 := tmp868.FindInternedVar(lang.NewSymbol("concat"))
										if tmp869.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp869)))
										}
										tmp870 := tmp869.Get()
										tmp871 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp872 := tmp871.FindInternedVar(lang.NewSymbol("list"))
										if tmp872.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp872)))
										}
										tmp873 := tmp872.Get()
										tmp874 := lang.Apply(tmp873, []any{lang.NewSymbol("glojure.core/chunk-cons")})
										tmp875 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp876 := tmp875.FindInternedVar(lang.NewSymbol("list"))
										if tmp876.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp876)))
										}
										tmp877 := tmp876.Get()
										tmp878 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp879 := tmp878.FindInternedVar(lang.NewSymbol("seq"))
										if tmp879.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp879)))
										}
										tmp880 := tmp879.Get()
										tmp881 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp882 := tmp881.FindInternedVar(lang.NewSymbol("concat"))
										if tmp882.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp882)))
										}
										tmp883 := tmp882.Get()
										tmp884 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp885 := tmp884.FindInternedVar(lang.NewSymbol("list"))
										if tmp885.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp885)))
										}
										tmp886 := tmp885.Get()
										tmp887 := lang.Apply(tmp886, []any{lang.NewSymbol("glojure.core/chunk")})
										tmp888 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp889 := tmp888.FindInternedVar(lang.NewSymbol("list"))
										if tmp889.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp889)))
										}
										tmp890 := tmp889.Get()
										tmp891 := lang.Apply(tmp890, []any{v302})
										tmp892 := lang.Apply(tmp883, []any{tmp887, tmp891})
										tmp893 := lang.Apply(tmp880, []any{tmp892})
										tmp894 := lang.Apply(tmp877, []any{tmp893})
										tmp895 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp896 := tmp895.FindInternedVar(lang.NewSymbol("list"))
										if tmp896.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp896)))
										}
										tmp897 := tmp896.Get()
										tmp898 := lang.Apply(tmp897, []any{nil})
										tmp899 := lang.Apply(tmp870, []any{tmp874, tmp894, tmp898})
										tmp900 := lang.Apply(tmp867, []any{tmp899})
										tmp901 := lang.Apply(tmp864, []any{tmp900})
										tmp902 := lang.Apply(tmp614, []any{tmp618, tmp789, tmp861, tmp901})
										tmp903 := lang.Apply(tmp611, []any{tmp902})
										tmp904 := lang.Apply(tmp608, []any{tmp903})
										tmp905 := lang.Apply(tmp494, []any{tmp498, tmp605, tmp904})
										tmp906 := lang.Apply(tmp491, []any{tmp905})
										tmp907 := lang.Apply(tmp488, []any{tmp906})
										tmp908 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp909 := tmp908.FindInternedVar(lang.NewSymbol("list"))
										if tmp909.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp909)))
										}
										tmp910 := tmp909.Get()
										tmp911 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp912 := tmp911.FindInternedVar(lang.NewSymbol("seq"))
										if tmp912.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp912)))
										}
										tmp913 := tmp912.Get()
										tmp914 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp915 := tmp914.FindInternedVar(lang.NewSymbol("concat"))
										if tmp915.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp915)))
										}
										tmp916 := tmp915.Get()
										tmp917 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp918 := tmp917.FindInternedVar(lang.NewSymbol("list"))
										if tmp918.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp918)))
										}
										tmp919 := tmp918.Get()
										tmp920 := lang.Apply(tmp919, []any{lang.NewSymbol("glojure.core/let")})
										tmp921 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp922 := tmp921.FindInternedVar(lang.NewSymbol("list"))
										if tmp922.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp922)))
										}
										tmp923 := tmp922.Get()
										tmp924 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp925 := tmp924.FindInternedVar(lang.NewSymbol("apply"))
										if tmp925.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp925)))
										}
										tmp926 := tmp925.Get()
										tmp927 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp928 := tmp927.FindInternedVar(lang.NewSymbol("vector"))
										if tmp928.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp928)))
										}
										tmp929 := tmp928.Get()
										tmp930 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp931 := tmp930.FindInternedVar(lang.NewSymbol("seq"))
										if tmp931.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp931)))
										}
										tmp932 := tmp931.Get()
										tmp933 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp934 := tmp933.FindInternedVar(lang.NewSymbol("concat"))
										if tmp934.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp934)))
										}
										tmp935 := tmp934.Get()
										tmp936 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp937 := tmp936.FindInternedVar(lang.NewSymbol("list"))
										if tmp937.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp937)))
										}
										tmp938 := tmp937.Get()
										tmp939 := lang.Apply(tmp938, []any{v100})
										tmp940 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp941 := tmp940.FindInternedVar(lang.NewSymbol("list"))
										if tmp941.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp941)))
										}
										tmp942 := tmp941.Get()
										tmp943 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp944 := tmp943.FindInternedVar(lang.NewSymbol("seq"))
										if tmp944.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp944)))
										}
										tmp945 := tmp944.Get()
										tmp946 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp947 := tmp946.FindInternedVar(lang.NewSymbol("concat"))
										if tmp947.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp947)))
										}
										tmp948 := tmp947.Get()
										tmp949 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp950 := tmp949.FindInternedVar(lang.NewSymbol("list"))
										if tmp950.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp950)))
										}
										tmp951 := tmp950.Get()
										tmp952 := lang.Apply(tmp951, []any{lang.NewSymbol("glojure.core/first")})
										tmp953 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp954 := tmp953.FindInternedVar(lang.NewSymbol("list"))
										if tmp954.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp954)))
										}
										tmp955 := tmp954.Get()
										tmp956 := lang.Apply(tmp955, []any{v140})
										tmp957 := lang.Apply(tmp948, []any{tmp952, tmp956})
										tmp958 := lang.Apply(tmp945, []any{tmp957})
										tmp959 := lang.Apply(tmp942, []any{tmp958})
										tmp960 := lang.Apply(tmp935, []any{tmp939, tmp959})
										tmp961 := lang.Apply(tmp932, []any{tmp960})
										tmp962 := lang.Apply(tmp926, []any{tmp929, tmp961})
										tmp963 := lang.Apply(tmp923, []any{tmp962})
										tmp964 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp965 := tmp964.FindInternedVar(lang.NewSymbol("list"))
										if tmp965.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp965)))
										}
										tmp966 := tmp965.Get()
										tmp967 := lang.Apply(v144, []any{v112})
										tmp968 := lang.Apply(tmp966, []any{tmp967})
										tmp969 := lang.Apply(tmp916, []any{tmp920, tmp963, tmp968})
										tmp970 := lang.Apply(tmp913, []any{tmp969})
										tmp971 := lang.Apply(tmp910, []any{tmp970})
										tmp972 := lang.Apply(tmp461, []any{tmp465, tmp485, tmp907, tmp971})
										tmp973 := lang.Apply(tmp458, []any{tmp972})
										tmp974 := lang.Apply(tmp455, []any{tmp973})
										tmp975 := lang.Apply(tmp405, []any{tmp409, tmp452, tmp974})
										tmp976 := lang.Apply(tmp402, []any{tmp975})
										tmp977 := lang.Apply(tmp399, []any{tmp976})
										tmp978 := lang.Apply(tmp365, []any{tmp369, tmp396, tmp977})
										tmp979 := lang.Apply(tmp362, []any{tmp978})
										tmp980 := lang.Apply(tmp359, []any{tmp979})
										tmp981 := lang.Apply(tmp352, []any{tmp356, tmp980})
										tmp982 := lang.Apply(tmp349, []any{tmp981})
										tmp983 := lang.Apply(tmp346, []any{tmp982})
										tmp984 := lang.Apply(tmp312, []any{tmp316, tmp320, tmp343, tmp983})
										tmp985 := lang.Apply(tmp309, []any{tmp984})
										tmp292 = tmp985
									} // end let
									tmp145 = tmp292
								}
								tmp130 = tmp145
							} // end let
							tmp67 = tmp130
						} // end let
						return tmp67
					})
					v65 = tmp64
					_ = v65
				}
				tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4668), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4729), lang.NewKeyword("end-column"), int(68))
				tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v67 any = tmp66
				_ = v67
				tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp69 := tmp68.FindInternedVar(lang.NewSymbol("seq"))
				if tmp69.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
				}
				tmp70 := tmp69.Get()
				tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp72 := tmp71.FindInternedVar(lang.NewSymbol("concat"))
				if tmp72.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
				}
				tmp73 := tmp72.Get()
				tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
				if tmp75.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
				}
				tmp76 := tmp75.Get()
				tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("glojure.core/let")})
				tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp79 := tmp78.FindInternedVar(lang.NewSymbol("list"))
				if tmp79.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
				}
				tmp80 := tmp79.Get()
				tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp82 := tmp81.FindInternedVar(lang.NewSymbol("apply"))
				if tmp82.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
				}
				tmp83 := tmp82.Get()
				tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp85 := tmp84.FindInternedVar(lang.NewSymbol("vector"))
				if tmp85.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
				}
				tmp86 := tmp85.Get()
				tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp88 := tmp87.FindInternedVar(lang.NewSymbol("seq"))
				if tmp88.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
				}
				tmp89 := tmp88.Get()
				tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp91 := tmp90.FindInternedVar(lang.NewSymbol("concat"))
				if tmp91.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
				}
				tmp92 := tmp91.Get()
				tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
				if tmp94.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
				}
				tmp95 := tmp94.Get()
				tmp96 := lang.Apply(tmp95, []any{lang.NewSymbol("iter__0__auto__")})
				tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
				if tmp98.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
				}
				tmp99 := tmp98.Get()
				tmp100 := lang.Apply(v59, []any{v5})
				tmp101 := lang.Apply(v67, []any{tmp100})
				tmp102 := lang.Apply(tmp99, []any{tmp101})
				tmp103 := lang.Apply(tmp92, []any{tmp96, tmp102})
				tmp104 := lang.Apply(tmp89, []any{tmp103})
				tmp105 := lang.Apply(tmp83, []any{tmp86, tmp104})
				tmp106 := lang.Apply(tmp80, []any{tmp105})
				tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
				if tmp108.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
				}
				tmp109 := tmp108.Get()
				tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp111 := tmp110.FindInternedVar(lang.NewSymbol("seq"))
				if tmp111.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
				}
				tmp112 := tmp111.Get()
				tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp114 := tmp113.FindInternedVar(lang.NewSymbol("concat"))
				if tmp114.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
				}
				tmp115 := tmp114.Get()
				tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp117 := tmp116.FindInternedVar(lang.NewSymbol("list"))
				if tmp117.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
				}
				tmp118 := tmp117.Get()
				tmp119 := lang.Apply(tmp118, []any{lang.NewSymbol("iter__0__auto__")})
				tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp121 := tmp120.FindInternedVar(lang.NewSymbol("list"))
				if tmp121.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
				}
				tmp122 := tmp121.Get()
				tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp124 := tmp123.FindInternedVar(lang.NewSymbol("second"))
				if tmp124.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
				}
				tmp125 := tmp124.Get()
				tmp126 := lang.Apply(tmp125, []any{v5})
				tmp127 := lang.Apply(tmp122, []any{tmp126})
				tmp128 := lang.Apply(tmp115, []any{tmp119, tmp127})
				tmp129 := lang.Apply(tmp112, []any{tmp128})
				tmp130 := lang.Apply(tmp109, []any{tmp129})
				tmp131 := lang.Apply(tmp73, []any{tmp77, tmp106, tmp130})
				tmp132 := lang.Apply(tmp70, []any{tmp131})
				tmp55 = tmp132
			} // end let
			return tmp55
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// force
	{
		tmp0 := lang.NewSymbol("force").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(754), lang.NewKeyword("end-line"), int(754))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(nil, "force")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("force is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// format
	{
		tmp0 := lang.NewSymbol("format").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5717), lang.NewKeyword("end-line"), int(5717))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("apply"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{fmt.Sprintf, v3, v4})
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// frequencies
	{
		tmp0 := lang.NewSymbol("frequencies").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a map from distinct items in coll to the number of times\n  they appear.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7185), lang.NewKeyword("end-line"), int(7185))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("persistent!"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("reduce"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v11 := args[0]
				_ = v11
				v12 := args[1]
				_ = v12
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("assoc!"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("inc"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("get"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{v11, v12, int64(0)})
				tmp23 := lang.Apply(tmp18, []any{tmp22})
				tmp24 := lang.Apply(tmp15, []any{v11, v12, tmp23})
				return tmp24
			})
			tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7192), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7193), lang.NewKeyword("end-column"), int(54))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("transient"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := lang.NewMap()
			tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7194), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7194), lang.NewKeyword("end-column"), int(24))
			tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp19 := lang.Apply(tmp15, []any{tmp18})
			tmp20 := lang.Apply(tmp9, []any{tmp12, tmp19, v3})
			tmp21 := lang.Apply(tmp6, []any{tmp20})
			return tmp21
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future
	{
		tmp0 := lang.NewSymbol("future").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7009), lang.NewKeyword("end-line"), int(7009))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/future-call")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("concat"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("fn*")})
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("apply"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("vector"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
				if tmp39.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
				}
				tmp40 := tmp39.Get()
				tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
				if tmp42.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
				}
				tmp43 := tmp42.Get()
				tmp44 := lang.Apply(tmp43, nil)
				tmp45 := lang.Apply(tmp40, []any{tmp44})
				tmp46 := lang.Apply(tmp34, []any{tmp37, tmp45})
				tmp47 := lang.Apply(tmp31, []any{tmp46})
				tmp48 := lang.Apply(tmp24, []any{tmp28, tmp47, v5})
				tmp49 := lang.Apply(tmp21, []any{tmp48})
				tmp50 := lang.Apply(tmp18, []any{tmp49})
				tmp51 := lang.Apply(tmp11, []any{tmp15, tmp50})
				tmp52 := lang.Apply(tmp8, []any{tmp51})
				return tmp52
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-call
	{
		tmp0 := lang.NewSymbol("future-call").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7003), lang.NewKeyword("end-line"), int(7003))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("binding-conveyor-fn"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				// let binding "fut"
				tmp10 := lang.Apply(lang.AgentSubmit, []any{v9})
				var v11 any = tmp10
				_ = v11
				tmp4 = v11
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancel
	{
		tmp0 := lang.NewSymbol("future-cancel").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Cancels the future, if possible.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7019), lang.NewKeyword("end-line"), int(7019))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "cancel")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("cancel is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{true})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-cancelled?
	{
		tmp0 := lang.NewSymbol("future-cancelled?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns true if future f is cancelled", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7025), lang.NewKeyword("end-line"), int(7025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isCancelled")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isCancelled")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future-done?
	{
		tmp0 := lang.NewSymbol("future-done?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns true if future f is done", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6538), lang.NewKeyword("end-line"), int(6538))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isDone")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isDone")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// future?
	{
		tmp0 := lang.NewSymbol("future?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a future", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6532), lang.NewKeyword("end-line"), int(6532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gen-class
	{
		tmp0 := lang.NewSymbol("gen-class").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// gensym
	{
		tmp0 := lang.NewSymbol("gensym").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("prefix-string"))), lang.NewKeyword("doc"), "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(599), lang.NewKeyword("end-line"), int(599))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("gensym"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				tmp6 := lang.Apply(tmp5, []any{"G__"})
				return tmp6
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("str"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("str"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10, _ := lang.FieldOrMethod(runtime4.RT, "NextID")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NextID is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				tmp12 := lang.Apply(tmp9, []any{tmp11})
				tmp13 := lang.Apply(tmp6, []any{v3, tmp12})
				tmp14 := lang.Apply(lang.NewSymbol, []any{tmp13})
				return tmp14
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get
	{
		var tmp1 lang.FnFunc
		{ // function get__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol(".")})
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("concat"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/Get")})
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v3})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v4})
					tmp41 := lang.Apply(tmp28, []any{tmp32, tmp36, tmp40, v5})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp22, []any{tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp15, tmp19, tmp43})
					tmp45 := lang.Apply(tmp8, []any{tmp44})
					return tmp45
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("get").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("key"), lang.NewSymbol("not-found"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1489), lang.NewKeyword("end-line"), int(1489))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.Get, []any{v4, v5})
				return tmp6
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(lang.GetDefault, []any{v4, v5, v6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-in
	{
		tmp0 := lang.NewSymbol("get-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks"), lang.NewSymbol("not-found"))), lang.NewKeyword("doc"), "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6128), lang.NewKeyword("end-line"), int(6128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("get"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp7, []any{tmp10, v3, v4})
				return tmp11
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "sentinel"
					tmp7 := lang.Apply(reflect.StructOf, []any{nil})
					tmp8 := lang.Apply(reflect.New, []any{tmp7})
					tmp9, ok := lang.FieldOrMethod(tmp8, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp8, "Interface")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					var v11 any = tmp10
					_ = v11
					// let binding "m"
					var v12 any = v3
					_ = v12
					// let binding "ks"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v4})
					var v17 any = tmp16
					_ = v17
					for {
						var tmp18 any
						if lang.IsTruthy(v17) {
							var tmp19 any
							{ // let
								// let binding "m"
								tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp21 := tmp20.FindInternedVar(lang.NewSymbol("get"))
								if tmp21.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
								}
								tmp22 := tmp21.Get()
								tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
								if tmp24.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
								}
								tmp25 := tmp24.Get()
								tmp26 := lang.Apply(tmp25, []any{v17})
								tmp27 := lang.Apply(tmp22, []any{v12, tmp26, v11})
								var v28 any = tmp27
								_ = v28
								var tmp29 any
								tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp31 := tmp30.FindInternedVar(lang.NewSymbol("identical?"))
								if tmp31.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
								}
								tmp32 := tmp31.Get()
								tmp33 := lang.Apply(tmp32, []any{v11, v28})
								if lang.IsTruthy(tmp33) {
									tmp29 = v5
								} else {
									var tmp34 any = v11
									var tmp35 any = v28
									tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp38 := tmp37.FindInternedVar(lang.NewSymbol("next"))
									if tmp38.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
									}
									tmp39 := tmp38.Get()
									tmp40 := lang.Apply(tmp39, []any{v17})
									var tmp36 any = tmp40
									v11 = tmp34
									v12 = tmp35
									v17 = tmp36
									continue
								}
								tmp19 = tmp29
							} // end let
							tmp18 = tmp19
						} else {
							tmp18 = v12
						}
						tmp6 = tmp18
						break
					}
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-method
	{
		tmp0 := lang.NewSymbol("get-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"))), lang.NewKeyword("doc"), "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1815), lang.NewKeyword("end-line"), int(1815))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "getMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-thread-bindings
	{
		tmp0 := lang.NewSymbol("get-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1937), lang.NewKeyword("end-line"), int(1937))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// get-validator
	{
		tmp0 := lang.NewSymbol("get-validator").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"))), lang.NewKeyword("doc"), "Gets the validator-fn for a var/ref/agent/atom.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2392), lang.NewKeyword("end-line"), int(2392))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "getValidator")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("getValidator is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// global-hierarchy
	{
		tmp0 := lang.NewSymbol("global-hierarchy").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5513), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(5514), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, lang.NewMap(lang.NewKeyword("parents"), lang.NewMap(), lang.NewKeyword("descendants"), lang.NewMap(), lang.NewKeyword("ancestors"), lang.NewMap()), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// group-by
	{
		tmp0 := lang.NewSymbol("group-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7128), lang.NewKeyword("end-line"), int(7128))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("persistent!"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			var tmp11 lang.FnFunc
			tmp11 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v12 := args[0]
				_ = v12
				v13 := args[1]
				_ = v13
				var tmp14 any
				{ // let
					// let binding "k"
					tmp15 := lang.Apply(v3, []any{v13})
					var v16 any = tmp15
					_ = v16
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("assoc!"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("conj"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("get"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.NewVector()
					tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7139), lang.NewKeyword("column"), int(40), lang.NewKeyword("end-line"), int(7139), lang.NewKeyword("end-column"), int(41))
					tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp29 := lang.Apply(tmp25, []any{v12, v16, tmp28})
					tmp30 := lang.Apply(tmp22, []any{tmp29, v13})
					tmp31 := lang.Apply(tmp19, []any{v12, v16, tmp30})
					tmp14 = tmp31
				} // end let
				return tmp14
			})
			tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7137), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(7139), lang.NewKeyword("end-column"), int(48))
			tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("transient"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.NewMap()
			tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7140), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(7140), lang.NewKeyword("end-column"), int(17))
			tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp20 := lang.Apply(tmp16, []any{tmp19})
			tmp21 := lang.Apply(tmp10, []any{tmp13, tmp20, v4})
			tmp22 := lang.Apply(tmp7, []any{tmp21})
			return tmp22
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// halt-when
	{
		tmp0 := lang.NewSymbol("halt-when").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("retf"))), lang.NewKeyword("doc"), "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7657), lang.NewKeyword("end-line"), int(7657))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("halt-when"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3, nil})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v6 := args[0]
					_ = v6
					var tmp7 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp8 := lang.Apply(v6, nil)
							return tmp8
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							var tmp10 any
							{ // let
								// let binding "and__0__auto__"
								tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp12 := tmp11.FindInternedVar(lang.NewSymbol("map?"))
								if tmp12.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
								}
								tmp13 := tmp12.Get()
								tmp14 := lang.Apply(tmp13, []any{v8})
								var v15 any = tmp14
								_ = v15
								var tmp16 any
								if lang.IsTruthy(v15) {
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("contains?"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.Apply(tmp19, []any{v8, lang.NewKeyword("glojure.core/halt")})
									tmp16 = tmp20
								} else {
									tmp16 = v15
								}
								tmp10 = tmp16
							} // end let
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(lang.NewKeyword("glojure.core/halt"), []any{v8})
								tmp9 = tmp11
							} else {
								tmp12 := lang.Apply(v6, []any{v8})
								tmp9 = tmp12
							}
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							tmp11 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp11) {
								tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp13 := tmp12.FindInternedVar(lang.NewSymbol("reduced"))
								if tmp13.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
								}
								tmp14 := tmp13.Get()
								var tmp15 any
								if lang.IsTruthy(v4) {
									tmp16 := lang.Apply(v6, []any{v8})
									tmp17 := lang.Apply(v4, []any{tmp16, v9})
									tmp15 = tmp17
								} else {
									tmp15 = v9
								}
								tmp18 := lang.NewMap(lang.NewKeyword("glojure.core/halt"), tmp15)
								tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7678), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7678), lang.NewKeyword("end-column"), int(72))
								tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp21 := lang.Apply(tmp14, []any{tmp20})
								tmp10 = tmp21
							} else {
								tmp22 := lang.Apply(v6, []any{v8, v9})
								tmp10 = tmp22
							}
							return tmp10
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7670), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7679), lang.NewKeyword("end-column"), int(34))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp9
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7669), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7679), lang.NewKeyword("end-column"), int(35))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash
	{
		tmp0 := lang.NewSymbol("hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5189), lang.NewKeyword("end-line"), int(5189))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.HashEq, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-map
	{
		tmp0 := lang.NewSymbol("hash-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(378), lang.NewKeyword("end-line"), int(378))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewMap()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(384), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(384), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentHashMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-ordered-coll
	{
		tmp0 := lang.NewSymbol("hash-ordered-coll").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5210), lang.NewKeyword("end-line"), int(5210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-set
	{
		tmp0 := lang.NewSymbol("hash-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(388), lang.NewKeyword("end-line"), int(388))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(393), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(393), lang.NewKeyword("end-column"), int(9))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(nil, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// hash-unordered-coll
	{
		tmp0 := lang.NewSymbol("hash-unordered-coll").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5219), lang.NewKeyword("end-line"), int(5219))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ident?
	{
		tmp0 := lang.NewSymbol("ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1608), lang.NewKeyword("end-line"), int(1608))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("keyword?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("symbol?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp10 = tmp14
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identical?
	{
		var tmp1 lang.FnFunc
		{ // function identical?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("glojure.lang.Util")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("glojure.core/identical")})
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{v4})
				tmp31 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp22, tmp26, tmp30})
				tmp32 := lang.Apply(tmp7, []any{tmp31})
				return tmp32
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("identical?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Tests if 2 arguments are the same object", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(768), lang.NewKeyword("end-line"), int(768))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.Identical, []any{v4, v5})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// identity
	{
		tmp0 := lang.NewSymbol("identity").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns its argument.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1446), lang.NewKeyword("end-line"), int(1446))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return v3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-let
	{
		tmp0 := lang.NewSymbol("if-let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then"), lang.NewSymbol("else"), lang.NewSymbol("&"), lang.NewSymbol("oldform"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1839), lang.NewKeyword("end-line"), int(1839))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/if-let")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{nil})
				tmp29 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp24, tmp28})
				tmp30 := lang.Apply(tmp9, []any{tmp29})
				return tmp30
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v5})
				if lang.IsTruthy(tmp13) {
				} else {
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("str"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v3})
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("meta"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(lang.NewKeyword("line"), []any{tmp27})
					tmp29 := lang.Apply(tmp16, []any{tmp20, " requires ", "a vector for its binding", " in ", tmp23, ":", tmp28})
					tmp30 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp29})
					panic(tmp30)
				}
				_ = tmp9
				var tmp31 any
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("nil?"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v8})
				if lang.IsTruthy(tmp35) {
				} else {
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("str"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp40 := tmp39.FindInternedVar(lang.NewSymbol("first"))
					if tmp40.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
					}
					tmp41 := tmp40.Get()
					tmp42 := lang.Apply(tmp41, []any{v3})
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("meta"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v3})
					tmp50 := lang.Apply(lang.NewKeyword("line"), []any{tmp49})
					tmp51 := lang.Apply(tmp38, []any{tmp42, " requires ", "1 or 2 forms after binding vector", " in ", tmp45, ":", tmp50})
					tmp52 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp51})
					panic(tmp52)
				}
				_ = tmp31
				var tmp53 any
				tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp55 := tmp54.FindInternedVar(lang.NewSymbol("="))
				if tmp55.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
				}
				tmp56 := tmp55.Get()
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("count"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{v5})
				tmp61 := lang.Apply(tmp56, []any{int64(2), tmp60})
				if lang.IsTruthy(tmp61) {
				} else {
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("str"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("first"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v3})
					tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp70 := tmp69.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp70.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
					}
					tmp71 := tmp70.Get()
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("meta"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{v3})
					tmp76 := lang.Apply(lang.NewKeyword("line"), []any{tmp75})
					tmp77 := lang.Apply(tmp64, []any{tmp68, " requires ", "exactly 2 forms in binding vector", " in ", tmp71, ":", tmp76})
					tmp78 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp77})
					panic(tmp78)
				}
				_ = tmp53
				var tmp79 any
				{ // let
					// let binding "form"
					tmp80 := lang.Apply(v5, []any{int64(0)})
					var v81 any = tmp80
					_ = v81
					// let binding "tst"
					tmp82 := lang.Apply(v5, []any{int64(1)})
					var v83 any = tmp82
					_ = v83
					tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp85 := tmp84.FindInternedVar(lang.NewSymbol("seq"))
					if tmp85.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
					}
					tmp86 := tmp85.Get()
					tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp88 := tmp87.FindInternedVar(lang.NewSymbol("concat"))
					if tmp88.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
					}
					tmp89 := tmp88.Get()
					tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp91 := tmp90.FindInternedVar(lang.NewSymbol("list"))
					if tmp91.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
					}
					tmp92 := tmp91.Get()
					tmp93 := lang.Apply(tmp92, []any{lang.NewSymbol("glojure.core/let")})
					tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
					if tmp95.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
					}
					tmp96 := tmp95.Get()
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("apply"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("vector"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("seq"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("concat"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
					if tmp110.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
					}
					tmp111 := tmp110.Get()
					tmp112 := lang.Apply(tmp111, []any{lang.NewSymbol("temp__0__auto__")})
					tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp114 := tmp113.FindInternedVar(lang.NewSymbol("list"))
					if tmp114.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
					}
					tmp115 := tmp114.Get()
					tmp116 := lang.Apply(tmp115, []any{v83})
					tmp117 := lang.Apply(tmp108, []any{tmp112, tmp116})
					tmp118 := lang.Apply(tmp105, []any{tmp117})
					tmp119 := lang.Apply(tmp99, []any{tmp102, tmp118})
					tmp120 := lang.Apply(tmp96, []any{tmp119})
					tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp122 := tmp121.FindInternedVar(lang.NewSymbol("list"))
					if tmp122.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
					}
					tmp123 := tmp122.Get()
					tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp125 := tmp124.FindInternedVar(lang.NewSymbol("seq"))
					if tmp125.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
					}
					tmp126 := tmp125.Get()
					tmp127 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp128 := tmp127.FindInternedVar(lang.NewSymbol("concat"))
					if tmp128.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp128)))
					}
					tmp129 := tmp128.Get()
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{lang.NewSymbol("if")})
					tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
					if tmp135.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
					}
					tmp136 := tmp135.Get()
					tmp137 := lang.Apply(tmp136, []any{lang.NewSymbol("temp__0__auto__")})
					tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp139 := tmp138.FindInternedVar(lang.NewSymbol("list"))
					if tmp139.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
					}
					tmp140 := tmp139.Get()
					tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp142 := tmp141.FindInternedVar(lang.NewSymbol("seq"))
					if tmp142.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
					}
					tmp143 := tmp142.Get()
					tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp145 := tmp144.FindInternedVar(lang.NewSymbol("concat"))
					if tmp145.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
					}
					tmp146 := tmp145.Get()
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.Apply(tmp149, []any{lang.NewSymbol("glojure.core/let")})
					tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp152 := tmp151.FindInternedVar(lang.NewSymbol("list"))
					if tmp152.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
					}
					tmp153 := tmp152.Get()
					tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp155 := tmp154.FindInternedVar(lang.NewSymbol("apply"))
					if tmp155.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
					}
					tmp156 := tmp155.Get()
					tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp158 := tmp157.FindInternedVar(lang.NewSymbol("vector"))
					if tmp158.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
					}
					tmp159 := tmp158.Get()
					tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp161 := tmp160.FindInternedVar(lang.NewSymbol("seq"))
					if tmp161.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
					}
					tmp162 := tmp161.Get()
					tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp164 := tmp163.FindInternedVar(lang.NewSymbol("concat"))
					if tmp164.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
					}
					tmp165 := tmp164.Get()
					tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp167 := tmp166.FindInternedVar(lang.NewSymbol("list"))
					if tmp167.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
					}
					tmp168 := tmp167.Get()
					tmp169 := lang.Apply(tmp168, []any{v81})
					tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp171 := tmp170.FindInternedVar(lang.NewSymbol("list"))
					if tmp171.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
					}
					tmp172 := tmp171.Get()
					tmp173 := lang.Apply(tmp172, []any{lang.NewSymbol("temp__0__auto__")})
					tmp174 := lang.Apply(tmp165, []any{tmp169, tmp173})
					tmp175 := lang.Apply(tmp162, []any{tmp174})
					tmp176 := lang.Apply(tmp156, []any{tmp159, tmp175})
					tmp177 := lang.Apply(tmp153, []any{tmp176})
					tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp179 := tmp178.FindInternedVar(lang.NewSymbol("list"))
					if tmp179.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
					}
					tmp180 := tmp179.Get()
					tmp181 := lang.Apply(tmp180, []any{v6})
					tmp182 := lang.Apply(tmp146, []any{tmp150, tmp177, tmp181})
					tmp183 := lang.Apply(tmp143, []any{tmp182})
					tmp184 := lang.Apply(tmp140, []any{tmp183})
					tmp185 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp186 := tmp185.FindInternedVar(lang.NewSymbol("list"))
					if tmp186.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp186)))
					}
					tmp187 := tmp186.Get()
					tmp188 := lang.Apply(tmp187, []any{v7})
					tmp189 := lang.Apply(tmp129, []any{tmp133, tmp137, tmp184, tmp188})
					tmp190 := lang.Apply(tmp126, []any{tmp189})
					tmp191 := lang.Apply(tmp123, []any{tmp190})
					tmp192 := lang.Apply(tmp89, []any{tmp93, tmp120, tmp191})
					tmp193 := lang.Apply(tmp86, []any{tmp192})
					tmp79 = tmp193
				} // end let
				return tmp79
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-not
	{
		tmp0 := lang.NewSymbol("if-not").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("then"), lang.NewSymbol("else"))), lang.NewKeyword("doc"), "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(760), lang.NewKeyword("end-line"), int(760))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/if-not")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{nil})
				tmp29 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp24, tmp28})
				tmp30 := lang.Apply(tmp9, []any{tmp29})
				return tmp30
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("concat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("if")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/not")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v5})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp39 := tmp38.FindInternedVar(lang.NewSymbol("list"))
				if tmp39.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
				}
				tmp40 := tmp39.Get()
				tmp41 := lang.Apply(tmp40, []any{v6})
				tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp43 := tmp42.FindInternedVar(lang.NewSymbol("list"))
				if tmp43.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
				}
				tmp44 := tmp43.Get()
				tmp45 := lang.Apply(tmp44, []any{v7})
				tmp46 := lang.Apply(tmp13, []any{tmp17, tmp37, tmp41, tmp45})
				tmp47 := lang.Apply(tmp10, []any{tmp46})
				return tmp47
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// if-some
	{
		tmp0 := lang.NewSymbol("if-some").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then")), lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("then"), lang.NewSymbol("else"), lang.NewSymbol("&"), lang.NewSymbol("oldform"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1874), lang.NewKeyword("end-line"), int(1874))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/if-some")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v6})
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{nil})
				tmp29 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp24, tmp28})
				tmp30 := lang.Apply(tmp9, []any{tmp29})
				return tmp30
			default:
				if len(args) < 5 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var v8 any = lang.NewList(args[5:]...)
				_ = v8
				var tmp9 any
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v5})
				if lang.IsTruthy(tmp13) {
				} else {
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("str"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v3})
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("meta"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(lang.NewKeyword("line"), []any{tmp27})
					tmp29 := lang.Apply(tmp16, []any{tmp20, " requires ", "a vector for its binding", " in ", tmp23, ":", tmp28})
					tmp30 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp29})
					panic(tmp30)
				}
				_ = tmp9
				var tmp31 any
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("nil?"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v8})
				if lang.IsTruthy(tmp35) {
				} else {
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("str"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp40 := tmp39.FindInternedVar(lang.NewSymbol("first"))
					if tmp40.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
					}
					tmp41 := tmp40.Get()
					tmp42 := lang.Apply(tmp41, []any{v3})
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("meta"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v3})
					tmp50 := lang.Apply(lang.NewKeyword("line"), []any{tmp49})
					tmp51 := lang.Apply(tmp38, []any{tmp42, " requires ", "1 or 2 forms after binding vector", " in ", tmp45, ":", tmp50})
					tmp52 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp51})
					panic(tmp52)
				}
				_ = tmp31
				var tmp53 any
				tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp55 := tmp54.FindInternedVar(lang.NewSymbol("="))
				if tmp55.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
				}
				tmp56 := tmp55.Get()
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("count"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{v5})
				tmp61 := lang.Apply(tmp56, []any{int64(2), tmp60})
				if lang.IsTruthy(tmp61) {
				} else {
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("str"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("first"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v3})
					tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp70 := tmp69.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp70.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
					}
					tmp71 := tmp70.Get()
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("meta"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.Apply(tmp74, []any{v3})
					tmp76 := lang.Apply(lang.NewKeyword("line"), []any{tmp75})
					tmp77 := lang.Apply(tmp64, []any{tmp68, " requires ", "exactly 2 forms in binding vector", " in ", tmp71, ":", tmp76})
					tmp78 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp77})
					panic(tmp78)
				}
				_ = tmp53
				var tmp79 any
				{ // let
					// let binding "form"
					tmp80 := lang.Apply(v5, []any{int64(0)})
					var v81 any = tmp80
					_ = v81
					// let binding "tst"
					tmp82 := lang.Apply(v5, []any{int64(1)})
					var v83 any = tmp82
					_ = v83
					tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp85 := tmp84.FindInternedVar(lang.NewSymbol("seq"))
					if tmp85.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
					}
					tmp86 := tmp85.Get()
					tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp88 := tmp87.FindInternedVar(lang.NewSymbol("concat"))
					if tmp88.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
					}
					tmp89 := tmp88.Get()
					tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp91 := tmp90.FindInternedVar(lang.NewSymbol("list"))
					if tmp91.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
					}
					tmp92 := tmp91.Get()
					tmp93 := lang.Apply(tmp92, []any{lang.NewSymbol("glojure.core/let")})
					tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
					if tmp95.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
					}
					tmp96 := tmp95.Get()
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("apply"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("vector"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("seq"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("concat"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
					if tmp110.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
					}
					tmp111 := tmp110.Get()
					tmp112 := lang.Apply(tmp111, []any{lang.NewSymbol("temp__0__auto__")})
					tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp114 := tmp113.FindInternedVar(lang.NewSymbol("list"))
					if tmp114.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
					}
					tmp115 := tmp114.Get()
					tmp116 := lang.Apply(tmp115, []any{v83})
					tmp117 := lang.Apply(tmp108, []any{tmp112, tmp116})
					tmp118 := lang.Apply(tmp105, []any{tmp117})
					tmp119 := lang.Apply(tmp99, []any{tmp102, tmp118})
					tmp120 := lang.Apply(tmp96, []any{tmp119})
					tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp122 := tmp121.FindInternedVar(lang.NewSymbol("list"))
					if tmp122.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
					}
					tmp123 := tmp122.Get()
					tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp125 := tmp124.FindInternedVar(lang.NewSymbol("seq"))
					if tmp125.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
					}
					tmp126 := tmp125.Get()
					tmp127 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp128 := tmp127.FindInternedVar(lang.NewSymbol("concat"))
					if tmp128.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp128)))
					}
					tmp129 := tmp128.Get()
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{lang.NewSymbol("if")})
					tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
					if tmp135.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
					}
					tmp136 := tmp135.Get()
					tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
					if tmp138.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
					}
					tmp139 := tmp138.Get()
					tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
					if tmp141.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
					}
					tmp142 := tmp141.Get()
					tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
					if tmp144.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
					}
					tmp145 := tmp144.Get()
					tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("glojure.core/nil?")})
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.Apply(tmp149, []any{lang.NewSymbol("temp__0__auto__")})
					tmp151 := lang.Apply(tmp142, []any{tmp146, tmp150})
					tmp152 := lang.Apply(tmp139, []any{tmp151})
					tmp153 := lang.Apply(tmp136, []any{tmp152})
					tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp155 := tmp154.FindInternedVar(lang.NewSymbol("list"))
					if tmp155.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
					}
					tmp156 := tmp155.Get()
					tmp157 := lang.Apply(tmp156, []any{v7})
					tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp159 := tmp158.FindInternedVar(lang.NewSymbol("list"))
					if tmp159.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
					}
					tmp160 := tmp159.Get()
					tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp162 := tmp161.FindInternedVar(lang.NewSymbol("seq"))
					if tmp162.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
					}
					tmp163 := tmp162.Get()
					tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp165 := tmp164.FindInternedVar(lang.NewSymbol("concat"))
					if tmp165.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
					}
					tmp166 := tmp165.Get()
					tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp168 := tmp167.FindInternedVar(lang.NewSymbol("list"))
					if tmp168.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
					}
					tmp169 := tmp168.Get()
					tmp170 := lang.Apply(tmp169, []any{lang.NewSymbol("glojure.core/let")})
					tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
					if tmp172.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
					}
					tmp173 := tmp172.Get()
					tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp175 := tmp174.FindInternedVar(lang.NewSymbol("apply"))
					if tmp175.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
					}
					tmp176 := tmp175.Get()
					tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp178 := tmp177.FindInternedVar(lang.NewSymbol("vector"))
					if tmp178.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
					}
					tmp179 := tmp178.Get()
					tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp181 := tmp180.FindInternedVar(lang.NewSymbol("seq"))
					if tmp181.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
					}
					tmp182 := tmp181.Get()
					tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp184 := tmp183.FindInternedVar(lang.NewSymbol("concat"))
					if tmp184.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
					}
					tmp185 := tmp184.Get()
					tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp187 := tmp186.FindInternedVar(lang.NewSymbol("list"))
					if tmp187.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
					}
					tmp188 := tmp187.Get()
					tmp189 := lang.Apply(tmp188, []any{v81})
					tmp190 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp191 := tmp190.FindInternedVar(lang.NewSymbol("list"))
					if tmp191.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp191)))
					}
					tmp192 := tmp191.Get()
					tmp193 := lang.Apply(tmp192, []any{lang.NewSymbol("temp__0__auto__")})
					tmp194 := lang.Apply(tmp185, []any{tmp189, tmp193})
					tmp195 := lang.Apply(tmp182, []any{tmp194})
					tmp196 := lang.Apply(tmp176, []any{tmp179, tmp195})
					tmp197 := lang.Apply(tmp173, []any{tmp196})
					tmp198 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp199 := tmp198.FindInternedVar(lang.NewSymbol("list"))
					if tmp199.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp199)))
					}
					tmp200 := tmp199.Get()
					tmp201 := lang.Apply(tmp200, []any{v6})
					tmp202 := lang.Apply(tmp166, []any{tmp170, tmp197, tmp201})
					tmp203 := lang.Apply(tmp163, []any{tmp202})
					tmp204 := lang.Apply(tmp160, []any{tmp203})
					tmp205 := lang.Apply(tmp129, []any{tmp133, tmp153, tmp157, tmp204})
					tmp206 := lang.Apply(tmp126, []any{tmp205})
					tmp207 := lang.Apply(tmp123, []any{tmp206})
					tmp208 := lang.Apply(tmp89, []any{tmp93, tmp120, tmp207})
					tmp209 := lang.Apply(tmp86, []any{tmp208})
					tmp79 = tmp209
				} // end let
				return tmp79
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ifn?
	{
		tmp0 := lang.NewSymbol("ifn?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6209), lang.NewKeyword("end-line"), int(6209))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// import
	{
		tmp0 := lang.NewSymbol("import").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("import-symbols-or-lists"))), lang.NewKeyword("doc"), "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3426), lang.NewKeyword("end-line"), int(3426))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "specs"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("map"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						var tmp12 any
						var tmp13 any
						{ // let
							// let binding "and__0__auto__"
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("seq?"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.Apply(tmp16, []any{v11})
							var v18 any = tmp17
							_ = v18
							var tmp19 any
							if lang.IsTruthy(v18) {
								tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp21 := tmp20.FindInternedVar(lang.NewSymbol("="))
								if tmp21.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
								}
								tmp22 := tmp21.Get()
								tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
								if tmp24.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
								}
								tmp25 := tmp24.Get()
								tmp26 := lang.Apply(tmp25, []any{v11})
								tmp27 := lang.Apply(tmp22, []any{lang.NewSymbol("quote"), tmp26})
								tmp19 = tmp27
							} else {
								tmp19 = v18
							}
							tmp13 = tmp19
						} // end let
						if lang.IsTruthy(tmp13) {
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("second"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.Apply(tmp16, []any{v11})
							tmp12 = tmp17
						} else {
							tmp12 = v11
						}
						return tmp12
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3434), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(3434), lang.NewKeyword("end-column"), int(73))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.Apply(tmp9, []any{tmp12, v5})
					var v14 any = tmp13
					_ = v14
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("seq"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("concat"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("do")})
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("map"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v29 := args[0]
						_ = v29
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("list"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Import"), v29})
						return tmp33
					})
					tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3436), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(3436), lang.NewKeyword("end-column"), int(73))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					var tmp34 lang.FnFunc
					tmp34 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v35 := args[0]
						_ = v35
						v36 := args[1]
						_ = v36
						var tmp37 any
						tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp39 := tmp38.FindInternedVar(lang.NewSymbol("symbol?"))
						if tmp39.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
						}
						tmp40 := tmp39.Get()
						tmp41 := lang.Apply(tmp40, []any{v36})
						if lang.IsTruthy(tmp41) {
							tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp43 := tmp42.FindInternedVar(lang.NewSymbol("conj"))
							if tmp43.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
							}
							tmp44 := tmp43.Get()
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("name"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.Apply(tmp47, []any{v36})
							tmp49 := lang.Apply(tmp44, []any{v35, tmp48})
							tmp37 = tmp49
						} else {
							var tmp50 any
							{ // let
								// let binding "p"
								tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp52 := tmp51.FindInternedVar(lang.NewSymbol("first"))
								if tmp52.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
								}
								tmp53 := tmp52.Get()
								tmp54 := lang.Apply(tmp53, []any{v36})
								var v55 any = tmp54
								_ = v55
								// let binding "cs"
								tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp57 := tmp56.FindInternedVar(lang.NewSymbol("rest"))
								if tmp57.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
								}
								tmp58 := tmp57.Get()
								tmp59 := lang.Apply(tmp58, []any{v36})
								var v60 any = tmp59
								_ = v60
								tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp62 := tmp61.FindInternedVar(lang.NewSymbol("into1"))
								if tmp62.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
								}
								tmp63 := tmp62.Get()
								tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp65 := tmp64.FindInternedVar(lang.NewSymbol("map"))
								if tmp65.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
								}
								tmp66 := tmp65.Get()
								var tmp67 lang.FnFunc
								tmp67 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v68 := args[0]
									_ = v68
									tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp70 := tmp69.FindInternedVar(lang.NewSymbol("str"))
									if tmp70.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
									}
									tmp71 := tmp70.Get()
									tmp72 := lang.Apply(tmp71, []any{v55, ".", v68})
									return tmp72
								})
								tmp68 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3441), lang.NewKeyword("column"), int(45), lang.NewKeyword("end-line"), int(3441), lang.NewKeyword("end-column"), int(58))
								tmp69, err := lang.WithMeta(tmp67, tmp68.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp70 := lang.Apply(tmp66, []any{tmp69, v60})
								tmp71 := lang.Apply(tmp63, []any{v35, tmp70})
								tmp50 = tmp71
							} // end let
							tmp37 = tmp50
						}
						return tmp37
					})
					tmp35 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3437), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(3441), lang.NewKeyword("end-column"), int(66))
					tmp36, err := lang.WithMeta(tmp34, tmp35.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp37 := lang.NewVector()
					tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3442), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(3442), lang.NewKeyword("end-column"), int(26))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp40 := lang.Apply(tmp33, []any{tmp36, tmp39, v14})
					tmp41 := lang.Apply(tmp27, []any{tmp30, tmp40})
					tmp42 := lang.Apply(tmp20, []any{tmp24, tmp41})
					tmp43 := lang.Apply(tmp17, []any{tmp42})
					tmp6 = tmp43
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// in-ns
	{
		tmp0 := lang.NewSymbol("in-ns").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc
	{
		var tmp1 lang.FnFunc
		{ // function inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("unchecked_inc")
				} else {
					tmp30 = lang.NewSymbol("inc")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("inc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(915), lang.NewKeyword("end-line"), int(915))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inc'
	{
		var tmp1 lang.FnFunc
		{ // function inc'__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/IncP")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("inc'").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(908), lang.NewKeyword("end-line"), int(908))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IncP")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IncP is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// indexed?
	{
		tmp0 := lang.NewSymbol("indexed?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return true if coll implements Indexed, indicating efficient lookup by index", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6263), lang.NewKeyword("end-line"), int(6263))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// infinite?
	{
		var tmp1 lang.FnFunc
		{ // function infinite?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("Double/isInfinite")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := lang.Apply(tmp9, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("infinite?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is negative or positive infinity, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7977), lang.NewKeyword("end-line"), int(7977))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst-ms
	{
		tmp0 := lang.NewSymbol("inst-ms").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("inst"))), lang.NewKeyword("doc"), "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6831), lang.NewKeyword("end-line"), int(6831))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// inst?
	{
		tmp0 := lang.NewSymbol("inst?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x satisfies Inst", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6837), lang.NewKeyword("end-line"), int(6837))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// instance?
	{
		tmp0 := lang.NewSymbol("instance?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("c"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Evaluates x and tests if it is an instance of the type\n    t. Returns true or false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(139), lang.NewKeyword("end-line"), int(143))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function instance?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.HasType, []any{v4, v5})
				return tmp6
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(143), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(143), lang.NewKeyword("end-column"), int(85))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int
	{
		var tmp1 lang.FnFunc
		{ // function int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("uncheckedIntCast")
				} else {
					tmp30 = lang.NewSymbol("intCast")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to int", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(875), lang.NewKeyword("end-line"), int(875))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "IntCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int-array
	{
		var tmp1 lang.FnFunc
		{ // function int-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/IntArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("int-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of ints", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5356), lang.NewKeyword("end-line"), int(5356))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IntArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "IntArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("IntArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// int?
	{
		tmp0 := lang.NewSymbol("int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1395), lang.NewKeyword("end-line"), int(1395))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{lang.Builtins["int64"], v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					var tmp11 any
					{ // let
						// let binding "or__0__auto__"
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{nil, v3})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp17 = v16
						} else {
							var tmp18 any
							{ // let
								// let binding "or__0__auto__"
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("instance?"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.Apply(tmp21, []any{nil, v3})
								var v23 any = tmp22
								_ = v23
								var tmp24 any
								if lang.IsTruthy(v23) {
									tmp24 = v23
								} else {
									tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp26 := tmp25.FindInternedVar(lang.NewSymbol("instance?"))
									if tmp26.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
									}
									tmp27 := tmp26.Get()
									tmp28 := lang.Apply(tmp27, []any{nil, v3})
									tmp24 = tmp28
								}
								tmp18 = tmp24
							} // end let
							tmp17 = tmp18
						}
						tmp11 = tmp17
					} // end let
					tmp10 = tmp11
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// integer?
	{
		tmp0 := lang.NewSymbol("integer?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1379), lang.NewKeyword("end-line"), int(1379))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsInteger, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interleave
	{
		tmp0 := lang.NewSymbol("interleave").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("c1")), lang.NewVector(lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a lazy seq of the first item in each coll, then the second etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4308), lang.NewKeyword("end-line"), int(4308))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return lang.NewList()
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					return v3
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "s1"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						// let binding "s2"
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("seq"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v4})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						var tmp18 any
						{ // let
							// let binding "and__0__auto__"
							var v19 any = v11
							_ = v19
							var tmp20 any
							if lang.IsTruthy(v19) {
								tmp20 = v16
							} else {
								tmp20 = v19
							}
							tmp18 = tmp20
						} // end let
						if lang.IsTruthy(tmp18) {
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("cons"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("first"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.Apply(tmp24, []any{v11})
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("cons"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v16})
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("interleave"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("rest"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{v11})
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("rest"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v16})
							tmp44 := lang.Apply(tmp35, []any{tmp39, tmp43})
							tmp45 := lang.Apply(tmp28, []any{tmp32, tmp44})
							tmp46 := lang.Apply(tmp21, []any{tmp25, tmp45})
							tmp17 = tmp46
						} else {
						}
						tmp6 = tmp17
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "ss"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("map"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("conj"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v5, v4, v3})
						tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17})
						var v19 any = tmp18
						_ = v19
						var tmp20 any
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("every?"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("identity"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp23, []any{tmp26, v19})
						if lang.IsTruthy(tmp27) {
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("map"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.Apply(tmp33, []any{tmp36, v19})
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("apply"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("interleave"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("map"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp48 := tmp47.FindInternedVar(lang.NewSymbol("rest"))
							if tmp48.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
							}
							tmp49 := tmp48.Get()
							tmp50 := lang.Apply(tmp46, []any{tmp49, v19})
							tmp51 := lang.Apply(tmp40, []any{tmp43, tmp50})
							tmp52 := lang.Apply(tmp30, []any{tmp37, tmp51})
							tmp20 = tmp52
						} else {
						}
						tmp7 = tmp20
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// intern
	{
		tmp0 := lang.NewSymbol("intern").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6311), lang.NewKeyword("end-line"), int(6311))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "v"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("the-ns"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(tmp8, []any{v3})
					tmp10 := lang.Apply(nil, []any{tmp9, v4})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("meta"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v4})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("meta"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v4})
						tmp21, _ := lang.FieldOrMethod(v11, "setMeta")
						if reflect.TypeOf(tmp21).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp22 := lang.Apply(tmp21, []any{tmp20})
						tmp12 = tmp22
					} else {
					}
					_ = tmp12
					tmp5 = v11
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "v"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("the-ns"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp11 := lang.Apply(nil, []any{tmp10, v4, v5})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("meta"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v4})
					if lang.IsTruthy(tmp17) {
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("meta"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v4})
						tmp22, _ := lang.FieldOrMethod(v12, "setMeta")
						if reflect.TypeOf(tmp22).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMeta is not a function")))
						}
						tmp23 := lang.Apply(tmp22, []any{tmp21})
						tmp13 = tmp23
					} else {
					}
					_ = tmp13
					tmp6 = v12
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// interpose
	{
		tmp0 := lang.NewSymbol("interpose").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sep")), lang.NewVector(lang.NewSymbol("sep"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5230), lang.NewKeyword("end-line"), int(5230))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "started"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{false})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("deref"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v11})
								if lang.IsTruthy(tmp19) {
									var tmp20 any
									{ // let
										// let binding "sepr"
										tmp21 := lang.Apply(v5, []any{v13, v3})
										var v22 any = tmp21
										_ = v22
										var tmp23 any
										tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp25 := tmp24.FindInternedVar(lang.NewSymbol("reduced?"))
										if tmp25.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
										}
										tmp26 := tmp25.Get()
										tmp27 := lang.Apply(tmp26, []any{v22})
										if lang.IsTruthy(tmp27) {
											tmp23 = v22
										} else {
											tmp28 := lang.Apply(v5, []any{v22, v14})
											tmp23 = tmp28
										}
										tmp20 = tmp23
									} // end let
									tmp15 = tmp20
								} else {
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("vreset!"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.Apply(tmp23, []any{v11, true})
									_ = tmp24
									tmp25 := lang.Apply(v5, []any{v13, v14})
									tmp15 = tmp25
								}
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5238), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(5249), lang.NewKeyword("end-column"), int(35))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5236), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(5249), lang.NewKeyword("end-column"), int(37))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("drop"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("interleave"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("repeat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v3})
				tmp15 := lang.Apply(tmp10, []any{tmp14, v4})
				tmp16 := lang.Apply(tmp7, []any{int64(1), tmp15})
				return tmp16
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into
	{
		tmp0 := lang.NewSymbol("into").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("to")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("from")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("xform"), lang.NewSymbol("from"))), lang.NewKeyword("doc"), "Returns a new coll consisting of to with all of the items of\n  from conjoined. A transducer may be supplied.\n  (into x) returns x. (into) returns [].", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6922), lang.NewKeyword("end-line"), int(6922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6928), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(6928), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
				if lang.IsTruthy(tmp10) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("persistent!"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("reduce"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("transient"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26, v4})
					tmp28 := lang.Apply(tmp16, []any{tmp27})
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("meta"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{v3})
					tmp33 := lang.Apply(tmp13, []any{tmp28, tmp32})
					tmp5 = tmp33
				} else {
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("reduce"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("conj"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp36, []any{tmp39, v3, v4})
					tmp5 = tmp40
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					var tmp12 any
					{ // let
						// let binding "tm"
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("meta"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v3})
						var v17 any = tmp16
						_ = v17
						// let binding "rf"
						var tmp18 lang.FnFunc
						tmp18 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 1:
								v19 := args[0]
								_ = v19
								tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp21 := tmp20.FindInternedVar(lang.NewSymbol("with-meta"))
								if tmp21.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
								}
								tmp22 := tmp21.Get()
								tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp24 := tmp23.FindInternedVar(lang.NewSymbol("persistent!"))
								if tmp24.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
								}
								tmp25 := tmp24.Get()
								tmp26 := lang.Apply(tmp25, []any{v19})
								tmp27 := lang.Apply(tmp22, []any{tmp26, v17})
								return tmp27
							case 2:
								v19 := args[0]
								_ = v19
								v20 := args[1]
								_ = v20
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("conj!"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(tmp23, []any{v19, v20})
								return tmp24
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6937), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(6939), lang.NewKeyword("end-column"), int(44))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v21 any = tmp20
						_ = v21
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("transduce"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("transient"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(tmp27, []any{v3})
						tmp29 := lang.Apply(tmp24, []any{v4, v21, tmp28, v5})
						tmp12 = tmp29
					} // end let
					tmp6 = tmp12
				} else {
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("transduce"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("conj"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp15, []any{v4, tmp18, v3, v5})
					tmp6 = tmp19
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into-array
	{
		tmp0 := lang.NewSymbol("into-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("aseq")), lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("aseq"))), lang.NewKeyword("doc"), "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3444), lang.NewKeyword("end-line"), int(3444))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3})
				tmp8 := lang.Apply(nil, []any{tmp7})
				return tmp8
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9 := lang.Apply(nil, []any{v3, tmp8})
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// into1
	{
		tmp0 := lang.NewSymbol("into1").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("from"))), lang.NewKeyword("doc"), "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3416), lang.NewKeyword("end-line"), int(3416), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
			if lang.IsTruthy(tmp10) {
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("persistent!"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("conj!"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("transient"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.Apply(tmp22, []any{v3})
				tmp24 := lang.Apply(tmp16, []any{tmp19, tmp23, v4})
				tmp25 := lang.Apply(tmp13, []any{tmp24})
				tmp5 = tmp25
			} else {
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("conj"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp28, []any{tmp31, v3, v4})
				tmp5 = tmp32
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ints
	{
		var tmp1 lang.FnFunc
		{ // function ints
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Ints")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("ints").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to int[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5397), lang.NewKeyword("end-line"), int(5397))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Ints")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Ints is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// io!
	{
		tmp0 := lang.NewSymbol("io!").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2504), lang.NewKeyword("end-line"), int(2504))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "message"
					var tmp7 any
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("string?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("first"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v5})
					tmp15 := lang.Apply(tmp10, []any{tmp14})
					if lang.IsTruthy(tmp15) {
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v5})
						tmp7 = tmp19
					} else {
					}
					var v20 any = tmp7
					_ = v20
					// let binding "body"
					var tmp21 any
					if lang.IsTruthy(v20) {
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v5})
						tmp21 = tmp25
					} else {
						tmp21 = v5
					}
					var v26 any = tmp21
					_ = v26
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("if")})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.lang.LockingTransaction/isRunning")})
					tmp50 := lang.Apply(tmp45, []any{tmp49})
					tmp51 := lang.Apply(tmp42, []any{tmp50})
					tmp52 := lang.Apply(tmp39, []any{tmp51})
					tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
					if tmp54.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
					}
					tmp55 := tmp54.Get()
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("seq"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp60 := tmp59.FindInternedVar(lang.NewSymbol("concat"))
					if tmp60.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
					}
					tmp61 := tmp60.Get()
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("list"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("throw")})
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp70 := tmp69.FindInternedVar(lang.NewSymbol("seq"))
					if tmp70.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
					}
					tmp71 := tmp70.Get()
					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("concat"))
					if tmp73.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
					}
					tmp74 := tmp73.Get()
					tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp76 := tmp75.FindInternedVar(lang.NewSymbol("list"))
					if tmp76.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
					}
					tmp77 := tmp76.Get()
					tmp78 := lang.Apply(tmp77, []any{lang.NewSymbol("new")})
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("list"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.Apply(tmp81, []any{lang.NewSymbol("glojure.core/IllegalStateException")})
					tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp84 := tmp83.FindInternedVar(lang.NewSymbol("list"))
					if tmp84.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
					}
					tmp85 := tmp84.Get()
					var tmp86 any
					{ // let
						// let binding "or__0__auto__"
						var v87 any = v20
						_ = v87
						var tmp88 any
						if lang.IsTruthy(v87) {
							tmp88 = v87
						} else {
							tmp88 = "I/O in transaction"
						}
						tmp86 = tmp88
					} // end let
					tmp87 := lang.Apply(tmp85, []any{tmp86})
					tmp88 := lang.Apply(tmp74, []any{tmp78, tmp82, tmp87})
					tmp89 := lang.Apply(tmp71, []any{tmp88})
					tmp90 := lang.Apply(tmp68, []any{tmp89})
					tmp91 := lang.Apply(tmp61, []any{tmp65, tmp90})
					tmp92 := lang.Apply(tmp58, []any{tmp91})
					tmp93 := lang.Apply(tmp55, []any{tmp92})
					tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp95 := tmp94.FindInternedVar(lang.NewSymbol("list"))
					if tmp95.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
					}
					tmp96 := tmp95.Get()
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("seq"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("concat"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("list"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("do")})
					tmp107 := lang.Apply(tmp102, []any{tmp106, v26})
					tmp108 := lang.Apply(tmp99, []any{tmp107})
					tmp109 := lang.Apply(tmp96, []any{tmp108})
					tmp110 := lang.Apply(tmp32, []any{tmp36, tmp52, tmp93, tmp109})
					tmp111 := lang.Apply(tmp29, []any{tmp110})
					tmp6 = tmp111
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// isa?
	{
		tmp0 := lang.NewSymbol("isa?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("child"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("child"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5543), lang.NewKeyword("end-line"), int(5543))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("isa?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("global-hierarchy"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp7, []any{tmp10, v3, v4})
				return tmp11
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("="))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v4, v5})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp12 = v11
					} else {
						var tmp13 any
						{ // let
							// let binding "or__0__auto__"
							var tmp14 any
							{ // let
								// let binding "and__0__auto__"
								tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp16 := tmp15.FindInternedVar(lang.NewSymbol("class?"))
								if tmp16.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
								}
								tmp17 := tmp16.Get()
								tmp18 := lang.Apply(tmp17, []any{v5})
								var v19 any = tmp18
								_ = v19
								var tmp20 any
								if lang.IsTruthy(v19) {
									var tmp21 any
									{ // let
										// let binding "and__0__auto__"
										tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp23 := tmp22.FindInternedVar(lang.NewSymbol("class?"))
										if tmp23.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
										}
										tmp24 := tmp23.Get()
										tmp25 := lang.Apply(tmp24, []any{v4})
										var v26 any = tmp25
										_ = v26
										var tmp27 any
										if lang.IsTruthy(v26) {
											tmp28, _ := lang.FieldOrMethod(v4, "AssignableTo")
											if reflect.TypeOf(tmp28).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("AssignableTo is not a function")))
											}
											tmp29 := lang.Apply(tmp28, []any{v5})
											tmp27 = tmp29
										} else {
											tmp27 = v26
										}
										tmp21 = tmp27
									} // end let
									tmp20 = tmp21
								} else {
									tmp20 = v19
								}
								tmp14 = tmp20
							} // end let
							var v15 any = tmp14
							_ = v15
							var tmp16 any
							if lang.IsTruthy(v15) {
								tmp16 = v15
							} else {
								var tmp17 any
								{ // let
									// let binding "or__0__auto__"
									tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp19 := tmp18.FindInternedVar(lang.NewSymbol("contains?"))
									if tmp19.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
									}
									tmp20 := tmp19.Get()
									tmp21 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
									tmp22 := lang.Apply(tmp21, []any{v4})
									tmp23 := lang.Apply(tmp20, []any{tmp22, v5})
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									if lang.IsTruthy(v24) {
										tmp25 = v24
									} else {
										var tmp26 any
										{ // let
											// let binding "or__0__auto__"
											var tmp27 any
											{ // let
												// let binding "and__0__auto__"
												tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp29 := tmp28.FindInternedVar(lang.NewSymbol("class?"))
												if tmp29.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
												}
												tmp30 := tmp29.Get()
												tmp31 := lang.Apply(tmp30, []any{v4})
												var v32 any = tmp31
												_ = v32
												var tmp33 any
												if lang.IsTruthy(v32) {
													tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp35 := tmp34.FindInternedVar(lang.NewSymbol("some"))
													if tmp35.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
													}
													tmp36 := tmp35.Get()
													var tmp37 lang.FnFunc
													tmp37 = lang.NewFnFunc(func(args ...any) any {
														if len(args) != 1 {
															panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
														}
														v38 := args[0]
														_ = v38
														tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp40 := tmp39.FindInternedVar(lang.NewSymbol("contains?"))
														if tmp40.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
														}
														tmp41 := tmp40.Get()
														tmp42 := lang.Apply(lang.NewKeyword("ancestors"), []any{v3})
														tmp43 := lang.Apply(tmp42, []any{v38})
														tmp44 := lang.Apply(tmp41, []any{tmp43, v5})
														return tmp44
													})
													tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5556), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(5556), lang.NewKeyword("end-column"), int(71))
													tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
													if err != nil {
														panic(err)
													}
													tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp41 := tmp40.FindInternedVar(lang.NewSymbol("supers"))
													if tmp41.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
													}
													tmp42 := tmp41.Get()
													tmp43 := lang.Apply(tmp42, []any{v4})
													tmp44 := lang.Apply(tmp36, []any{tmp39, tmp43})
													tmp33 = tmp44
												} else {
													tmp33 = v32
												}
												tmp27 = tmp33
											} // end let
											var v28 any = tmp27
											_ = v28
											var tmp29 any
											if lang.IsTruthy(v28) {
												tmp29 = v28
											} else {
												var tmp30 any
												{ // let
													// let binding "and__0__auto__"
													tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp32 := tmp31.FindInternedVar(lang.NewSymbol("vector?"))
													if tmp32.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
													}
													tmp33 := tmp32.Get()
													tmp34 := lang.Apply(tmp33, []any{v5})
													var v35 any = tmp34
													_ = v35
													var tmp36 any
													if lang.IsTruthy(v35) {
														var tmp37 any
														{ // let
															// let binding "and__0__auto__"
															tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp39 := tmp38.FindInternedVar(lang.NewSymbol("vector?"))
															if tmp39.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
															}
															tmp40 := tmp39.Get()
															tmp41 := lang.Apply(tmp40, []any{v4})
															var v42 any = tmp41
															_ = v42
															var tmp43 any
															if lang.IsTruthy(v42) {
																var tmp44 any
																{ // let
																	// let binding "and__0__auto__"
																	tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp46 := tmp45.FindInternedVar(lang.NewSymbol("="))
																	if tmp46.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
																	}
																	tmp47 := tmp46.Get()
																	tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp49 := tmp48.FindInternedVar(lang.NewSymbol("count"))
																	if tmp49.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
																	}
																	tmp50 := tmp49.Get()
																	tmp51 := lang.Apply(tmp50, []any{v5})
																	tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp53 := tmp52.FindInternedVar(lang.NewSymbol("count"))
																	if tmp53.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
																	}
																	tmp54 := tmp53.Get()
																	tmp55 := lang.Apply(tmp54, []any{v4})
																	tmp56 := lang.Apply(tmp47, []any{tmp51, tmp55})
																	var v57 any = tmp56
																	_ = v57
																	var tmp58 any
																	if lang.IsTruthy(v57) {
																		var tmp59 any
																		{ // let
																			// let binding "ret"
																			var v60 any = true
																			_ = v60
																			// let binding "i"
																			var v61 any = int64(0)
																			_ = v61
																			for {
																				var tmp62 any
																				var tmp63 any
																				{ // let
																					// let binding "or__0__auto__"
																					tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																					tmp65 := tmp64.FindInternedVar(lang.NewSymbol("not"))
																					if tmp65.IsMacro() {
																						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
																					}
																					tmp66 := tmp65.Get()
																					tmp67 := lang.Apply(tmp66, []any{v60})
																					var v68 any = tmp67
																					_ = v68
																					var tmp69 any
																					if lang.IsTruthy(v68) {
																						tmp69 = v68
																					} else {
																						tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																						tmp71 := tmp70.FindInternedVar(lang.NewSymbol("="))
																						if tmp71.IsMacro() {
																							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
																						}
																						tmp72 := tmp71.Get()
																						tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																						tmp74 := tmp73.FindInternedVar(lang.NewSymbol("count"))
																						if tmp74.IsMacro() {
																							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
																						}
																						tmp75 := tmp74.Get()
																						tmp76 := lang.Apply(tmp75, []any{v5})
																						tmp77 := lang.Apply(tmp72, []any{v61, tmp76})
																						tmp69 = tmp77
																					}
																					tmp63 = tmp69
																				} // end let
																				if lang.IsTruthy(tmp63) {
																					tmp62 = v60
																				} else {
																					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("isa?"))
																					if tmp66.IsMacro() {
																						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
																					}
																					tmp67 := tmp66.Get()
																					tmp68 := lang.Apply(v4, []any{v61})
																					tmp69 := lang.Apply(v5, []any{v61})
																					tmp70 := lang.Apply(tmp67, []any{v3, tmp68, tmp69})
																					var tmp64 any = tmp70
																					tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																					tmp73 := tmp72.FindInternedVar(lang.NewSymbol("inc"))
																					if tmp73.IsMacro() {
																						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
																					}
																					tmp74 := tmp73.Get()
																					tmp75 := lang.Apply(tmp74, []any{v61})
																					var tmp71 any = tmp75
																					v60 = tmp64
																					v61 = tmp71
																					continue
																				}
																				tmp59 = tmp62
																				break
																			}
																		} // end let
																		tmp58 = tmp59
																	} else {
																		tmp58 = v57
																	}
																	tmp44 = tmp58
																} // end let
																tmp43 = tmp44
															} else {
																tmp43 = v42
															}
															tmp37 = tmp43
														} // end let
														tmp36 = tmp37
													} else {
														tmp36 = v35
													}
													tmp30 = tmp36
												} // end let
												tmp29 = tmp30
											}
											tmp26 = tmp29
										} // end let
										tmp25 = tmp26
									}
									tmp17 = tmp25
								} // end let
								tmp16 = tmp17
							}
							tmp13 = tmp16
						} // end let
						tmp12 = tmp13
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterate
	{
		tmp0 := lang.NewSymbol("iterate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!) sequence of x, (f x), (f (f x)) etc.\n  f must be free of side-effects", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3011), lang.NewKeyword("end-line"), int(3011))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iteration
	{
		tmp0 := lang.NewSymbol("iteration").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("step"), lang.NewSymbol("&"), lang.NewMap(lang.NewKeyword("keys"), lang.NewVector(lang.NewSymbol("somef"), lang.NewSymbol("vf"), lang.NewSymbol("kf"), lang.NewSymbol("initk")), lang.NewKeyword("or"), lang.NewMap(lang.NewSymbol("vf"), lang.NewSymbol("identity"), lang.NewSymbol("kf"), lang.NewSymbol("identity"), lang.NewSymbol("somef"), lang.NewSymbol("some?"), lang.NewSymbol("initk"), nil)))), lang.NewKeyword("doc"), "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n\n  This can be used e.g. to consume APIs that return paginated or batched data.\n\n   step - (possibly impure) fn of 'k' -> 'ret'\n\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7716), lang.NewKeyword("end-line"), int(7716))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "map__345"
					var v6 any = v4
					_ = v6
					// let binding "map__345"
					var tmp7 any
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v6})
					if lang.IsTruthy(tmp11) {
						var tmp12 any
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v6})
						if lang.IsTruthy(tmp16) {
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("to-array"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.Apply(tmp19, []any{v6})
							tmp21 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp20})
							tmp12 = tmp21
						} else {
							var tmp22 any
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.Apply(tmp25, []any{v6})
							if lang.IsTruthy(tmp26) {
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("first"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{v6})
								tmp22 = tmp30
							} else {
							}
							tmp12 = tmp22
						}
						tmp7 = tmp12
					} else {
						tmp7 = v6
					}
					var v31 any = tmp7
					_ = v31
					// let binding "somef"
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("get"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("some?"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp34, []any{v31, lang.NewKeyword("somef"), tmp37})
					var v39 any = tmp38
					_ = v39
					// let binding "vf"
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("get"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("identity"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.Apply(tmp42, []any{v31, lang.NewKeyword("vf"), tmp45})
					var v47 any = tmp46
					_ = v47
					// let binding "kf"
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("get"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp52 := tmp51.FindInternedVar(lang.NewSymbol("identity"))
					if tmp52.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
					}
					tmp53 := tmp52.Get()
					tmp54 := lang.Apply(tmp50, []any{v31, lang.NewKeyword("kf"), tmp53})
					var v55 any = tmp54
					_ = v55
					// let binding "initk"
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("get"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.Apply(tmp58, []any{v31, lang.NewKeyword("initk"), nil})
					var v60 any = tmp59
					_ = v60
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("seq"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.NewVector(nil)
					tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7743), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(7743), lang.NewKeyword("end-column"), int(11))
					tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp67 lang.FnFunc
					{ // function next
						var v68 lang.FnFunc
						tmp67 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v69 := args[0]
							_ = v69
							var tmp70 any
							tmp71 := lang.Apply(v39, []any{v69})
							if lang.IsTruthy(tmp71) {
								tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp73 := tmp72.FindInternedVar(lang.NewSymbol("cons"))
								if tmp73.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
								}
								tmp74 := tmp73.Get()
								tmp75 := lang.Apply(v47, []any{v69})
								var tmp76 any
								{ // let
									// let binding "temp__0__auto__"
									tmp77 := lang.Apply(v55, []any{v69})
									var v78 any = tmp77
									_ = v78
									var tmp79 any
									tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp81 := tmp80.FindInternedVar(lang.NewSymbol("nil?"))
									if tmp81.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
									}
									tmp82 := tmp81.Get()
									tmp83 := lang.Apply(tmp82, []any{v78})
									if lang.IsTruthy(tmp83) {
									} else {
										var tmp84 any
										{ // let
											// let binding "k"
											var v85 any = v78
											_ = v85
											var tmp86 lang.FnFunc
											tmp86 = lang.NewFnFunc(func(args ...any) any {
												if len(args) != 0 {
													panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
												}
												tmp87 := lang.Apply(v3, []any{v85})
												tmp88 := lang.Apply(v68, []any{tmp87})
												return tmp88
											})
											tmp87 := lang.Apply(lang.NewLazySeq, []any{tmp86})
											tmp84 = tmp87
										} // end let
										tmp79 = tmp84
									}
									tmp76 = tmp79
								} // end let
								tmp77 := lang.Apply(tmp74, []any{tmp75, tmp76})
								tmp70 = tmp77
							} else {
							}
							return tmp70
						})
						v68 = tmp67
						_ = v68
					}
					tmp68 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7744), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7748), lang.NewKeyword("end-column"), int(51))
					tmp69, err := lang.WithMeta(tmp67, tmp68.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp70 := lang.Apply(v3, []any{v60})
					tmp71 := lang.Apply(tmp69, []any{tmp70})
					tmp72 := lang.Apply(tmp63, []any{tmp66, tmp71})
					tmp73 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("reduce"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.NewVector(nil, nil, nil)
					tmp78 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7751), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7751), lang.NewKeyword("end-column"), int(22))
					tmp79, err := lang.WithMeta(tmp77, tmp78.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var tmp80 any
					{ // let
						// let binding "acc"
						var v81 any = nil
						_ = v81
						// let binding "ret"
						tmp82 := lang.Apply(v3, []any{v60})
						var v83 any = tmp82
						_ = v83
						for {
							var tmp84 any
							tmp85 := lang.Apply(v39, []any{v83})
							if lang.IsTruthy(tmp85) {
								var tmp86 any
								{ // let
									// let binding "acc"
									tmp87 := lang.Apply(v47, []any{v83})
									tmp88 := lang.Apply(nil, []any{v81, tmp87})
									var v89 any = tmp88
									_ = v89
									var tmp90 any
									tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp92 := tmp91.FindInternedVar(lang.NewSymbol("reduced?"))
									if tmp92.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
									}
									tmp93 := tmp92.Get()
									tmp94 := lang.Apply(tmp93, []any{v89})
									if lang.IsTruthy(tmp94) {
										tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp96 := tmp95.FindInternedVar(lang.NewSymbol("deref"))
										if tmp96.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
										}
										tmp97 := tmp96.Get()
										tmp98 := lang.Apply(tmp97, []any{v89})
										tmp90 = tmp98
									} else {
										var tmp99 any
										{ // let
											// let binding "temp__0__auto__"
											tmp100 := lang.Apply(v55, []any{v83})
											var v101 any = tmp100
											_ = v101
											var tmp102 any
											tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp104 := tmp103.FindInternedVar(lang.NewSymbol("nil?"))
											if tmp104.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
											}
											tmp105 := tmp104.Get()
											tmp106 := lang.Apply(tmp105, []any{v101})
											if lang.IsTruthy(tmp106) {
												tmp102 = v89
											} else {
												var tmp107 any
												{ // let
													// let binding "k"
													var v108 any = v101
													_ = v108
													var tmp109 any = v89
													tmp111 := lang.Apply(v3, []any{v108})
													var tmp110 any = tmp111
													v81 = tmp109
													v83 = tmp110
													continue
												} // end let
												tmp102 = tmp107
											}
											tmp99 = tmp102
										} // end let
										tmp90 = tmp99
									}
									tmp86 = tmp90
								} // end let
								tmp84 = tmp86
							} else {
								tmp84 = v81
							}
							tmp80 = tmp84
							break
						}
					} // end let
					tmp81 := lang.Apply(tmp76, []any{tmp79, tmp80})
					tmp82 := lang.Apply(nil, []any{nil, tmp72, tmp73, tmp81})
					tmp5 = tmp82
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// iterator-seq
	{
		tmp0 := lang.NewSymbol("iterator-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iter"))), lang.NewKeyword("doc"), "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5700), lang.NewKeyword("end-line"), int(5700))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// juxt
	{
		tmp0 := lang.NewSymbol("juxt").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("h")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("g"), lang.NewSymbol("h"), lang.NewSymbol("&"), lang.NewSymbol("fs"))), lang.NewKeyword("doc"), "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2568), lang.NewKeyword("end-line"), int(2568))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp5 := lang.Apply(v3, nil)
						tmp6 := lang.NewVector(tmp5)
						tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2578), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2578), lang.NewKeyword("end-column"), int(16))
						tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp8
					case 1:
						v5 := args[0]
						_ = v5
						tmp6 := lang.Apply(v3, []any{v5})
						tmp7 := lang.NewVector(tmp6)
						tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2579), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2579), lang.NewKeyword("end-column"), int(19))
						tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp9
					case 2:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v5, v6})
						tmp8 := lang.NewVector(tmp7)
						tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2580), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2580), lang.NewKeyword("end-column"), int(23))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 3:
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v5, v6, v7})
						tmp9 := lang.NewVector(tmp8)
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2581), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2581), lang.NewKeyword("end-column"), int(27))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v5 := args[0]
						_ = v5
						v6 := args[1]
						_ = v6
						v7 := args[2]
						_ = v7
						var v8 any = lang.NewList(args[3:]...)
						_ = v8
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("apply"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v3, v5, v6, v7, v8})
						tmp13 := lang.NewVector(tmp12)
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2582), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2582), lang.NewKeyword("end-column"), int(45))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp15
					}
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2577), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2582), lang.NewKeyword("end-column"), int(47))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, nil)
						tmp7 := lang.Apply(v4, nil)
						tmp8 := lang.NewVector(tmp6, tmp7)
						tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2585), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2585), lang.NewKeyword("end-column"), int(20))
						tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp10
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v6})
						tmp8 := lang.Apply(v4, []any{v6})
						tmp9 := lang.NewVector(tmp7, tmp8)
						tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2586), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2586), lang.NewKeyword("end-column"), int(25))
						tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp11
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v6, v7})
						tmp9 := lang.Apply(v4, []any{v6, v7})
						tmp10 := lang.NewVector(tmp8, tmp9)
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2587), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2587), lang.NewKeyword("end-column"), int(31))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v6, v7, v8})
						tmp10 := lang.Apply(v4, []any{v6, v7, v8})
						tmp11 := lang.NewVector(tmp9, tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2588), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2588), lang.NewKeyword("end-column"), int(37))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v3, v6, v7, v8, v9})
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("apply"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v4, v6, v7, v8, v9})
						tmp18 := lang.NewVector(tmp13, tmp17)
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2589), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2589), lang.NewKeyword("end-column"), int(66))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp20
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2584), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2589), lang.NewKeyword("end-column"), int(68))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, nil)
						tmp8 := lang.Apply(v4, nil)
						tmp9 := lang.Apply(v5, nil)
						tmp10 := lang.NewVector(tmp7, tmp8, tmp9)
						tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2592), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(2592), lang.NewKeyword("end-column"), int(24))
						tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp12
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v7})
						tmp9 := lang.Apply(v4, []any{v7})
						tmp10 := lang.Apply(v5, []any{v7})
						tmp11 := lang.NewVector(tmp8, tmp9, tmp10)
						tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2593), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(2593), lang.NewKeyword("end-column"), int(31))
						tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp13
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v7, v8})
						tmp10 := lang.Apply(v4, []any{v7, v8})
						tmp11 := lang.Apply(v5, []any{v7, v8})
						tmp12 := lang.NewVector(tmp9, tmp10, tmp11)
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2594), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2594), lang.NewKeyword("end-column"), int(39))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp14
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v7, v8, v9})
						tmp11 := lang.Apply(v4, []any{v7, v8, v9})
						tmp12 := lang.Apply(v5, []any{v7, v8, v9})
						tmp13 := lang.NewVector(tmp10, tmp11, tmp12)
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2595), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2595), lang.NewKeyword("end-column"), int(47))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp15
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("apply"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v3, v7, v8, v9, v10})
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("apply"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v4, v7, v8, v9, v10})
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("apply"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v5, v7, v8, v9, v10})
						tmp23 := lang.NewVector(tmp14, tmp18, tmp22)
						tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2596), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2596), lang.NewKeyword("end-column"), int(87))
						tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						return tmp25
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2591), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2596), lang.NewKeyword("end-column"), int(89))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "fs"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("list*"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v3, v4, v5, v6})
					var v12 any = tmp11
					_ = v12
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							var tmp17 lang.FnFunc
							tmp17 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v18 := args[0]
								_ = v18
								v19 := args[1]
								_ = v19
								tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp21 := tmp20.FindInternedVar(lang.NewSymbol("conj"))
								if tmp21.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
								}
								tmp22 := tmp21.Get()
								tmp23 := lang.Apply(v19, nil)
								tmp24 := lang.Apply(tmp22, []any{v18, tmp23})
								return tmp24
							})
							tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2600), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(2600), lang.NewKeyword("end-column"), int(37))
							tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp20 := lang.NewVector()
							tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2600), lang.NewKeyword("column"), int(39), lang.NewKeyword("end-line"), int(2600), lang.NewKeyword("end-column"), int(40))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 := lang.Apply(tmp16, []any{tmp19, tmp22, v12})
							return tmp23
						case 1:
							v14 := args[0]
							_ = v14
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							var tmp18 lang.FnFunc
							tmp18 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v19 := args[0]
								_ = v19
								v20 := args[1]
								_ = v20
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("conj"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(v20, []any{v14})
								tmp25 := lang.Apply(tmp23, []any{v19, tmp24})
								return tmp25
							})
							tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2601), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(2601), lang.NewKeyword("end-column"), int(40))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.NewVector()
							tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2601), lang.NewKeyword("column"), int(42), lang.NewKeyword("end-line"), int(2601), lang.NewKeyword("end-column"), int(43))
							tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp24 := lang.Apply(tmp17, []any{tmp20, tmp23, v12})
							return tmp24
						case 2:
							v14 := args[0]
							_ = v14
							v15 := args[1]
							_ = v15
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							var tmp19 lang.FnFunc
							tmp19 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v20 := args[0]
								_ = v20
								v21 := args[1]
								_ = v21
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("conj"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(v21, []any{v14, v15})
								tmp26 := lang.Apply(tmp24, []any{v20, tmp25})
								return tmp26
							})
							tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2602), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(2602), lang.NewKeyword("end-column"), int(44))
							tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp22 := lang.NewVector()
							tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2602), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(2602), lang.NewKeyword("end-column"), int(47))
							tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp25 := lang.Apply(tmp18, []any{tmp21, tmp24, v12})
							return tmp25
						case 3:
							v14 := args[0]
							_ = v14
							v15 := args[1]
							_ = v15
							v16 := args[2]
							_ = v16
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							var tmp20 lang.FnFunc
							tmp20 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v21 := args[0]
								_ = v21
								v22 := args[1]
								_ = v22
								tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp24 := tmp23.FindInternedVar(lang.NewSymbol("conj"))
								if tmp24.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
								}
								tmp25 := tmp24.Get()
								tmp26 := lang.Apply(v22, []any{v14, v15, v16})
								tmp27 := lang.Apply(tmp25, []any{v21, tmp26})
								return tmp27
							})
							tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2603), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(2603), lang.NewKeyword("end-column"), int(48))
							tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp23 := lang.NewVector()
							tmp24 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2603), lang.NewKeyword("column"), int(50), lang.NewKeyword("end-line"), int(2603), lang.NewKeyword("end-column"), int(51))
							tmp25, err := lang.WithMeta(tmp23, tmp24.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp26 := lang.Apply(tmp19, []any{tmp22, tmp25, v12})
							return tmp26
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v14 := args[0]
							_ = v14
							v15 := args[1]
							_ = v15
							v16 := args[2]
							_ = v16
							var v17 any = lang.NewList(args[3:]...)
							_ = v17
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							var tmp21 lang.FnFunc
							tmp21 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v22 := args[0]
								_ = v22
								v23 := args[1]
								_ = v23
								tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp25 := tmp24.FindInternedVar(lang.NewSymbol("conj"))
								if tmp25.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
								}
								tmp26 := tmp25.Get()
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("apply"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{v23, v14, v15, v16, v17})
								tmp31 := lang.Apply(tmp26, []any{v22, tmp30})
								return tmp31
							})
							tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2604), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(66))
							tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp24 := lang.NewVector()
							tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2604), lang.NewKeyword("column"), int(68), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(69))
							tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp27 := lang.Apply(tmp20, []any{tmp23, tmp26, v12})
							return tmp27
						}
					})
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2599), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(2604), lang.NewKeyword("end-column"), int(75))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp15
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep
	{
		tmp0 := lang.NewSymbol("keep").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7339), lang.NewKeyword("end-line"), int(7339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "v"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp14 := tmp13.FindInternedVar(lang.NewSymbol("nil?"))
								if tmp14.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
								}
								tmp15 := tmp14.Get()
								tmp16 := lang.Apply(tmp15, []any{v11})
								if lang.IsTruthy(tmp16) {
									tmp12 = v7
								} else {
									tmp17 := lang.Apply(v5, []any{v7, v11})
									tmp12 = tmp17
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7347), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7354), lang.NewKeyword("end-column"), int(31))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7346), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7354), lang.NewKeyword("end-column"), int(32))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("chunked-seq?"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v14})
								if lang.IsTruthy(tmp19) {
									var tmp20 any
									{ // let
										// let binding "c"
										tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp22 := tmp21.FindInternedVar(lang.NewSymbol("chunk-first"))
										if tmp22.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
										}
										tmp23 := tmp22.Get()
										tmp24 := lang.Apply(tmp23, []any{v14})
										var v25 any = tmp24
										_ = v25
										// let binding "size"
										tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp27 := tmp26.FindInternedVar(lang.NewSymbol("count"))
										if tmp27.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
										}
										tmp28 := tmp27.Get()
										tmp29 := lang.Apply(tmp28, []any{v25})
										var v30 any = tmp29
										_ = v30
										// let binding "b"
										tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp32 := tmp31.FindInternedVar(lang.NewSymbol("chunk-buffer"))
										if tmp32.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
										}
										tmp33 := tmp32.Get()
										tmp34 := lang.Apply(tmp33, []any{v30})
										var v35 any = tmp34
										_ = v35
										var tmp36 any
										{ // let
											// let binding "n__0__auto__"
											tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp38 := tmp37.FindInternedVar(lang.NewSymbol("long"))
											if tmp38.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
											}
											tmp39 := tmp38.Get()
											tmp40 := lang.Apply(tmp39, []any{v30})
											var v41 any = tmp40
											_ = v41
											var tmp42 any
											{ // let
												// let binding "i"
												var v43 any = int64(0)
												_ = v43
												for {
													var tmp44 any
													tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp46 := tmp45.FindInternedVar(lang.NewSymbol("<"))
													if tmp46.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
													}
													tmp47 := tmp46.Get()
													tmp48 := lang.Apply(tmp47, []any{v43, v41})
													if lang.IsTruthy(tmp48) {
														var tmp49 any
														{ // let
															// let binding "x"
															tmp50, _ := lang.FieldOrMethod(v25, "nth")
															if reflect.TypeOf(tmp50).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp51 := lang.Apply(tmp50, []any{v43})
															tmp52 := lang.Apply(v3, []any{tmp51})
															var v53 any = tmp52
															_ = v53
															var tmp54 any
															tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp56 := tmp55.FindInternedVar(lang.NewSymbol("nil?"))
															if tmp56.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
															}
															tmp57 := tmp56.Get()
															tmp58 := lang.Apply(tmp57, []any{v53})
															if lang.IsTruthy(tmp58) {
															} else {
																tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp60 := tmp59.FindInternedVar(lang.NewSymbol("chunk-append"))
																if tmp60.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
																}
																tmp61 := tmp60.Get()
																tmp62 := lang.Apply(tmp61, []any{v35, v53})
																tmp54 = tmp62
															}
															tmp49 = tmp54
														} // end let
														_ = tmp49
														tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp52 := tmp51.FindInternedVar(lang.NewSymbol("unchecked-inc"))
														if tmp52.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
														}
														tmp53 := tmp52.Get()
														tmp54 := lang.Apply(tmp53, []any{v43})
														var tmp50 any = tmp54
														v43 = tmp50
														continue
													} else {
													}
													tmp42 = tmp44
													break
												}
											} // end let
											tmp36 = tmp42
										} // end let
										_ = tmp36
										tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp38 := tmp37.FindInternedVar(lang.NewSymbol("chunk-cons"))
										if tmp38.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
										}
										tmp39 := tmp38.Get()
										tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp41 := tmp40.FindInternedVar(lang.NewSymbol("chunk"))
										if tmp41.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
										}
										tmp42 := tmp41.Get()
										tmp43 := lang.Apply(tmp42, []any{v35})
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("keep"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp48 := tmp47.FindInternedVar(lang.NewSymbol("chunk-rest"))
										if tmp48.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
										}
										tmp49 := tmp48.Get()
										tmp50 := lang.Apply(tmp49, []any{v14})
										tmp51 := lang.Apply(tmp46, []any{v3, tmp50})
										tmp52 := lang.Apply(tmp39, []any{tmp43, tmp51})
										tmp20 = tmp52
									} // end let
									tmp15 = tmp20
								} else {
									var tmp21 any
									{ // let
										// let binding "x"
										tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp23 := tmp22.FindInternedVar(lang.NewSymbol("first"))
										if tmp23.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
										}
										tmp24 := tmp23.Get()
										tmp25 := lang.Apply(tmp24, []any{v14})
										tmp26 := lang.Apply(v3, []any{tmp25})
										var v27 any = tmp26
										_ = v27
										var tmp28 any
										tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp30 := tmp29.FindInternedVar(lang.NewSymbol("nil?"))
										if tmp30.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
										}
										tmp31 := tmp30.Get()
										tmp32 := lang.Apply(tmp31, []any{v27})
										if lang.IsTruthy(tmp32) {
											tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp34 := tmp33.FindInternedVar(lang.NewSymbol("keep"))
											if tmp34.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
											}
											tmp35 := tmp34.Get()
											tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp37 := tmp36.FindInternedVar(lang.NewSymbol("rest"))
											if tmp37.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
											}
											tmp38 := tmp37.Get()
											tmp39 := lang.Apply(tmp38, []any{v14})
											tmp40 := lang.Apply(tmp35, []any{v3, tmp39})
											tmp28 = tmp40
										} else {
											tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp42 := tmp41.FindInternedVar(lang.NewSymbol("cons"))
											if tmp42.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
											}
											tmp43 := tmp42.Get()
											tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp45 := tmp44.FindInternedVar(lang.NewSymbol("keep"))
											if tmp45.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
											}
											tmp46 := tmp45.Get()
											tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp48 := tmp47.FindInternedVar(lang.NewSymbol("rest"))
											if tmp48.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
											}
											tmp49 := tmp48.Get()
											tmp50 := lang.Apply(tmp49, []any{v14})
											tmp51 := lang.Apply(tmp46, []any{v3, tmp50})
											tmp52 := lang.Apply(tmp43, []any{v27, tmp51})
											tmp28 = tmp52
										}
										tmp21 = tmp28
									} // end let
									tmp15 = tmp21
								}
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keep-indexed
	{
		tmp0 := lang.NewSymbol("keep-indexed").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7372), lang.NewKeyword("end-line"), int(7372))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{int64(-1)})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "i"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("inc"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp20 any
									switch reflect.TypeOf(tmp19).Kind() {
									case reflect.Func:
										tmp20 = lang.Apply(tmp19, nil)
									default:
										tmp20 = tmp19
									}
									tmp21 := lang.Apply(tmp18, []any{tmp20})
									tmp22, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp22).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp23 := lang.Apply(tmp22, []any{tmp21})
									var v24 any = tmp23
									_ = v24
									// let binding "v"
									tmp25 := lang.Apply(v3, []any{v24, v14})
									var v26 any = tmp25
									_ = v26
									var tmp27 any
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("nil?"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.Apply(tmp30, []any{v26})
									if lang.IsTruthy(tmp31) {
										tmp27 = v13
									} else {
										tmp32 := lang.Apply(v5, []any{v13, v26})
										tmp27 = tmp32
									}
									tmp15 = tmp27
								} // end let
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7382), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7390), lang.NewKeyword("end-column"), int(33))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7380), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7390), lang.NewKeyword("end-column"), int(35))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// key
	{
		tmp0 := lang.NewSymbol("key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns the key of the map entry.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1563), lang.NewKeyword("end-line"), int(1563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetKey")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetKey is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keys
	{
		tmp0 := lang.NewSymbol("keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"))), lang.NewKeyword("doc"), "Returns a sequence of the map's keys, in the same order as (seq map).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1551), lang.NewKeyword("end-line"), int(1551))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Keys, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword
	{
		tmp1 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp0 := lang.NewSymbol("keyword").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(609), lang.NewKeyword("end-line"), int(609))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("keyword?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp5 = v4
				} else {
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("symbol?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v4})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(lang.InternKeywordSymbol, []any{v4})
						tmp10 = tmp15
					} else {
						var tmp16 any
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("string?"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{v4})
						if lang.IsTruthy(tmp20) {
							tmp21 := lang.Apply(lang.InternKeywordString, []any{v4})
							tmp16 = tmp21
						} else {
						}
						tmp10 = tmp16
					}
					tmp5 = tmp10
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternKeyword, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// keyword?
	{
		tmp0 := lang.NewSymbol("keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Keyword", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(563), lang.NewKeyword("end-line"), int(563))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// last
	{
		tmp0 := lang.NewSymbol("last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return the last item in coll, in linear time", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(262), lang.NewKeyword("end-line"), int(266))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function last
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
			recur_loop_32:
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("next"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("next"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v4})
					var tmp10 any = tmp14
					v4 = tmp10
					goto recur_loop_32
				} else {
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v4})
					tmp5 = tmp18
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(266), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(269), lang.NewKeyword("end-column"), int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-cat
	{
		tmp0 := lang.NewSymbol("lazy-cat").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4636), lang.NewKeyword("end-line"), int(4636))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/concat")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("map"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				var tmp19 lang.FnFunc
				tmp19 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v20 := args[0]
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("glojure.core/lazy-seq"), v20})
					return tmp24
				})
				tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4644), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(4644), lang.NewKeyword("end-column"), int(37))
				tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp22 := lang.Apply(tmp18, []any{tmp21, v5})
				tmp23 := lang.Apply(tmp11, []any{tmp15, tmp22})
				tmp24 := lang.Apply(tmp8, []any{tmp23})
				return tmp24
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lazy-seq
	{
		tmp0 := lang.NewSymbol("lazy-seq").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(676), lang.NewKeyword("end-line"), int(676))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("list"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("list*"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.NewVector()
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(683), lang.NewKeyword("column"), int(101), lang.NewKeyword("end-line"), int(683), lang.NewKeyword("end-column"), int(102))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := lang.Apply(tmp11, []any{lang.NewSymbol("fn*"), tmp14, v5})
				tmp16 := lang.Apply(tmp8, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.NewLazySeq"), tmp15})
				return tmp16
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// let
	{
		tmp0 := lang.NewSymbol("let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://glojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("let"), lang.NewVector(lang.NewSymbol("bindings*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4496), lang.NewKeyword("end-line"), int(4496), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp56 := tmp55.FindInternedVar(lang.NewSymbol("seq"))
				if tmp56.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
				}
				tmp57 := tmp56.Get()
				tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp59 := tmp58.FindInternedVar(lang.NewSymbol("concat"))
				if tmp59.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
				}
				tmp60 := tmp59.Get()
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("let*")})
				tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
				if tmp66.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
				}
				tmp67 := tmp66.Get()
				tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp69 := tmp68.FindInternedVar(lang.NewSymbol("destructure"))
				if tmp69.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
				}
				tmp70 := tmp69.Get()
				tmp71 := lang.Apply(tmp70, []any{v5})
				tmp72 := lang.Apply(tmp67, []any{tmp71})
				tmp73 := lang.Apply(tmp60, []any{tmp64, tmp72, v6})
				tmp74 := lang.Apply(tmp57, []any{tmp73})
				return tmp74
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// letfn
	{
		tmp0 := lang.NewSymbol("letfn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fnspecs"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("letfn"), lang.NewVector(lang.NewSymbol("fnspecs*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("url"), nil, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6545), lang.NewKeyword("end-line"), int(6545), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("letfn*")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("vec"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("interleave"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("map"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp28, []any{tmp31, v5})
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("map"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				var tmp36 lang.FnFunc
				tmp36 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v37 := args[0]
					_ = v37
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("cons"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp40, []any{lang.NewSymbol("glojure.core/fn"), v37})
					return tmp41
				})
				tmp37 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6555), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(6555), lang.NewKeyword("end-column"), int(47))
				tmp38, err := lang.WithMeta(tmp36, tmp37.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp39 := lang.Apply(tmp35, []any{tmp38, v5})
				tmp40 := lang.Apply(tmp25, []any{tmp32, tmp39})
				tmp41 := lang.Apply(tmp22, []any{tmp40})
				tmp42 := lang.Apply(tmp19, []any{tmp41})
				tmp43 := lang.Apply(tmp12, []any{tmp16, tmp42, v6})
				tmp44 := lang.Apply(tmp9, []any{tmp43})
				return tmp44
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// libspec?
	{
		tmp0 := lang.NewSymbol("libspec?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a libspec", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5848), lang.NewKeyword("end-line"), int(5848), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("symbol?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					var tmp11 any
					{ // let
						// let binding "and__0__auto__"
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("vector?"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v3})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							var tmp18 any
							{ // let
								// let binding "or__0__auto__"
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("nil?"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("second"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v3})
								tmp26 := lang.Apply(tmp21, []any{tmp25})
								var v27 any = tmp26
								_ = v27
								var tmp28 any
								if lang.IsTruthy(v27) {
									tmp28 = v27
								} else {
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("keyword?"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("second"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v3})
									tmp36 := lang.Apply(tmp31, []any{tmp35})
									tmp28 = tmp36
								}
								tmp18 = tmp28
							} // end let
							tmp17 = tmp18
						} else {
							tmp17 = v16
						}
						tmp11 = tmp17
					} // end let
					tmp10 = tmp11
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// lift-ns
	{
		tmp0 := lang.NewSymbol("lift-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns [lifted-ns lifted-kvs] or nil if m can't be lifted.", lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(261), lang.NewKeyword("end-line"), int(261), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*print-namespace-maps*"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			if lang.IsTruthy(tmp7) {
				var tmp8 any
				{ // let
					// let binding "ns"
					var v9 any = nil
					_ = v9
					// let binding "G__221"
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{v3})
					var v14 any = tmp13
					_ = v14
					// let binding "vec__222"
					var v15 any = v14
					_ = v15
					// let binding "seq__223"
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("seq"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v15})
					var v20 any = tmp19
					_ = v20
					// let binding "first__224"
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v20})
					var v25 any = tmp24
					_ = v25
					// let binding "seq__223"
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("next"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.Apply(tmp28, []any{v20})
					var v30 any = tmp29
					_ = v30
					// let binding "vec__225"
					var v31 any = v25
					_ = v31
					// let binding "k"
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("nth"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v31, int64(0), nil})
					var v36 any = tmp35
					_ = v36
					// let binding "v"
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("nth"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v31, int64(1), nil})
					var v41 any = tmp40
					_ = v41
					// let binding "entry"
					var v42 any = v31
					_ = v42
					// let binding "entries"
					var v43 any = v30
					_ = v43
					// let binding "kvs"
					tmp44 := lang.NewVector()
					tmp45 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(267), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(267), lang.NewKeyword("end-column"), int(17))
					tmp46, err := lang.WithMeta(tmp44, tmp45.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v47 any = tmp46
					_ = v47
					var tmp48 any
					{ // let
						// let binding "ns"
						var v49 any = v9
						_ = v49
						// let binding "G__221"
						var v50 any = v14
						_ = v50
						// let binding "kvs"
						var v51 any = v47
						_ = v51
						for {
							var tmp52 any
							{ // let
								// let binding "ns"
								var v53 any = v49
								_ = v53
								// let binding "vec__228"
								var v54 any = v50
								_ = v54
								// let binding "seq__229"
								tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp56 := tmp55.FindInternedVar(lang.NewSymbol("seq"))
								if tmp56.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
								}
								tmp57 := tmp56.Get()
								tmp58 := lang.Apply(tmp57, []any{v54})
								var v59 any = tmp58
								_ = v59
								// let binding "first__230"
								tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp61 := tmp60.FindInternedVar(lang.NewSymbol("first"))
								if tmp61.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
								}
								tmp62 := tmp61.Get()
								tmp63 := lang.Apply(tmp62, []any{v59})
								var v64 any = tmp63
								_ = v64
								// let binding "seq__229"
								tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp66 := tmp65.FindInternedVar(lang.NewSymbol("next"))
								if tmp66.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
								}
								tmp67 := tmp66.Get()
								tmp68 := lang.Apply(tmp67, []any{v59})
								var v69 any = tmp68
								_ = v69
								// let binding "vec__231"
								var v70 any = v64
								_ = v70
								// let binding "k"
								tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp72 := tmp71.FindInternedVar(lang.NewSymbol("nth"))
								if tmp72.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
								}
								tmp73 := tmp72.Get()
								tmp74 := lang.Apply(tmp73, []any{v70, int64(0), nil})
								var v75 any = tmp74
								_ = v75
								// let binding "v"
								tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp77 := tmp76.FindInternedVar(lang.NewSymbol("nth"))
								if tmp77.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
								}
								tmp78 := tmp77.Get()
								tmp79 := lang.Apply(tmp78, []any{v70, int64(1), nil})
								var v80 any = tmp79
								_ = v80
								// let binding "entry"
								var v81 any = v70
								_ = v81
								// let binding "entries"
								var v82 any = v69
								_ = v82
								// let binding "kvs"
								var v83 any = v51
								_ = v83
								var tmp84 any
								if lang.IsTruthy(v81) {
									var tmp85 any
									tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp87 := tmp86.FindInternedVar(lang.NewSymbol("qualified-ident?"))
									if tmp87.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
									}
									tmp88 := tmp87.Get()
									tmp89 := lang.Apply(tmp88, []any{v75})
									if lang.IsTruthy(tmp89) {
										var tmp90 any
										if lang.IsTruthy(v53) {
											var tmp91 any
											tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp93 := tmp92.FindInternedVar(lang.NewSymbol("="))
											if tmp93.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
											}
											tmp94 := tmp93.Get()
											tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp96 := tmp95.FindInternedVar(lang.NewSymbol("namespace"))
											if tmp96.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
											}
											tmp97 := tmp96.Get()
											tmp98 := lang.Apply(tmp97, []any{v75})
											tmp99 := lang.Apply(tmp94, []any{v53, tmp98})
											if lang.IsTruthy(tmp99) {
												var tmp100 any = v53
												var tmp101 any = v82
												tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp104 := tmp103.FindInternedVar(lang.NewSymbol("conj"))
												if tmp104.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
												}
												tmp105 := tmp104.Get()
												tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp107 := tmp106.FindInternedVar(lang.NewSymbol("strip-ns"))
												if tmp107.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
												}
												tmp108 := tmp107.Get()
												tmp109 := lang.Apply(tmp108, []any{v75})
												tmp110 := lang.NewVector(tmp109, v80)
												tmp111 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(272), lang.NewKeyword("column"), int(43), lang.NewKeyword("end-line"), int(272), lang.NewKeyword("end-column"), int(58))
												tmp112, err := lang.WithMeta(tmp110, tmp111.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp113 := lang.Apply(tmp105, []any{v83, tmp112})
												var tmp102 any = tmp113
												v49 = tmp100
												v50 = tmp101
												v51 = tmp102
												continue
											} else {
											}
											tmp90 = tmp91
										} else {
											var tmp114 any
											{ // let
												// let binding "temp__0__auto__"
												tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp116 := tmp115.FindInternedVar(lang.NewSymbol("namespace"))
												if tmp116.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
												}
												tmp117 := tmp116.Get()
												tmp118 := lang.Apply(tmp117, []any{v75})
												var v119 any = tmp118
												_ = v119
												var tmp120 any
												if lang.IsTruthy(v119) {
													var tmp121 any
													{ // let
														// let binding "new-ns"
														var v122 any = v119
														_ = v122
														var tmp123 any = v122
														var tmp124 any = v82
														tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp127 := tmp126.FindInternedVar(lang.NewSymbol("conj"))
														if tmp127.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
														}
														tmp128 := tmp127.Get()
														tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp130 := tmp129.FindInternedVar(lang.NewSymbol("strip-ns"))
														if tmp130.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
														}
														tmp131 := tmp130.Get()
														tmp132 := lang.Apply(tmp131, []any{v75})
														tmp133 := lang.NewVector(tmp132, v80)
														tmp134 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(274), lang.NewKeyword("column"), int(47), lang.NewKeyword("end-line"), int(274), lang.NewKeyword("end-column"), int(62))
														tmp135, err := lang.WithMeta(tmp133, tmp134.(lang.IPersistentMap))
														if err != nil {
															panic(err)
														}
														tmp136 := lang.Apply(tmp128, []any{v83, tmp135})
														var tmp125 any = tmp136
														v49 = tmp123
														v50 = tmp124
														v51 = tmp125
														continue
													} // end let
													tmp120 = tmp121
												} else {
												}
												tmp114 = tmp120
											} // end let
											tmp90 = tmp114
										}
										tmp85 = tmp90
									} else {
									}
									tmp84 = tmp85
								} else {
									tmp115 := lang.NewVector(v53, v83)
									tmp116 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(275), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(275), lang.NewKeyword("end-column"), int(16))
									tmp117, err := lang.WithMeta(tmp115, tmp116.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp84 = tmp117
								}
								tmp52 = tmp84
							} // end let
							tmp48 = tmp52
							break
						}
					} // end let
					tmp8 = tmp48
				} // end let
				tmp4 = tmp8
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// line-seq
	{
		tmp0 := lang.NewSymbol("line-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rdr"))), lang.NewKeyword("doc"), "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3068), lang.NewKeyword("end-line"), int(3068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "temp__0__auto__"
				tmp5, ok := lang.FieldOrMethod(v3, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "readLine")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				if lang.IsTruthy(v7) {
					var tmp9 any
					{ // let
						// let binding "line"
						var v10 any = v7
						_ = v10
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("cons"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("line-seq"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, []any{v3})
							return tmp18
						})
						tmp15 := lang.Apply(lang.NewLazySeq, []any{tmp14})
						tmp16 := lang.Apply(tmp13, []any{v10, tmp15})
						tmp9 = tmp16
					} // end let
					tmp8 = tmp9
				} else {
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list
	{
		tmp0 := lang.NewSymbol("list").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("items"))), lang.NewKeyword("doc"), "Creates a new list containing the items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(15), lang.NewKeyword("end-line"), int(18))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list*
	{
		tmp0 := lang.NewSymbol("list*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("args")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(641), lang.NewKeyword("end-line"), int(641))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("cons"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("cons"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("cons"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v4, v5})
				tmp13 := lang.Apply(tmp8, []any{v3, tmp12})
				return tmp13
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("cons"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("cons"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("cons"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v5, v6})
				tmp17 := lang.Apply(tmp12, []any{v4, tmp16})
				tmp18 := lang.Apply(tmp9, []any{v3, tmp17})
				return tmp18
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("cons"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("cons"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("cons"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("cons"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("spread"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.Apply(tmp22, []any{v7})
				tmp24 := lang.Apply(tmp19, []any{v6, tmp23})
				tmp25 := lang.Apply(tmp16, []any{v5, tmp24})
				tmp26 := lang.Apply(tmp13, []any{v4, tmp25})
				tmp27 := lang.Apply(tmp10, []any{v3, tmp26})
				return tmp27
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// list?
	{
		tmp0 := lang.NewSymbol("list?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentList", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6198), lang.NewKeyword("end-line"), int(6198))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.IPersistentList)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load
	{
		tmp0 := lang.NewSymbol("load").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("paths"))), lang.NewKeyword("doc"), "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("redef"), true, lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6095), lang.NewKeyword("end-line"), int(6095))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "seq_133"
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.Apply(tmp7, []any{v3})
					var v9 any = tmp8
					_ = v9
					// let binding "chunk_134"
					var v10 any = nil
					_ = v10
					// let binding "count_135"
					var v11 any = int64(0)
					_ = v11
					// let binding "i_136"
					var v12 any = int64(0)
					_ = v12
					for {
						var tmp13 any
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("<"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v12, v11})
						if lang.IsTruthy(tmp17) {
							var tmp18 any
							{ // let
								// let binding "path"
								tmp19, _ := lang.FieldOrMethod(v10, "nth")
								if reflect.TypeOf(tmp19).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
								}
								tmp20 := lang.Apply(tmp19, []any{v12})
								var v21 any = tmp20
								_ = v21
								var tmp22 any
								{ // let
									// let binding "path"
									var tmp23 any
									tmp24 := lang.Apply(strings8.HasPrefix, []any{v21, "/"})
									if lang.IsTruthy(tmp24) {
										tmp23 = v21
									} else {
										tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp26 := tmp25.FindInternedVar(lang.NewSymbol("str"))
										if tmp26.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
										}
										tmp27 := tmp26.Get()
										tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp29 := tmp28.FindInternedVar(lang.NewSymbol("root-directory"))
										if tmp29.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
										}
										tmp30 := tmp29.Get()
										tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp32 := tmp31.FindInternedVar(lang.NewSymbol("ns-name"))
										if tmp32.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
										}
										tmp33 := tmp32.Get()
										tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp35 := tmp34.FindInternedVar(lang.NewSymbol("*ns*"))
										if tmp35.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
										}
										tmp36 := tmp35.Get()
										tmp37 := lang.Apply(tmp33, []any{tmp36})
										tmp38 := lang.Apply(tmp30, []any{tmp37})
										tmp39 := lang.Apply(tmp27, []any{tmp38, lang.NewChar(47), v21})
										tmp23 = tmp39
									}
									var v40 any = tmp23
									_ = v40
									var tmp41 any
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									if lang.IsTruthy(tmp44) {
										tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp46 := tmp45.FindInternedVar(lang.NewSymbol("printf"))
										if tmp46.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
										}
										tmp47 := tmp46.Get()
										tmp48 := lang.Apply(tmp47, []any{"(glojure.core/load \"%s\")\n", v40})
										_ = tmp48
										tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp50 := tmp49.FindInternedVar(lang.NewSymbol("flush"))
										if tmp50.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
										}
										tmp51 := tmp50.Get()
										tmp52 := lang.Apply(tmp51, nil)
										tmp41 = tmp52
									} else {
									}
									_ = tmp41
									tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp54 := tmp53.FindInternedVar(lang.NewSymbol("check-cyclic-dependency"))
									if tmp54.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
									}
									tmp55 := tmp54.Get()
									tmp56 := lang.Apply(tmp55, []any{v40})
									_ = tmp56
									var tmp57 any
									tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp59 := tmp58.FindInternedVar(lang.NewSymbol("="))
									if tmp59.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
									}
									tmp60 := tmp59.Get()
									tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp62 := tmp61.FindInternedVar(lang.NewSymbol("first"))
									if tmp62.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
									}
									tmp63 := tmp62.Get()
									tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp65 := tmp64.FindInternedVar(lang.NewSymbol("*pending-paths*"))
									if tmp65.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
									}
									tmp66 := tmp65.Get()
									tmp67 := lang.Apply(tmp63, []any{tmp66})
									tmp68 := lang.Apply(tmp60, []any{v40, tmp67})
									if lang.IsTruthy(tmp68) {
									} else {
										var tmp69 any
										{ // let
											tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp71 := tmp70.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
											if tmp71.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
											}
											tmp72 := tmp71.Get()
											tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp74 := tmp73.FindInternedVar(lang.NewSymbol("hash-map"))
											if tmp74.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
											}
											tmp75 := tmp74.Get()
											tmp76 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*pending-paths*"))
											tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp78 := tmp77.FindInternedVar(lang.NewSymbol("conj"))
											if tmp78.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
											}
											tmp79 := tmp78.Get()
											tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp81 := tmp80.FindInternedVar(lang.NewSymbol("*pending-paths*"))
											if tmp81.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
											}
											tmp82 := tmp81.Get()
											tmp83 := lang.Apply(tmp79, []any{tmp82, v40})
											tmp84 := lang.Apply(tmp75, []any{tmp76, tmp83})
											tmp85 := lang.Apply(tmp72, []any{tmp84})
											_ = tmp85
											var tmp86 any
											func() {
												defer func() {
													tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp88 := tmp87.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
													if tmp88.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
													}
													tmp89 := tmp88.Get()
													tmp90 := lang.Apply(tmp89, nil)
													_ = tmp90
												}()
												tmp91 := lang.Apply(strings8.TrimPrefix, []any{v40, "/"})
												tmp92, _ := lang.FieldOrMethod(runtime4.RT, "Load")
												if reflect.TypeOf(tmp92).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
												}
												tmp93 := lang.Apply(tmp92, []any{tmp91})
												tmp86 = tmp93
											}()
											tmp69 = tmp86
										} // end let
										tmp57 = tmp69
									}
									tmp22 = tmp57
								} // end let
								_ = tmp22
								var tmp23 any = v9
								var tmp24 any = v10
								var tmp25 any = v11
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("unchecked-inc"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{v12})
								var tmp26 any = tmp30
								v9 = tmp23
								v10 = tmp24
								v11 = tmp25
								v12 = tmp26
								continue
							} // end let
							tmp13 = tmp18
						} else {
							var tmp19 any
							{ // let
								// let binding "temp__0__auto__"
								tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp21 := tmp20.FindInternedVar(lang.NewSymbol("seq"))
								if tmp21.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
								}
								tmp22 := tmp21.Get()
								tmp23 := lang.Apply(tmp22, []any{v9})
								var v24 any = tmp23
								_ = v24
								var tmp25 any
								if lang.IsTruthy(v24) {
									var tmp26 any
									{ // let
										// let binding "seq_133"
										var v27 any = v24
										_ = v27
										var tmp28 any
										tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp30 := tmp29.FindInternedVar(lang.NewSymbol("chunked-seq?"))
										if tmp30.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
										}
										tmp31 := tmp30.Get()
										tmp32 := lang.Apply(tmp31, []any{v27})
										if lang.IsTruthy(tmp32) {
											var tmp33 any
											{ // let
												// let binding "c__0__auto__"
												tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp35 := tmp34.FindInternedVar(lang.NewSymbol("chunk-first"))
												if tmp35.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
												}
												tmp36 := tmp35.Get()
												tmp37 := lang.Apply(tmp36, []any{v27})
												var v38 any = tmp37
												_ = v38
												tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp41 := tmp40.FindInternedVar(lang.NewSymbol("chunk-rest"))
												if tmp41.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
												}
												tmp42 := tmp41.Get()
												tmp43 := lang.Apply(tmp42, []any{v27})
												var tmp39 any = tmp43
												var tmp44 any = v38
												tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp47 := tmp46.FindInternedVar(lang.NewSymbol("int"))
												if tmp47.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
												}
												tmp48 := tmp47.Get()
												tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp50 := tmp49.FindInternedVar(lang.NewSymbol("count"))
												if tmp50.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
												}
												tmp51 := tmp50.Get()
												tmp52 := lang.Apply(tmp51, []any{v38})
												tmp53 := lang.Apply(tmp48, []any{tmp52})
												var tmp45 any = tmp53
												tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp56 := tmp55.FindInternedVar(lang.NewSymbol("int"))
												if tmp56.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
												}
												tmp57 := tmp56.Get()
												tmp58 := lang.Apply(tmp57, []any{int64(0)})
												var tmp54 any = tmp58
												v9 = tmp39
												v10 = tmp44
												v11 = tmp45
												v12 = tmp54
												continue
											} // end let
											tmp28 = tmp33
										} else {
											var tmp34 any
											{ // let
												// let binding "path"
												tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp36 := tmp35.FindInternedVar(lang.NewSymbol("first"))
												if tmp36.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
												}
												tmp37 := tmp36.Get()
												tmp38 := lang.Apply(tmp37, []any{v27})
												var v39 any = tmp38
												_ = v39
												var tmp40 any
												{ // let
													// let binding "path"
													var tmp41 any
													tmp42 := lang.Apply(strings8.HasPrefix, []any{v39, "/"})
													if lang.IsTruthy(tmp42) {
														tmp41 = v39
													} else {
														tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp44 := tmp43.FindInternedVar(lang.NewSymbol("str"))
														if tmp44.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
														}
														tmp45 := tmp44.Get()
														tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp47 := tmp46.FindInternedVar(lang.NewSymbol("root-directory"))
														if tmp47.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
														}
														tmp48 := tmp47.Get()
														tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp50 := tmp49.FindInternedVar(lang.NewSymbol("ns-name"))
														if tmp50.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
														}
														tmp51 := tmp50.Get()
														tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp53 := tmp52.FindInternedVar(lang.NewSymbol("*ns*"))
														if tmp53.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
														}
														tmp54 := tmp53.Get()
														tmp55 := lang.Apply(tmp51, []any{tmp54})
														tmp56 := lang.Apply(tmp48, []any{tmp55})
														tmp57 := lang.Apply(tmp45, []any{tmp56, lang.NewChar(47), v39})
														tmp41 = tmp57
													}
													var v58 any = tmp41
													_ = v58
													var tmp59 any
													tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp61 := tmp60.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
													if tmp61.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
													}
													tmp62 := tmp61.Get()
													if lang.IsTruthy(tmp62) {
														tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp64 := tmp63.FindInternedVar(lang.NewSymbol("printf"))
														if tmp64.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
														}
														tmp65 := tmp64.Get()
														tmp66 := lang.Apply(tmp65, []any{"(glojure.core/load \"%s\")\n", v58})
														_ = tmp66
														tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp68 := tmp67.FindInternedVar(lang.NewSymbol("flush"))
														if tmp68.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
														}
														tmp69 := tmp68.Get()
														tmp70 := lang.Apply(tmp69, nil)
														tmp59 = tmp70
													} else {
													}
													_ = tmp59
													tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp72 := tmp71.FindInternedVar(lang.NewSymbol("check-cyclic-dependency"))
													if tmp72.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
													}
													tmp73 := tmp72.Get()
													tmp74 := lang.Apply(tmp73, []any{v58})
													_ = tmp74
													var tmp75 any
													tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp77 := tmp76.FindInternedVar(lang.NewSymbol("="))
													if tmp77.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
													}
													tmp78 := tmp77.Get()
													tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp80 := tmp79.FindInternedVar(lang.NewSymbol("first"))
													if tmp80.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
													}
													tmp81 := tmp80.Get()
													tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp83 := tmp82.FindInternedVar(lang.NewSymbol("*pending-paths*"))
													if tmp83.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
													}
													tmp84 := tmp83.Get()
													tmp85 := lang.Apply(tmp81, []any{tmp84})
													tmp86 := lang.Apply(tmp78, []any{v58, tmp85})
													if lang.IsTruthy(tmp86) {
													} else {
														var tmp87 any
														{ // let
															tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp89 := tmp88.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
															if tmp89.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
															}
															tmp90 := tmp89.Get()
															tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp92 := tmp91.FindInternedVar(lang.NewSymbol("hash-map"))
															if tmp92.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
															}
															tmp93 := tmp92.Get()
															tmp94 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*pending-paths*"))
															tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp96 := tmp95.FindInternedVar(lang.NewSymbol("conj"))
															if tmp96.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
															}
															tmp97 := tmp96.Get()
															tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp99 := tmp98.FindInternedVar(lang.NewSymbol("*pending-paths*"))
															if tmp99.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
															}
															tmp100 := tmp99.Get()
															tmp101 := lang.Apply(tmp97, []any{tmp100, v58})
															tmp102 := lang.Apply(tmp93, []any{tmp94, tmp101})
															tmp103 := lang.Apply(tmp90, []any{tmp102})
															_ = tmp103
															var tmp104 any
															func() {
																defer func() {
																	tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp106 := tmp105.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
																	if tmp106.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
																	}
																	tmp107 := tmp106.Get()
																	tmp108 := lang.Apply(tmp107, nil)
																	_ = tmp108
																}()
																tmp109 := lang.Apply(strings8.TrimPrefix, []any{v58, "/"})
																tmp110, _ := lang.FieldOrMethod(runtime4.RT, "Load")
																if reflect.TypeOf(tmp110).Kind() != reflect.Func {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("Load is not a function")))
																}
																tmp111 := lang.Apply(tmp110, []any{tmp109})
																tmp104 = tmp111
															}()
															tmp87 = tmp104
														} // end let
														tmp75 = tmp87
													}
													tmp40 = tmp75
												} // end let
												_ = tmp40
												tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp43 := tmp42.FindInternedVar(lang.NewSymbol("next"))
												if tmp43.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
												}
												tmp44 := tmp43.Get()
												tmp45 := lang.Apply(tmp44, []any{v27})
												var tmp41 any = tmp45
												var tmp46 any = nil
												var tmp47 any = int64(0)
												var tmp48 any = int64(0)
												v9 = tmp41
												v10 = tmp46
												v11 = tmp47
												v12 = tmp48
												continue
											} // end let
											tmp28 = tmp34
										}
										tmp26 = tmp28
									} // end let
									tmp25 = tmp26
								} else {
								}
								tmp19 = tmp25
							} // end let
							tmp13 = tmp19
						}
						tmp4 = tmp13
						break
					}
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-all
	{
		tmp0 := lang.NewSymbol("load-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"), lang.NewSymbol("need-ns"), lang.NewSymbol("require"))), lang.NewKeyword("doc"), "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5892), lang.NewKeyword("end-line"), int(5892), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("commute"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("*loaded-libs*"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v14 := args[0]
					_ = v14
					v15 := args[1]
					_ = v15
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("conj"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp18, []any{tmp21, v14, v15})
					return tmp22
				})
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5899), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(5899), lang.NewKeyword("end-column"), int(47))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp16 any
				{ // let
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loaded-libs*"))
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("ref"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("sorted-set"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, nil)
					tmp31 := lang.Apply(tmp26, []any{tmp30})
					tmp32 := lang.Apply(tmp22, []any{tmp23, tmp31})
					tmp33 := lang.Apply(tmp19, []any{tmp32})
					_ = tmp33
					var tmp34 any
					func() {
						defer func() {
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							tmp38 := lang.Apply(tmp37, nil)
							_ = tmp38
						}()
						tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp40 := tmp39.FindInternedVar(lang.NewSymbol("load-one"))
						if tmp40.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
						}
						tmp41 := tmp40.Get()
						tmp42 := lang.Apply(tmp41, []any{v3, v4, v5})
						_ = tmp42
						tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp44 := tmp43.FindInternedVar(lang.NewSymbol("deref"))
						if tmp44.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
						}
						tmp45 := tmp44.Get()
						tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp47 := tmp46.FindInternedVar(lang.NewSymbol("*loaded-libs*"))
						if tmp47.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
						}
						tmp48 := tmp47.Get()
						tmp49 := lang.Apply(tmp45, []any{tmp48})
						tmp34 = tmp49
					}()
					tmp16 = tmp34
				} // end let
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp15, tmp16})
				return tmp17
			})
			tmp7, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
			if reflect.TypeOf(tmp7).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
			}
			tmp8 := lang.Apply(tmp7, []any{tmp6})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-reader-file
	{
		tmp0 := lang.NewSymbol("load-data-reader-file").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7836), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7836), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("mappings"), lang.NewSymbol("url"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "rdr"
				tmp6, ok := lang.FieldOrMethod(v4, "openStream")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "openStream")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, "UTF-8"})
				tmp9 := lang.Apply(nil, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				func() {
					defer func() {
						tmp12, ok := lang.FieldOrMethod(v10, "close")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "close")))
						}
						var tmp13 any
						switch reflect.TypeOf(tmp12).Kind() {
						case reflect.Func:
							tmp13 = lang.Apply(tmp12, nil)
						default:
							tmp13 = tmp12
						}
						_ = tmp13
					}()
					var tmp14 any
					{ // let
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*file*"))
						tmp22, ok := lang.FieldOrMethod(v4, "getFile")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getFile")))
						}
						var tmp23 any
						switch reflect.TypeOf(tmp22).Kind() {
						case reflect.Func:
							tmp23 = lang.Apply(tmp22, nil)
						default:
							tmp23 = tmp22
						}
						tmp24 := lang.Apply(tmp20, []any{tmp21, tmp23})
						tmp25 := lang.Apply(tmp17, []any{tmp24})
						_ = tmp25
						var tmp26 any
						func() {
							defer func() {
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, nil)
								_ = tmp30
							}()
							var tmp31 any
							{ // let
								// let binding "read-opts"
								var tmp32 any
								tmp33, ok := lang.FieldOrMethod(v4, "getPath")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getPath")))
								}
								var tmp34 any
								switch reflect.TypeOf(tmp33).Kind() {
								case reflect.Func:
									tmp34 = lang.Apply(tmp33, nil)
								default:
									tmp34 = tmp33
								}
								tmp35, _ := lang.FieldOrMethod(tmp34, "endsWith")
								if reflect.TypeOf(tmp35).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("endsWith is not a function")))
								}
								tmp36 := lang.Apply(tmp35, []any{"cljc"})
								if lang.IsTruthy(tmp36) {
									tmp37 := lang.NewMap(lang.NewKeyword("eof"), nil, lang.NewKeyword("read-cond"), lang.NewKeyword("allow"))
									tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7842), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7842), lang.NewKeyword("end-column"), int(52))
									tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 = tmp39
								} else {
									tmp40 := lang.NewMap(lang.NewKeyword("eof"), nil)
									tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7843), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7843), lang.NewKeyword("end-column"), int(34))
									tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 = tmp42
								}
								var v43 any = tmp32
								_ = v43
								// let binding "new-mappings"
								tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp45 := tmp44.FindInternedVar(lang.NewSymbol("read"))
								if tmp45.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
								}
								tmp46 := tmp45.Get()
								tmp47 := lang.Apply(tmp46, []any{v43, v10})
								var v48 any = tmp47
								_ = v48
								var tmp49 any
								tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp51 := tmp50.FindInternedVar(lang.NewSymbol("not"))
								if tmp51.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
								}
								tmp52 := tmp51.Get()
								tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp54 := tmp53.FindInternedVar(lang.NewSymbol("map?"))
								if tmp54.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
								}
								tmp55 := tmp54.Get()
								tmp56 := lang.Apply(tmp55, []any{v48})
								tmp57 := lang.Apply(tmp52, []any{tmp56})
								if lang.IsTruthy(tmp57) {
									tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp59 := tmp58.FindInternedVar(lang.NewSymbol("ex-info"))
									if tmp59.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
									}
									tmp60 := tmp59.Get()
									tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp62 := tmp61.FindInternedVar(lang.NewSymbol("str"))
									if tmp62.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
									}
									tmp63 := tmp62.Get()
									tmp64 := lang.Apply(tmp63, []any{"Not a valid data-reader map"})
									tmp65 := lang.NewMap(lang.NewKeyword("url"), v4)
									tmp66 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7847), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(7847), lang.NewKeyword("end-column"), int(36))
									tmp67, err := lang.WithMeta(tmp65, tmp66.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp68 := lang.Apply(tmp60, []any{tmp64, tmp67})
									panic(tmp68)
								} else {
								}
								_ = tmp49
								tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp70 := tmp69.FindInternedVar(lang.NewSymbol("reduce"))
								if tmp70.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
								}
								tmp71 := tmp70.Get()
								var tmp72 lang.FnFunc
								tmp72 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 2 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v73 := args[0]
									_ = v73
									v74 := args[1]
									_ = v74
									var tmp75 any
									{ // let
										// let binding "vec__347"
										var v76 any = v74
										_ = v76
										// let binding "k"
										tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp78 := tmp77.FindInternedVar(lang.NewSymbol("nth"))
										if tmp78.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
										}
										tmp79 := tmp78.Get()
										tmp80 := lang.Apply(tmp79, []any{v76, int64(0), nil})
										var v81 any = tmp80
										_ = v81
										// let binding "v"
										tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp83 := tmp82.FindInternedVar(lang.NewSymbol("nth"))
										if tmp83.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
										}
										tmp84 := tmp83.Get()
										tmp85 := lang.Apply(tmp84, []any{v76, int64(1), nil})
										var v86 any = tmp85
										_ = v86
										var tmp87 any
										tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp89 := tmp88.FindInternedVar(lang.NewSymbol("not"))
										if tmp89.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
										}
										tmp90 := tmp89.Get()
										tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp92 := tmp91.FindInternedVar(lang.NewSymbol("symbol?"))
										if tmp92.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
										}
										tmp93 := tmp92.Get()
										tmp94 := lang.Apply(tmp93, []any{v81})
										tmp95 := lang.Apply(tmp90, []any{tmp94})
										if lang.IsTruthy(tmp95) {
											tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp97 := tmp96.FindInternedVar(lang.NewSymbol("ex-info"))
											if tmp97.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
											}
											tmp98 := tmp97.Get()
											tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp100 := tmp99.FindInternedVar(lang.NewSymbol("str"))
											if tmp100.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
											}
											tmp101 := tmp100.Get()
											tmp102 := lang.Apply(tmp101, []any{"Invalid form in data-reader file"})
											tmp103 := lang.NewMap(lang.NewKeyword("url"), v4, lang.NewKeyword("form"), v81)
											tmp104 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7852), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7853), lang.NewKeyword("end-column"), int(38))
											tmp105, err := lang.WithMeta(tmp103, tmp104.(lang.IPersistentMap))
											if err != nil {
												panic(err)
											}
											tmp106 := lang.Apply(tmp98, []any{tmp102, tmp105})
											panic(tmp106)
										} else {
										}
										_ = tmp87
										var tmp107 any
										{ // let
											// let binding "v-var"
											tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp109 := tmp108.FindInternedVar(lang.NewSymbol("data-reader-var"))
											if tmp109.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
											}
											tmp110 := tmp109.Get()
											tmp111 := lang.Apply(tmp110, []any{v86})
											var v112 any = tmp111
											_ = v112
											var tmp113 any
											var tmp114 any
											{ // let
												// let binding "and__0__auto__"
												tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp116 := tmp115.FindInternedVar(lang.NewSymbol("contains?"))
												if tmp116.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
												}
												tmp117 := tmp116.Get()
												tmp118 := lang.Apply(tmp117, []any{v3, v81})
												var v119 any = tmp118
												_ = v119
												var tmp120 any
												if lang.IsTruthy(v119) {
													tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp122 := tmp121.FindInternedVar(lang.NewSymbol("not="))
													if tmp122.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
													}
													tmp123 := tmp122.Get()
													tmp124 := lang.Apply(v3, []any{v81})
													tmp125 := lang.Apply(tmp123, []any{tmp124, v112})
													tmp120 = tmp125
												} else {
													tmp120 = v119
												}
												tmp114 = tmp120
											} // end let
											if lang.IsTruthy(tmp114) {
												tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp116 := tmp115.FindInternedVar(lang.NewSymbol("ex-info"))
												if tmp116.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
												}
												tmp117 := tmp116.Get()
												tmp118 := lang.NewMap(lang.NewKeyword("url"), v4, lang.NewKeyword("conflict"), v81, lang.NewKeyword("mappings"), v73)
												tmp119 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7858), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(7860), lang.NewKeyword("end-column"), int(44))
												tmp120, err := lang.WithMeta(tmp118, tmp119.(lang.IPersistentMap))
												if err != nil {
													panic(err)
												}
												tmp121 := lang.Apply(tmp117, []any{"Conflicting data-reader mapping", tmp120})
												panic(tmp121)
											} else {
											}
											_ = tmp113
											tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp123 := tmp122.FindInternedVar(lang.NewSymbol("assoc"))
											if tmp123.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
											}
											tmp124 := tmp123.Get()
											tmp125 := lang.Apply(tmp124, []any{v73, v81, v112})
											tmp107 = tmp125
										} // end let
										tmp75 = tmp107
									} // end let
									return tmp75
								})
								tmp73 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7849), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7861), lang.NewKeyword("end-column"), int(32))
								tmp74, err := lang.WithMeta(tmp72, tmp73.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp75 := lang.Apply(tmp71, []any{tmp74, v3, v48})
								tmp31 = tmp75
							} // end let
							tmp26 = tmp31
						}()
						tmp14 = tmp26
					} // end let
					tmp11 = tmp14
				}()
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-data-readers
	{
		tmp0 := lang.NewSymbol("load-data-readers").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7865), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7865), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp4 := tmp3.FindInternedVar(lang.NewSymbol("alter-var-root"))
			if tmp4.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
			}
			tmp5 := tmp4.Get()
			tmp6 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*data-readers*"))
			var tmp7 lang.FnFunc
			tmp7 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v8 := args[0]
				_ = v8
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("reduce"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("load-data-reader-file"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("data-reader-urls"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, nil)
				tmp19 := lang.Apply(tmp11, []any{tmp14, v8, tmp18})
				return tmp19
			})
			tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7867), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7869), lang.NewKeyword("end-column"), int(57))
			tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp10 := lang.Apply(tmp5, []any{tmp6, tmp9})
			return tmp10
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-file
	{
		tmp0 := lang.NewSymbol("load-file").WithMeta(lang.NewMap(lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-lib
	{
		tmp0 := lang.NewSymbol("load-lib").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prefix"), lang.NewSymbol("lib"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Loads a lib with options", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5904), lang.NewKeyword("end-line"), int(5904), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("throw-if"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				var tmp9 any
				{ // let
					// let binding "and__0__auto__"
					var v10 any = v3
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("name"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v4})
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("int"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{lang.NewChar(46)})
						tmp23 := lang.Apply(strings8.Index, []any{tmp18, tmp22})
						tmp24 := lang.Apply(tmp14, []any{tmp23})
						tmp11 = tmp24
					} else {
						tmp11 = v10
					}
					tmp9 = tmp11
				} // end let
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("name"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v4})
				tmp14 := lang.Apply(tmp8, []any{tmp9, "Found lib name '%s' containing period with prefix '%s'.  lib names inside prefix lists must not contain periods", tmp13, v3})
				_ = tmp14
				var tmp15 any
				{ // let
					// let binding "lib"
					var tmp16 any
					if lang.IsTruthy(v3) {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("symbol"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("str"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v3, lang.NewChar(46), v4})
						tmp24 := lang.Apply(tmp19, []any{tmp23})
						tmp16 = tmp24
					} else {
						tmp16 = v4
					}
					var v25 any = tmp16
					_ = v25
					// let binding "opts"
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("apply"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp28, []any{tmp31, v5})
					var v33 any = tmp32
					_ = v33
					// let binding "map__110"
					var v34 any = v33
					_ = v34
					// let binding "map__110"
					var tmp35 any
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("seq?"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v34})
					if lang.IsTruthy(tmp39) {
						var tmp40 any
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("next"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.Apply(tmp43, []any{v34})
						if lang.IsTruthy(tmp44) {
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("to-array"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.Apply(tmp47, []any{v34})
							tmp49 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp48})
							tmp40 = tmp49
						} else {
							var tmp50 any
							tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp52 := tmp51.FindInternedVar(lang.NewSymbol("seq"))
							if tmp52.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
							}
							tmp53 := tmp52.Get()
							tmp54 := lang.Apply(tmp53, []any{v34})
							if lang.IsTruthy(tmp54) {
								tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp56 := tmp55.FindInternedVar(lang.NewSymbol("first"))
								if tmp56.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
								}
								tmp57 := tmp56.Get()
								tmp58 := lang.Apply(tmp57, []any{v34})
								tmp50 = tmp58
							} else {
							}
							tmp40 = tmp50
						}
						tmp35 = tmp40
					} else {
						tmp35 = v34
					}
					var v59 any = tmp35
					_ = v59
					// let binding "as"
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("get"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.Apply(tmp62, []any{v59, lang.NewKeyword("as")})
					var v64 any = tmp63
					_ = v64
					// let binding "reload"
					tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp66 := tmp65.FindInternedVar(lang.NewSymbol("get"))
					if tmp66.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
					}
					tmp67 := tmp66.Get()
					tmp68 := lang.Apply(tmp67, []any{v59, lang.NewKeyword("reload")})
					var v69 any = tmp68
					_ = v69
					// let binding "reload-all"
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("get"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.Apply(tmp72, []any{v59, lang.NewKeyword("reload-all")})
					var v74 any = tmp73
					_ = v74
					// let binding "require"
					tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp76 := tmp75.FindInternedVar(lang.NewSymbol("get"))
					if tmp76.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
					}
					tmp77 := tmp76.Get()
					tmp78 := lang.Apply(tmp77, []any{v59, lang.NewKeyword("require")})
					var v79 any = tmp78
					_ = v79
					// let binding "use"
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("get"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.Apply(tmp82, []any{v59, lang.NewKeyword("use")})
					var v84 any = tmp83
					_ = v84
					// let binding "verbose"
					tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp86 := tmp85.FindInternedVar(lang.NewSymbol("get"))
					if tmp86.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
					}
					tmp87 := tmp86.Get()
					tmp88 := lang.Apply(tmp87, []any{v59, lang.NewKeyword("verbose")})
					var v89 any = tmp88
					_ = v89
					// let binding "as-alias"
					tmp90 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp91 := tmp90.FindInternedVar(lang.NewSymbol("get"))
					if tmp91.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp91)))
					}
					tmp92 := tmp91.Get()
					tmp93 := lang.Apply(tmp92, []any{v59, lang.NewKeyword("as-alias")})
					var v94 any = tmp93
					_ = v94
					// let binding "loaded"
					tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp96 := tmp95.FindInternedVar(lang.NewSymbol("contains?"))
					if tmp96.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
					}
					tmp97 := tmp96.Get()
					tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp99 := tmp98.FindInternedVar(lang.NewSymbol("deref"))
					if tmp99.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
					}
					tmp100 := tmp99.Get()
					tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp102 := tmp101.FindInternedVar(lang.NewSymbol("*loaded-libs*"))
					if tmp102.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
					}
					tmp103 := tmp102.Get()
					tmp104 := lang.Apply(tmp100, []any{tmp103})
					tmp105 := lang.Apply(tmp97, []any{tmp104, v25})
					var v106 any = tmp105
					_ = v106
					// let binding "need-ns"
					var tmp107 any
					{ // let
						// let binding "or__0__auto__"
						var v108 any = v64
						_ = v108
						var tmp109 any
						if lang.IsTruthy(v108) {
							tmp109 = v108
						} else {
							tmp109 = v84
						}
						tmp107 = tmp109
					} // end let
					var v108 any = tmp107
					_ = v108
					// let binding "load"
					var tmp109 any
					if lang.IsTruthy(v74) {
						tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp111 := tmp110.FindInternedVar(lang.NewSymbol("load-all"))
						if tmp111.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
						}
						tmp112 := tmp111.Get()
						tmp109 = tmp112
					} else {
						var tmp113 any
						if lang.IsTruthy(v69) {
							tmp114 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp115 := tmp114.FindInternedVar(lang.NewSymbol("load-one"))
							if tmp115.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp115)))
							}
							tmp116 := tmp115.Get()
							tmp113 = tmp116
						} else {
							var tmp117 any
							tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp119 := tmp118.FindInternedVar(lang.NewSymbol("not"))
							if tmp119.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
							}
							tmp120 := tmp119.Get()
							tmp121 := lang.Apply(tmp120, []any{v106})
							if lang.IsTruthy(tmp121) {
								var tmp122 any
								if lang.IsTruthy(v108) {
									tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp124 := tmp123.FindInternedVar(lang.NewSymbol("load-one"))
									if tmp124.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
									}
									tmp125 := tmp124.Get()
									tmp122 = tmp125
								} else {
									var tmp126 any
									if lang.IsTruthy(v94) {
										var tmp127 lang.FnFunc
										tmp127 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 3 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v128 := args[0]
											_ = v128
											v129 := args[1]
											_ = v129
											v130 := args[2]
											_ = v130
											tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp132 := tmp131.FindInternedVar(lang.NewSymbol("create-ns"))
											if tmp132.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
											}
											tmp133 := tmp132.Get()
											tmp134 := lang.Apply(tmp133, []any{v128})
											return tmp134
										})
										tmp128 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5918), lang.NewKeyword("column"), int(48), lang.NewKeyword("end-line"), int(5918), lang.NewKeyword("end-column"), int(88))
										tmp129, err := lang.WithMeta(tmp127, tmp128.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp126 = tmp129
									} else {
										var tmp130 any
										if lang.IsTruthy(lang.NewKeyword("else")) {
											tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp132 := tmp131.FindInternedVar(lang.NewSymbol("load-one"))
											if tmp132.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
											}
											tmp133 := tmp132.Get()
											tmp130 = tmp133
										} else {
										}
										tmp126 = tmp130
									}
									tmp122 = tmp126
								}
								tmp117 = tmp122
							} else {
							}
							tmp113 = tmp117
						}
						tmp109 = tmp113
					}
					var v134 any = tmp109
					_ = v134
					// let binding "filter-opts"
					tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp136 := tmp135.FindInternedVar(lang.NewSymbol("select-keys"))
					if tmp136.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
					}
					tmp137 := tmp136.Get()
					tmp138 := lang.Apply(tmp137, []any{v33, lang.NewList(lang.NewKeyword("exclude"), lang.NewKeyword("only"), lang.NewKeyword("rename"), lang.NewKeyword("refer"))})
					var v139 any = tmp138
					_ = v139
					// let binding "undefined-on-entry"
					tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp141 := tmp140.FindInternedVar(lang.NewSymbol("not"))
					if tmp141.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
					}
					tmp142 := tmp141.Get()
					tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp144 := tmp143.FindInternedVar(lang.NewSymbol("find-ns"))
					if tmp144.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
					}
					tmp145 := tmp144.Get()
					tmp146 := lang.Apply(tmp145, []any{v25})
					tmp147 := lang.Apply(tmp142, []any{tmp146})
					var v148 any = tmp147
					_ = v148
					var tmp149 any
					{ // let
						tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp151 := tmp150.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp151.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
						}
						tmp152 := tmp151.Get()
						tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp154 := tmp153.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp154.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
						}
						tmp155 := tmp154.Get()
						tmp156 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*loading-verbosely*"))
						var tmp157 any
						{ // let
							// let binding "or__0__auto__"
							tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp159 := tmp158.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
							if tmp159.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
							}
							tmp160 := tmp159.Get()
							var v161 any = tmp160
							_ = v161
							var tmp162 any
							if lang.IsTruthy(v161) {
								tmp162 = v161
							} else {
								tmp162 = v89
							}
							tmp157 = tmp162
						} // end let
						tmp158 := lang.Apply(tmp155, []any{tmp156, tmp157})
						tmp159 := lang.Apply(tmp152, []any{tmp158})
						_ = tmp159
						var tmp160 any
						func() {
							defer func() {
								tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp162 := tmp161.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp162.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
								}
								tmp163 := tmp162.Get()
								tmp164 := lang.Apply(tmp163, nil)
								_ = tmp164
							}()
							var tmp165 any
							if lang.IsTruthy(v134) {
								var tmp166 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v167 := r
												_ = v167
												var tmp168 any
												if lang.IsTruthy(v148) {
													tmp169 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp170 := tmp169.FindInternedVar(lang.NewSymbol("remove-ns"))
													if tmp170.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp170)))
													}
													tmp171 := tmp170.Get()
													tmp172 := lang.Apply(tmp171, []any{v25})
													tmp168 = tmp172
												} else {
												}
												_ = tmp168
												panic(v167)
											} else {
												panic(r)
											}
										}
									}()
									tmp167 := lang.Apply(v134, []any{v25, v108, v79})
									tmp166 = tmp167
								}()
								tmp165 = tmp166
							} else {
								tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp169 := tmp168.FindInternedVar(lang.NewSymbol("throw-if"))
								if tmp169.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
								}
								tmp170 := tmp169.Get()
								var tmp171 any
								{ // let
									// let binding "and__0__auto__"
									var v172 any = v108
									_ = v172
									var tmp173 any
									if lang.IsTruthy(v172) {
										tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp175 := tmp174.FindInternedVar(lang.NewSymbol("not"))
										if tmp175.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
										}
										tmp176 := tmp175.Get()
										tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp178 := tmp177.FindInternedVar(lang.NewSymbol("find-ns"))
										if tmp178.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
										}
										tmp179 := tmp178.Get()
										tmp180 := lang.Apply(tmp179, []any{v25})
										tmp181 := lang.Apply(tmp176, []any{tmp180})
										tmp173 = tmp181
									} else {
										tmp173 = v172
									}
									tmp171 = tmp173
								} // end let
								tmp172 := lang.Apply(tmp170, []any{tmp171, "namespace '%s' not found", v25})
								tmp165 = tmp172
							}
							_ = tmp165
							var tmp173 any
							var tmp174 any
							{ // let
								// let binding "and__0__auto__"
								var v175 any = v108
								_ = v175
								var tmp176 any
								if lang.IsTruthy(v175) {
									tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp178 := tmp177.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
									if tmp178.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
									}
									tmp179 := tmp178.Get()
									tmp176 = tmp179
								} else {
									tmp176 = v175
								}
								tmp174 = tmp176
							} // end let
							if lang.IsTruthy(tmp174) {
								tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp176 := tmp175.FindInternedVar(lang.NewSymbol("printf"))
								if tmp176.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
								}
								tmp177 := tmp176.Get()
								tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp179 := tmp178.FindInternedVar(lang.NewSymbol("ns-name"))
								if tmp179.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
								}
								tmp180 := tmp179.Get()
								tmp181 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp182 := tmp181.FindInternedVar(lang.NewSymbol("*ns*"))
								if tmp182.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp182)))
								}
								tmp183 := tmp182.Get()
								tmp184 := lang.Apply(tmp180, []any{tmp183})
								tmp185 := lang.Apply(tmp177, []any{"(glojure.core/in-ns '%s)\n", tmp184})
								tmp173 = tmp185
							} else {
							}
							_ = tmp173
							var tmp186 any
							if lang.IsTruthy(v64) {
								var tmp187 any
								tmp188 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp189 := tmp188.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
								if tmp189.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp189)))
								}
								tmp190 := tmp189.Get()
								if lang.IsTruthy(tmp190) {
									tmp191 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp192 := tmp191.FindInternedVar(lang.NewSymbol("printf"))
									if tmp192.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp192)))
									}
									tmp193 := tmp192.Get()
									tmp194 := lang.Apply(tmp193, []any{"(glojure.core/alias '%s '%s)\n", v64, v25})
									tmp187 = tmp194
								} else {
								}
								_ = tmp187
								tmp195 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp196 := tmp195.FindInternedVar(lang.NewSymbol("alias"))
								if tmp196.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp196)))
								}
								tmp197 := tmp196.Get()
								tmp198 := lang.Apply(tmp197, []any{v64, v25})
								tmp186 = tmp198
							} else {
							}
							_ = tmp186
							var tmp199 any
							if lang.IsTruthy(v94) {
								var tmp200 any
								tmp201 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp202 := tmp201.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
								if tmp202.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp202)))
								}
								tmp203 := tmp202.Get()
								if lang.IsTruthy(tmp203) {
									tmp204 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp205 := tmp204.FindInternedVar(lang.NewSymbol("printf"))
									if tmp205.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp205)))
									}
									tmp206 := tmp205.Get()
									tmp207 := lang.Apply(tmp206, []any{"(glojure.core/alias '%s '%s)\n", v94, v25})
									tmp200 = tmp207
								} else {
								}
								_ = tmp200
								tmp208 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp209 := tmp208.FindInternedVar(lang.NewSymbol("alias"))
								if tmp209.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp209)))
								}
								tmp210 := tmp209.Get()
								tmp211 := lang.Apply(tmp210, []any{v94, v25})
								tmp199 = tmp211
							} else {
							}
							_ = tmp199
							var tmp212 any
							var tmp213 any
							{ // let
								// let binding "or__0__auto__"
								var v214 any = v84
								_ = v214
								var tmp215 any
								if lang.IsTruthy(v214) {
									tmp215 = v214
								} else {
									tmp216 := lang.Apply(lang.NewKeyword("refer"), []any{v139})
									tmp215 = tmp216
								}
								tmp213 = tmp215
							} // end let
							if lang.IsTruthy(tmp213) {
								var tmp214 any
								tmp215 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp216 := tmp215.FindInternedVar(lang.NewSymbol("*loading-verbosely*"))
								if tmp216.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp216)))
								}
								tmp217 := tmp216.Get()
								if lang.IsTruthy(tmp217) {
									tmp218 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp219 := tmp218.FindInternedVar(lang.NewSymbol("printf"))
									if tmp219.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp219)))
									}
									tmp220 := tmp219.Get()
									tmp221 := lang.Apply(tmp220, []any{"(glojure.core/refer '%s", v25})
									_ = tmp221
									var tmp222 any
									{ // let
										// let binding "seq_111"
										tmp223 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp224 := tmp223.FindInternedVar(lang.NewSymbol("seq"))
										if tmp224.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp224)))
										}
										tmp225 := tmp224.Get()
										tmp226 := lang.Apply(tmp225, []any{v139})
										var v227 any = tmp226
										_ = v227
										// let binding "chunk_112"
										var v228 any = nil
										_ = v228
										// let binding "count_113"
										var v229 any = int64(0)
										_ = v229
										// let binding "i_114"
										var v230 any = int64(0)
										_ = v230
										for {
											var tmp231 any
											tmp232 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp233 := tmp232.FindInternedVar(lang.NewSymbol("<"))
											if tmp233.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp233)))
											}
											tmp234 := tmp233.Get()
											tmp235 := lang.Apply(tmp234, []any{v230, v229})
											if lang.IsTruthy(tmp235) {
												var tmp236 any
												{ // let
													// let binding "opt"
													tmp237, _ := lang.FieldOrMethod(v228, "nth")
													if reflect.TypeOf(tmp237).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
													}
													tmp238 := lang.Apply(tmp237, []any{v230})
													var v239 any = tmp238
													_ = v239
													tmp240 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp241 := tmp240.FindInternedVar(lang.NewSymbol("printf"))
													if tmp241.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp241)))
													}
													tmp242 := tmp241.Get()
													tmp243 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp244 := tmp243.FindInternedVar(lang.NewSymbol("key"))
													if tmp244.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp244)))
													}
													tmp245 := tmp244.Get()
													tmp246 := lang.Apply(tmp245, []any{v239})
													tmp247 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp248 := tmp247.FindInternedVar(lang.NewSymbol("print-str"))
													if tmp248.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp248)))
													}
													tmp249 := tmp248.Get()
													tmp250 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp251 := tmp250.FindInternedVar(lang.NewSymbol("val"))
													if tmp251.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp251)))
													}
													tmp252 := tmp251.Get()
													tmp253 := lang.Apply(tmp252, []any{v239})
													tmp254 := lang.Apply(tmp249, []any{tmp253})
													tmp255 := lang.Apply(tmp242, []any{" %s '%s", tmp246, tmp254})
													_ = tmp255
													var tmp256 any = v227
													var tmp257 any = v228
													var tmp258 any = v229
													tmp260 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp261 := tmp260.FindInternedVar(lang.NewSymbol("unchecked-inc"))
													if tmp261.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp261)))
													}
													tmp262 := tmp261.Get()
													tmp263 := lang.Apply(tmp262, []any{v230})
													var tmp259 any = tmp263
													v227 = tmp256
													v228 = tmp257
													v229 = tmp258
													v230 = tmp259
													continue
												} // end let
												tmp231 = tmp236
											} else {
												var tmp237 any
												{ // let
													// let binding "temp__0__auto__"
													tmp238 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp239 := tmp238.FindInternedVar(lang.NewSymbol("seq"))
													if tmp239.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp239)))
													}
													tmp240 := tmp239.Get()
													tmp241 := lang.Apply(tmp240, []any{v227})
													var v242 any = tmp241
													_ = v242
													var tmp243 any
													if lang.IsTruthy(v242) {
														var tmp244 any
														{ // let
															// let binding "seq_111"
															var v245 any = v242
															_ = v245
															var tmp246 any
															tmp247 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp248 := tmp247.FindInternedVar(lang.NewSymbol("chunked-seq?"))
															if tmp248.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp248)))
															}
															tmp249 := tmp248.Get()
															tmp250 := lang.Apply(tmp249, []any{v245})
															if lang.IsTruthy(tmp250) {
																var tmp251 any
																{ // let
																	// let binding "c__0__auto__"
																	tmp252 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp253 := tmp252.FindInternedVar(lang.NewSymbol("chunk-first"))
																	if tmp253.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp253)))
																	}
																	tmp254 := tmp253.Get()
																	tmp255 := lang.Apply(tmp254, []any{v245})
																	var v256 any = tmp255
																	_ = v256
																	tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp259 := tmp258.FindInternedVar(lang.NewSymbol("chunk-rest"))
																	if tmp259.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
																	}
																	tmp260 := tmp259.Get()
																	tmp261 := lang.Apply(tmp260, []any{v245})
																	var tmp257 any = tmp261
																	var tmp262 any = v256
																	tmp264 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp265 := tmp264.FindInternedVar(lang.NewSymbol("int"))
																	if tmp265.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp265)))
																	}
																	tmp266 := tmp265.Get()
																	tmp267 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp268 := tmp267.FindInternedVar(lang.NewSymbol("count"))
																	if tmp268.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp268)))
																	}
																	tmp269 := tmp268.Get()
																	tmp270 := lang.Apply(tmp269, []any{v256})
																	tmp271 := lang.Apply(tmp266, []any{tmp270})
																	var tmp263 any = tmp271
																	tmp273 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp274 := tmp273.FindInternedVar(lang.NewSymbol("int"))
																	if tmp274.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp274)))
																	}
																	tmp275 := tmp274.Get()
																	tmp276 := lang.Apply(tmp275, []any{int64(0)})
																	var tmp272 any = tmp276
																	v227 = tmp257
																	v228 = tmp262
																	v229 = tmp263
																	v230 = tmp272
																	continue
																} // end let
																tmp246 = tmp251
															} else {
																var tmp252 any
																{ // let
																	// let binding "opt"
																	tmp253 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp254 := tmp253.FindInternedVar(lang.NewSymbol("first"))
																	if tmp254.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp254)))
																	}
																	tmp255 := tmp254.Get()
																	tmp256 := lang.Apply(tmp255, []any{v245})
																	var v257 any = tmp256
																	_ = v257
																	tmp258 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp259 := tmp258.FindInternedVar(lang.NewSymbol("printf"))
																	if tmp259.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp259)))
																	}
																	tmp260 := tmp259.Get()
																	tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp262 := tmp261.FindInternedVar(lang.NewSymbol("key"))
																	if tmp262.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
																	}
																	tmp263 := tmp262.Get()
																	tmp264 := lang.Apply(tmp263, []any{v257})
																	tmp265 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp266 := tmp265.FindInternedVar(lang.NewSymbol("print-str"))
																	if tmp266.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp266)))
																	}
																	tmp267 := tmp266.Get()
																	tmp268 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp269 := tmp268.FindInternedVar(lang.NewSymbol("val"))
																	if tmp269.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp269)))
																	}
																	tmp270 := tmp269.Get()
																	tmp271 := lang.Apply(tmp270, []any{v257})
																	tmp272 := lang.Apply(tmp267, []any{tmp271})
																	tmp273 := lang.Apply(tmp260, []any{" %s '%s", tmp264, tmp272})
																	_ = tmp273
																	tmp275 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp276 := tmp275.FindInternedVar(lang.NewSymbol("next"))
																	if tmp276.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp276)))
																	}
																	tmp277 := tmp276.Get()
																	tmp278 := lang.Apply(tmp277, []any{v245})
																	var tmp274 any = tmp278
																	var tmp279 any = nil
																	var tmp280 any = int64(0)
																	var tmp281 any = int64(0)
																	v227 = tmp274
																	v228 = tmp279
																	v229 = tmp280
																	v230 = tmp281
																	continue
																} // end let
																tmp246 = tmp252
															}
															tmp244 = tmp246
														} // end let
														tmp243 = tmp244
													} else {
													}
													tmp237 = tmp243
												} // end let
												tmp231 = tmp237
											}
											tmp222 = tmp231
											break
										}
									} // end let
									_ = tmp222
									tmp223 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp224 := tmp223.FindInternedVar(lang.NewSymbol("printf"))
									if tmp224.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp224)))
									}
									tmp225 := tmp224.Get()
									tmp226 := lang.Apply(tmp225, []any{")\n"})
									tmp214 = tmp226
								} else {
								}
								_ = tmp214
								tmp227 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp228 := tmp227.FindInternedVar(lang.NewSymbol("apply"))
								if tmp228.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp228)))
								}
								tmp229 := tmp228.Get()
								tmp230 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp231 := tmp230.FindInternedVar(lang.NewSymbol("refer"))
								if tmp231.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp231)))
								}
								tmp232 := tmp231.Get()
								tmp233 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp234 := tmp233.FindInternedVar(lang.NewSymbol("mapcat"))
								if tmp234.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp234)))
								}
								tmp235 := tmp234.Get()
								tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp237 := tmp236.FindInternedVar(lang.NewSymbol("seq"))
								if tmp237.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
								}
								tmp238 := tmp237.Get()
								tmp239 := lang.Apply(tmp235, []any{tmp238, v139})
								tmp240 := lang.Apply(tmp229, []any{tmp232, v25, tmp239})
								tmp212 = tmp240
							} else {
							}
							tmp160 = tmp212
						}()
						tmp149 = tmp160
					} // end let
					tmp15 = tmp149
				} // end let
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-libs
	{
		tmp0 := lang.NewSymbol("load-libs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5951), lang.NewKeyword("end-line"), int(5951), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "flags"
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("filter"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("keyword?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp7, []any{tmp10, v3})
					var v12 any = tmp11
					_ = v12
					// let binding "opts"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("interleave"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("repeat"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{true})
					tmp20 := lang.Apply(tmp15, []any{v12, tmp19})
					var v21 any = tmp20
					_ = v21
					// let binding "args"
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("filter"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("complement"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("keyword?"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.Apply(tmp27, []any{tmp30})
					tmp32 := lang.Apply(tmp24, []any{tmp31, v3})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					{ // let
						// let binding "supported"
						tmp35 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{lang.NewKeyword("as"), lang.NewKeyword("reload"), lang.NewKeyword("reload-all"), lang.NewKeyword("require"), lang.NewKeyword("use"), lang.NewKeyword("verbose"), lang.NewKeyword("refer"), lang.NewKeyword("as-alias")}))
						tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5959), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(5959), lang.NewKeyword("end-column"), int(86))
						tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v38 any = tmp37
						_ = v38
						// let binding "unsupported"
						tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq"))
						if tmp40.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
						}
						tmp41 := tmp40.Get()
						tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp43 := tmp42.FindInternedVar(lang.NewSymbol("remove"))
						if tmp43.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
						}
						tmp44 := tmp43.Get()
						tmp45 := lang.Apply(tmp44, []any{v38, v12})
						tmp46 := lang.Apply(tmp41, []any{tmp45})
						var v47 any = tmp46
						_ = v47
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("throw-if"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp52 := tmp51.FindInternedVar(lang.NewSymbol("apply"))
						if tmp52.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
						}
						tmp53 := tmp52.Get()
						tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp55 := tmp54.FindInternedVar(lang.NewSymbol("str"))
						if tmp55.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
						}
						tmp56 := tmp55.Get()
						tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp58 := tmp57.FindInternedVar(lang.NewSymbol("interpose"))
						if tmp58.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
						}
						tmp59 := tmp58.Get()
						tmp60 := lang.Apply(tmp59, []any{lang.NewChar(44), v47})
						tmp61 := lang.Apply(tmp53, []any{tmp56, "Unsupported option(s) supplied: ", tmp60})
						tmp62 := lang.Apply(tmp50, []any{v47, tmp61})
						tmp34 = tmp62
					} // end let
					_ = tmp34
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("throw-if"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("not"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("seq"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v33})
					tmp45 := lang.Apply(tmp40, []any{tmp44})
					tmp46 := lang.Apply(tmp37, []any{tmp45, "Nothing specified to load"})
					_ = tmp46
					var tmp47 any
					{ // let
						// let binding "seq_115"
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("seq"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v33})
						var v52 any = tmp51
						_ = v52
						// let binding "chunk_116"
						var v53 any = nil
						_ = v53
						// let binding "count_117"
						var v54 any = int64(0)
						_ = v54
						// let binding "i_118"
						var v55 any = int64(0)
						_ = v55
						for {
							var tmp56 any
							tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp58 := tmp57.FindInternedVar(lang.NewSymbol("<"))
							if tmp58.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
							}
							tmp59 := tmp58.Get()
							tmp60 := lang.Apply(tmp59, []any{v55, v54})
							if lang.IsTruthy(tmp60) {
								var tmp61 any
								{ // let
									// let binding "arg"
									tmp62, _ := lang.FieldOrMethod(v53, "nth")
									if reflect.TypeOf(tmp62).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp63 := lang.Apply(tmp62, []any{v55})
									var v64 any = tmp63
									_ = v64
									var tmp65 any
									tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp67 := tmp66.FindInternedVar(lang.NewSymbol("libspec?"))
									if tmp67.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
									}
									tmp68 := tmp67.Get()
									tmp69 := lang.Apply(tmp68, []any{v64})
									if lang.IsTruthy(tmp69) {
										tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp71 := tmp70.FindInternedVar(lang.NewSymbol("apply"))
										if tmp71.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
										}
										tmp72 := tmp71.Get()
										tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp74 := tmp73.FindInternedVar(lang.NewSymbol("load-lib"))
										if tmp74.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
										}
										tmp75 := tmp74.Get()
										tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp77 := tmp76.FindInternedVar(lang.NewSymbol("prependss"))
										if tmp77.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
										}
										tmp78 := tmp77.Get()
										tmp79 := lang.Apply(tmp78, []any{v64, v21})
										tmp80 := lang.Apply(tmp72, []any{tmp75, nil, tmp79})
										tmp65 = tmp80
									} else {
										var tmp81 any
										{ // let
											// let binding "vec__119"
											var v82 any = v64
											_ = v82
											// let binding "seq__120"
											tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp84 := tmp83.FindInternedVar(lang.NewSymbol("seq"))
											if tmp84.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
											}
											tmp85 := tmp84.Get()
											tmp86 := lang.Apply(tmp85, []any{v82})
											var v87 any = tmp86
											_ = v87
											// let binding "first__121"
											tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp89 := tmp88.FindInternedVar(lang.NewSymbol("first"))
											if tmp89.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
											}
											tmp90 := tmp89.Get()
											tmp91 := lang.Apply(tmp90, []any{v87})
											var v92 any = tmp91
											_ = v92
											// let binding "seq__120"
											tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp94 := tmp93.FindInternedVar(lang.NewSymbol("next"))
											if tmp94.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
											}
											tmp95 := tmp94.Get()
											tmp96 := lang.Apply(tmp95, []any{v87})
											var v97 any = tmp96
											_ = v97
											// let binding "prefix"
											var v98 any = v92
											_ = v98
											// let binding "args"
											var v99 any = v97
											_ = v99
											tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp101 := tmp100.FindInternedVar(lang.NewSymbol("throw-if"))
											if tmp101.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
											}
											tmp102 := tmp101.Get()
											tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp104 := tmp103.FindInternedVar(lang.NewSymbol("nil?"))
											if tmp104.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
											}
											tmp105 := tmp104.Get()
											tmp106 := lang.Apply(tmp105, []any{v98})
											tmp107 := lang.Apply(tmp102, []any{tmp106, "prefix cannot be nil"})
											_ = tmp107
											var tmp108 any
											{ // let
												// let binding "seq_122"
												tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp110 := tmp109.FindInternedVar(lang.NewSymbol("seq"))
												if tmp110.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
												}
												tmp111 := tmp110.Get()
												tmp112 := lang.Apply(tmp111, []any{v99})
												var v113 any = tmp112
												_ = v113
												// let binding "chunk_123"
												var v114 any = nil
												_ = v114
												// let binding "count_124"
												var v115 any = int64(0)
												_ = v115
												// let binding "i_125"
												var v116 any = int64(0)
												_ = v116
												for {
													var tmp117 any
													tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp119 := tmp118.FindInternedVar(lang.NewSymbol("<"))
													if tmp119.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
													}
													tmp120 := tmp119.Get()
													tmp121 := lang.Apply(tmp120, []any{v116, v115})
													if lang.IsTruthy(tmp121) {
														var tmp122 any
														{ // let
															// let binding "arg"
															tmp123, _ := lang.FieldOrMethod(v114, "nth")
															if reflect.TypeOf(tmp123).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
															}
															tmp124 := lang.Apply(tmp123, []any{v116})
															var v125 any = tmp124
															_ = v125
															tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp127 := tmp126.FindInternedVar(lang.NewSymbol("apply"))
															if tmp127.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
															}
															tmp128 := tmp127.Get()
															tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp130 := tmp129.FindInternedVar(lang.NewSymbol("load-lib"))
															if tmp130.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
															}
															tmp131 := tmp130.Get()
															tmp132 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp133 := tmp132.FindInternedVar(lang.NewSymbol("prependss"))
															if tmp133.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp133)))
															}
															tmp134 := tmp133.Get()
															tmp135 := lang.Apply(tmp134, []any{v125, v21})
															tmp136 := lang.Apply(tmp128, []any{tmp131, v98, tmp135})
															_ = tmp136
															var tmp137 any = v113
															var tmp138 any = v114
															var tmp139 any = v115
															tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp142 := tmp141.FindInternedVar(lang.NewSymbol("unchecked-inc"))
															if tmp142.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
															}
															tmp143 := tmp142.Get()
															tmp144 := lang.Apply(tmp143, []any{v116})
															var tmp140 any = tmp144
															v113 = tmp137
															v114 = tmp138
															v115 = tmp139
															v116 = tmp140
															continue
														} // end let
														tmp117 = tmp122
													} else {
														var tmp123 any
														{ // let
															// let binding "temp__0__auto__"
															tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp125 := tmp124.FindInternedVar(lang.NewSymbol("seq"))
															if tmp125.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
															}
															tmp126 := tmp125.Get()
															tmp127 := lang.Apply(tmp126, []any{v113})
															var v128 any = tmp127
															_ = v128
															var tmp129 any
															if lang.IsTruthy(v128) {
																var tmp130 any
																{ // let
																	// let binding "seq_122"
																	var v131 any = v128
																	_ = v131
																	var tmp132 any
																	tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp134 := tmp133.FindInternedVar(lang.NewSymbol("chunked-seq?"))
																	if tmp134.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
																	}
																	tmp135 := tmp134.Get()
																	tmp136 := lang.Apply(tmp135, []any{v131})
																	if lang.IsTruthy(tmp136) {
																		var tmp137 any
																		{ // let
																			// let binding "c__0__auto__"
																			tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp139 := tmp138.FindInternedVar(lang.NewSymbol("chunk-first"))
																			if tmp139.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
																			}
																			tmp140 := tmp139.Get()
																			tmp141 := lang.Apply(tmp140, []any{v131})
																			var v142 any = tmp141
																			_ = v142
																			tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp145 := tmp144.FindInternedVar(lang.NewSymbol("chunk-rest"))
																			if tmp145.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
																			}
																			tmp146 := tmp145.Get()
																			tmp147 := lang.Apply(tmp146, []any{v131})
																			var tmp143 any = tmp147
																			var tmp148 any = v142
																			tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp151 := tmp150.FindInternedVar(lang.NewSymbol("int"))
																			if tmp151.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
																			}
																			tmp152 := tmp151.Get()
																			tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp154 := tmp153.FindInternedVar(lang.NewSymbol("count"))
																			if tmp154.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
																			}
																			tmp155 := tmp154.Get()
																			tmp156 := lang.Apply(tmp155, []any{v142})
																			tmp157 := lang.Apply(tmp152, []any{tmp156})
																			var tmp149 any = tmp157
																			tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp160 := tmp159.FindInternedVar(lang.NewSymbol("int"))
																			if tmp160.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
																			}
																			tmp161 := tmp160.Get()
																			tmp162 := lang.Apply(tmp161, []any{int64(0)})
																			var tmp158 any = tmp162
																			v113 = tmp143
																			v114 = tmp148
																			v115 = tmp149
																			v116 = tmp158
																			continue
																		} // end let
																		tmp132 = tmp137
																	} else {
																		var tmp138 any
																		{ // let
																			// let binding "arg"
																			tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp140 := tmp139.FindInternedVar(lang.NewSymbol("first"))
																			if tmp140.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
																			}
																			tmp141 := tmp140.Get()
																			tmp142 := lang.Apply(tmp141, []any{v131})
																			var v143 any = tmp142
																			_ = v143
																			tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp145 := tmp144.FindInternedVar(lang.NewSymbol("apply"))
																			if tmp145.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
																			}
																			tmp146 := tmp145.Get()
																			tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp148 := tmp147.FindInternedVar(lang.NewSymbol("load-lib"))
																			if tmp148.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
																			}
																			tmp149 := tmp148.Get()
																			tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp151 := tmp150.FindInternedVar(lang.NewSymbol("prependss"))
																			if tmp151.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
																			}
																			tmp152 := tmp151.Get()
																			tmp153 := lang.Apply(tmp152, []any{v143, v21})
																			tmp154 := lang.Apply(tmp146, []any{tmp149, v98, tmp153})
																			_ = tmp154
																			tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp157 := tmp156.FindInternedVar(lang.NewSymbol("next"))
																			if tmp157.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
																			}
																			tmp158 := tmp157.Get()
																			tmp159 := lang.Apply(tmp158, []any{v131})
																			var tmp155 any = tmp159
																			var tmp160 any = nil
																			var tmp161 any = int64(0)
																			var tmp162 any = int64(0)
																			v113 = tmp155
																			v114 = tmp160
																			v115 = tmp161
																			v116 = tmp162
																			continue
																		} // end let
																		tmp132 = tmp138
																	}
																	tmp130 = tmp132
																} // end let
																tmp129 = tmp130
															} else {
															}
															tmp123 = tmp129
														} // end let
														tmp117 = tmp123
													}
													tmp108 = tmp117
													break
												}
											} // end let
											tmp81 = tmp108
										} // end let
										tmp65 = tmp81
									}
									_ = tmp65
									var tmp82 any = v52
									var tmp83 any = v53
									var tmp84 any = v54
									tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp87 := tmp86.FindInternedVar(lang.NewSymbol("unchecked-inc"))
									if tmp87.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
									}
									tmp88 := tmp87.Get()
									tmp89 := lang.Apply(tmp88, []any{v55})
									var tmp85 any = tmp89
									v52 = tmp82
									v53 = tmp83
									v54 = tmp84
									v55 = tmp85
									continue
								} // end let
								tmp56 = tmp61
							} else {
								var tmp62 any
								{ // let
									// let binding "temp__0__auto__"
									tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp64 := tmp63.FindInternedVar(lang.NewSymbol("seq"))
									if tmp64.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
									}
									tmp65 := tmp64.Get()
									tmp66 := lang.Apply(tmp65, []any{v52})
									var v67 any = tmp66
									_ = v67
									var tmp68 any
									if lang.IsTruthy(v67) {
										var tmp69 any
										{ // let
											// let binding "seq_115"
											var v70 any = v67
											_ = v70
											var tmp71 any
											tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp73 := tmp72.FindInternedVar(lang.NewSymbol("chunked-seq?"))
											if tmp73.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
											}
											tmp74 := tmp73.Get()
											tmp75 := lang.Apply(tmp74, []any{v70})
											if lang.IsTruthy(tmp75) {
												var tmp76 any
												{ // let
													// let binding "c__0__auto__"
													tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp78 := tmp77.FindInternedVar(lang.NewSymbol("chunk-first"))
													if tmp78.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
													}
													tmp79 := tmp78.Get()
													tmp80 := lang.Apply(tmp79, []any{v70})
													var v81 any = tmp80
													_ = v81
													tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp84 := tmp83.FindInternedVar(lang.NewSymbol("chunk-rest"))
													if tmp84.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
													}
													tmp85 := tmp84.Get()
													tmp86 := lang.Apply(tmp85, []any{v70})
													var tmp82 any = tmp86
													var tmp87 any = v81
													tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp90 := tmp89.FindInternedVar(lang.NewSymbol("int"))
													if tmp90.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
													}
													tmp91 := tmp90.Get()
													tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp93 := tmp92.FindInternedVar(lang.NewSymbol("count"))
													if tmp93.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
													}
													tmp94 := tmp93.Get()
													tmp95 := lang.Apply(tmp94, []any{v81})
													tmp96 := lang.Apply(tmp91, []any{tmp95})
													var tmp88 any = tmp96
													tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp99 := tmp98.FindInternedVar(lang.NewSymbol("int"))
													if tmp99.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
													}
													tmp100 := tmp99.Get()
													tmp101 := lang.Apply(tmp100, []any{int64(0)})
													var tmp97 any = tmp101
													v52 = tmp82
													v53 = tmp87
													v54 = tmp88
													v55 = tmp97
													continue
												} // end let
												tmp71 = tmp76
											} else {
												var tmp77 any
												{ // let
													// let binding "arg"
													tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp79 := tmp78.FindInternedVar(lang.NewSymbol("first"))
													if tmp79.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
													}
													tmp80 := tmp79.Get()
													tmp81 := lang.Apply(tmp80, []any{v70})
													var v82 any = tmp81
													_ = v82
													var tmp83 any
													tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp85 := tmp84.FindInternedVar(lang.NewSymbol("libspec?"))
													if tmp85.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
													}
													tmp86 := tmp85.Get()
													tmp87 := lang.Apply(tmp86, []any{v82})
													if lang.IsTruthy(tmp87) {
														tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp89 := tmp88.FindInternedVar(lang.NewSymbol("apply"))
														if tmp89.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
														}
														tmp90 := tmp89.Get()
														tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp92 := tmp91.FindInternedVar(lang.NewSymbol("load-lib"))
														if tmp92.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
														}
														tmp93 := tmp92.Get()
														tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp95 := tmp94.FindInternedVar(lang.NewSymbol("prependss"))
														if tmp95.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
														}
														tmp96 := tmp95.Get()
														tmp97 := lang.Apply(tmp96, []any{v82, v21})
														tmp98 := lang.Apply(tmp90, []any{tmp93, nil, tmp97})
														tmp83 = tmp98
													} else {
														var tmp99 any
														{ // let
															// let binding "vec__126"
															var v100 any = v82
															_ = v100
															// let binding "seq__127"
															tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp102 := tmp101.FindInternedVar(lang.NewSymbol("seq"))
															if tmp102.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
															}
															tmp103 := tmp102.Get()
															tmp104 := lang.Apply(tmp103, []any{v100})
															var v105 any = tmp104
															_ = v105
															// let binding "first__128"
															tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp107 := tmp106.FindInternedVar(lang.NewSymbol("first"))
															if tmp107.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
															}
															tmp108 := tmp107.Get()
															tmp109 := lang.Apply(tmp108, []any{v105})
															var v110 any = tmp109
															_ = v110
															// let binding "seq__127"
															tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp112 := tmp111.FindInternedVar(lang.NewSymbol("next"))
															if tmp112.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
															}
															tmp113 := tmp112.Get()
															tmp114 := lang.Apply(tmp113, []any{v105})
															var v115 any = tmp114
															_ = v115
															// let binding "prefix"
															var v116 any = v110
															_ = v116
															// let binding "args"
															var v117 any = v115
															_ = v117
															tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp119 := tmp118.FindInternedVar(lang.NewSymbol("throw-if"))
															if tmp119.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
															}
															tmp120 := tmp119.Get()
															tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp122 := tmp121.FindInternedVar(lang.NewSymbol("nil?"))
															if tmp122.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
															}
															tmp123 := tmp122.Get()
															tmp124 := lang.Apply(tmp123, []any{v116})
															tmp125 := lang.Apply(tmp120, []any{tmp124, "prefix cannot be nil"})
															_ = tmp125
															var tmp126 any
															{ // let
																// let binding "seq_129"
																tmp127 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp128 := tmp127.FindInternedVar(lang.NewSymbol("seq"))
																if tmp128.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp128)))
																}
																tmp129 := tmp128.Get()
																tmp130 := lang.Apply(tmp129, []any{v117})
																var v131 any = tmp130
																_ = v131
																// let binding "chunk_130"
																var v132 any = nil
																_ = v132
																// let binding "count_131"
																var v133 any = int64(0)
																_ = v133
																// let binding "i_132"
																var v134 any = int64(0)
																_ = v134
																for {
																	var tmp135 any
																	tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																	tmp137 := tmp136.FindInternedVar(lang.NewSymbol("<"))
																	if tmp137.IsMacro() {
																		panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
																	}
																	tmp138 := tmp137.Get()
																	tmp139 := lang.Apply(tmp138, []any{v134, v133})
																	if lang.IsTruthy(tmp139) {
																		var tmp140 any
																		{ // let
																			// let binding "arg"
																			tmp141, _ := lang.FieldOrMethod(v132, "nth")
																			if reflect.TypeOf(tmp141).Kind() != reflect.Func {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																			}
																			tmp142 := lang.Apply(tmp141, []any{v134})
																			var v143 any = tmp142
																			_ = v143
																			tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp145 := tmp144.FindInternedVar(lang.NewSymbol("apply"))
																			if tmp145.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
																			}
																			tmp146 := tmp145.Get()
																			tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp148 := tmp147.FindInternedVar(lang.NewSymbol("load-lib"))
																			if tmp148.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
																			}
																			tmp149 := tmp148.Get()
																			tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp151 := tmp150.FindInternedVar(lang.NewSymbol("prependss"))
																			if tmp151.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
																			}
																			tmp152 := tmp151.Get()
																			tmp153 := lang.Apply(tmp152, []any{v143, v21})
																			tmp154 := lang.Apply(tmp146, []any{tmp149, v116, tmp153})
																			_ = tmp154
																			var tmp155 any = v131
																			var tmp156 any = v132
																			var tmp157 any = v133
																			tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp160 := tmp159.FindInternedVar(lang.NewSymbol("unchecked-inc"))
																			if tmp160.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
																			}
																			tmp161 := tmp160.Get()
																			tmp162 := lang.Apply(tmp161, []any{v134})
																			var tmp158 any = tmp162
																			v131 = tmp155
																			v132 = tmp156
																			v133 = tmp157
																			v134 = tmp158
																			continue
																		} // end let
																		tmp135 = tmp140
																	} else {
																		var tmp141 any
																		{ // let
																			// let binding "temp__0__auto__"
																			tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																			tmp143 := tmp142.FindInternedVar(lang.NewSymbol("seq"))
																			if tmp143.IsMacro() {
																				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
																			}
																			tmp144 := tmp143.Get()
																			tmp145 := lang.Apply(tmp144, []any{v131})
																			var v146 any = tmp145
																			_ = v146
																			var tmp147 any
																			if lang.IsTruthy(v146) {
																				var tmp148 any
																				{ // let
																					// let binding "seq_129"
																					var v149 any = v146
																					_ = v149
																					var tmp150 any
																					tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																					tmp152 := tmp151.FindInternedVar(lang.NewSymbol("chunked-seq?"))
																					if tmp152.IsMacro() {
																						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
																					}
																					tmp153 := tmp152.Get()
																					tmp154 := lang.Apply(tmp153, []any{v149})
																					if lang.IsTruthy(tmp154) {
																						var tmp155 any
																						{ // let
																							// let binding "c__0__auto__"
																							tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp157 := tmp156.FindInternedVar(lang.NewSymbol("chunk-first"))
																							if tmp157.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
																							}
																							tmp158 := tmp157.Get()
																							tmp159 := lang.Apply(tmp158, []any{v149})
																							var v160 any = tmp159
																							_ = v160
																							tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp163 := tmp162.FindInternedVar(lang.NewSymbol("chunk-rest"))
																							if tmp163.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
																							}
																							tmp164 := tmp163.Get()
																							tmp165 := lang.Apply(tmp164, []any{v149})
																							var tmp161 any = tmp165
																							var tmp166 any = v160
																							tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp169 := tmp168.FindInternedVar(lang.NewSymbol("int"))
																							if tmp169.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
																							}
																							tmp170 := tmp169.Get()
																							tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp172 := tmp171.FindInternedVar(lang.NewSymbol("count"))
																							if tmp172.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
																							}
																							tmp173 := tmp172.Get()
																							tmp174 := lang.Apply(tmp173, []any{v160})
																							tmp175 := lang.Apply(tmp170, []any{tmp174})
																							var tmp167 any = tmp175
																							tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp178 := tmp177.FindInternedVar(lang.NewSymbol("int"))
																							if tmp178.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
																							}
																							tmp179 := tmp178.Get()
																							tmp180 := lang.Apply(tmp179, []any{int64(0)})
																							var tmp176 any = tmp180
																							v131 = tmp161
																							v132 = tmp166
																							v133 = tmp167
																							v134 = tmp176
																							continue
																						} // end let
																						tmp150 = tmp155
																					} else {
																						var tmp156 any
																						{ // let
																							// let binding "arg"
																							tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp158 := tmp157.FindInternedVar(lang.NewSymbol("first"))
																							if tmp158.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
																							}
																							tmp159 := tmp158.Get()
																							tmp160 := lang.Apply(tmp159, []any{v149})
																							var v161 any = tmp160
																							_ = v161
																							tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp163 := tmp162.FindInternedVar(lang.NewSymbol("apply"))
																							if tmp163.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
																							}
																							tmp164 := tmp163.Get()
																							tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp166 := tmp165.FindInternedVar(lang.NewSymbol("load-lib"))
																							if tmp166.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
																							}
																							tmp167 := tmp166.Get()
																							tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp169 := tmp168.FindInternedVar(lang.NewSymbol("prependss"))
																							if tmp169.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
																							}
																							tmp170 := tmp169.Get()
																							tmp171 := lang.Apply(tmp170, []any{v161, v21})
																							tmp172 := lang.Apply(tmp164, []any{tmp167, v116, tmp171})
																							_ = tmp172
																							tmp174 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																							tmp175 := tmp174.FindInternedVar(lang.NewSymbol("next"))
																							if tmp175.IsMacro() {
																								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp175)))
																							}
																							tmp176 := tmp175.Get()
																							tmp177 := lang.Apply(tmp176, []any{v149})
																							var tmp173 any = tmp177
																							var tmp178 any = nil
																							var tmp179 any = int64(0)
																							var tmp180 any = int64(0)
																							v131 = tmp173
																							v132 = tmp178
																							v133 = tmp179
																							v134 = tmp180
																							continue
																						} // end let
																						tmp150 = tmp156
																					}
																					tmp148 = tmp150
																				} // end let
																				tmp147 = tmp148
																			} else {
																			}
																			tmp141 = tmp147
																		} // end let
																		tmp135 = tmp141
																	}
																	tmp126 = tmp135
																	break
																}
															} // end let
															tmp99 = tmp126
														} // end let
														tmp83 = tmp99
													}
													_ = tmp83
													tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp102 := tmp101.FindInternedVar(lang.NewSymbol("next"))
													if tmp102.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
													}
													tmp103 := tmp102.Get()
													tmp104 := lang.Apply(tmp103, []any{v70})
													var tmp100 any = tmp104
													var tmp105 any = nil
													var tmp106 any = int64(0)
													var tmp107 any = int64(0)
													v52 = tmp100
													v53 = tmp105
													v54 = tmp106
													v55 = tmp107
													continue
												} // end let
												tmp71 = tmp77
											}
											tmp69 = tmp71
										} // end let
										tmp68 = tmp69
									} else {
									}
									tmp62 = tmp68
								} // end let
								tmp56 = tmp62
							}
							tmp47 = tmp56
							break
						}
					} // end let
					tmp4 = tmp47
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-one
	{
		tmp0 := lang.NewSymbol("load-one").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"), lang.NewSymbol("need-ns"), lang.NewSymbol("require"))), lang.NewKeyword("doc"), "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5879), lang.NewKeyword("end-line"), int(5879), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("load"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("root-resource"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp11, []any{v3})
			tmp13 := lang.Apply(tmp8, []any{tmp12})
			_ = tmp13
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("throw-if"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			var tmp17 any
			{ // let
				// let binding "and__0__auto__"
				var v18 any = v4
				_ = v18
				var tmp19 any
				if lang.IsTruthy(v18) {
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("not"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("find-ns"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := lang.Apply(tmp22, []any{tmp26})
					tmp19 = tmp27
				} else {
					tmp19 = v18
				}
				tmp17 = tmp19
			} // end let
			tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp19 := tmp18.FindInternedVar(lang.NewSymbol("root-resource"))
			if tmp19.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
			}
			tmp20 := tmp19.Get()
			tmp21 := lang.Apply(tmp20, []any{v3})
			tmp22 := lang.Apply(tmp16, []any{tmp17, "namespace '%s' not found after loading '%s'", v3, tmp21})
			_ = tmp22
			var tmp23 any
			if lang.IsTruthy(v5) {
				var tmp24 lang.FnFunc
				tmp24 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("commute"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("*loaded-libs*"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("conj"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp27, []any{tmp30, tmp33, v3})
					return tmp34
				})
				tmp25, _ := lang.FieldOrMethod(lang.LockingTransaction, "RunInTransaction")
				if reflect.TypeOf(tmp25).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("RunInTransaction is not a function")))
				}
				tmp26 := lang.Apply(tmp25, []any{tmp24})
				tmp23 = tmp26
			} else {
			}
			return tmp23
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-reader
	{
		tmp0 := lang.NewSymbol("load-reader").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rdr"))), lang.NewKeyword("doc"), "Sequentially read and evaluate the set of forms contained in the\n  stream/file", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4081), lang.NewKeyword("end-line"), int(4081))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.Compiler, "load")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("load is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// load-string
	{
		tmp0 := lang.NewSymbol("load-string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Sequentially read and evaluate the set of forms contained in the\n  string", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4088), lang.NewKeyword("end-line"), int(4088))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rdr"
				tmp5 := lang.Apply(nil, []any{v3})
				tmp6 := lang.Apply(nil, []any{tmp5})
				var v7 any = tmp6
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("load-reader"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp4 = tmp11
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loaded-libs
	{
		tmp0 := lang.NewSymbol("loaded-libs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a sorted set of symbols naming the currently loaded libs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6090), lang.NewKeyword("end-line"), int(6090))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp4 := tmp3.FindInternedVar(lang.NewSymbol("deref"))
			if tmp4.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
			}
			tmp5 := tmp4.Get()
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*loaded-libs*"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp5, []any{tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// locking
	{
		tmp0 := lang.NewSymbol("locking").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1643), lang.NewKeyword("end-line"), int(1643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/let")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("lockee__0__auto__")})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v5})
				tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
				tmp41 := lang.Apply(tmp28, []any{tmp40})
				tmp42 := lang.Apply(tmp22, []any{tmp25, tmp41})
				tmp43 := lang.Apply(tmp19, []any{tmp42})
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("try")})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
				if tmp61.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
				}
				tmp62 := tmp61.Get()
				tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp64 := tmp63.FindInternedVar(lang.NewSymbol("concat"))
				if tmp64.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
				}
				tmp65 := tmp64.Get()
				tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
				if tmp67.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
				}
				tmp68 := tmp67.Get()
				tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/let")})
				tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
				if tmp71.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
				}
				tmp72 := tmp71.Get()
				tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp74 := tmp73.FindInternedVar(lang.NewSymbol("apply"))
				if tmp74.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
				}
				tmp75 := tmp74.Get()
				tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp77 := tmp76.FindInternedVar(lang.NewSymbol("vector"))
				if tmp77.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
				}
				tmp78 := tmp77.Get()
				tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp80 := tmp79.FindInternedVar(lang.NewSymbol("seq"))
				if tmp80.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
				}
				tmp81 := tmp80.Get()
				tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp83 := tmp82.FindInternedVar(lang.NewSymbol("concat"))
				if tmp83.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
				}
				tmp84 := tmp83.Get()
				tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp86 := tmp85.FindInternedVar(lang.NewSymbol("list"))
				if tmp86.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
				}
				tmp87 := tmp86.Get()
				tmp88 := lang.Apply(tmp87, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
				if tmp90.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
				}
				tmp91 := tmp90.Get()
				tmp92 := lang.Apply(tmp91, []any{lang.NewSymbol("lockee__0__auto__")})
				tmp93 := lang.Apply(tmp84, []any{tmp88, tmp92})
				tmp94 := lang.Apply(tmp81, []any{tmp93})
				tmp95 := lang.Apply(tmp75, []any{tmp78, tmp94})
				tmp96 := lang.Apply(tmp72, []any{tmp95})
				tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
				if tmp98.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
				}
				tmp99 := tmp98.Get()
				tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp101 := tmp100.FindInternedVar(lang.NewSymbol("seq"))
				if tmp101.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
				}
				tmp102 := tmp101.Get()
				tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp104 := tmp103.FindInternedVar(lang.NewSymbol("concat"))
				if tmp104.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
				}
				tmp105 := tmp104.Get()
				tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
				if tmp107.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
				}
				tmp108 := tmp107.Get()
				tmp109 := lang.Apply(tmp108, []any{lang.NewSymbol("monitor-enter")})
				tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp111 := tmp110.FindInternedVar(lang.NewSymbol("list"))
				if tmp111.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
				}
				tmp112 := tmp111.Get()
				tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp114 := lang.Apply(tmp105, []any{tmp109, tmp113})
				tmp115 := lang.Apply(tmp102, []any{tmp114})
				tmp116 := lang.Apply(tmp99, []any{tmp115})
				tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp118 := tmp117.FindInternedVar(lang.NewSymbol("list"))
				if tmp118.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
				}
				tmp119 := tmp118.Get()
				tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp121 := tmp120.FindInternedVar(lang.NewSymbol("seq"))
				if tmp121.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
				}
				tmp122 := tmp121.Get()
				tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp124 := tmp123.FindInternedVar(lang.NewSymbol("concat"))
				if tmp124.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
				}
				tmp125 := tmp124.Get()
				tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
				if tmp127.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
				}
				tmp128 := tmp127.Get()
				tmp129 := lang.Apply(tmp128, []any{lang.NewSymbol("try")})
				tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
				if tmp131.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
				}
				tmp132 := tmp131.Get()
				tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp134 := tmp133.FindInternedVar(lang.NewSymbol("seq"))
				if tmp134.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
				}
				tmp135 := tmp134.Get()
				tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp137 := tmp136.FindInternedVar(lang.NewSymbol("concat"))
				if tmp137.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
				}
				tmp138 := tmp137.Get()
				tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp140 := tmp139.FindInternedVar(lang.NewSymbol("list"))
				if tmp140.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
				}
				tmp141 := tmp140.Get()
				tmp142 := lang.Apply(tmp141, []any{lang.NewSymbol("finally")})
				tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
				if tmp144.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
				}
				tmp145 := tmp144.Get()
				tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp147 := tmp146.FindInternedVar(lang.NewSymbol("seq"))
				if tmp147.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
				}
				tmp148 := tmp147.Get()
				tmp149 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp150 := tmp149.FindInternedVar(lang.NewSymbol("concat"))
				if tmp150.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp150)))
				}
				tmp151 := tmp150.Get()
				tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp153 := tmp152.FindInternedVar(lang.NewSymbol("list"))
				if tmp153.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
				}
				tmp154 := tmp153.Get()
				tmp155 := lang.Apply(tmp154, []any{lang.NewSymbol("monitor-exit")})
				tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp157 := tmp156.FindInternedVar(lang.NewSymbol("list"))
				if tmp157.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
				}
				tmp158 := tmp157.Get()
				tmp159 := lang.Apply(tmp158, []any{lang.NewSymbol("locklocal__1__auto__")})
				tmp160 := lang.Apply(tmp151, []any{tmp155, tmp159})
				tmp161 := lang.Apply(tmp148, []any{tmp160})
				tmp162 := lang.Apply(tmp145, []any{tmp161})
				tmp163 := lang.Apply(tmp138, []any{tmp142, tmp162})
				tmp164 := lang.Apply(tmp135, []any{tmp163})
				tmp165 := lang.Apply(tmp132, []any{tmp164})
				tmp166 := lang.Apply(tmp125, []any{tmp129, v6, tmp165})
				tmp167 := lang.Apply(tmp122, []any{tmp166})
				tmp168 := lang.Apply(tmp119, []any{tmp167})
				tmp169 := lang.Apply(tmp65, []any{tmp69, tmp96, tmp116, tmp168})
				tmp170 := lang.Apply(tmp62, []any{tmp169})
				tmp171 := lang.Apply(tmp59, []any{tmp170})
				tmp172 := lang.Apply(tmp52, []any{tmp56, tmp171})
				tmp173 := lang.Apply(tmp49, []any{tmp172})
				tmp174 := lang.Apply(tmp46, []any{tmp173})
				tmp175 := lang.Apply(tmp12, []any{tmp16, tmp43, tmp174})
				tmp176 := lang.Apply(tmp9, []any{tmp175})
				return tmp176
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long
	{
		var tmp1 lang.FnFunc
		{ // function long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/LongCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to long", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3481), lang.NewKeyword("end-line"), int(3481))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.LongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// long-array
	{
		var tmp1 lang.FnFunc
		{ // function long-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/LongArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("long-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of longs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5364), lang.NewKeyword("end-line"), int(5364))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "LongArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "LongArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("LongArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// longs
	{
		var tmp1 lang.FnFunc
		{ // function longs
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Longs")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("longs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to long[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5407), lang.NewKeyword("end-line"), int(5407))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Longs")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Longs is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// loop
	{
		tmp0 := lang.NewSymbol("loop").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", lang.NewKeyword("forms"), lang.NewVector(lang.NewList(lang.NewSymbol("loop"), lang.NewVector(lang.NewSymbol("bindings*")), lang.NewSymbol("exprs*"))), lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4597), lang.NewKeyword("end-line"), int(4597), lang.NewKeyword("special-form"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "db"
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("destructure"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.Apply(tmp58, []any{v5})
					var v60 any = tmp59
					_ = v60
					var tmp61 any
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("="))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.Apply(tmp64, []any{v60, v5})
					if lang.IsTruthy(tmp65) {
						tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp67 := tmp66.FindInternedVar(lang.NewSymbol("seq"))
						if tmp67.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
						}
						tmp68 := tmp67.Get()
						tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp70 := tmp69.FindInternedVar(lang.NewSymbol("concat"))
						if tmp70.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
						}
						tmp71 := tmp70.Get()
						tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp73 := tmp72.FindInternedVar(lang.NewSymbol("list"))
						if tmp73.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
						}
						tmp74 := tmp73.Get()
						tmp75 := lang.Apply(tmp74, []any{lang.NewSymbol("loop*")})
						tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp77 := tmp76.FindInternedVar(lang.NewSymbol("list"))
						if tmp77.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
						}
						tmp78 := tmp77.Get()
						tmp79 := lang.Apply(tmp78, []any{v5})
						tmp80 := lang.Apply(tmp71, []any{tmp75, tmp79, v6})
						tmp81 := lang.Apply(tmp68, []any{tmp80})
						tmp61 = tmp81
					} else {
						var tmp82 any
						{ // let
							// let binding "vs"
							tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp84 := tmp83.FindInternedVar(lang.NewSymbol("take-nth"))
							if tmp84.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
							}
							tmp85 := tmp84.Get()
							tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp87 := tmp86.FindInternedVar(lang.NewSymbol("drop"))
							if tmp87.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
							}
							tmp88 := tmp87.Get()
							tmp89 := lang.Apply(tmp88, []any{int64(1), v5})
							tmp90 := lang.Apply(tmp85, []any{int64(2), tmp89})
							var v91 any = tmp90
							_ = v91
							// let binding "bs"
							tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp93 := tmp92.FindInternedVar(lang.NewSymbol("take-nth"))
							if tmp93.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
							}
							tmp94 := tmp93.Get()
							tmp95 := lang.Apply(tmp94, []any{int64(2), v5})
							var v96 any = tmp95
							_ = v96
							// let binding "gs"
							tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp98 := tmp97.FindInternedVar(lang.NewSymbol("map"))
							if tmp98.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
							}
							tmp99 := tmp98.Get()
							var tmp100 lang.FnFunc
							tmp100 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v101 := args[0]
								_ = v101
								var tmp102 any
								tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp104 := tmp103.FindInternedVar(lang.NewSymbol("symbol?"))
								if tmp104.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
								}
								tmp105 := tmp104.Get()
								tmp106 := lang.Apply(tmp105, []any{v101})
								if lang.IsTruthy(tmp106) {
									tmp102 = v101
								} else {
									tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp108 := tmp107.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp108.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
									}
									tmp109 := tmp108.Get()
									tmp110 := lang.Apply(tmp109, nil)
									tmp102 = tmp110
								}
								return tmp102
							})
							tmp101 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4611), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(4611), lang.NewKeyword("end-column"), int(58))
							tmp102, err := lang.WithMeta(tmp100, tmp101.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp103 := lang.Apply(tmp99, []any{tmp102, v96})
							var v104 any = tmp103
							_ = v104
							// let binding "bfs"
							tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp106 := tmp105.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp106.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
							}
							tmp107 := tmp106.Get()
							var tmp108 lang.FnFunc
							tmp108 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v109 := args[0]
								_ = v109
								v110 := args[1]
								_ = v110
								var tmp111 any
								{ // let
									// let binding "vec__17"
									var v112 any = v110
									_ = v112
									// let binding "b"
									tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp114 := tmp113.FindInternedVar(lang.NewSymbol("nth"))
									if tmp114.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
									}
									tmp115 := tmp114.Get()
									tmp116 := lang.Apply(tmp115, []any{v112, int64(0), nil})
									var v117 any = tmp116
									_ = v117
									// let binding "v"
									tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp119 := tmp118.FindInternedVar(lang.NewSymbol("nth"))
									if tmp119.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
									}
									tmp120 := tmp119.Get()
									tmp121 := lang.Apply(tmp120, []any{v112, int64(1), nil})
									var v122 any = tmp121
									_ = v122
									// let binding "g"
									tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp124 := tmp123.FindInternedVar(lang.NewSymbol("nth"))
									if tmp124.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
									}
									tmp125 := tmp124.Get()
									tmp126 := lang.Apply(tmp125, []any{v112, int64(2), nil})
									var v127 any = tmp126
									_ = v127
									var tmp128 any
									tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp130 := tmp129.FindInternedVar(lang.NewSymbol("symbol?"))
									if tmp130.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
									}
									tmp131 := tmp130.Get()
									tmp132 := lang.Apply(tmp131, []any{v117})
									if lang.IsTruthy(tmp132) {
										tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp134 := tmp133.FindInternedVar(lang.NewSymbol("conj"))
										if tmp134.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
										}
										tmp135 := tmp134.Get()
										tmp136 := lang.Apply(tmp135, []any{v109, v127, v122})
										tmp128 = tmp136
									} else {
										tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp138 := tmp137.FindInternedVar(lang.NewSymbol("conj"))
										if tmp138.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
										}
										tmp139 := tmp138.Get()
										tmp140 := lang.Apply(tmp139, []any{v109, v127, v122, v117, v127})
										tmp128 = tmp140
									}
									tmp111 = tmp128
								} // end let
								return tmp111
							})
							tmp109 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4612), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(4615), lang.NewKeyword("end-column"), int(50))
							tmp110, err := lang.WithMeta(tmp108, tmp109.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp111 := lang.NewVector()
							tmp112 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4616), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(4616), lang.NewKeyword("end-column"), int(28))
							tmp113, err := lang.WithMeta(tmp111, tmp112.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp114 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp115 := tmp114.FindInternedVar(lang.NewSymbol("map"))
							if tmp115.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp115)))
							}
							tmp116 := tmp115.Get()
							tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp118 := tmp117.FindInternedVar(lang.NewSymbol("vector"))
							if tmp118.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
							}
							tmp119 := tmp118.Get()
							tmp120 := lang.Apply(tmp116, []any{tmp119, v96, v91, v104})
							tmp121 := lang.Apply(tmp107, []any{tmp110, tmp113, tmp120})
							var v122 any = tmp121
							_ = v122
							tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp124 := tmp123.FindInternedVar(lang.NewSymbol("seq"))
							if tmp124.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
							}
							tmp125 := tmp124.Get()
							tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp127 := tmp126.FindInternedVar(lang.NewSymbol("concat"))
							if tmp127.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
							}
							tmp128 := tmp127.Get()
							tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp130 := tmp129.FindInternedVar(lang.NewSymbol("list"))
							if tmp130.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
							}
							tmp131 := tmp130.Get()
							tmp132 := lang.Apply(tmp131, []any{lang.NewSymbol("glojure.core/let")})
							tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp134 := tmp133.FindInternedVar(lang.NewSymbol("list"))
							if tmp134.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
							}
							tmp135 := tmp134.Get()
							tmp136 := lang.Apply(tmp135, []any{v122})
							tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp138 := tmp137.FindInternedVar(lang.NewSymbol("list"))
							if tmp138.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
							}
							tmp139 := tmp138.Get()
							tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp141 := tmp140.FindInternedVar(lang.NewSymbol("seq"))
							if tmp141.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
							}
							tmp142 := tmp141.Get()
							tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp144 := tmp143.FindInternedVar(lang.NewSymbol("concat"))
							if tmp144.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
							}
							tmp145 := tmp144.Get()
							tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
							if tmp147.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
							}
							tmp148 := tmp147.Get()
							tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("loop*")})
							tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp151 := tmp150.FindInternedVar(lang.NewSymbol("list"))
							if tmp151.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
							}
							tmp152 := tmp151.Get()
							tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp154 := tmp153.FindInternedVar(lang.NewSymbol("vec"))
							if tmp154.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
							}
							tmp155 := tmp154.Get()
							tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp157 := tmp156.FindInternedVar(lang.NewSymbol("interleave"))
							if tmp157.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
							}
							tmp158 := tmp157.Get()
							tmp159 := lang.Apply(tmp158, []any{v104, v104})
							tmp160 := lang.Apply(tmp155, []any{tmp159})
							tmp161 := lang.Apply(tmp152, []any{tmp160})
							tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp163 := tmp162.FindInternedVar(lang.NewSymbol("list"))
							if tmp163.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
							}
							tmp164 := tmp163.Get()
							tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp166 := tmp165.FindInternedVar(lang.NewSymbol("seq"))
							if tmp166.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
							}
							tmp167 := tmp166.Get()
							tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp169 := tmp168.FindInternedVar(lang.NewSymbol("concat"))
							if tmp169.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
							}
							tmp170 := tmp169.Get()
							tmp171 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp172 := tmp171.FindInternedVar(lang.NewSymbol("list"))
							if tmp172.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp172)))
							}
							tmp173 := tmp172.Get()
							tmp174 := lang.Apply(tmp173, []any{lang.NewSymbol("glojure.core/let")})
							tmp175 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp176 := tmp175.FindInternedVar(lang.NewSymbol("list"))
							if tmp176.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp176)))
							}
							tmp177 := tmp176.Get()
							tmp178 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp179 := tmp178.FindInternedVar(lang.NewSymbol("vec"))
							if tmp179.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp179)))
							}
							tmp180 := tmp179.Get()
							tmp181 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp182 := tmp181.FindInternedVar(lang.NewSymbol("interleave"))
							if tmp182.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp182)))
							}
							tmp183 := tmp182.Get()
							tmp184 := lang.Apply(tmp183, []any{v96, v104})
							tmp185 := lang.Apply(tmp180, []any{tmp184})
							tmp186 := lang.Apply(tmp177, []any{tmp185})
							tmp187 := lang.Apply(tmp170, []any{tmp174, tmp186, v6})
							tmp188 := lang.Apply(tmp167, []any{tmp187})
							tmp189 := lang.Apply(tmp164, []any{tmp188})
							tmp190 := lang.Apply(tmp145, []any{tmp149, tmp161, tmp189})
							tmp191 := lang.Apply(tmp142, []any{tmp190})
							tmp192 := lang.Apply(tmp139, []any{tmp191})
							tmp193 := lang.Apply(tmp128, []any{tmp132, tmp136, tmp192})
							tmp194 := lang.Apply(tmp125, []any{tmp193})
							tmp82 = tmp194
						} // end let
						tmp61 = tmp82
					}
					tmp55 = tmp61
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand
	{
		tmp0 := lang.NewSymbol("macroexpand").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4025), lang.NewKeyword("end-line"), int(4025))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ex"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("macroexpand-1"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("identical?"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v9, v3})
				if lang.IsTruthy(tmp14) {
					tmp10 = v3
				} else {
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("macroexpand"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v9})
					tmp10 = tmp18
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// macroexpand-1
	{
		tmp0 := lang.NewSymbol("macroexpand-1").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"))), lang.NewKeyword("doc"), "If form represents a macro form, returns its expansion,\n  else returns form.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4017), lang.NewKeyword("end-line"), int(4017))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.Compiler, "macroexpand1")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("macroexpand1 is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-array
	{
		tmp0 := lang.NewSymbol("make-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("len")), lang.NewVector(lang.NewSymbol("type"), lang.NewSymbol("dim"), lang.NewSymbol("&"), lang.NewSymbol("more-dims"))), lang.NewKeyword("doc"), "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3985), lang.NewKeyword("end-line"), int(3985))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("int"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v4})
				tmp9, _ := lang.FieldOrMethod(nil, "newInstance")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{v3, tmp8})
				return tmp10
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "dims"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("cons"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v4, v5})
					var v11 any = tmp10
					_ = v11
					// let binding "dimarray"
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("make-array"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15, ok := lang.FieldOrMethod(nil, "TYPE")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "TYPE")))
					}
					var tmp16 any
					switch reflect.TypeOf(tmp15).Kind() {
					case reflect.Func:
						tmp16 = lang.Apply(tmp15, nil)
					default:
						tmp16 = tmp15
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("count"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v11})
					tmp21 := lang.Apply(tmp14, []any{tmp16, tmp20})
					var v22 any = tmp21
					_ = v22
					var tmp23 any
					{ // let
						// let binding "n__0__auto__"
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("long"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("alength"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{v22})
						tmp31 := lang.Apply(tmp26, []any{tmp30})
						var v32 any = tmp31
						_ = v32
						var tmp33 any
						{ // let
							// let binding "i"
							var v34 any = int64(0)
							_ = v34
							for {
								var tmp35 any
								tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp37 := tmp36.FindInternedVar(lang.NewSymbol("<"))
								if tmp37.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
								}
								tmp38 := tmp37.Get()
								tmp39 := lang.Apply(tmp38, []any{v34, v32})
								if lang.IsTruthy(tmp39) {
									tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp41 := tmp40.FindInternedVar(lang.NewSymbol("aset-int"))
									if tmp41.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
									}
									tmp42 := tmp41.Get()
									tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp44 := tmp43.FindInternedVar(lang.NewSymbol("nth"))
									if tmp44.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
									}
									tmp45 := tmp44.Get()
									tmp46 := lang.Apply(tmp45, []any{v11, v34})
									tmp47 := lang.Apply(tmp42, []any{v22, v34, tmp46})
									_ = tmp47
									tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp50 := tmp49.FindInternedVar(lang.NewSymbol("unchecked-inc"))
									if tmp50.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
									}
									tmp51 := tmp50.Get()
									tmp52 := lang.Apply(tmp51, []any{v34})
									var tmp48 any = tmp52
									v34 = tmp48
									continue
								} else {
								}
								tmp33 = tmp35
								break
							}
						} // end let
						tmp23 = tmp33
					} // end let
					_ = tmp23
					tmp24, _ := lang.FieldOrMethod(nil, "newInstance")
					if reflect.TypeOf(tmp24).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("newInstance is not a function")))
					}
					tmp25 := lang.Apply(tmp24, []any{v3, v22})
					tmp6 = tmp25
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// make-hierarchy
	{
		tmp0 := lang.NewSymbol("make-hierarchy").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Creates a hierarchy object for use with derive, isa? etc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5507), lang.NewKeyword("end-line"), int(5507))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.NewMap()
			tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(17))
			tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp6 := lang.NewMap()
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(32), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(33))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp9 := lang.NewMap()
			tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(47))
			tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp12 := lang.NewMap(lang.NewKeyword("parents"), tmp5, lang.NewKeyword("descendants"), tmp8, lang.NewKeyword("ancestors"), tmp11)
			tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5511), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(5511), lang.NewKeyword("end-column"), int(48))
			tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp14
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map
	{
		tmp0 := lang.NewSymbol("map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2719), lang.NewKeyword("end-line"), int(2719))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							tmp9 := lang.Apply(v3, []any{v8})
							tmp10 := lang.Apply(v5, []any{v7, tmp9})
							return tmp10
						default:
							if len(args) < 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var v9 any = lang.NewList(args[2:]...)
							_ = v9
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							tmp13 := lang.Apply(tmp12, []any{v3, v8, v9})
							tmp14 := lang.Apply(v5, []any{v7, tmp13})
							return tmp14
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2730), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2736), lang.NewKeyword("end-column"), int(47))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2729), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2736), lang.NewKeyword("end-column"), int(48))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("chunked-seq?"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v14})
								if lang.IsTruthy(tmp19) {
									var tmp20 any
									{ // let
										// let binding "c"
										tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp22 := tmp21.FindInternedVar(lang.NewSymbol("chunk-first"))
										if tmp22.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
										}
										tmp23 := tmp22.Get()
										tmp24 := lang.Apply(tmp23, []any{v14})
										var v25 any = tmp24
										_ = v25
										// let binding "size"
										tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp27 := tmp26.FindInternedVar(lang.NewSymbol("int"))
										if tmp27.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
										}
										tmp28 := tmp27.Get()
										tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp30 := tmp29.FindInternedVar(lang.NewSymbol("count"))
										if tmp30.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
										}
										tmp31 := tmp30.Get()
										tmp32 := lang.Apply(tmp31, []any{v25})
										tmp33 := lang.Apply(tmp28, []any{tmp32})
										var v34 any = tmp33
										_ = v34
										// let binding "b"
										tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp36 := tmp35.FindInternedVar(lang.NewSymbol("chunk-buffer"))
										if tmp36.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
										}
										tmp37 := tmp36.Get()
										tmp38 := lang.Apply(tmp37, []any{v34})
										var v39 any = tmp38
										_ = v39
										var tmp40 any
										{ // let
											// let binding "n__0__auto__"
											tmp41 := lang.Apply(lang.LongCast, []any{v34})
											var v42 any = tmp41
											_ = v42
											var tmp43 any
											{ // let
												// let binding "i"
												var v44 any = int64(0)
												_ = v44
												for {
													var tmp45 any
													tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp47 := tmp46.FindInternedVar(lang.NewSymbol("<"))
													if tmp47.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
													}
													tmp48 := tmp47.Get()
													tmp49 := lang.Apply(tmp48, []any{v44, v42})
													if lang.IsTruthy(tmp49) {
														tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp51 := tmp50.FindInternedVar(lang.NewSymbol("chunk-append"))
														if tmp51.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
														}
														tmp52 := tmp51.Get()
														tmp53, _ := lang.FieldOrMethod(v25, "nth")
														if reflect.TypeOf(tmp53).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
														}
														tmp54 := lang.Apply(tmp53, []any{v44})
														tmp55 := lang.Apply(v3, []any{tmp54})
														tmp56 := lang.Apply(tmp52, []any{v39, tmp55})
														_ = tmp56
														tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp59 := tmp58.FindInternedVar(lang.NewSymbol("unchecked-inc"))
														if tmp59.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
														}
														tmp60 := tmp59.Get()
														tmp61 := lang.Apply(tmp60, []any{v44})
														var tmp57 any = tmp61
														v44 = tmp57
														continue
													} else {
													}
													tmp43 = tmp45
													break
												}
											} // end let
											tmp40 = tmp43
										} // end let
										_ = tmp40
										tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp42 := tmp41.FindInternedVar(lang.NewSymbol("chunk-cons"))
										if tmp42.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
										}
										tmp43 := tmp42.Get()
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("chunk"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.Apply(tmp46, []any{v39})
										tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp49 := tmp48.FindInternedVar(lang.NewSymbol("map"))
										if tmp49.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
										}
										tmp50 := tmp49.Get()
										tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp52 := tmp51.FindInternedVar(lang.NewSymbol("chunk-rest"))
										if tmp52.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
										}
										tmp53 := tmp52.Get()
										tmp54 := lang.Apply(tmp53, []any{v14})
										tmp55 := lang.Apply(tmp50, []any{v3, tmp54})
										tmp56 := lang.Apply(tmp43, []any{tmp47, tmp55})
										tmp20 = tmp56
									} // end let
									tmp15 = tmp20
								} else {
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("cons"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("first"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v14})
									tmp28 := lang.Apply(v3, []any{tmp27})
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("map"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("rest"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v14})
									tmp36 := lang.Apply(tmp31, []any{v3, tmp35})
									tmp37 := lang.Apply(tmp23, []any{tmp28, tmp36})
									tmp15 = tmp37
								}
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "s1"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v4})
						var v12 any = tmp11
						_ = v12
						// let binding "s2"
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v5})
						var v17 any = tmp16
						_ = v17
						var tmp18 any
						var tmp19 any
						{ // let
							// let binding "and__0__auto__"
							var v20 any = v12
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								tmp21 = v17
							} else {
								tmp21 = v20
							}
							tmp19 = tmp21
						} // end let
						if lang.IsTruthy(tmp19) {
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("cons"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.Apply(tmp25, []any{v12})
							tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp28 := tmp27.FindInternedVar(lang.NewSymbol("first"))
							if tmp28.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
							}
							tmp29 := tmp28.Get()
							tmp30 := lang.Apply(tmp29, []any{v17})
							tmp31 := lang.Apply(v3, []any{tmp26, tmp30})
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("map"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("rest"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							tmp38 := lang.Apply(tmp37, []any{v12})
							tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp40 := tmp39.FindInternedVar(lang.NewSymbol("rest"))
							if tmp40.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
							}
							tmp41 := tmp40.Get()
							tmp42 := lang.Apply(tmp41, []any{v17})
							tmp43 := lang.Apply(tmp34, []any{v3, tmp38, tmp42})
							tmp44 := lang.Apply(tmp22, []any{tmp31, tmp43})
							tmp18 = tmp44
						} else {
						}
						tmp7 = tmp18
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "s1"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v4})
						var v13 any = tmp12
						_ = v13
						// let binding "s2"
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("seq"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v5})
						var v18 any = tmp17
						_ = v18
						// let binding "s3"
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v6})
						var v23 any = tmp22
						_ = v23
						var tmp24 any
						var tmp25 any
						{ // let
							// let binding "and__0__auto__"
							var v26 any = v13
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								var tmp28 any
								{ // let
									// let binding "and__0__auto__"
									var v29 any = v18
									_ = v29
									var tmp30 any
									if lang.IsTruthy(v29) {
										tmp30 = v23
									} else {
										tmp30 = v29
									}
									tmp28 = tmp30
								} // end let
								tmp27 = tmp28
							} else {
								tmp27 = v26
							}
							tmp25 = tmp27
						} // end let
						if lang.IsTruthy(tmp25) {
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("cons"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v13})
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("first"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.Apply(tmp35, []any{v18})
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("first"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.Apply(tmp39, []any{v23})
							tmp41 := lang.Apply(v3, []any{tmp32, tmp36, tmp40})
							tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp43 := tmp42.FindInternedVar(lang.NewSymbol("map"))
							if tmp43.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
							}
							tmp44 := tmp43.Get()
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("rest"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.Apply(tmp47, []any{v13})
							tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp50 := tmp49.FindInternedVar(lang.NewSymbol("rest"))
							if tmp50.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
							}
							tmp51 := tmp50.Get()
							tmp52 := lang.Apply(tmp51, []any{v18})
							tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp54 := tmp53.FindInternedVar(lang.NewSymbol("rest"))
							if tmp54.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
							}
							tmp55 := tmp54.Get()
							tmp56 := lang.Apply(tmp55, []any{v23})
							tmp57 := lang.Apply(tmp44, []any{v3, tmp48, tmp52, tmp56})
							tmp58 := lang.Apply(tmp28, []any{tmp41, tmp57})
							tmp24 = tmp58
						} else {
						}
						tmp8 = tmp24
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "step"
					var tmp9 lang.FnFunc
					{ // function step
						var v10 lang.FnFunc
						tmp9 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v11 := args[0]
							_ = v11
							var tmp12 lang.FnFunc
							tmp12 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp13 any
								{ // let
									// let binding "ss"
									tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp15 := tmp14.FindInternedVar(lang.NewSymbol("map"))
									if tmp15.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
									}
									tmp16 := tmp15.Get()
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.Apply(tmp16, []any{tmp19, v11})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp24 := tmp23.FindInternedVar(lang.NewSymbol("every?"))
									if tmp24.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
									}
									tmp25 := tmp24.Get()
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("identity"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29 := lang.Apply(tmp25, []any{tmp28, v21})
									if lang.IsTruthy(tmp29) {
										tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp31 := tmp30.FindInternedVar(lang.NewSymbol("cons"))
										if tmp31.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
										}
										tmp32 := tmp31.Get()
										tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp34 := tmp33.FindInternedVar(lang.NewSymbol("map"))
										if tmp34.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
										}
										tmp35 := tmp34.Get()
										tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp37 := tmp36.FindInternedVar(lang.NewSymbol("first"))
										if tmp37.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
										}
										tmp38 := tmp37.Get()
										tmp39 := lang.Apply(tmp35, []any{tmp38, v21})
										tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp41 := tmp40.FindInternedVar(lang.NewSymbol("map"))
										if tmp41.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
										}
										tmp42 := tmp41.Get()
										tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp44 := tmp43.FindInternedVar(lang.NewSymbol("rest"))
										if tmp44.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
										}
										tmp45 := tmp44.Get()
										tmp46 := lang.Apply(tmp42, []any{tmp45, v21})
										tmp47 := lang.Apply(v10, []any{tmp46})
										tmp48 := lang.Apply(tmp32, []any{tmp39, tmp47})
										tmp22 = tmp48
									} else {
									}
									tmp13 = tmp22
								} // end let
								return tmp13
							})
							tmp13 := lang.Apply(lang.NewLazySeq, []any{tmp12})
							return tmp13
						})
						v10 = tmp9
						_ = v10
					}
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2761), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(2765), lang.NewKeyword("end-column"), int(68))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v17 := args[0]
						_ = v17
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("apply"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v3, v17})
						return tmp21
					})
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2766), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(2766), lang.NewKeyword("end-column"), int(22))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("conj"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v7, v6, v5, v4})
					tmp23 := lang.Apply(v12, []any{tmp22})
					tmp24 := lang.Apply(tmp15, []any{tmp18, tmp23})
					tmp8 = tmp24
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-entry?
	{
		tmp0 := lang.NewSymbol("map-entry?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a map entry", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.8", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1473), lang.NewKeyword("end-line"), int(1473))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.MapEntry)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map-indexed
	{
		tmp0 := lang.NewSymbol("map-indexed").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7309), lang.NewKeyword("end-line"), int(7309))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "i"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{int64(-1)})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp16 := tmp15.FindInternedVar(lang.NewSymbol("inc"))
								if tmp16.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
								}
								tmp17 := tmp16.Get()
								tmp18, ok := lang.FieldOrMethod(v11, "Deref")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
								}
								var tmp19 any
								switch reflect.TypeOf(tmp18).Kind() {
								case reflect.Func:
									tmp19 = lang.Apply(tmp18, nil)
								default:
									tmp19 = tmp18
								}
								tmp20 := lang.Apply(tmp17, []any{tmp19})
								tmp21, _ := lang.FieldOrMethod(v11, "reset")
								if reflect.TypeOf(tmp21).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
								}
								tmp22 := lang.Apply(tmp21, []any{tmp20})
								tmp23 := lang.Apply(v3, []any{tmp22, v14})
								tmp24 := lang.Apply(v5, []any{v13, tmp23})
								return tmp24
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7320), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7324), lang.NewKeyword("end-column"), int(48))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7318), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7324), lang.NewKeyword("end-column"), int(50))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// map?
	{
		tmp0 := lang.NewSymbol("map?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements IPersistentMap", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(167), lang.NewKeyword("end-line"), int(171))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function map?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf((*lang.IPersistentMap)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
				return tmp9
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(171), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(171), lang.NewKeyword("end-column"), int(97))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapcat
	{
		tmp0 := lang.NewSymbol("mapcat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2775), lang.NewKeyword("end-line"), int(2775))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("comp"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("map"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("cat"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp6, []any{tmp10, tmp13})
				return tmp14
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("apply"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("apply"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("map"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp13, []any{tmp16, v3, v4})
				tmp18 := lang.Apply(tmp7, []any{tmp10, tmp17})
				return tmp18
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mapv
	{
		tmp0 := lang.NewSymbol("mapv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("c1"), lang.NewSymbol("c2"), lang.NewSymbol("c3"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6943), lang.NewKeyword("end-line"), int(6943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("persistent!"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				var tmp11 lang.FnFunc
				tmp11 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v12 := args[0]
					_ = v12
					v13 := args[1]
					_ = v13
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(v3, []any{v13})
					tmp18 := lang.Apply(tmp16, []any{v12, tmp17})
					return tmp18
				})
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6952), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6952), lang.NewKeyword("end-column"), int(43))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("transient"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.NewVector()
				tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6952), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6952), lang.NewKeyword("end-column"), int(57))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.Apply(tmp16, []any{tmp19})
				tmp21 := lang.Apply(tmp10, []any{tmp13, tmp20, v4})
				tmp22 := lang.Apply(tmp7, []any{tmp21})
				return tmp22
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("into"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.NewVector()
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6955), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6955), lang.NewKeyword("end-column"), int(13))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("map"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3, v4, v5})
				tmp16 := lang.Apply(tmp8, []any{tmp11, tmp15})
				return tmp16
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("into"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.NewVector()
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6957), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6957), lang.NewKeyword("end-column"), int(13))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4, v5, v6})
				tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16})
				return tmp17
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("into"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.NewVector()
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6959), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(6959), lang.NewKeyword("end-column"), int(13))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("apply"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("map"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp16, []any{tmp19, v3, v4, v5, v6, v7})
				tmp21 := lang.Apply(tmp10, []any{tmp13, tmp20})
				return tmp21
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed14
					} else {
						tmp4 = closed14
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed14
					} else {
						tmp5 = closed14
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed14
					} else {
						tmp6 = closed14
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("max").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the greatest of the nums.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1108), lang.NewKeyword("end-line"), int(1108))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Max")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Max is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("max"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("max"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-key
	{
		tmp0 := lang.NewSymbol("max-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5013), lang.NewKeyword("end-line"), int(5013))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol(">"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(v3, []any{v4})
				tmp11 := lang.Apply(v3, []any{v5})
				tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11})
				if lang.IsTruthy(tmp12) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__55"
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol(">"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v9, v11})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.NewVector(v4, v9)
						tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5023), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(5023), lang.NewKeyword("end-column"), int(36))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp19
					} else {
						tmp20 := lang.NewVector(v5, v11)
						tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5023), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(5023), lang.NewKeyword("end-column"), int(43))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp22
					}
					var v23 any = tmp12
					_ = v23
					// let binding "v"
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("nth"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v23, int64(0), nil})
					var v28 any = tmp27
					_ = v28
					// let binding "kv"
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("nth"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{v23, int64(1), nil})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					{ // let
						// let binding "v"
						var v35 any = v28
						_ = v35
						// let binding "kv"
						var v36 any = v33
						_ = v36
						// let binding "more"
						var v37 any = v6
						_ = v37
						for {
							var tmp38 any
							if lang.IsTruthy(v37) {
								var tmp39 any
								{ // let
									// let binding "w"
									tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
									if tmp41.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
									}
									tmp42 := tmp41.Get()
									tmp43 := lang.Apply(tmp42, []any{v37})
									var v44 any = tmp43
									_ = v44
									// let binding "kw"
									tmp45 := lang.Apply(v3, []any{v44})
									var v46 any = tmp45
									_ = v46
									var tmp47 any
									tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp49 := tmp48.FindInternedVar(lang.NewSymbol(">="))
									if tmp49.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
									}
									tmp50 := tmp49.Get()
									tmp51 := lang.Apply(tmp50, []any{v46, v36})
									if lang.IsTruthy(tmp51) {
										var tmp52 any = v44
										var tmp53 any = v46
										tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp56 := tmp55.FindInternedVar(lang.NewSymbol("next"))
										if tmp56.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
										}
										tmp57 := tmp56.Get()
										tmp58 := lang.Apply(tmp57, []any{v37})
										var tmp54 any = tmp58
										v35 = tmp52
										v36 = tmp53
										v37 = tmp54
										continue
									} else {
										var tmp59 any = v35
										var tmp60 any = v36
										tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp63 := tmp62.FindInternedVar(lang.NewSymbol("next"))
										if tmp63.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
										}
										tmp64 := tmp63.Get()
										tmp65 := lang.Apply(tmp64, []any{v37})
										var tmp61 any = tmp65
										v35 = tmp59
										v36 = tmp60
										v37 = tmp61
										continue
									}
									tmp39 = tmp47
								} // end let
								tmp38 = tmp39
							} else {
								tmp38 = v35
							}
							tmp34 = tmp38
							break
						}
					} // end let
					tmp7 = tmp34
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-mask-bits
	{
		tmp0 := lang.NewSymbol("max-mask-bits").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6601), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6601), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(13), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// max-switch-table-size
	{
		tmp0 := lang.NewSymbol("max-switch-table-size").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6602), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(6602), lang.NewKeyword("end-column"), int(36), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, int64(8192), true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-destructured
	{
		tmp0 := lang.NewSymbol("maybe-destructured").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4514), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(4515), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("params"), lang.NewSymbol("body"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("every?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("symbol?"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp8, []any{tmp11, v3})
			if lang.IsTruthy(tmp12) {
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("cons"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp5 = tmp16
			} else {
				var tmp17 any
				{ // let
					// let binding "params"
					var v18 any = v3
					_ = v18
					// let binding "new-params"
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.NewVector()
					tmp23 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4520), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(4520), lang.NewKeyword("end-column"), int(35))
					tmp24, err := lang.WithMeta(tmp22, tmp23.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("meta"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.Apply(tmp27, []any{v18})
					tmp29 := lang.Apply(tmp21, []any{tmp24, tmp28})
					var v30 any = tmp29
					_ = v30
					// let binding "lets"
					tmp31 := lang.NewVector()
					tmp32 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4521), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(4521), lang.NewKeyword("end-column"), int(18))
					tmp33, err := lang.WithMeta(tmp31, tmp32.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v34 any = tmp33
					_ = v34
					for {
						var tmp35 any
						if lang.IsTruthy(v18) {
							var tmp36 any
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("symbol?"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v18})
							tmp44 := lang.Apply(tmp39, []any{tmp43})
							if lang.IsTruthy(tmp44) {
								tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp47 := tmp46.FindInternedVar(lang.NewSymbol("next"))
								if tmp47.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
								}
								tmp48 := tmp47.Get()
								tmp49 := lang.Apply(tmp48, []any{v18})
								var tmp45 any = tmp49
								tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp52 := tmp51.FindInternedVar(lang.NewSymbol("conj"))
								if tmp52.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
								}
								tmp53 := tmp52.Get()
								tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp55 := tmp54.FindInternedVar(lang.NewSymbol("first"))
								if tmp55.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
								}
								tmp56 := tmp55.Get()
								tmp57 := lang.Apply(tmp56, []any{v18})
								tmp58 := lang.Apply(tmp53, []any{v30, tmp57})
								var tmp50 any = tmp58
								var tmp59 any = v34
								v18 = tmp45
								v30 = tmp50
								v34 = tmp59
								continue
							} else {
								var tmp60 any
								{ // let
									// let binding "gparam"
									tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp62 := tmp61.FindInternedVar(lang.NewSymbol("gensym"))
									if tmp62.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
									}
									tmp63 := tmp62.Get()
									tmp64 := lang.Apply(tmp63, []any{"p__"})
									var v65 any = tmp64
									_ = v65
									tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp68 := tmp67.FindInternedVar(lang.NewSymbol("next"))
									if tmp68.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
									}
									tmp69 := tmp68.Get()
									tmp70 := lang.Apply(tmp69, []any{v18})
									var tmp66 any = tmp70
									tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp73 := tmp72.FindInternedVar(lang.NewSymbol("conj"))
									if tmp73.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
									}
									tmp74 := tmp73.Get()
									tmp75 := lang.Apply(tmp74, []any{v30, v65})
									var tmp71 any = tmp75
									tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp78 := tmp77.FindInternedVar(lang.NewSymbol("conj"))
									if tmp78.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
									}
									tmp79 := tmp78.Get()
									tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp81 := tmp80.FindInternedVar(lang.NewSymbol("conj"))
									if tmp81.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
									}
									tmp82 := tmp81.Get()
									tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp84 := tmp83.FindInternedVar(lang.NewSymbol("first"))
									if tmp84.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
									}
									tmp85 := tmp84.Get()
									tmp86 := lang.Apply(tmp85, []any{v18})
									tmp87 := lang.Apply(tmp82, []any{v34, tmp86})
									tmp88 := lang.Apply(tmp79, []any{tmp87, v65})
									var tmp76 any = tmp88
									v18 = tmp66
									v30 = tmp71
									v34 = tmp76
									continue
								} // end let
								tmp36 = tmp60
							}
							tmp35 = tmp36
						} else {
							tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp62 := tmp61.FindInternedVar(lang.NewSymbol("seq"))
							if tmp62.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
							}
							tmp63 := tmp62.Get()
							tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp65 := tmp64.FindInternedVar(lang.NewSymbol("concat"))
							if tmp65.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
							}
							tmp66 := tmp65.Get()
							tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp68 := tmp67.FindInternedVar(lang.NewSymbol("list"))
							if tmp68.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
							}
							tmp69 := tmp68.Get()
							tmp70 := lang.Apply(tmp69, []any{v30})
							tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
							if tmp72.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
							}
							tmp73 := tmp72.Get()
							tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq"))
							if tmp75.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
							}
							tmp76 := tmp75.Get()
							tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp78 := tmp77.FindInternedVar(lang.NewSymbol("concat"))
							if tmp78.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
							}
							tmp79 := tmp78.Get()
							tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
							if tmp81.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
							}
							tmp82 := tmp81.Get()
							tmp83 := lang.Apply(tmp82, []any{lang.NewSymbol("glojure.core/let")})
							tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp85 := tmp84.FindInternedVar(lang.NewSymbol("list"))
							if tmp85.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
							}
							tmp86 := tmp85.Get()
							tmp87 := lang.Apply(tmp86, []any{v34})
							tmp88 := lang.Apply(tmp79, []any{tmp83, tmp87, v4})
							tmp89 := lang.Apply(tmp76, []any{tmp88})
							tmp90 := lang.Apply(tmp73, []any{tmp89})
							tmp91 := lang.Apply(tmp66, []any{tmp70, tmp90})
							tmp92 := lang.Apply(tmp63, []any{tmp91})
							tmp35 = tmp92
						}
						tmp17 = tmp35
						break
					}
				} // end let
				tmp5 = tmp17
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// maybe-min-hash
	{
		tmp0 := lang.NewSymbol("maybe-min-hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("hashes"))), lang.NewKeyword("doc"), "takes a collection of hashes and returns [shift mask] or nil if none found", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6604), lang.NewKeyword("end-line"), int(6604), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("first"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("filter"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			var tmp10 lang.FnFunc
			tmp10 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v11 := args[0]
				_ = v11
				var tmp12 any
				{ // let
					// let binding "vec__151"
					var v13 any = v11
					_ = v13
					// let binding "s"
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("nth"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v13, int64(0), nil})
					var v18 any = tmp17
					_ = v18
					// let binding "m"
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("nth"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v13, int64(1), nil})
					var v23 any = tmp22
					_ = v23
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("apply"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("distinct?"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("map"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					var tmp33 lang.FnFunc
					tmp33 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v34 := args[0]
						_ = v34
						tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp36 := tmp35.FindInternedVar(lang.NewSymbol("shift-mask"))
						if tmp36.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
						}
						tmp37 := tmp36.Get()
						tmp38 := lang.Apply(tmp37, []any{v18, v23, v34})
						return tmp38
					})
					tmp34 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6609), lang.NewKeyword("column"), int(37), lang.NewKeyword("end-line"), int(6609), lang.NewKeyword("end-column"), int(55))
					tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp36 := lang.Apply(tmp32, []any{tmp35, v3})
					tmp37 := lang.Apply(tmp26, []any{tmp29, tmp36})
					tmp12 = tmp37
				} // end let
				return tmp12
			})
			tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6608), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6609), lang.NewKeyword("end-column"), int(65))
			tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp13 any
			{ // let
				// let binding "iter__0__auto__"
				var tmp14 lang.FnFunc
				{ // function iter__154
					var v15 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v16 := args[0]
						_ = v16
						var tmp17 lang.FnFunc
						tmp17 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							var tmp18 any
							{ // let
								// let binding "s__155"
								var v19 any = v16
								_ = v19
								for {
									var tmp20 any
									{ // let
										// let binding "temp__0__auto__"
										tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
										if tmp22.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
										}
										tmp23 := tmp22.Get()
										tmp24 := lang.Apply(tmp23, []any{v19})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										if lang.IsTruthy(v25) {
											var tmp27 any
											{ // let
												// let binding "xs__0__auto__"
												var v28 any = v25
												_ = v28
												var tmp29 any
												{ // let
													// let binding "mask"
													tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp31 := tmp30.FindInternedVar(lang.NewSymbol("first"))
													if tmp31.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
													}
													tmp32 := tmp31.Get()
													tmp33 := lang.Apply(tmp32, []any{v28})
													var v34 any = tmp33
													_ = v34
													var tmp35 any
													{ // let
														// let binding "iterys__0__auto__"
														var tmp36 lang.FnFunc
														{ // function iter__156
															var v37 lang.FnFunc
															tmp36 = lang.NewFnFunc(func(args ...any) any {
																if len(args) != 1 {
																	panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																}
																v38 := args[0]
																_ = v38
																var tmp39 lang.FnFunc
																tmp39 = lang.NewFnFunc(func(args ...any) any {
																	if len(args) != 0 {
																		panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
																	}
																	var tmp40 any
																	{ // let
																		// let binding "s__157"
																		var v41 any = v38
																		_ = v41
																		for {
																			var tmp42 any
																			{ // let
																				// let binding "temp__0__auto__"
																				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
																				if tmp44.IsMacro() {
																					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
																				}
																				tmp45 := tmp44.Get()
																				tmp46 := lang.Apply(tmp45, []any{v41})
																				var v47 any = tmp46
																				_ = v47
																				var tmp48 any
																				if lang.IsTruthy(v47) {
																					var tmp49 any
																					{ // let
																						// let binding "s__157"
																						var v50 any = v47
																						_ = v50
																						var tmp51 any
																						tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																						tmp53 := tmp52.FindInternedVar(lang.NewSymbol("chunked-seq?"))
																						if tmp53.IsMacro() {
																							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
																						}
																						tmp54 := tmp53.Get()
																						tmp55 := lang.Apply(tmp54, []any{v50})
																						if lang.IsTruthy(tmp55) {
																							var tmp56 any
																							{ // let
																								// let binding "c__0__auto__"
																								tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp58 := tmp57.FindInternedVar(lang.NewSymbol("chunk-first"))
																								if tmp58.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
																								}
																								tmp59 := tmp58.Get()
																								tmp60 := lang.Apply(tmp59, []any{v50})
																								var v61 any = tmp60
																								_ = v61
																								// let binding "size__1__auto__"
																								tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp63 := tmp62.FindInternedVar(lang.NewSymbol("int"))
																								if tmp63.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
																								}
																								tmp64 := tmp63.Get()
																								tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp66 := tmp65.FindInternedVar(lang.NewSymbol("count"))
																								if tmp66.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
																								}
																								tmp67 := tmp66.Get()
																								tmp68 := lang.Apply(tmp67, []any{v61})
																								tmp69 := lang.Apply(tmp64, []any{tmp68})
																								var v70 any = tmp69
																								_ = v70
																								// let binding "b__159"
																								tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp72 := tmp71.FindInternedVar(lang.NewSymbol("chunk-buffer"))
																								if tmp72.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
																								}
																								tmp73 := tmp72.Get()
																								tmp74 := lang.Apply(tmp73, []any{v70})
																								var v75 any = tmp74
																								_ = v75
																								var tmp76 any
																								var tmp77 any
																								{ // let
																									// let binding "i__158"
																									tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp79 := tmp78.FindInternedVar(lang.NewSymbol("int"))
																									if tmp79.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
																									}
																									tmp80 := tmp79.Get()
																									tmp81 := lang.Apply(tmp80, []any{int64(0)})
																									var v82 any = tmp81
																									_ = v82
																									for {
																										var tmp83 any
																										tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																										tmp85 := tmp84.FindInternedVar(lang.NewSymbol("<"))
																										if tmp85.IsMacro() {
																											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
																										}
																										tmp86 := tmp85.Get()
																										tmp87 := lang.Apply(tmp86, []any{v82, v70})
																										if lang.IsTruthy(tmp87) {
																											var tmp88 any
																											{ // let
																												// let binding "shift"
																												tmp89, _ := lang.FieldOrMethod(v61, "nth")
																												if reflect.TypeOf(tmp89).Kind() != reflect.Func {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
																												}
																												tmp90 := lang.Apply(tmp89, []any{v82})
																												var v91 any = tmp90
																												_ = v91
																												tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																												tmp93 := tmp92.FindInternedVar(lang.NewSymbol("chunk-append"))
																												if tmp93.IsMacro() {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
																												}
																												tmp94 := tmp93.Get()
																												tmp95 := lang.NewVector(v91, v34)
																												tmp96 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6612), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6612), lang.NewKeyword("end-column"), int(26))
																												tmp97, err := lang.WithMeta(tmp95, tmp96.(lang.IPersistentMap))
																												if err != nil {
																													panic(err)
																												}
																												tmp98 := lang.Apply(tmp94, []any{v75, tmp97})
																												_ = tmp98
																												tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																												tmp101 := tmp100.FindInternedVar(lang.NewSymbol("unchecked-inc"))
																												if tmp101.IsMacro() {
																													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
																												}
																												tmp102 := tmp101.Get()
																												tmp103 := lang.Apply(tmp102, []any{v82})
																												var tmp99 any = tmp103
																												v82 = tmp99
																												continue
																											} // end let
																											tmp83 = tmp88
																										} else {
																											tmp83 = true
																										}
																										tmp77 = tmp83
																										break
																									}
																								} // end let
																								if lang.IsTruthy(tmp77) {
																									tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp79 := tmp78.FindInternedVar(lang.NewSymbol("chunk-cons"))
																									if tmp79.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
																									}
																									tmp80 := tmp79.Get()
																									tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp82 := tmp81.FindInternedVar(lang.NewSymbol("chunk"))
																									if tmp82.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
																									}
																									tmp83 := tmp82.Get()
																									tmp84 := lang.Apply(tmp83, []any{v75})
																									tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp86 := tmp85.FindInternedVar(lang.NewSymbol("chunk-rest"))
																									if tmp86.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
																									}
																									tmp87 := tmp86.Get()
																									tmp88 := lang.Apply(tmp87, []any{v50})
																									tmp89 := lang.Apply(v37, []any{tmp88})
																									tmp90 := lang.Apply(tmp80, []any{tmp84, tmp89})
																									tmp76 = tmp90
																								} else {
																									tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp92 := tmp91.FindInternedVar(lang.NewSymbol("chunk-cons"))
																									if tmp92.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
																									}
																									tmp93 := tmp92.Get()
																									tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																									tmp95 := tmp94.FindInternedVar(lang.NewSymbol("chunk"))
																									if tmp95.IsMacro() {
																										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
																									}
																									tmp96 := tmp95.Get()
																									tmp97 := lang.Apply(tmp96, []any{v75})
																									tmp98 := lang.Apply(tmp93, []any{tmp97, nil})
																									tmp76 = tmp98
																								}
																								tmp56 = tmp76
																							} // end let
																							tmp51 = tmp56
																						} else {
																							var tmp57 any
																							{ // let
																								// let binding "shift"
																								tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp59 := tmp58.FindInternedVar(lang.NewSymbol("first"))
																								if tmp59.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
																								}
																								tmp60 := tmp59.Get()
																								tmp61 := lang.Apply(tmp60, []any{v50})
																								var v62 any = tmp61
																								_ = v62
																								tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp64 := tmp63.FindInternedVar(lang.NewSymbol("cons"))
																								if tmp64.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
																								}
																								tmp65 := tmp64.Get()
																								tmp66 := lang.NewVector(v62, v34)
																								tmp67 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6612), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6612), lang.NewKeyword("end-column"), int(26))
																								tmp68, err := lang.WithMeta(tmp66, tmp67.(lang.IPersistentMap))
																								if err != nil {
																									panic(err)
																								}
																								tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																								tmp70 := tmp69.FindInternedVar(lang.NewSymbol("rest"))
																								if tmp70.IsMacro() {
																									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
																								}
																								tmp71 := tmp70.Get()
																								tmp72 := lang.Apply(tmp71, []any{v50})
																								tmp73 := lang.Apply(v37, []any{tmp72})
																								tmp74 := lang.Apply(tmp65, []any{tmp68, tmp73})
																								tmp57 = tmp74
																							} // end let
																							tmp51 = tmp57
																						}
																						tmp49 = tmp51
																					} // end let
																					tmp48 = tmp49
																				} else {
																				}
																				tmp42 = tmp48
																			} // end let
																			tmp40 = tmp42
																			break
																		}
																	} // end let
																	return tmp40
																})
																tmp40 := lang.Apply(lang.NewLazySeq, []any{tmp39})
																return tmp40
															})
															v37 = tmp36
															_ = v37
														}
														var v37 any = tmp36
														_ = v37
														// let binding "fs__1__auto__"
														tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
														if tmp39.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
														}
														tmp40 := tmp39.Get()
														tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp42 := tmp41.FindInternedVar(lang.NewSymbol("range"))
														if tmp42.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
														}
														tmp43 := tmp42.Get()
														tmp44 := lang.Apply(tmp43, []any{int64(0), int64(31)})
														tmp45 := lang.Apply(v37, []any{tmp44})
														tmp46 := lang.Apply(tmp40, []any{tmp45})
														var v47 any = tmp46
														_ = v47
														var tmp48 any
														if lang.IsTruthy(v47) {
															tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp50 := tmp49.FindInternedVar(lang.NewSymbol("concat"))
															if tmp50.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
															}
															tmp51 := tmp50.Get()
															tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp53 := tmp52.FindInternedVar(lang.NewSymbol("rest"))
															if tmp53.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
															}
															tmp54 := tmp53.Get()
															tmp55 := lang.Apply(tmp54, []any{v19})
															tmp56 := lang.Apply(v15, []any{tmp55})
															tmp57 := lang.Apply(tmp51, []any{v47, tmp56})
															tmp48 = tmp57
														} else {
															tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp60 := tmp59.FindInternedVar(lang.NewSymbol("rest"))
															if tmp60.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
															}
															tmp61 := tmp60.Get()
															tmp62 := lang.Apply(tmp61, []any{v19})
															var tmp58 any = tmp62
															v19 = tmp58
															continue
														}
														tmp35 = tmp48
													} // end let
													tmp29 = tmp35
												} // end let
												tmp27 = tmp29
											} // end let
											tmp26 = tmp27
										} else {
										}
										tmp20 = tmp26
									} // end let
									tmp18 = tmp20
									break
								}
							} // end let
							return tmp18
						})
						tmp18 := lang.Apply(lang.NewLazySeq, []any{tmp17})
						return tmp18
					})
					v15 = tmp14
					_ = v15
				}
				var v15 any = tmp14
				_ = v15
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("map"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				var tmp19 lang.FnFunc
				tmp19 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v20 := args[0]
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("dec"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("bit-shift-left"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{int64(1), v20})
					tmp28 := lang.Apply(tmp23, []any{tmp27})
					return tmp28
				})
				tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6610), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(6610), lang.NewKeyword("end-column"), int(55))
				tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("range"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("inc"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("max-mask-bits"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp27, []any{tmp30})
				tmp32 := lang.Apply(tmp24, []any{int64(1), tmp31})
				tmp33 := lang.Apply(tmp18, []any{tmp21, tmp32})
				tmp34 := lang.Apply(v15, []any{tmp33})
				tmp13 = tmp34
			} // end let
			tmp14 := lang.Apply(tmp9, []any{tmp12, tmp13})
			tmp15 := lang.Apply(tmp6, []any{tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memfn
	{
		tmp0 := lang.NewSymbol("memfn").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3872), lang.NewKeyword("end-line"), int(3872))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "t"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{"target"})
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("meta"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v5})
					tmp19 := lang.Apply(tmp10, []any{tmp14, tmp18})
					var v20 any = tmp19
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/fn")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("apply"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("vector"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v20})
					tmp50 := lang.Apply(tmp45, []any{tmp49, v6})
					tmp51 := lang.Apply(tmp42, []any{tmp50})
					tmp52 := lang.Apply(tmp36, []any{tmp39, tmp51})
					tmp53 := lang.Apply(tmp33, []any{tmp52})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("list"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("seq"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("concat"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("list"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.Apply(tmp65, []any{lang.NewSymbol(".")})
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("list"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.Apply(tmp69, []any{v20})
					tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
					if tmp72.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
					}
					tmp73 := tmp72.Get()
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("concat"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.Apply(tmp82, []any{v5})
					tmp84 := lang.Apply(tmp79, []any{tmp83, v6})
					tmp85 := lang.Apply(tmp76, []any{tmp84})
					tmp86 := lang.Apply(tmp73, []any{tmp85})
					tmp87 := lang.Apply(tmp62, []any{tmp66, tmp70, tmp86})
					tmp88 := lang.Apply(tmp59, []any{tmp87})
					tmp89 := lang.Apply(tmp56, []any{tmp88})
					tmp90 := lang.Apply(tmp26, []any{tmp30, tmp53, tmp89})
					tmp91 := lang.Apply(tmp23, []any{tmp90})
					tmp7 = tmp91
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// memoize
	{
		tmp0 := lang.NewSymbol("memoize").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6337), lang.NewKeyword("end-line"), int(6337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "mem"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("atom"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.NewMap()
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6345), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(6345), lang.NewKeyword("end-column"), int(20))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				var v12 any = tmp11
				_ = v12
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v14 any = lang.NewList(args[0:]...)
						_ = v14
						var tmp15 any
						{ // let
							// let binding "temp__0__auto__"
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("find"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("deref"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.Apply(tmp21, []any{v12})
							tmp23 := lang.Apply(tmp18, []any{tmp22, v14})
							var v24 any = tmp23
							_ = v24
							var tmp25 any
							if lang.IsTruthy(v24) {
								var tmp26 any
								{ // let
									// let binding "e"
									var v27 any = v24
									_ = v27
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("val"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.Apply(tmp30, []any{v27})
									tmp26 = tmp31
								} // end let
								tmp25 = tmp26
							} else {
								var tmp27 any
								{ // let
									// let binding "ret"
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("apply"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.Apply(tmp30, []any{v3, v14})
									var v32 any = tmp31
									_ = v32
									tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp34 := tmp33.FindInternedVar(lang.NewSymbol("swap!"))
									if tmp34.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
									}
									tmp35 := tmp34.Get()
									tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp37 := tmp36.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp37.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
									}
									tmp38 := tmp37.Get()
									tmp39 := lang.Apply(tmp35, []any{v12, tmp38, v14, v32})
									_ = tmp39
									tmp27 = v32
								} // end let
								tmp25 = tmp27
							}
							tmp15 = tmp25
						} // end let
						return tmp15
					}
				})
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6346), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6351), lang.NewKeyword("end-column"), int(16))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp15
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge
	{
		tmp0 := lang.NewSymbol("merge").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("maps"))), lang.NewKeyword("doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3040), lang.NewKeyword("end-line"), int(3040))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("some"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("identity"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp7, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					var tmp15 lang.FnFunc
					tmp15 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v16 := args[0]
						_ = v16
						v17 := args[1]
						_ = v17
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("conj"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						var tmp21 any
						{ // let
							// let binding "or__0__auto__"
							var v22 any = v16
							_ = v22
							var tmp23 any
							if lang.IsTruthy(v22) {
								tmp23 = v22
							} else {
								tmp24 := lang.NewMap()
								tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3048), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(3048), lang.NewKeyword("end-column"), int(29))
								tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp23 = tmp26
							}
							tmp21 = tmp23
						} // end let
						tmp22 := lang.Apply(tmp20, []any{tmp21, v17})
						return tmp22
					})
					tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3048), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(3048), lang.NewKeyword("end-column"), int(34))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := lang.Apply(tmp14, []any{tmp17, v3})
					tmp4 = tmp18
				} else {
				}
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-hash-collisions
	{
		tmp0 := lang.NewSymbol("merge-hash-collisions").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr-sym"), lang.NewSymbol("default"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6647), lang.NewKeyword("end-line"), int(6647), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "buckets"
				var tmp8 any
				{ // let
					// let binding "m"
					tmp9 := lang.NewMap()
					tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6661), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(6661), lang.NewKeyword("end-column"), int(27))
					tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v12 any = tmp11
					_ = v12
					// let binding "ks"
					var v13 any = v5
					_ = v13
					// let binding "vs"
					var v14 any = v6
					_ = v14
					for {
						var tmp15 any
						var tmp16 any
						{ // let
							// let binding "and__0__auto__"
							var v17 any = v13
							_ = v17
							var tmp18 any
							if lang.IsTruthy(v17) {
								tmp18 = v14
							} else {
								tmp18 = v17
							}
							tmp16 = tmp18
						} // end let
						if lang.IsTruthy(tmp16) {
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("update"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.Apply(tmp23, []any{v13})
							tmp25 := lang.Apply(lang.Hash, []any{tmp24})
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("fnil"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("conj"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.NewVector()
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6664), lang.NewKeyword("column"), int(102), lang.NewKeyword("end-line"), int(6664), lang.NewKeyword("end-column"), int(103))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp35 := lang.Apply(tmp28, []any{tmp31, tmp34})
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("first"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{v13})
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v14})
							tmp44 := lang.NewVector(tmp39, tmp43)
							tmp45 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6664), lang.NewKeyword("column"), int(106), lang.NewKeyword("end-line"), int(6664), lang.NewKeyword("end-column"), int(128))
							tmp46, err := lang.WithMeta(tmp44, tmp45.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp47 := lang.Apply(tmp20, []any{v12, tmp25, tmp35, tmp46})
							var tmp17 any = tmp47
							tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp50 := tmp49.FindInternedVar(lang.NewSymbol("next"))
							if tmp50.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
							}
							tmp51 := tmp50.Get()
							tmp52 := lang.Apply(tmp51, []any{v13})
							var tmp48 any = tmp52
							tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp55 := tmp54.FindInternedVar(lang.NewSymbol("next"))
							if tmp55.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
							}
							tmp56 := tmp55.Get()
							tmp57 := lang.Apply(tmp56, []any{v14})
							var tmp53 any = tmp57
							v12 = tmp17
							v13 = tmp48
							v14 = tmp53
							continue
						} else {
							tmp15 = v12
						}
						tmp8 = tmp15
						break
					}
				} // end let
				var v9 any = tmp8
				_ = v9
				// let binding "assoc-multi"
				var tmp10 lang.FnFunc
				tmp10 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v11 := args[0]
					_ = v11
					v12 := args[1]
					_ = v12
					v13 := args[2]
					_ = v13
					var tmp14 any
					{ // let
						// let binding "testexprs"
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("mapcat"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						var tmp18 lang.FnFunc
						tmp18 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v19 := args[0]
							_ = v19
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.Apply(tmp25, []any{v19})
							tmp27 := lang.Apply(tmp22, []any{lang.NewSymbol("quote"), tmp26})
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("second"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							tmp31 := lang.Apply(tmp30, []any{v19})
							tmp32 := lang.NewVector(tmp27, tmp31)
							tmp33 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6668), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6668), lang.NewKeyword("end-column"), int(93))
							tmp34, err := lang.WithMeta(tmp32, tmp33.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							return tmp34
						})
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6668), lang.NewKeyword("column"), int(47), lang.NewKeyword("end-line"), int(6668), lang.NewKeyword("end-column"), int(94))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp21 := lang.Apply(tmp17, []any{tmp20, v13})
						var v22 any = tmp21
						_ = v22
						// let binding "expr"
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("concat"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
						if tmp30.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
						}
						tmp31 := tmp30.Get()
						tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/condp")})
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.Apply(tmp35, []any{lang.NewSymbol("glojure.core/=")})
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.Apply(tmp39, []any{v3})
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.Apply(tmp43, []any{v4})
						tmp45 := lang.Apply(tmp28, []any{tmp32, tmp36, tmp40, v22, tmp44})
						tmp46 := lang.Apply(tmp25, []any{tmp45})
						var v47 any = tmp46
						_ = v47
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("assoc"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v11, v12, v47})
						tmp14 = tmp51
					} // end let
					return tmp14
				})
				tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6667), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(6670), lang.NewKeyword("end-column"), int(42))
				tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v13 any = tmp12
				_ = v13
				// let binding "hmap"
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				var tmp17 lang.FnFunc
				tmp17 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v18 := args[0]
					_ = v18
					v19 := args[1]
					_ = v19
					var tmp20 any
					{ // let
						// let binding "vec__164"
						var v21 any = v19
						_ = v21
						// let binding "h"
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("nth"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v21, int64(0), nil})
						var v26 any = tmp25
						_ = v26
						// let binding "bucket"
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("nth"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{v21, int64(1), nil})
						var v31 any = tmp30
						_ = v31
						var tmp32 any
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("=="))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("count"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.Apply(tmp38, []any{v31})
						tmp40 := lang.Apply(tmp35, []any{int64(1), tmp39})
						if lang.IsTruthy(tmp40) {
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("assoc"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("ffirst"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.Apply(tmp46, []any{v31})
							tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp49 := tmp48.FindInternedVar(lang.NewSymbol("second"))
							if tmp49.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
							}
							tmp50 := tmp49.Get()
							tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp52 := tmp51.FindInternedVar(lang.NewSymbol("first"))
							if tmp52.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
							}
							tmp53 := tmp52.Get()
							tmp54 := lang.Apply(tmp53, []any{v31})
							tmp55 := lang.Apply(tmp50, []any{tmp54})
							tmp56 := lang.Apply(tmp43, []any{v18, tmp47, tmp55})
							tmp32 = tmp56
						} else {
							tmp57 := lang.Apply(v13, []any{v18, v26, v31})
							tmp32 = tmp57
						}
						tmp20 = tmp32
					} // end let
					return tmp20
				})
				tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6672), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(6675), lang.NewKeyword("end-column"), int(45))
				tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp20 := lang.NewMap()
				tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6676), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(6676), lang.NewKeyword("end-column"), int(17))
				tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp23 := lang.Apply(tmp16, []any{tmp19, tmp22, v9})
				var v24 any = tmp23
				_ = v24
				// let binding "skip-check"
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("into1"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6680), lang.NewKeyword("column"), int(29), lang.NewKeyword("end-line"), int(6680), lang.NewKeyword("end-column"), int(31))
				tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("map"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
				if tmp35.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
				}
				tmp36 := tmp35.Get()
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("filter"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				var tmp40 lang.FnFunc
				tmp40 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v41 := args[0]
					_ = v41
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("<"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("count"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("second"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v41})
					tmp52 := lang.Apply(tmp47, []any{tmp51})
					tmp53 := lang.Apply(tmp44, []any{int64(1), tmp52})
					return tmp53
				})
				tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6678), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(6678), lang.NewKeyword("end-column"), int(54))
				tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp43 := lang.Apply(tmp39, []any{tmp42, v9})
				tmp44 := lang.Apply(tmp33, []any{tmp36, tmp43})
				tmp45 := lang.Apply(tmp27, []any{tmp30, tmp44})
				var v46 any = tmp45
				_ = v46
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("keys"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.Apply(tmp49, []any{v24})
				tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp52 := tmp51.FindInternedVar(lang.NewSymbol("vals"))
				if tmp52.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
				}
				tmp53 := tmp52.Get()
				tmp54 := lang.Apply(tmp53, []any{v24})
				tmp55 := lang.NewVector(tmp50, tmp54, v46)
				tmp56 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6681), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6681), lang.NewKeyword("end-column"), int(40))
				tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp7 = tmp57
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// merge-with
	{
		tmp0 := lang.NewSymbol("merge-with").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("maps"))), lang.NewKeyword("doc"), "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3050), lang.NewKeyword("end-line"), int(3050))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("some"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("identity"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp8, []any{tmp11, v4})
				if lang.IsTruthy(tmp12) {
					var tmp13 any
					{ // let
						// let binding "merge-entry"
						var tmp14 lang.FnFunc
						tmp14 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v15 := args[0]
							_ = v15
							v16 := args[1]
							_ = v16
							var tmp17 any
							{ // let
								// let binding "k"
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("key"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v16})
								var v22 any = tmp21
								_ = v22
								// let binding "v"
								tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp24 := tmp23.FindInternedVar(lang.NewSymbol("val"))
								if tmp24.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
								}
								tmp25 := tmp24.Get()
								tmp26 := lang.Apply(tmp25, []any{v16})
								var v27 any = tmp26
								_ = v27
								var tmp28 any
								tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp30 := tmp29.FindInternedVar(lang.NewSymbol("contains?"))
								if tmp30.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
								}
								tmp31 := tmp30.Get()
								tmp32 := lang.Apply(tmp31, []any{v15, v22})
								if lang.IsTruthy(tmp32) {
									tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp34 := tmp33.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp34.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
									}
									tmp35 := tmp34.Get()
									tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp37 := tmp36.FindInternedVar(lang.NewSymbol("get"))
									if tmp37.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
									}
									tmp38 := tmp37.Get()
									tmp39 := lang.Apply(tmp38, []any{v15, v22})
									tmp40 := lang.Apply(v3, []any{tmp39, v27})
									tmp41 := lang.Apply(tmp35, []any{v15, v22, tmp40})
									tmp28 = tmp41
								} else {
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									tmp45 := lang.Apply(tmp44, []any{v15, v22, v27})
									tmp28 = tmp45
								}
								tmp17 = tmp28
							} // end let
							return tmp17
						})
						tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3059), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(3063), lang.NewKeyword("end-column"), int(23))
						tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v17 any = tmp16
						_ = v17
						// let binding "merge2"
						var tmp18 lang.FnFunc
						tmp18 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v19 := args[0]
							_ = v19
							v20 := args[1]
							_ = v20
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							var tmp24 any
							{ // let
								// let binding "or__0__auto__"
								var v25 any = v19
								_ = v25
								var tmp26 any
								if lang.IsTruthy(v25) {
									tmp26 = v25
								} else {
									tmp27 := lang.NewMap()
									tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3065), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(3065), lang.NewKeyword("end-column"), int(35))
									tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp26 = tmp29
								}
								tmp24 = tmp26
							} // end let
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v20})
							tmp29 := lang.Apply(tmp23, []any{v17, tmp24, tmp28})
							return tmp29
						})
						tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3064), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(3065), lang.NewKeyword("end-column"), int(47))
						tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v21 any = tmp20
						_ = v21
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("reduce1"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v21, v4})
						tmp13 = tmp25
					} // end let
					tmp5 = tmp13
				} else {
				}
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// meta
	{
		tmp0 := lang.NewSymbol("meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"))), lang.NewKeyword("doc"), "Returns the metadata of obj, returns nil if there is no metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(202), lang.NewKeyword("end-line"), int(206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
				if lang.IsTruthy(tmp10) {
					tmp11, ok := lang.FieldOrMethod(v4, "Meta")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "Meta")))
					}
					var tmp12 any
					switch reflect.TypeOf(tmp11).Kind() {
					case reflect.Func:
						tmp12 = lang.Apply(tmp11, nil)
					default:
						tmp12 = tmp11
					}
					tmp5 = tmp12
				} else {
				}
				return tmp5
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(206), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(208), lang.NewKeyword("end-column"), int(21))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// methods
	{
		tmp0 := lang.NewSymbol("methods").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Given a multimethod, returns a map of dispatch values -> dispatch fns", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1809), lang.NewKeyword("end-line"), int(1809))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getMethodTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMethodTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min
	{
		var tmp1 lang.FnFunc
		tmp1 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v2 := args[0]
				_ = v2
				var tmp3 any
				{ // let
					// let binding "op"
					var tmp4 any
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					if lang.IsTruthy(tmp7) {
						tmp4 = closed15
					} else {
						tmp4 = closed15
					}
					var v8 any = tmp4
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("concat"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol(".")})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
					if tmp33.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
					}
					tmp34 := tmp33.Get()
					tmp35 := lang.Apply(tmp34, []any{v8})
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.Apply(tmp38, []any{v2})
					tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
					tmp41 := lang.Apply(tmp28, []any{tmp40})
					tmp42 := lang.Apply(tmp25, []any{tmp41})
					tmp43 := lang.Apply(tmp14, []any{tmp18, tmp22, tmp42})
					tmp44 := lang.Apply(tmp11, []any{tmp43})
					tmp3 = tmp44
				} // end let
				return tmp3
			case 2:
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var tmp4 any
				{ // let
					// let binding "op"
					var tmp5 any
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					if lang.IsTruthy(tmp8) {
						tmp5 = closed15
					} else {
						tmp5 = closed15
					}
					var v9 any = tmp5
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol(".")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("seq"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("concat"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.Apply(tmp35, []any{v9})
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v2})
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.Apply(tmp32, []any{tmp36, tmp40, tmp44})
					tmp46 := lang.Apply(tmp29, []any{tmp45})
					tmp47 := lang.Apply(tmp26, []any{tmp46})
					tmp48 := lang.Apply(tmp15, []any{tmp19, tmp23, tmp47})
					tmp49 := lang.Apply(tmp12, []any{tmp48})
					tmp4 = tmp49
				} // end let
				return tmp4
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v2 := args[0]
				_ = v2
				v3 := args[1]
				_ = v3
				var v4 any = lang.NewList(args[2:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "op"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					if lang.IsTruthy(tmp9) {
						tmp6 = closed15
					} else {
						tmp6 = closed15
					}
					var v10 any = tmp6
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						v16 := args[1]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v10})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{v15})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{v16})
						tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
						tmp53 := lang.Apply(tmp36, []any{tmp52})
						tmp54 := lang.Apply(tmp33, []any{tmp53})
						tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
						tmp56 := lang.Apply(tmp19, []any{tmp55})
						return tmp56
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v10})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.Apply(tmp46, []any{v2})
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp51})
					tmp53 := lang.Apply(tmp36, []any{tmp52})
					tmp54 := lang.Apply(tmp33, []any{tmp53})
					tmp55 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp54})
					tmp56 := lang.Apply(tmp19, []any{tmp55})
					tmp57 := lang.Apply(tmp13, []any{tmp16, tmp56, v4})
					tmp5 = tmp57
				} // end let
				return tmp5
			}
		})
		tmp1 = tmp1.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))).(lang.FnFunc)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Gt")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Gt is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{nil, int64(1)})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp0 := lang.NewSymbol("min").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the least of the nums.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), tmp2, lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1118), lang.NewKeyword("end-line"), int(1118))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v5 := args[0]
				_ = v5
				return v5
			case 2:
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(lang.Numbers, "Min")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Min is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v5, v6})
				return tmp8
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var v7 any = lang.NewList(args[2:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("reduce1"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("min"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("min"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v5, v6})
				tmp18 := lang.Apply(tmp10, []any{tmp13, tmp17, v7})
				return tmp18
			}
		})
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// min-key
	{
		tmp0 := lang.NewSymbol("min-key").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("k"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5033), lang.NewKeyword("end-line"), int(5033))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return v4
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("<"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(v3, []any{v4})
				tmp11 := lang.Apply(v3, []any{v5})
				tmp12 := lang.Apply(tmp9, []any{tmp10, tmp11})
				if lang.IsTruthy(tmp12) {
					tmp6 = v4
				} else {
					tmp6 = v5
				}
				return tmp6
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "kx"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ky"
					tmp10 := lang.Apply(v3, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "vec__58"
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("<"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v9, v11})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.NewVector(v4, v9)
						tmp18 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5043), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(5043), lang.NewKeyword("end-column"), int(36))
						tmp19, err := lang.WithMeta(tmp17, tmp18.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp19
					} else {
						tmp20 := lang.NewVector(v5, v11)
						tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5043), lang.NewKeyword("column"), int(38), lang.NewKeyword("end-line"), int(5043), lang.NewKeyword("end-column"), int(43))
						tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp12 = tmp22
					}
					var v23 any = tmp12
					_ = v23
					// let binding "v"
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("nth"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v23, int64(0), nil})
					var v28 any = tmp27
					_ = v28
					// let binding "kv"
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("nth"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{v23, int64(1), nil})
					var v33 any = tmp32
					_ = v33
					var tmp34 any
					{ // let
						// let binding "v"
						var v35 any = v28
						_ = v35
						// let binding "kv"
						var v36 any = v33
						_ = v36
						// let binding "more"
						var v37 any = v6
						_ = v37
						for {
							var tmp38 any
							if lang.IsTruthy(v37) {
								var tmp39 any
								{ // let
									// let binding "w"
									tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp41 := tmp40.FindInternedVar(lang.NewSymbol("first"))
									if tmp41.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
									}
									tmp42 := tmp41.Get()
									tmp43 := lang.Apply(tmp42, []any{v37})
									var v44 any = tmp43
									_ = v44
									// let binding "kw"
									tmp45 := lang.Apply(v3, []any{v44})
									var v46 any = tmp45
									_ = v46
									var tmp47 any
									tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp49 := tmp48.FindInternedVar(lang.NewSymbol("<="))
									if tmp49.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
									}
									tmp50 := tmp49.Get()
									tmp51 := lang.Apply(tmp50, []any{v46, v36})
									if lang.IsTruthy(tmp51) {
										var tmp52 any = v44
										var tmp53 any = v46
										tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp56 := tmp55.FindInternedVar(lang.NewSymbol("next"))
										if tmp56.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
										}
										tmp57 := tmp56.Get()
										tmp58 := lang.Apply(tmp57, []any{v37})
										var tmp54 any = tmp58
										v35 = tmp52
										v36 = tmp53
										v37 = tmp54
										continue
									} else {
										var tmp59 any = v35
										var tmp60 any = v36
										tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp63 := tmp62.FindInternedVar(lang.NewSymbol("next"))
										if tmp63.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
										}
										tmp64 := tmp63.Get()
										tmp65 := lang.Apply(tmp64, []any{v37})
										var tmp61 any = tmp65
										v35 = tmp59
										v36 = tmp60
										v37 = tmp61
										continue
									}
									tmp39 = tmp47
								} // end let
								tmp38 = tmp39
							} else {
								tmp38 = v35
							}
							tmp34 = tmp38
							break
						}
					} // end let
					tmp7 = tmp34
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mix-collection-hash
	{
		tmp0 := lang.NewSymbol("mix-collection-hash").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("hash-basis"), lang.NewSymbol("count"))), lang.NewKeyword("doc"), "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://glojure.org/data_structures#hash for full algorithms.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5199), lang.NewKeyword("end-line"), int(5199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mk-bound-fn
	{
		tmp0 := lang.NewSymbol("mk-bound-fn").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5127), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(5127), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key"))), lang.NewKeyword("private"), true, lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 lang.FnFunc
			tmp6 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v7 := args[0]
				_ = v7
				tmp8, ok := lang.FieldOrMethod(v3, "comparator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "comparator")))
				}
				var tmp9 any
				switch reflect.TypeOf(tmp8).Kind() {
				case reflect.Func:
					tmp9 = lang.Apply(tmp8, nil)
				default:
					tmp9 = tmp8
				}
				tmp10, _ := lang.FieldOrMethod(v3, "entryKey")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("entryKey is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{v7})
				tmp12, _ := lang.FieldOrMethod(tmp9, "compare")
				if reflect.TypeOf(tmp12).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("compare is not a function")))
				}
				tmp13 := lang.Apply(tmp12, []any{tmp11, v5})
				tmp14 := lang.Apply(v4, []any{tmp13, int64(0)})
				return tmp14
			})
			tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5130), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(5131), lang.NewKeyword("end-column"), int(64))
			tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// mod
	{
		tmp0 := lang.NewSymbol("mod").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("doc"), "Modulus of num and div. Truncates toward negative infinity.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3567), lang.NewKeyword("end-line"), int(3567))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("rem"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				var tmp12 any
				{ // let
					// let binding "or__0__auto__"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("zero?"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v10})
					var v17 any = tmp16
					_ = v17
					var tmp18 any
					if lang.IsTruthy(v17) {
						tmp18 = v17
					} else {
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("="))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v3})
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("pos?"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.Apply(tmp28, []any{v4})
						tmp30 := lang.Apply(tmp21, []any{tmp25, tmp29})
						tmp18 = tmp30
					}
					tmp12 = tmp18
				} // end let
				if lang.IsTruthy(tmp12) {
					tmp11 = v10
				} else {
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("+"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v10, v4})
					tmp11 = tmp16
				}
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// name
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("name").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the name String of a string, symbol or keyword.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1585), lang.NewKeyword("end-line"), int(1585))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("string?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v4})
			if lang.IsTruthy(tmp9) {
				tmp5 = v4
			} else {
				tmp10, _ := lang.FieldOrMethod(v4, "Name")
				if reflect.TypeOf(tmp10).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Name is not a function")))
				}
				tmp11 := lang.Apply(tmp10, []any{})
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// namespace
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("namespace").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the namespace String of a symbol or keyword, or nil if not present.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1593), lang.NewKeyword("end-line"), int(1593))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v4, "Namespace")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Namespace is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{})
			return tmp6
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nary-inline
	{
		tmp0 := lang.NewSymbol("nary-inline").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(948), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(948), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("op")), lang.NewVector(lang.NewSymbol("op"), lang.NewSymbol("unchecked-op"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("nary-inline"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3, v3})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 1:
						v6 := args[0]
						_ = v6
						var tmp7 any
						{ // let
							// let binding "op"
							var tmp8 any
							tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp10 := tmp9.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
							if tmp10.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
							}
							tmp11 := tmp10.Get()
							if lang.IsTruthy(tmp11) {
								tmp8 = v4
							} else {
								tmp8 = v3
							}
							var v12 any = tmp8
							_ = v12
							tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq"))
							if tmp14.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
							}
							tmp15 := tmp14.Get()
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("concat"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.Apply(tmp21, []any{lang.NewSymbol(".")})
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
							if tmp28.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
							}
							tmp29 := tmp28.Get()
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("concat"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{v12})
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v6})
							tmp44 := lang.Apply(tmp35, []any{tmp39, tmp43})
							tmp45 := lang.Apply(tmp32, []any{tmp44})
							tmp46 := lang.Apply(tmp29, []any{tmp45})
							tmp47 := lang.Apply(tmp18, []any{tmp22, tmp26, tmp46})
							tmp48 := lang.Apply(tmp15, []any{tmp47})
							tmp7 = tmp48
						} // end let
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var tmp8 any
						{ // let
							// let binding "op"
							var tmp9 any
							tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp11 := tmp10.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
							if tmp11.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
							}
							tmp12 := tmp11.Get()
							if lang.IsTruthy(tmp12) {
								tmp9 = v4
							} else {
								tmp9 = v3
							}
							var v13 any = tmp9
							_ = v13
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("seq"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("concat"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{lang.NewSymbol(".")})
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("seq"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp35 := tmp34.FindInternedVar(lang.NewSymbol("concat"))
							if tmp35.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
							}
							tmp36 := tmp35.Get()
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.Apply(tmp39, []any{v13})
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(tmp43, []any{v6})
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.Apply(tmp47, []any{v7})
							tmp49 := lang.Apply(tmp36, []any{tmp40, tmp44, tmp48})
							tmp50 := lang.Apply(tmp33, []any{tmp49})
							tmp51 := lang.Apply(tmp30, []any{tmp50})
							tmp52 := lang.Apply(tmp19, []any{tmp23, tmp27, tmp51})
							tmp53 := lang.Apply(tmp16, []any{tmp52})
							tmp8 = tmp53
						} // end let
						return tmp8
					default:
						if len(args) < 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						var v8 any = lang.NewList(args[2:]...)
						_ = v8
						var tmp9 any
						{ // let
							// let binding "op"
							var tmp10 any
							tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp12 := tmp11.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
							if tmp12.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
							}
							tmp13 := tmp12.Get()
							if lang.IsTruthy(tmp13) {
								tmp10 = v4
							} else {
								tmp10 = v3
							}
							var v14 any = tmp10
							_ = v14
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("reduce1"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							var tmp18 lang.FnFunc
							tmp18 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 2 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v19 := args[0]
								_ = v19
								v20 := args[1]
								_ = v20
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
								if tmp25.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
								}
								tmp26 := tmp25.Get()
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol(".")})
								tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
								if tmp32.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
								}
								tmp33 := tmp32.Get()
								tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
								tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
								if tmp36.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
								}
								tmp37 := tmp36.Get()
								tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
								if tmp39.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
								}
								tmp40 := tmp39.Get()
								tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
								if tmp42.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
								}
								tmp43 := tmp42.Get()
								tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
								if tmp45.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
								}
								tmp46 := tmp45.Get()
								tmp47 := lang.Apply(tmp46, []any{v14})
								tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
								if tmp49.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
								}
								tmp50 := tmp49.Get()
								tmp51 := lang.Apply(tmp50, []any{v19})
								tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
								if tmp53.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
								}
								tmp54 := tmp53.Get()
								tmp55 := lang.Apply(tmp54, []any{v20})
								tmp56 := lang.Apply(tmp43, []any{tmp47, tmp51, tmp55})
								tmp57 := lang.Apply(tmp40, []any{tmp56})
								tmp58 := lang.Apply(tmp37, []any{tmp57})
								tmp59 := lang.Apply(tmp26, []any{tmp30, tmp34, tmp58})
								tmp60 := lang.Apply(tmp23, []any{tmp59})
								return tmp60
							})
							tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(959), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(959), lang.NewKeyword("end-column"), int(88))
							tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
							if tmp28.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
							}
							tmp29 := tmp28.Get()
							tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol(".")})
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
							if tmp45.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
							}
							tmp46 := tmp45.Get()
							tmp47 := lang.Apply(tmp46, []any{v14})
							tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
							if tmp49.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
							}
							tmp50 := tmp49.Get()
							tmp51 := lang.Apply(tmp50, []any{v6})
							tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
							if tmp53.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
							}
							tmp54 := tmp53.Get()
							tmp55 := lang.Apply(tmp54, []any{v7})
							tmp56 := lang.Apply(tmp43, []any{tmp47, tmp51, tmp55})
							tmp57 := lang.Apply(tmp40, []any{tmp56})
							tmp58 := lang.Apply(tmp37, []any{tmp57})
							tmp59 := lang.Apply(tmp26, []any{tmp30, tmp34, tmp58})
							tmp60 := lang.Apply(tmp23, []any{tmp59})
							tmp61 := lang.Apply(tmp17, []any{tmp20, tmp60, v8})
							tmp9 = tmp61
						} // end let
						return tmp9
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(951), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(960), lang.NewKeyword("end-column"), int(86))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nat-int?
	{
		tmp0 := lang.NewSymbol("nat-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a non-negative fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1415), lang.NewKeyword("end-line"), int(1415))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("int?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("not"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("neg?"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					tmp10 = tmp18
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg-int?
	{
		tmp0 := lang.NewSymbol("neg-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a negative fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1409), lang.NewKeyword("end-line"), int(1409))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("int?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("neg?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp10 = tmp14
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// neg?
	{
		var tmp1 lang.FnFunc
		{ // function neg?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/IsNeg")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("neg?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is less than zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1259), lang.NewKeyword("end-line"), int(1259))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsNeg")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsNeg is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// newline
	{
		tmp0 := lang.NewSymbol("newline").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Writes a platform-specific newline to *out*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3698), lang.NewKeyword("end-line"), int(3698))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp4 := tmp3.FindInternedVar(lang.NewSymbol("*out*"))
			if tmp4.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
			}
			tmp5 := tmp4.Get()
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("system-newline"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(lang.AppendWriter, []any{tmp5, tmp8})
			_ = tmp9
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// next
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("next").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(55), lang.NewKeyword("end-line"), int(61))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function next
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Next, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(61), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(61), lang.NewKeyword("end-column"), int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nfirst
	{
		tmp0 := lang.NewSymbol("nfirst").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (next (first x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(105), lang.NewKeyword("end-line"), int(109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nfirst
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("next"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("first"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				return tmp12
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(109), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(109), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nil?
	{
		tmp1 := reflect.TypeOf(false)
		var tmp2 lang.FnFunc
		{ // function nil?__inliner
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("list"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Identical"), v4, nil})
				return tmp8
			})
			v3 = tmp2
			_ = v3
		}
		tmp0 := lang.NewSymbol("nil?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp2, lang.NewKeyword("doc"), "Returns true if x is nil, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(435), lang.NewKeyword("end-line"), int(435))).(*lang.Symbol)
		var tmp4 lang.FnFunc
		tmp4 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v5 := args[0]
			_ = v5
			tmp6 := lang.Apply(lang.IsNil, []any{v5})
			return tmp6
		})
		tmp5 := reflect.TypeOf(false)
		tmp4 = tmp4.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp5)).(lang.FnFunc)
		tmp3 := ns.InternWithValue(tmp0, tmp4, true)
		if tmp0.Meta() != nil {
			tmp3.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nnext
	{
		tmp0 := lang.NewSymbol("nnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (next (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(6), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(119), lang.NewKeyword("end-line"), int(123))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function nnext
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("next"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("next"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				return tmp12
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(123), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(123), lang.NewKeyword("end-column"), int(46))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// normalize-slurp-opts
	{
		tmp0 := lang.NewSymbol("normalize-slurp-opts").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6974), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(6974), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("opts"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("string?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("first"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v3})
			tmp12 := lang.Apply(tmp7, []any{tmp11})
			if lang.IsTruthy(tmp12) {
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("println"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc)."})
				_ = tmp16
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v3})
				tmp21 := lang.NewVector(lang.NewKeyword("encoding"), tmp20)
				tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6979), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(6979), lang.NewKeyword("end-column"), int(30))
				tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp4 = tmp23
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is logical false, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(523), lang.NewKeyword("end-line"), int(523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			if lang.IsTruthy(v4) {
				tmp5 = false
			} else {
				tmp5 = true
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-any?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not-any?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns false if (pred x) is logical true for any x in coll,\n  else true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(2696), lang.NewKeyword("end-line"), int(2701))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed17, nil)
				tmp5 := lang.Apply(closed16, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed17, []any{v4})
				tmp6 := lang.Apply(closed16, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed17, []any{v4, v5})
				tmp7 := lang.Apply(closed16, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed17, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed16, []any{tmp7})
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{closed17, v4, v5, v6, v7})
				tmp12 := lang.Apply(closed16, []any{tmp11})
				return tmp12
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-empty
	{
		tmp0 := lang.NewSymbol("not-empty").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "If coll is empty, returns nil, else coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5516), lang.NewKeyword("end-line"), int(5516))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp4 = v3
			} else {
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not-every?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not-every?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns false if (pred x) is logical true for every x in\n  coll, else true.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(2677), lang.NewKeyword("end-line"), int(2682))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp4 := lang.Apply(closed18, nil)
				tmp5 := lang.Apply(closed16, []any{tmp4})
				return tmp5
			case 1:
				v4 := args[0]
				_ = v4
				tmp5 := lang.Apply(closed18, []any{v4})
				tmp6 := lang.Apply(closed16, []any{tmp5})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(closed18, []any{v4, v5})
				tmp7 := lang.Apply(closed16, []any{tmp6})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7 := lang.Apply(closed18, []any{v4, v5, v6})
				tmp8 := lang.Apply(closed16, []any{tmp7})
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				var v7 any = lang.NewList(args[3:]...)
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{closed18, v4, v5, v6, v7})
				tmp12 := lang.Apply(closed16, []any{tmp11})
				return tmp12
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2559), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2564), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// not=
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("not=").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as (not (= obj1 obj2))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(812), lang.NewKeyword("end-line"), int(812))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				return false
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("not"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("="))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v4, v5})
				tmp13 := lang.Apply(tmp8, []any{tmp12})
				return tmp13
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				var v6 any = lang.NewList(args[2:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("not"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("="))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp12, []any{tmp15, v4, v5, v6})
				tmp17 := lang.Apply(tmp9, []any{tmp16})
				return tmp17
			}
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns
	{
		tmp0 := lang.NewSymbol("ns").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name"), lang.NewSymbol("docstring?"), lang.NewSymbol("attr-map?"), lang.NewSymbol("references*"))), lang.NewKeyword("doc"), "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-glojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-glojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-glojure is not used, a\n  default (refer 'glojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-glojure :exclude [ancestors printf])\n    (:require (glojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5742), lang.NewKeyword("end-line"), int(5742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "process-reference"
					var tmp8 lang.FnFunc
					tmp8 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						var tmp10 any
						{ // let
							// let binding "vec__107"
							var v11 any = v9
							_ = v11
							// let binding "seq__108"
							tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp13 := tmp12.FindInternedVar(lang.NewSymbol("seq"))
							if tmp13.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
							}
							tmp14 := tmp13.Get()
							tmp15 := lang.Apply(tmp14, []any{v11})
							var v16 any = tmp15
							_ = v16
							// let binding "first__109"
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.Apply(tmp19, []any{v16})
							var v21 any = tmp20
							_ = v21
							// let binding "seq__108"
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.Apply(tmp24, []any{v16})
							var v26 any = tmp25
							_ = v26
							// let binding "kname"
							var v27 any = v21
							_ = v27
							// let binding "args"
							var v28 any = v26
							_ = v28
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("seq"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("concat"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("symbol"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("name"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(tmp43, []any{v27})
							tmp45 := lang.Apply(tmp40, []any{"glojure.core", tmp44})
							tmp46 := lang.Apply(tmp37, []any{tmp45})
							tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp48 := tmp47.FindInternedVar(lang.NewSymbol("map"))
							if tmp48.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
							}
							tmp49 := tmp48.Get()
							var tmp50 lang.FnFunc
							tmp50 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v51 := args[0]
								_ = v51
								tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
								if tmp53.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
								}
								tmp54 := tmp53.Get()
								tmp55 := lang.Apply(tmp54, []any{lang.NewSymbol("quote"), v51})
								return tmp55
							})
							tmp51 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5769), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(5769), lang.NewKeyword("end-column"), int(36))
							tmp52, err := lang.WithMeta(tmp50, tmp51.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp53 := lang.Apply(tmp49, []any{tmp52, v28})
							tmp54 := lang.Apply(tmp34, []any{tmp46, tmp53})
							tmp55 := lang.Apply(tmp31, []any{tmp54})
							tmp10 = tmp55
						} // end let
						return tmp10
					})
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5767), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(5769), lang.NewKeyword("end-column"), int(44))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					// let binding "docstring"
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("string?"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v6})
					tmp20 := lang.Apply(tmp15, []any{tmp19})
					if lang.IsTruthy(tmp20) {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v6})
						tmp12 = tmp24
					} else {
					}
					var v25 any = tmp12
					_ = v25
					// let binding "references"
					var tmp26 any
					if lang.IsTruthy(v25) {
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("next"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{v6})
						tmp26 = tmp30
					} else {
						tmp26 = v6
					}
					var v31 any = tmp26
					_ = v31
					// let binding "name"
					var tmp32 any
					if lang.IsTruthy(v25) {
						tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp34 := tmp33.FindInternedVar(lang.NewSymbol("vary-meta"))
						if tmp34.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
						}
						tmp35 := tmp34.Get()
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("assoc"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.Apply(tmp35, []any{v5, tmp38, lang.NewKeyword("doc"), v25})
						tmp32 = tmp39
					} else {
						tmp32 = v5
					}
					var v40 any = tmp32
					_ = v40
					// let binding "metadata"
					var tmp41 any
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("map?"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("first"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.Apply(tmp47, []any{v31})
					tmp49 := lang.Apply(tmp44, []any{tmp48})
					if lang.IsTruthy(tmp49) {
						tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp51 := tmp50.FindInternedVar(lang.NewSymbol("first"))
						if tmp51.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
						}
						tmp52 := tmp51.Get()
						tmp53 := lang.Apply(tmp52, []any{v31})
						tmp41 = tmp53
					} else {
					}
					var v54 any = tmp41
					_ = v54
					// let binding "references"
					var tmp55 any
					if lang.IsTruthy(v54) {
						tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp57 := tmp56.FindInternedVar(lang.NewSymbol("next"))
						if tmp57.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
						}
						tmp58 := tmp57.Get()
						tmp59 := lang.Apply(tmp58, []any{v31})
						tmp55 = tmp59
					} else {
						tmp55 = v31
					}
					var v60 any = tmp55
					_ = v60
					// let binding "name"
					var tmp61 any
					if lang.IsTruthy(v54) {
						tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp63 := tmp62.FindInternedVar(lang.NewSymbol("vary-meta"))
						if tmp63.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
						}
						tmp64 := tmp63.Get()
						tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp66 := tmp65.FindInternedVar(lang.NewSymbol("merge"))
						if tmp66.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
						}
						tmp67 := tmp66.Get()
						tmp68 := lang.Apply(tmp64, []any{v40, tmp67, v54})
						tmp61 = tmp68
					} else {
						tmp61 = v40
					}
					var v69 any = tmp61
					_ = v69
					// let binding "gen-class-clause"
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("first"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("filter"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					var tmp76 lang.FnFunc
					tmp76 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v77 := args[0]
						_ = v77
						tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp79 := tmp78.FindInternedVar(lang.NewSymbol("="))
						if tmp79.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
						}
						tmp80 := tmp79.Get()
						tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp82 := tmp81.FindInternedVar(lang.NewSymbol("first"))
						if tmp82.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
						}
						tmp83 := tmp82.Get()
						tmp84 := lang.Apply(tmp83, []any{v77})
						tmp85 := lang.Apply(tmp80, []any{lang.NewKeyword("gen-class"), tmp84})
						return tmp85
					})
					tmp77 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5780), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(5780), lang.NewKeyword("end-column"), int(65))
					tmp78, err := lang.WithMeta(tmp76, tmp77.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp79 := lang.Apply(tmp75, []any{tmp78, v60})
					tmp80 := lang.Apply(tmp72, []any{tmp79})
					var v81 any = tmp80
					_ = v81
					// let binding "gen-class-call"
					var tmp82 any
					if lang.IsTruthy(v81) {
						tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp84 := tmp83.FindInternedVar(lang.NewSymbol("list*"))
						if tmp84.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
						}
						tmp85 := tmp84.Get()
						tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp87 := tmp86.FindInternedVar(lang.NewSymbol("str"))
						if tmp87.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
						}
						tmp88 := tmp87.Get()
						tmp89 := lang.Apply(tmp88, []any{v69})
						tmp90, _ := lang.FieldOrMethod(tmp89, "replace")
						if reflect.TypeOf(tmp90).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("replace is not a function")))
						}
						tmp91 := lang.Apply(tmp90, []any{lang.NewChar(45), lang.NewChar(95)})
						tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp93 := tmp92.FindInternedVar(lang.NewSymbol("next"))
						if tmp93.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
						}
						tmp94 := tmp93.Get()
						tmp95 := lang.Apply(tmp94, []any{v81})
						tmp96 := lang.Apply(tmp85, []any{lang.NewSymbol("glojure.core/gen-class"), lang.NewKeyword("name"), tmp91, lang.NewKeyword("impl-ns"), v69, lang.NewKeyword("main"), true, tmp95})
						tmp82 = tmp96
					} else {
					}
					var v97 any = tmp82
					_ = v97
					// let binding "references"
					tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp99 := tmp98.FindInternedVar(lang.NewSymbol("remove"))
					if tmp99.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
					}
					tmp100 := tmp99.Get()
					var tmp101 lang.FnFunc
					tmp101 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v102 := args[0]
						_ = v102
						tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp104 := tmp103.FindInternedVar(lang.NewSymbol("="))
						if tmp104.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
						}
						tmp105 := tmp104.Get()
						tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp107 := tmp106.FindInternedVar(lang.NewSymbol("first"))
						if tmp107.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
						}
						tmp108 := tmp107.Get()
						tmp109 := lang.Apply(tmp108, []any{v102})
						tmp110 := lang.Apply(tmp105, []any{lang.NewKeyword("gen-class"), tmp109})
						return tmp110
					})
					tmp102 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5784), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5784), lang.NewKeyword("end-column"), int(52))
					tmp103, err := lang.WithMeta(tmp101, tmp102.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp104 := lang.Apply(tmp100, []any{tmp103, v60})
					var v105 any = tmp104
					_ = v105
					// let binding "name-metadata"
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("meta"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.Apply(tmp108, []any{v69})
					var v110 any = tmp109
					_ = v110
					tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp112 := tmp111.FindInternedVar(lang.NewSymbol("seq"))
					if tmp112.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
					}
					tmp113 := tmp112.Get()
					tmp114 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp115 := tmp114.FindInternedVar(lang.NewSymbol("concat"))
					if tmp115.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp115)))
					}
					tmp116 := tmp115.Get()
					tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp118 := tmp117.FindInternedVar(lang.NewSymbol("list"))
					if tmp118.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
					}
					tmp119 := tmp118.Get()
					tmp120 := lang.Apply(tmp119, []any{lang.NewSymbol("do")})
					tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp122 := tmp121.FindInternedVar(lang.NewSymbol("list"))
					if tmp122.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
					}
					tmp123 := tmp122.Get()
					tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp125 := tmp124.FindInternedVar(lang.NewSymbol("seq"))
					if tmp125.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
					}
					tmp126 := tmp125.Get()
					tmp127 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp128 := tmp127.FindInternedVar(lang.NewSymbol("concat"))
					if tmp128.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp128)))
					}
					tmp129 := tmp128.Get()
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{lang.NewSymbol("glojure.core/in-ns")})
					tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
					if tmp135.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
					}
					tmp136 := tmp135.Get()
					tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
					if tmp138.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
					}
					tmp139 := tmp138.Get()
					tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
					if tmp141.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
					}
					tmp142 := tmp141.Get()
					tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
					if tmp144.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
					}
					tmp145 := tmp144.Get()
					tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("quote")})
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.Apply(tmp149, []any{v69})
					tmp151 := lang.Apply(tmp142, []any{tmp146, tmp150})
					tmp152 := lang.Apply(tmp139, []any{tmp151})
					tmp153 := lang.Apply(tmp136, []any{tmp152})
					tmp154 := lang.Apply(tmp129, []any{tmp133, tmp153})
					tmp155 := lang.Apply(tmp126, []any{tmp154})
					tmp156 := lang.Apply(tmp123, []any{tmp155})
					var tmp157 any
					if lang.IsTruthy(v110) {
						tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp159 := tmp158.FindInternedVar(lang.NewSymbol("seq"))
						if tmp159.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
						}
						tmp160 := tmp159.Get()
						tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp162 := tmp161.FindInternedVar(lang.NewSymbol("concat"))
						if tmp162.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
						}
						tmp163 := tmp162.Get()
						tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp165 := tmp164.FindInternedVar(lang.NewSymbol("list"))
						if tmp165.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
						}
						tmp166 := tmp165.Get()
						tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp168 := tmp167.FindInternedVar(lang.NewSymbol("seq"))
						if tmp168.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
						}
						tmp169 := tmp168.Get()
						tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp171 := tmp170.FindInternedVar(lang.NewSymbol("concat"))
						if tmp171.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
						}
						tmp172 := tmp171.Get()
						tmp173 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp174 := tmp173.FindInternedVar(lang.NewSymbol("list"))
						if tmp174.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp174)))
						}
						tmp175 := tmp174.Get()
						tmp176 := lang.Apply(tmp175, []any{lang.NewSymbol(".ResetMeta")})
						tmp177 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp178 := tmp177.FindInternedVar(lang.NewSymbol("list"))
						if tmp178.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp178)))
						}
						tmp179 := tmp178.Get()
						tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp181 := tmp180.FindInternedVar(lang.NewSymbol("seq"))
						if tmp181.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
						}
						tmp182 := tmp181.Get()
						tmp183 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp184 := tmp183.FindInternedVar(lang.NewSymbol("concat"))
						if tmp184.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp184)))
						}
						tmp185 := tmp184.Get()
						tmp186 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp187 := tmp186.FindInternedVar(lang.NewSymbol("list"))
						if tmp187.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp187)))
						}
						tmp188 := tmp187.Get()
						tmp189 := lang.Apply(tmp188, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.FindNamespace")})
						tmp190 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp191 := tmp190.FindInternedVar(lang.NewSymbol("list"))
						if tmp191.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp191)))
						}
						tmp192 := tmp191.Get()
						tmp193 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp194 := tmp193.FindInternedVar(lang.NewSymbol("seq"))
						if tmp194.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp194)))
						}
						tmp195 := tmp194.Get()
						tmp196 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp197 := tmp196.FindInternedVar(lang.NewSymbol("concat"))
						if tmp197.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp197)))
						}
						tmp198 := tmp197.Get()
						tmp199 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp200 := tmp199.FindInternedVar(lang.NewSymbol("list"))
						if tmp200.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp200)))
						}
						tmp201 := tmp200.Get()
						tmp202 := lang.Apply(tmp201, []any{lang.NewSymbol("quote")})
						tmp203 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp204 := tmp203.FindInternedVar(lang.NewSymbol("list"))
						if tmp204.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp204)))
						}
						tmp205 := tmp204.Get()
						tmp206 := lang.Apply(tmp205, []any{v69})
						tmp207 := lang.Apply(tmp198, []any{tmp202, tmp206})
						tmp208 := lang.Apply(tmp195, []any{tmp207})
						tmp209 := lang.Apply(tmp192, []any{tmp208})
						tmp210 := lang.Apply(tmp185, []any{tmp189, tmp209})
						tmp211 := lang.Apply(tmp182, []any{tmp210})
						tmp212 := lang.Apply(tmp179, []any{tmp211})
						tmp213 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp214 := tmp213.FindInternedVar(lang.NewSymbol("list"))
						if tmp214.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp214)))
						}
						tmp215 := tmp214.Get()
						tmp216 := lang.Apply(tmp215, []any{v110})
						tmp217 := lang.Apply(tmp172, []any{tmp176, tmp212, tmp216})
						tmp218 := lang.Apply(tmp169, []any{tmp217})
						tmp219 := lang.Apply(tmp166, []any{tmp218})
						tmp220 := lang.Apply(tmp163, []any{tmp219})
						tmp221 := lang.Apply(tmp160, []any{tmp220})
						tmp157 = tmp221
					} else {
					}
					tmp222 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp223 := tmp222.FindInternedVar(lang.NewSymbol("list"))
					if tmp223.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp223)))
					}
					tmp224 := tmp223.Get()
					tmp225 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp226 := tmp225.FindInternedVar(lang.NewSymbol("seq"))
					if tmp226.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp226)))
					}
					tmp227 := tmp226.Get()
					tmp228 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp229 := tmp228.FindInternedVar(lang.NewSymbol("concat"))
					if tmp229.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp229)))
					}
					tmp230 := tmp229.Get()
					tmp231 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp232 := tmp231.FindInternedVar(lang.NewSymbol("list"))
					if tmp232.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp232)))
					}
					tmp233 := tmp232.Get()
					tmp234 := lang.Apply(tmp233, []any{lang.NewSymbol("glojure.core/with-loading-context")})
					var tmp235 any
					if lang.IsTruthy(v97) {
						tmp236 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp237 := tmp236.FindInternedVar(lang.NewSymbol("list"))
						if tmp237.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp237)))
						}
						tmp238 := tmp237.Get()
						tmp239 := lang.Apply(tmp238, []any{v97})
						tmp235 = tmp239
					} else {
					}
					var tmp240 any
					var tmp241 any
					{ // let
						// let binding "and__0__auto__"
						tmp242 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp243 := tmp242.FindInternedVar(lang.NewSymbol("not="))
						if tmp243.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp243)))
						}
						tmp244 := tmp243.Get()
						tmp245 := lang.Apply(tmp244, []any{v69, lang.NewSymbol("glojure.core")})
						var v246 any = tmp245
						_ = v246
						var tmp247 any
						if lang.IsTruthy(v246) {
							tmp248 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp249 := tmp248.FindInternedVar(lang.NewSymbol("not-any?"))
							if tmp249.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp249)))
							}
							tmp250 := tmp249.Get()
							var tmp251 lang.FnFunc
							tmp251 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v252 := args[0]
								_ = v252
								tmp253 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp254 := tmp253.FindInternedVar(lang.NewSymbol("="))
								if tmp254.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp254)))
								}
								tmp255 := tmp254.Get()
								tmp256 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp257 := tmp256.FindInternedVar(lang.NewSymbol("first"))
								if tmp257.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp257)))
								}
								tmp258 := tmp257.Get()
								tmp259 := lang.Apply(tmp258, []any{v252})
								tmp260 := lang.Apply(tmp255, []any{lang.NewKeyword("refer-glojure"), tmp259})
								return tmp260
							})
							tmp252 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5793), lang.NewKeyword("column"), int(58), lang.NewKeyword("end-line"), int(5793), lang.NewKeyword("end-column"), int(86))
							tmp253, err := lang.WithMeta(tmp251, tmp252.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp254 := lang.Apply(tmp250, []any{tmp253, v105})
							tmp247 = tmp254
						} else {
							tmp247 = v246
						}
						tmp241 = tmp247
					} // end let
					if lang.IsTruthy(tmp241) {
						tmp242 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp243 := tmp242.FindInternedVar(lang.NewSymbol("seq"))
						if tmp243.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp243)))
						}
						tmp244 := tmp243.Get()
						tmp245 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp246 := tmp245.FindInternedVar(lang.NewSymbol("concat"))
						if tmp246.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp246)))
						}
						tmp247 := tmp246.Get()
						tmp248 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp249 := tmp248.FindInternedVar(lang.NewSymbol("list"))
						if tmp249.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp249)))
						}
						tmp250 := tmp249.Get()
						tmp251 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp252 := tmp251.FindInternedVar(lang.NewSymbol("seq"))
						if tmp252.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp252)))
						}
						tmp253 := tmp252.Get()
						tmp254 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp255 := tmp254.FindInternedVar(lang.NewSymbol("concat"))
						if tmp255.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp255)))
						}
						tmp256 := tmp255.Get()
						tmp257 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp258 := tmp257.FindInternedVar(lang.NewSymbol("list"))
						if tmp258.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp258)))
						}
						tmp259 := tmp258.Get()
						tmp260 := lang.Apply(tmp259, []any{lang.NewSymbol("glojure.core/refer")})
						tmp261 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp262 := tmp261.FindInternedVar(lang.NewSymbol("list"))
						if tmp262.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp262)))
						}
						tmp263 := tmp262.Get()
						tmp264 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp265 := tmp264.FindInternedVar(lang.NewSymbol("seq"))
						if tmp265.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp265)))
						}
						tmp266 := tmp265.Get()
						tmp267 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp268 := tmp267.FindInternedVar(lang.NewSymbol("concat"))
						if tmp268.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp268)))
						}
						tmp269 := tmp268.Get()
						tmp270 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp271 := tmp270.FindInternedVar(lang.NewSymbol("list"))
						if tmp271.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp271)))
						}
						tmp272 := tmp271.Get()
						tmp273 := lang.Apply(tmp272, []any{lang.NewSymbol("quote")})
						tmp274 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp275 := tmp274.FindInternedVar(lang.NewSymbol("list"))
						if tmp275.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp275)))
						}
						tmp276 := tmp275.Get()
						tmp277 := lang.Apply(tmp276, []any{lang.NewSymbol("glojure.core")})
						tmp278 := lang.Apply(tmp269, []any{tmp273, tmp277})
						tmp279 := lang.Apply(tmp266, []any{tmp278})
						tmp280 := lang.Apply(tmp263, []any{tmp279})
						tmp281 := lang.Apply(tmp256, []any{tmp260, tmp280})
						tmp282 := lang.Apply(tmp253, []any{tmp281})
						tmp283 := lang.Apply(tmp250, []any{tmp282})
						tmp284 := lang.Apply(tmp247, []any{tmp283})
						tmp285 := lang.Apply(tmp244, []any{tmp284})
						tmp240 = tmp285
					} else {
					}
					tmp286 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp287 := tmp286.FindInternedVar(lang.NewSymbol("map"))
					if tmp287.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp287)))
					}
					tmp288 := tmp287.Get()
					tmp289 := lang.Apply(tmp288, []any{v11, v105})
					tmp290 := lang.Apply(tmp230, []any{tmp234, tmp235, tmp240, tmp289})
					tmp291 := lang.Apply(tmp227, []any{tmp290})
					tmp292 := lang.Apply(tmp224, []any{tmp291})
					tmp293 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp294 := tmp293.FindInternedVar(lang.NewSymbol("list"))
					if tmp294.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp294)))
					}
					tmp295 := tmp294.Get()
					tmp296 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp297 := tmp296.FindInternedVar(lang.NewSymbol("seq"))
					if tmp297.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp297)))
					}
					tmp298 := tmp297.Get()
					tmp299 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp300 := tmp299.FindInternedVar(lang.NewSymbol("concat"))
					if tmp300.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp300)))
					}
					tmp301 := tmp300.Get()
					tmp302 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp303 := tmp302.FindInternedVar(lang.NewSymbol("list"))
					if tmp303.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp303)))
					}
					tmp304 := tmp303.Get()
					tmp305 := lang.Apply(tmp304, []any{lang.NewSymbol("if")})
					tmp306 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp307 := tmp306.FindInternedVar(lang.NewSymbol("list"))
					if tmp307.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp307)))
					}
					tmp308 := tmp307.Get()
					tmp309 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp310 := tmp309.FindInternedVar(lang.NewSymbol("seq"))
					if tmp310.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp310)))
					}
					tmp311 := tmp310.Get()
					tmp312 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp313 := tmp312.FindInternedVar(lang.NewSymbol("concat"))
					if tmp313.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp313)))
					}
					tmp314 := tmp313.Get()
					tmp315 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp316 := tmp315.FindInternedVar(lang.NewSymbol("list"))
					if tmp316.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp316)))
					}
					tmp317 := tmp316.Get()
					tmp318 := lang.Apply(tmp317, []any{lang.NewSymbol(".Equals")})
					tmp319 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp320 := tmp319.FindInternedVar(lang.NewSymbol("list"))
					if tmp320.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp320)))
					}
					tmp321 := tmp320.Get()
					tmp322 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp323 := tmp322.FindInternedVar(lang.NewSymbol("seq"))
					if tmp323.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp323)))
					}
					tmp324 := tmp323.Get()
					tmp325 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp326 := tmp325.FindInternedVar(lang.NewSymbol("concat"))
					if tmp326.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp326)))
					}
					tmp327 := tmp326.Get()
					tmp328 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp329 := tmp328.FindInternedVar(lang.NewSymbol("list"))
					if tmp329.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp329)))
					}
					tmp330 := tmp329.Get()
					tmp331 := lang.Apply(tmp330, []any{lang.NewSymbol("quote")})
					tmp332 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp333 := tmp332.FindInternedVar(lang.NewSymbol("list"))
					if tmp333.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp333)))
					}
					tmp334 := tmp333.Get()
					tmp335 := lang.Apply(tmp334, []any{v69})
					tmp336 := lang.Apply(tmp327, []any{tmp331, tmp335})
					tmp337 := lang.Apply(tmp324, []any{tmp336})
					tmp338 := lang.Apply(tmp321, []any{tmp337})
					tmp339 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp340 := tmp339.FindInternedVar(lang.NewSymbol("list"))
					if tmp340.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp340)))
					}
					tmp341 := tmp340.Get()
					tmp342 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp343 := tmp342.FindInternedVar(lang.NewSymbol("seq"))
					if tmp343.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp343)))
					}
					tmp344 := tmp343.Get()
					tmp345 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp346 := tmp345.FindInternedVar(lang.NewSymbol("concat"))
					if tmp346.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp346)))
					}
					tmp347 := tmp346.Get()
					tmp348 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp349 := tmp348.FindInternedVar(lang.NewSymbol("list"))
					if tmp349.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp349)))
					}
					tmp350 := tmp349.Get()
					tmp351 := lang.Apply(tmp350, []any{lang.NewSymbol("quote")})
					tmp352 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp353 := tmp352.FindInternedVar(lang.NewSymbol("list"))
					if tmp353.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp353)))
					}
					tmp354 := tmp353.Get()
					tmp355 := lang.Apply(tmp354, []any{lang.NewSymbol("glojure.core")})
					tmp356 := lang.Apply(tmp347, []any{tmp351, tmp355})
					tmp357 := lang.Apply(tmp344, []any{tmp356})
					tmp358 := lang.Apply(tmp341, []any{tmp357})
					tmp359 := lang.Apply(tmp314, []any{tmp318, tmp338, tmp358})
					tmp360 := lang.Apply(tmp311, []any{tmp359})
					tmp361 := lang.Apply(tmp308, []any{tmp360})
					tmp362 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp363 := tmp362.FindInternedVar(lang.NewSymbol("list"))
					if tmp363.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp363)))
					}
					tmp364 := tmp363.Get()
					tmp365 := lang.Apply(tmp364, []any{nil})
					tmp366 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp367 := tmp366.FindInternedVar(lang.NewSymbol("list"))
					if tmp367.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp367)))
					}
					tmp368 := tmp367.Get()
					tmp369 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp370 := tmp369.FindInternedVar(lang.NewSymbol("seq"))
					if tmp370.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp370)))
					}
					tmp371 := tmp370.Get()
					tmp372 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp373 := tmp372.FindInternedVar(lang.NewSymbol("concat"))
					if tmp373.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp373)))
					}
					tmp374 := tmp373.Get()
					tmp375 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp376 := tmp375.FindInternedVar(lang.NewSymbol("list"))
					if tmp376.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp376)))
					}
					tmp377 := tmp376.Get()
					tmp378 := lang.Apply(tmp377, []any{lang.NewSymbol("do")})
					tmp379 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp380 := tmp379.FindInternedVar(lang.NewSymbol("list"))
					if tmp380.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp380)))
					}
					tmp381 := tmp380.Get()
					tmp382 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp383 := tmp382.FindInternedVar(lang.NewSymbol("seq"))
					if tmp383.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp383)))
					}
					tmp384 := tmp383.Get()
					tmp385 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp386 := tmp385.FindInternedVar(lang.NewSymbol("concat"))
					if tmp386.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp386)))
					}
					tmp387 := tmp386.Get()
					tmp388 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp389 := tmp388.FindInternedVar(lang.NewSymbol("list"))
					if tmp389.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp389)))
					}
					tmp390 := tmp389.Get()
					tmp391 := lang.Apply(tmp390, []any{lang.NewSymbol("glojure.core/dosync")})
					tmp392 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp393 := tmp392.FindInternedVar(lang.NewSymbol("list"))
					if tmp393.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp393)))
					}
					tmp394 := tmp393.Get()
					tmp395 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp396 := tmp395.FindInternedVar(lang.NewSymbol("seq"))
					if tmp396.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp396)))
					}
					tmp397 := tmp396.Get()
					tmp398 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp399 := tmp398.FindInternedVar(lang.NewSymbol("concat"))
					if tmp399.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp399)))
					}
					tmp400 := tmp399.Get()
					tmp401 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp402 := tmp401.FindInternedVar(lang.NewSymbol("list"))
					if tmp402.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp402)))
					}
					tmp403 := tmp402.Get()
					tmp404 := lang.Apply(tmp403, []any{lang.NewSymbol("glojure.core/commute")})
					tmp405 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp406 := tmp405.FindInternedVar(lang.NewSymbol("list"))
					if tmp406.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp406)))
					}
					tmp407 := tmp406.Get()
					tmp408 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp409 := tmp408.FindInternedVar(lang.NewSymbol("seq"))
					if tmp409.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp409)))
					}
					tmp410 := tmp409.Get()
					tmp411 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp412 := tmp411.FindInternedVar(lang.NewSymbol("concat"))
					if tmp412.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp412)))
					}
					tmp413 := tmp412.Get()
					tmp414 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp415 := tmp414.FindInternedVar(lang.NewSymbol("list"))
					if tmp415.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp415)))
					}
					tmp416 := tmp415.Get()
					tmp417 := lang.Apply(tmp416, []any{lang.NewSymbol("glojure.core/deref")})
					tmp418 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp419 := tmp418.FindInternedVar(lang.NewSymbol("list"))
					if tmp419.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp419)))
					}
					tmp420 := tmp419.Get()
					tmp421 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp422 := tmp421.FindInternedVar(lang.NewSymbol("seq"))
					if tmp422.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp422)))
					}
					tmp423 := tmp422.Get()
					tmp424 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp425 := tmp424.FindInternedVar(lang.NewSymbol("concat"))
					if tmp425.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp425)))
					}
					tmp426 := tmp425.Get()
					tmp427 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp428 := tmp427.FindInternedVar(lang.NewSymbol("list"))
					if tmp428.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp428)))
					}
					tmp429 := tmp428.Get()
					tmp430 := lang.Apply(tmp429, []any{lang.NewSymbol("var")})
					tmp431 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp432 := tmp431.FindInternedVar(lang.NewSymbol("list"))
					if tmp432.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp432)))
					}
					tmp433 := tmp432.Get()
					tmp434 := lang.Apply(tmp433, []any{lang.NewSymbol("glojure.core/*loaded-libs*")})
					tmp435 := lang.Apply(tmp426, []any{tmp430, tmp434})
					tmp436 := lang.Apply(tmp423, []any{tmp435})
					tmp437 := lang.Apply(tmp420, []any{tmp436})
					tmp438 := lang.Apply(tmp413, []any{tmp417, tmp437})
					tmp439 := lang.Apply(tmp410, []any{tmp438})
					tmp440 := lang.Apply(tmp407, []any{tmp439})
					tmp441 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp442 := tmp441.FindInternedVar(lang.NewSymbol("list"))
					if tmp442.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp442)))
					}
					tmp443 := tmp442.Get()
					tmp444 := lang.Apply(tmp443, []any{lang.NewSymbol("glojure.core/conj")})
					tmp445 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp446 := tmp445.FindInternedVar(lang.NewSymbol("list"))
					if tmp446.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp446)))
					}
					tmp447 := tmp446.Get()
					tmp448 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp449 := tmp448.FindInternedVar(lang.NewSymbol("seq"))
					if tmp449.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp449)))
					}
					tmp450 := tmp449.Get()
					tmp451 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp452 := tmp451.FindInternedVar(lang.NewSymbol("concat"))
					if tmp452.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp452)))
					}
					tmp453 := tmp452.Get()
					tmp454 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp455 := tmp454.FindInternedVar(lang.NewSymbol("list"))
					if tmp455.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp455)))
					}
					tmp456 := tmp455.Get()
					tmp457 := lang.Apply(tmp456, []any{lang.NewSymbol("quote")})
					tmp458 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp459 := tmp458.FindInternedVar(lang.NewSymbol("list"))
					if tmp459.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp459)))
					}
					tmp460 := tmp459.Get()
					tmp461 := lang.Apply(tmp460, []any{v69})
					tmp462 := lang.Apply(tmp453, []any{tmp457, tmp461})
					tmp463 := lang.Apply(tmp450, []any{tmp462})
					tmp464 := lang.Apply(tmp447, []any{tmp463})
					tmp465 := lang.Apply(tmp400, []any{tmp404, tmp440, tmp444, tmp464})
					tmp466 := lang.Apply(tmp397, []any{tmp465})
					tmp467 := lang.Apply(tmp394, []any{tmp466})
					tmp468 := lang.Apply(tmp387, []any{tmp391, tmp467})
					tmp469 := lang.Apply(tmp384, []any{tmp468})
					tmp470 := lang.Apply(tmp381, []any{tmp469})
					tmp471 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp472 := tmp471.FindInternedVar(lang.NewSymbol("list"))
					if tmp472.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp472)))
					}
					tmp473 := tmp472.Get()
					tmp474 := lang.Apply(tmp473, []any{nil})
					tmp475 := lang.Apply(tmp374, []any{tmp378, tmp470, tmp474})
					tmp476 := lang.Apply(tmp371, []any{tmp475})
					tmp477 := lang.Apply(tmp368, []any{tmp476})
					tmp478 := lang.Apply(tmp301, []any{tmp305, tmp361, tmp365, tmp477})
					tmp479 := lang.Apply(tmp298, []any{tmp478})
					tmp480 := lang.Apply(tmp295, []any{tmp479})
					tmp481 := lang.Apply(tmp116, []any{tmp120, tmp156, tmp157, tmp292, tmp480})
					tmp482 := lang.Apply(tmp113, []any{tmp481})
					tmp7 = tmp482
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-aliases
	{
		tmp0 := lang.NewSymbol("ns-aliases").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the aliases for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4273), lang.NewKeyword("end-line"), int(4273))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8, ok := lang.FieldOrMethod(tmp7, "getAliases")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "getAliases")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-imports
	{
		tmp0 := lang.NewSymbol("ns-imports").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the import mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4199), lang.NewKeyword("end-line"), int(4199))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("filter-key"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("val"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("partial"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp14 := tmp13.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp14.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
			}
			tmp15 := tmp14.Get()
			tmp16 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
			tmp17 := lang.Apply(tmp12, []any{tmp15, tmp16})
			tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp19 := tmp18.FindInternedVar(lang.NewSymbol("ns-map"))
			if tmp19.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
			}
			tmp20 := tmp19.Get()
			tmp21 := lang.Apply(tmp20, []any{v3})
			tmp22 := lang.Apply(tmp6, []any{tmp9, tmp17, tmp21})
			return tmp22
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-interns
	{
		tmp0 := lang.NewSymbol("ns-interns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the intern mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4206), lang.NewKeyword("end-line"), int(4206))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("the-ns"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("filter-key"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("val"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v17 := args[0]
					_ = v17
					var tmp18 any
					{ // let
						// let binding "and__0__auto__"
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := reflect.TypeOf((*lang.Var)(nil))
						tmp23 := lang.Apply(tmp21, []any{tmp22, v17})
						var v24 any = tmp23
						_ = v24
						var tmp25 any
						if lang.IsTruthy(v24) {
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("="))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29, ok := lang.FieldOrMethod(v17, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "Namespace")))
							}
							var tmp30 any
							switch reflect.TypeOf(tmp29).Kind() {
							case reflect.Func:
								tmp30 = lang.Apply(tmp29, nil)
							default:
								tmp30 = tmp29
							}
							tmp31 := lang.Apply(tmp28, []any{v9, tmp30})
							tmp25 = tmp31
						} else {
							tmp25 = v24
						}
						tmp18 = tmp25
					} // end let
					return tmp18
				})
				tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4212), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4213), lang.NewKeyword("end-column"), int(56))
				tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("ns-map"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{v9})
				tmp23 := lang.Apply(tmp12, []any{tmp15, tmp18, tmp22})
				tmp4 = tmp23
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-map
	{
		tmp0 := lang.NewSymbol("ns-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of all the mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4170), lang.NewKeyword("end-line"), int(4170))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8, ok := lang.FieldOrMethod(tmp7, "Mappings")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "Mappings")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-name
	{
		tmp0 := lang.NewSymbol("ns-name").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns the name of the namespace, a symbol.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4163), lang.NewKeyword("end-line"), int(4163))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{v3})
			tmp8, ok := lang.FieldOrMethod(tmp7, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp7, "Name")))
			}
			var tmp9 any
			switch reflect.TypeOf(tmp8).Kind() {
			case reflect.Func:
				tmp9 = lang.Apply(tmp8, nil)
			default:
				tmp9 = tmp8
			}
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-publics
	{
		tmp0 := lang.NewSymbol("ns-publics").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the public intern mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4188), lang.NewKeyword("end-line"), int(4188))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("the-ns"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("filter-key"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("val"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v17 := args[0]
					_ = v17
					var tmp18 any
					{ // let
						// let binding "and__0__auto__"
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := reflect.TypeOf((*lang.Var)(nil))
						tmp23 := lang.Apply(tmp21, []any{tmp22, v17})
						var v24 any = tmp23
						_ = v24
						var tmp25 any
						if lang.IsTruthy(v24) {
							var tmp26 any
							{ // let
								// let binding "and__0__auto__"
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("="))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30, ok := lang.FieldOrMethod(v17, "Namespace")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "Namespace")))
								}
								var tmp31 any
								switch reflect.TypeOf(tmp30).Kind() {
								case reflect.Func:
									tmp31 = lang.Apply(tmp30, nil)
								default:
									tmp31 = tmp30
								}
								tmp32 := lang.Apply(tmp29, []any{v9, tmp31})
								var v33 any = tmp32
								_ = v33
								var tmp34 any
								if lang.IsTruthy(v33) {
									tmp35, ok := lang.FieldOrMethod(v17, "IsPublic")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "IsPublic")))
									}
									var tmp36 any
									switch reflect.TypeOf(tmp35).Kind() {
									case reflect.Func:
										tmp36 = lang.Apply(tmp35, nil)
									default:
										tmp36 = tmp35
									}
									tmp34 = tmp36
								} else {
									tmp34 = v33
								}
								tmp26 = tmp34
							} // end let
							tmp25 = tmp26
						} else {
							tmp25 = v24
						}
						tmp18 = tmp25
					} // end let
					return tmp18
				})
				tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4194), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4196), lang.NewKeyword("end-column"), int(48))
				tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("ns-map"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{v9})
				tmp23 := lang.Apply(tmp12, []any{tmp15, tmp18, tmp22})
				tmp4 = tmp23
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-refers
	{
		tmp0 := lang.NewSymbol("ns-refers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"))), lang.NewKeyword("doc"), "Returns a map of the refer mappings for the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4253), lang.NewKeyword("end-line"), int(4253))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ns"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("the-ns"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("filter-key"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("val"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				var tmp16 lang.FnFunc
				tmp16 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v17 := args[0]
					_ = v17
					var tmp18 any
					{ // let
						// let binding "and__0__auto__"
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := reflect.TypeOf((*lang.Var)(nil))
						tmp23 := lang.Apply(tmp21, []any{tmp22, v17})
						var v24 any = tmp23
						_ = v24
						var tmp25 any
						if lang.IsTruthy(v24) {
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("not="))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29, ok := lang.FieldOrMethod(v17, "Namespace")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "Namespace")))
							}
							var tmp30 any
							switch reflect.TypeOf(tmp29).Kind() {
							case reflect.Func:
								tmp30 = lang.Apply(tmp29, nil)
							default:
								tmp30 = tmp29
							}
							tmp31 := lang.Apply(tmp28, []any{v9, tmp30})
							tmp25 = tmp31
						} else {
							tmp25 = v24
						}
						tmp18 = tmp25
					} // end let
					return tmp18
				})
				tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4259), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(4260), lang.NewKeyword("end-column"), int(59))
				tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("ns-map"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{v9})
				tmp23 := lang.Apply(tmp12, []any{tmp15, tmp18, tmp22})
				tmp4 = tmp23
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-resolve
	{
		tmp0 := lang.NewSymbol("ns-resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("env"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4358), lang.NewKeyword("end-line"), int(4358))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("ns-resolve"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, nil, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("contains?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v4, v5})
				if lang.IsTruthy(tmp10) {
				} else {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("the-ns"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp15, _ := lang.FieldOrMethod(runtime4.Compiler, "maybeResolveIn")
					if reflect.TypeOf(tmp15).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("maybeResolveIn is not a function")))
					}
					tmp16 := lang.Apply(tmp15, []any{tmp14, v5})
					tmp6 = tmp16
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unalias
	{
		tmp0 := lang.NewSymbol("ns-unalias").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the alias for the symbol from the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4280), lang.NewKeyword("end-line"), int(4280))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9, _ := lang.FieldOrMethod(tmp8, "removeAlias")
			if reflect.TypeOf(tmp9).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeAlias is not a function")))
			}
			tmp10 := lang.Apply(tmp9, []any{v4})
			return tmp10
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ns-unmap
	{
		tmp0 := lang.NewSymbol("ns-unmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the mappings for the symbol from the namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4177), lang.NewKeyword("end-line"), int(4177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("the-ns"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			tmp9, _ := lang.FieldOrMethod(tmp8, "unmap")
			if reflect.TypeOf(tmp9).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("unmap is not a function")))
			}
			tmp10 := lang.Apply(tmp9, []any{v4})
			return tmp10
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nth
	{
		var tmp1 lang.FnFunc
		{ // function nth__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v3 := args[0]
					_ = v3
					v4 := args[1]
					_ = v4
					var v5 any = lang.NewList(args[2:]...)
					_ = v5
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol(".")})
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("list"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("seq"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("concat"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core/Nth")})
					tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp34 := tmp33.FindInternedVar(lang.NewSymbol("list"))
					if tmp34.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
					}
					tmp35 := tmp34.Get()
					tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp37 := tmp36.FindInternedVar(lang.NewSymbol("seq"))
					if tmp37.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
					}
					tmp38 := tmp37.Get()
					tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp40 := tmp39.FindInternedVar(lang.NewSymbol("concat"))
					if tmp40.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
					}
					tmp41 := tmp40.Get()
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("list"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.Apply(tmp44, []any{lang.NewSymbol("glojure.core/unquote")})
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{lang.NewSymbol("glojure.core/c")})
					tmp50 := lang.Apply(tmp41, []any{tmp45, tmp49})
					tmp51 := lang.Apply(tmp38, []any{tmp50})
					tmp52 := lang.Apply(tmp35, []any{tmp51})
					tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
					if tmp54.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
					}
					tmp55 := tmp54.Get()
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("seq"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp60 := tmp59.FindInternedVar(lang.NewSymbol("concat"))
					if tmp60.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
					}
					tmp61 := tmp60.Get()
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("list"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("glojure.core/unquote")})
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/i")})
					tmp70 := lang.Apply(tmp61, []any{tmp65, tmp69})
					tmp71 := lang.Apply(tmp58, []any{tmp70})
					tmp72 := lang.Apply(tmp55, []any{tmp71})
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("list"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("seq"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("concat"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp83 := tmp82.FindInternedVar(lang.NewSymbol("list"))
					if tmp83.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
					}
					tmp84 := tmp83.Get()
					tmp85 := lang.Apply(tmp84, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp87 := tmp86.FindInternedVar(lang.NewSymbol("list"))
					if tmp87.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
					}
					tmp88 := tmp87.Get()
					tmp89 := lang.Apply(tmp88, []any{lang.NewSymbol("glojure.core/nf")})
					tmp90 := lang.Apply(tmp81, []any{tmp85, tmp89})
					tmp91 := lang.Apply(tmp78, []any{tmp90})
					tmp92 := lang.Apply(tmp75, []any{tmp91})
					tmp93 := lang.Apply(tmp28, []any{tmp32, tmp52, tmp72, tmp92})
					tmp94 := lang.Apply(tmp25, []any{tmp93})
					tmp95 := lang.Apply(tmp22, []any{tmp94})
					tmp96 := lang.Apply(tmp11, []any{tmp15, tmp19, tmp95})
					tmp97 := lang.Apply(tmp8, []any{tmp96})
					return tmp97
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("index")), lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("index"), lang.NewSymbol("not-found"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(2), int64(3)})), lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(882), lang.NewKeyword("end-line"), int(882))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime4.RT, "Nth")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Nth is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			case 3:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				v6 := args[2]
				_ = v6
				tmp7, _ := lang.FieldOrMethod(runtime4.RT, "NthDefault")
				if reflect.TypeOf(tmp7).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("NthDefault is not a function")))
				}
				tmp8 := lang.Apply(tmp7, []any{v4, v5, v6})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthnext
	{
		tmp0 := lang.NewSymbol("nthnext").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns the nth next of coll, (seq coll) when n is 0.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3147), lang.NewKeyword("end-line"), int(3147))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
			tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
			if lang.IsTruthy(tmp10) {
				var tmp11 any
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("pos?"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v4})
				if lang.IsTruthy(tmp15) {
					var tmp16 any
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("int?"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v4})
					if lang.IsTruthy(tmp20) {
						tmp16 = v4
					} else {
						tmp21 := lang.Apply(nil, []any{v4})
						tmp16 = tmp21
					}
					tmp22, _ := lang.FieldOrMethod(v3, "drop")
					if reflect.TypeOf(tmp22).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
					}
					tmp23 := lang.Apply(tmp22, []any{tmp16})
					tmp11 = tmp23
				} else {
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp11 = tmp27
				}
				tmp5 = tmp11
			} else {
				var tmp28 any
				{ // let
					// let binding "n"
					var v29 any = v4
					_ = v29
					// let binding "xs"
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.Apply(tmp32, []any{v3})
					var v34 any = tmp33
					_ = v34
					for {
						var tmp35 any
						var tmp36 any
						{ // let
							// let binding "and__0__auto__"
							var v37 any = v34
							_ = v37
							var tmp38 any
							if lang.IsTruthy(v37) {
								tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp40 := tmp39.FindInternedVar(lang.NewSymbol("pos?"))
								if tmp40.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
								}
								tmp41 := tmp40.Get()
								tmp42 := lang.Apply(tmp41, []any{v29})
								tmp38 = tmp42
							} else {
								tmp38 = v37
							}
							tmp36 = tmp38
						} // end let
						if lang.IsTruthy(tmp36) {
							tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp39 := tmp38.FindInternedVar(lang.NewSymbol("dec"))
							if tmp39.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
							}
							tmp40 := tmp39.Get()
							tmp41 := lang.Apply(tmp40, []any{v29})
							var tmp37 any = tmp41
							tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp44 := tmp43.FindInternedVar(lang.NewSymbol("next"))
							if tmp44.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
							}
							tmp45 := tmp44.Get()
							tmp46 := lang.Apply(tmp45, []any{v34})
							var tmp42 any = tmp46
							v29 = tmp37
							v34 = tmp42
							continue
						} else {
							tmp35 = v34
						}
						tmp28 = tmp35
						break
					}
				} // end let
				tmp5 = tmp28
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// nthrest
	{
		tmp0 := lang.NewSymbol("nthrest").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns the nth rest of coll, coll when n is 0.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3161), lang.NewKeyword("end-line"), int(3161))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("pos?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v4})
			if lang.IsTruthy(tmp9) {
				var tmp10 any
				{ // let
					// let binding "or__0__auto__"
					var tmp11 any
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := reflect.TypeOf((*lang.IDrop)(nil)).Elem()
					tmp16 := lang.Apply(tmp14, []any{tmp15, v3})
					if lang.IsTruthy(tmp16) {
						var tmp17 any
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("int?"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v4})
						if lang.IsTruthy(tmp21) {
							tmp17 = v4
						} else {
							tmp22 := lang.Apply(nil, []any{v4})
							tmp17 = tmp22
						}
						tmp23, _ := lang.FieldOrMethod(v3, "drop")
						if reflect.TypeOf(tmp23).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("drop is not a function")))
						}
						tmp24 := lang.Apply(tmp23, []any{tmp17})
						tmp11 = tmp24
					} else {
						var tmp25 any
						{ // let
							// let binding "n"
							var v26 any = v4
							_ = v26
							// let binding "xs"
							var v27 any = v3
							_ = v27
							for {
								var tmp28 any
								{ // let
									// let binding "temp__0__auto__"
									var tmp29 any
									{ // let
										// let binding "and__0__auto__"
										tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp31 := tmp30.FindInternedVar(lang.NewSymbol("pos?"))
										if tmp31.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
										}
										tmp32 := tmp31.Get()
										tmp33 := lang.Apply(tmp32, []any{v26})
										var v34 any = tmp33
										_ = v34
										var tmp35 any
										if lang.IsTruthy(v34) {
											tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp37 := tmp36.FindInternedVar(lang.NewSymbol("seq"))
											if tmp37.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
											}
											tmp38 := tmp37.Get()
											tmp39 := lang.Apply(tmp38, []any{v27})
											tmp35 = tmp39
										} else {
											tmp35 = v34
										}
										tmp29 = tmp35
									} // end let
									var v30 any = tmp29
									_ = v30
									var tmp31 any
									if lang.IsTruthy(v30) {
										var tmp32 any
										{ // let
											// let binding "xs"
											var v33 any = v30
											_ = v33
											tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp36 := tmp35.FindInternedVar(lang.NewSymbol("dec"))
											if tmp36.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
											}
											tmp37 := tmp36.Get()
											tmp38 := lang.Apply(tmp37, []any{v26})
											var tmp34 any = tmp38
											tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp41 := tmp40.FindInternedVar(lang.NewSymbol("rest"))
											if tmp41.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
											}
											tmp42 := tmp41.Get()
											tmp43 := lang.Apply(tmp42, []any{v33})
											var tmp39 any = tmp43
											v26 = tmp34
											v27 = tmp39
											continue
										} // end let
										tmp31 = tmp32
									} else {
										tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp34 := tmp33.FindInternedVar(lang.NewSymbol("seq"))
										if tmp34.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
										}
										tmp35 := tmp34.Get()
										tmp36 := lang.Apply(tmp35, []any{v27})
										tmp31 = tmp36
									}
									tmp28 = tmp31
								} // end let
								tmp25 = tmp28
								break
							}
						} // end let
						tmp11 = tmp25
					}
					var v26 any = tmp11
					_ = v26
					var tmp27 any
					if lang.IsTruthy(v26) {
						tmp27 = v26
					} else {
						tmp27 = lang.NewList()
					}
					tmp10 = tmp27
				} // end let
				tmp5 = tmp10
			} else {
				tmp5 = v3
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// num
	{
		var tmp1 lang.FnFunc
		{ // function num__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Num")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("num").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to Number", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3474), lang.NewKeyword("end-line"), int(3474))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Num")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Num is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// number?
	{
		tmp0 := lang.NewSymbol("number?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a Number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3560), lang.NewKeyword("end-line"), int(3560))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.IsNumber, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// numerator
	{
		tmp1 := reflect.TypeOf((*big6.Int)(nil))
		tmp0 := lang.NewSymbol("numerator").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"))), lang.NewKeyword("doc"), "Returns the numerator part of a Ratio.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3583), lang.NewKeyword("end-line"), int(3583))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, ok := lang.FieldOrMethod(v4, "numerator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "numerator")))
			}
			var tmp6 any
			switch reflect.TypeOf(tmp5).Kind() {
			case reflect.Func:
				tmp6 = lang.Apply(tmp5, nil)
			default:
				tmp6 = tmp5
			}
			return tmp6
		})
		tmp4 := reflect.TypeOf((*big6.Int)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// object-array
	{
		var tmp1 lang.FnFunc
		{ // function object-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Object_array")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("object-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of objects", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5349), lang.NewKeyword("end-line"), int(5349))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "Object_array")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Object_array is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// odd?
	{
		tmp0 := lang.NewSymbol("odd?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is odd, throws an exception if n is not an integer", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1389), lang.NewKeyword("end-line"), int(1389))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("not"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("even?"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp9, []any{v3})
			tmp11 := lang.Apply(tmp6, []any{tmp10})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// or
	{
		tmp0 := lang.NewSymbol("or").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("next"))), lang.NewKeyword("doc"), "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(847), lang.NewKeyword("end-line"), int(847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				return v5
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/let")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("or__0__auto__")})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v5})
				tmp40 := lang.Apply(tmp31, []any{tmp35, tmp39})
				tmp41 := lang.Apply(tmp28, []any{tmp40})
				tmp42 := lang.Apply(tmp22, []any{tmp25, tmp41})
				tmp43 := lang.Apply(tmp19, []any{tmp42})
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("if")})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("or__0__auto__")})
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("or__0__auto__")})
				tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
				if tmp66.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
				}
				tmp67 := tmp66.Get()
				tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp69 := tmp68.FindInternedVar(lang.NewSymbol("seq"))
				if tmp69.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
				}
				tmp70 := tmp69.Get()
				tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp72 := tmp71.FindInternedVar(lang.NewSymbol("concat"))
				if tmp72.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
				}
				tmp73 := tmp72.Get()
				tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp75 := tmp74.FindInternedVar(lang.NewSymbol("list"))
				if tmp75.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
				}
				tmp76 := tmp75.Get()
				tmp77 := lang.Apply(tmp76, []any{lang.NewSymbol("glojure.core/or")})
				tmp78 := lang.Apply(tmp73, []any{tmp77, v6})
				tmp79 := lang.Apply(tmp70, []any{tmp78})
				tmp80 := lang.Apply(tmp67, []any{tmp79})
				tmp81 := lang.Apply(tmp52, []any{tmp56, tmp60, tmp64, tmp80})
				tmp82 := lang.Apply(tmp49, []any{tmp81})
				tmp83 := lang.Apply(tmp46, []any{tmp82})
				tmp84 := lang.Apply(tmp12, []any{tmp16, tmp43, tmp83})
				tmp85 := lang.Apply(tmp9, []any{tmp84})
				return tmp85
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parents
	{
		tmp0 := lang.NewSymbol("parents").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"))), lang.NewKeyword("doc"), "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5564), lang.NewKeyword("end-line"), int(5564))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("parents"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("global-hierarchy"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("not-empty"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				var tmp8 any
				{ // let
					// let binding "tp"
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("get"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					tmp13 := lang.Apply(tmp11, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("class?"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v4})
					if lang.IsTruthy(tmp19) {
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("into1"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("set"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("bases"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.Apply(tmp28, []any{v4})
						tmp30 := lang.Apply(tmp25, []any{tmp29})
						tmp31 := lang.Apply(tmp22, []any{tmp30, v14})
						tmp15 = tmp31
					} else {
						tmp15 = v14
					}
					tmp8 = tmp15
				} // end let
				tmp9 := lang.Apply(tmp7, []any{tmp8})
				return tmp9
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-boolean
	{
		tmp0 := lang.NewSymbol("parse-boolean").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7957), lang.NewKeyword("end-line"), int(7957))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("string?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				{ // let
					// let binding "G__353"
					var v10 any = v3
					_ = v10
				} // end let
				tmp4 = tmp9
			} else {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("parsing-err"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-double
	{
		tmp0 := lang.NewSymbol("parse-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse string with floating point components and return a Double value,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7935), lang.NewKeyword("end-line"), int(7935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("string?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				{ // let
					// let binding "result__3649__auto__"
					tmp10 := lang.Apply(strconv9.ParseFloat, []any{v3, int64(64)})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := lang.Apply(v11, []any{int64(1)})
					if lang.IsTruthy(tmp13) {
					} else {
						tmp14 := lang.Apply(v11, []any{int64(0)})
						tmp12 = tmp14
					}
					tmp9 = tmp12
				} // end let
				tmp4 = tmp9
			} else {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("parsing-err"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-impls
	{
		tmp0 := lang.NewSymbol("parse-impls").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(13), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(13), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("specs"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.NewMap()
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(14), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(14), lang.NewKeyword("end-column"), int(15))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v8 any = tmp7
				_ = v8
				// let binding "s"
				var v9 any = v3
				_ = v9
				for {
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v9})
					if lang.IsTruthy(tmp14) {
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("assoc"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v9})
						tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp24 := tmp23.FindInternedVar(lang.NewSymbol("take-while"))
						if tmp24.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
						}
						tmp25 := tmp24.Get()
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp30 := tmp29.FindInternedVar(lang.NewSymbol("next"))
						if tmp30.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
						}
						tmp31 := tmp30.Get()
						tmp32 := lang.Apply(tmp31, []any{v9})
						tmp33 := lang.Apply(tmp25, []any{tmp28, tmp32})
						tmp34 := lang.Apply(tmp18, []any{v8, tmp22, tmp33})
						var tmp15 any = tmp34
						tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp37 := tmp36.FindInternedVar(lang.NewSymbol("drop-while"))
						if tmp37.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
						}
						tmp38 := tmp37.Get()
						tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq?"))
						if tmp40.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
						}
						tmp41 := tmp40.Get()
						tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp43 := tmp42.FindInternedVar(lang.NewSymbol("next"))
						if tmp43.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
						}
						tmp44 := tmp43.Get()
						tmp45 := lang.Apply(tmp44, []any{v9})
						tmp46 := lang.Apply(tmp38, []any{tmp41, tmp45})
						var tmp35 any = tmp46
						v8 = tmp15
						v9 = tmp35
						continue
					} else {
						tmp10 = v8
					}
					tmp4 = tmp10
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-long
	{
		tmp0 := lang.NewSymbol("parse-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse string of decimal digits with optional leading -/+ and return a\n  Long value, or nil if parse fails", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7926), lang.NewKeyword("end-line"), int(7926))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("string?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				{ // let
					// let binding "result__3648__auto__"
					tmp10 := lang.Apply(strconv9.ParseInt, []any{v3, int64(10), int64(64)})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := lang.Apply(v11, []any{int64(1)})
					if lang.IsTruthy(tmp13) {
					} else {
						tmp14 := lang.Apply(v11, []any{int64(0)})
						tmp12 = tmp14
					}
					tmp9 = tmp12
				} // end let
				tmp4 = tmp9
			} else {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("parsing-err"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parse-uuid
	{
		tmp0 := lang.NewSymbol("parse-uuid").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Parse a string representing a UUID and return a java.util.UUID instance,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7946), lang.NewKeyword("end-line"), int(7946))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			func() {
				defer func() {
					if r := recover(); r != nil {
						tmp5 := reflect.TypeOf((*lang.IllegalArgumentError)(nil))
						if lang.CatchMatches(r, tmp5) {
							v6 := r
							_ = v6
						} else {
							panic(r)
						}
					}
				}()
				var tmp6 any
				{ // let
					// let binding "vec__350"
					tmp7 := lang.Apply(uuid10.Parse, []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "uuid"
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("nth"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{v8, int64(0), nil})
					var v13 any = tmp12
					_ = v13
					// let binding "err"
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("nth"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v8, int64(1), nil})
					var v18 any = tmp17
					_ = v18
					var tmp19 any
					if lang.IsTruthy(v18) {
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("str"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{"Error parsing UUID: ", v18})
						tmp24 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp23})
						panic(tmp24)
					} else {
						tmp19 = v13
					}
					tmp6 = tmp19
				} // end let
				tmp4 = tmp6
			}()
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// parsing-err
	{
		tmp0 := lang.NewSymbol("parsing-err").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Construct message for parsing for non-string parsing error", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(7921), lang.NewKeyword("end-line"), int(7921), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("str"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			var tmp7 any
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v3})
			if lang.IsTruthy(tmp11) {
				tmp7 = "nil"
			} else {
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("class"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16, ok := lang.FieldOrMethod(tmp15, "Name")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp15, "Name")))
				}
				var tmp17 any
				switch reflect.TypeOf(tmp16).Kind() {
				case reflect.Func:
					tmp17 = lang.Apply(tmp16, nil)
				default:
					tmp17 = tmp16
				}
				tmp7 = tmp17
			}
			tmp18 := lang.Apply(tmp6, []any{"Expected string, got ", tmp7})
			return tmp18
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partial
	{
		tmp0 := lang.NewSymbol("partial").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2"), lang.NewSymbol("arg3")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("arg1"), lang.NewSymbol("arg2"), lang.NewSymbol("arg3"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2606), lang.NewKeyword("end-line"), int(2606))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				return v3
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp6 := lang.Apply(v3, []any{v4})
						return tmp6
					case 1:
						v6 := args[0]
						_ = v6
						tmp7 := lang.Apply(v3, []any{v4, v6})
						return tmp7
					case 2:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v6, v7})
						return tmp8
					case 3:
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v6, v7, v8})
						return tmp9
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v6 := args[0]
						_ = v6
						v7 := args[1]
						_ = v7
						v8 := args[2]
						_ = v8
						var v9 any = lang.NewList(args[3:]...)
						_ = v9
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v3, v4, v6, v7, v8, v9})
						return tmp13
					}
				})
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2614), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2619), lang.NewKeyword("end-column"), int(48))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp7 := lang.Apply(v3, []any{v4, v5})
						return tmp7
					case 1:
						v7 := args[0]
						_ = v7
						tmp8 := lang.Apply(v3, []any{v4, v5, v7})
						return tmp8
					case 2:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v7, v8})
						return tmp9
					case 3:
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v7, v8, v9})
						return tmp10
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v7 := args[0]
						_ = v7
						v8 := args[1]
						_ = v8
						v9 := args[2]
						_ = v9
						var v10 any = lang.NewList(args[3:]...)
						_ = v10
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("apply"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v3, v4, v5, v7, v8, v9, v10})
						return tmp14
					}
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2621), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2626), lang.NewKeyword("end-column"), int(53))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					case 0:
						tmp8 := lang.Apply(v3, []any{v4, v5, v6})
						return tmp8
					case 1:
						v8 := args[0]
						_ = v8
						tmp9 := lang.Apply(v3, []any{v4, v5, v6, v8})
						return tmp9
					case 2:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						tmp10 := lang.Apply(v3, []any{v4, v5, v6, v8, v9})
						return tmp10
					case 3:
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						tmp11 := lang.Apply(v3, []any{v4, v5, v6, v8, v9, v10})
						return tmp11
					default:
						if len(args) < 3 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v8 := args[0]
						_ = v8
						v9 := args[1]
						_ = v9
						v10 := args[2]
						_ = v10
						var v11 any = lang.NewList(args[3:]...)
						_ = v11
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("apply"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v3, v4, v5, v6, v8, v9, v10, v11})
						return tmp15
					}
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2628), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2633), lang.NewKeyword("end-column"), int(58))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					switch len(args) {
					default:
						if len(args) < 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var v9 any = lang.NewList(args[0:]...)
						_ = v9
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("apply"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("concat"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v7, v9})
						tmp17 := lang.Apply(tmp12, []any{v3, v4, v5, v6, tmp16})
						return tmp17
					}
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2635), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(2635), lang.NewKeyword("end-column"), int(60))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition
	{
		tmp0 := lang.NewSymbol("partition").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("pad"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3177), lang.NewKeyword("end-line"), int(3177))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("partition"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v3, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v5})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "s"
								var v15 any = v12
								_ = v15
								var tmp16 any
								{ // let
									// let binding "p"
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("doall"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp21 := tmp20.FindInternedVar(lang.NewSymbol("take"))
									if tmp21.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
									}
									tmp22 := tmp21.Get()
									tmp23 := lang.Apply(tmp22, []any{v3, v15})
									tmp24 := lang.Apply(tmp19, []any{tmp23})
									var v25 any = tmp24
									_ = v25
									var tmp26 any
									tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp28 := tmp27.FindInternedVar(lang.NewSymbol("="))
									if tmp28.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
									}
									tmp29 := tmp28.Get()
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("count"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v25})
									tmp34 := lang.Apply(tmp29, []any{v3, tmp33})
									if lang.IsTruthy(tmp34) {
										tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp36 := tmp35.FindInternedVar(lang.NewSymbol("cons"))
										if tmp36.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
										}
										tmp37 := tmp36.Get()
										tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp39 := tmp38.FindInternedVar(lang.NewSymbol("partition"))
										if tmp39.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
										}
										tmp40 := tmp39.Get()
										tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp42 := tmp41.FindInternedVar(lang.NewSymbol("nthrest"))
										if tmp42.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
										}
										tmp43 := tmp42.Get()
										tmp44 := lang.Apply(tmp43, []any{v15, v4})
										tmp45 := lang.Apply(tmp40, []any{v3, v4, tmp44})
										tmp46 := lang.Apply(tmp37, []any{v25, tmp45})
										tmp26 = tmp46
									} else {
									}
									tmp16 = tmp26
								} // end let
								tmp14 = tmp16
							} // end let
							tmp13 = tmp14
						} else {
						}
						tmp7 = tmp13
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v6})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							var tmp15 any
							{ // let
								// let binding "s"
								var v16 any = v13
								_ = v16
								var tmp17 any
								{ // let
									// let binding "p"
									tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp19 := tmp18.FindInternedVar(lang.NewSymbol("doall"))
									if tmp19.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
									}
									tmp20 := tmp19.Get()
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("take"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.Apply(tmp23, []any{v3, v16})
									tmp25 := lang.Apply(tmp20, []any{tmp24})
									var v26 any = tmp25
									_ = v26
									var tmp27 any
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("="))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("count"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.Apply(tmp33, []any{v26})
									tmp35 := lang.Apply(tmp30, []any{v3, tmp34})
									if lang.IsTruthy(tmp35) {
										tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp37 := tmp36.FindInternedVar(lang.NewSymbol("cons"))
										if tmp37.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
										}
										tmp38 := tmp37.Get()
										tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp40 := tmp39.FindInternedVar(lang.NewSymbol("partition"))
										if tmp40.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
										}
										tmp41 := tmp40.Get()
										tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp43 := tmp42.FindInternedVar(lang.NewSymbol("nthrest"))
										if tmp43.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
										}
										tmp44 := tmp43.Get()
										tmp45 := lang.Apply(tmp44, []any{v16, v4})
										tmp46 := lang.Apply(tmp41, []any{v3, v4, v5, tmp45})
										tmp47 := lang.Apply(tmp38, []any{v26, tmp46})
										tmp27 = tmp47
									} else {
										tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
										if tmp49.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
										}
										tmp50 := tmp49.Get()
										tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp52 := tmp51.FindInternedVar(lang.NewSymbol("take"))
										if tmp52.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
										}
										tmp53 := tmp52.Get()
										tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp55 := tmp54.FindInternedVar(lang.NewSymbol("concat"))
										if tmp55.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
										}
										tmp56 := tmp55.Get()
										tmp57 := lang.Apply(tmp56, []any{v26, v5})
										tmp58 := lang.Apply(tmp53, []any{v3, tmp57})
										tmp59 := lang.Apply(tmp50, []any{tmp58})
										tmp27 = tmp59
									}
									tmp17 = tmp27
								} // end let
								tmp15 = tmp17
							} // end let
							tmp14 = tmp15
						} else {
						}
						tmp8 = tmp14
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-all
	{
		tmp0 := lang.NewSymbol("partition-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7222), lang.NewKeyword("end-line"), int(7222))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("to-array"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						tmp11 := lang.Apply(lang.NewArrayList, []any{tmp10})
						var v12 any = tmp11
						_ = v12
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp14 := lang.Apply(v5, nil)
								return tmp14
							case 1:
								v14 := args[0]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "result"
									var tmp16 any
									tmp17, ok := lang.FieldOrMethod(v12, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "isEmpty")))
									}
									var tmp18 any
									switch reflect.TypeOf(tmp17).Kind() {
									case reflect.Func:
										tmp18 = lang.Apply(tmp17, nil)
									default:
										tmp18 = tmp17
									}
									if lang.IsTruthy(tmp18) {
										tmp16 = v14
									} else {
										var tmp19 any
										{ // let
											// let binding "v"
											tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp21 := tmp20.FindInternedVar(lang.NewSymbol("vec"))
											if tmp21.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
											}
											tmp22 := tmp21.Get()
											tmp23, ok := lang.FieldOrMethod(v12, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "toArray")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											tmp25 := lang.Apply(tmp22, []any{tmp24})
											var v26 any = tmp25
											_ = v26
											tmp27, ok := lang.FieldOrMethod(v12, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "clear")))
											}
											var tmp28 any
											switch reflect.TypeOf(tmp27).Kind() {
											case reflect.Func:
												tmp28 = lang.Apply(tmp27, nil)
											default:
												tmp28 = tmp27
											}
											_ = tmp28
											tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp30 := tmp29.FindInternedVar(lang.NewSymbol("unreduced"))
											if tmp30.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
											}
											tmp31 := tmp30.Get()
											tmp32 := lang.Apply(v5, []any{v14, v26})
											tmp33 := lang.Apply(tmp31, []any{tmp32})
											tmp19 = tmp33
										} // end let
										tmp16 = tmp19
									}
									var v20 any = tmp16
									_ = v20
									tmp21 := lang.Apply(v5, []any{v20})
									tmp15 = tmp21
								} // end let
								return tmp15
							case 2:
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								tmp16, _ := lang.FieldOrMethod(v12, "add")
								if reflect.TypeOf(tmp16).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
								}
								tmp17 := lang.Apply(tmp16, []any{v15})
								_ = tmp17
								var tmp18 any
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("="))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22, ok := lang.FieldOrMethod(v12, "size")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "size")))
								}
								var tmp23 any
								switch reflect.TypeOf(tmp22).Kind() {
								case reflect.Func:
									tmp23 = lang.Apply(tmp22, nil)
								default:
									tmp23 = tmp22
								}
								tmp24 := lang.Apply(tmp21, []any{v3, tmp23})
								if lang.IsTruthy(tmp24) {
									var tmp25 any
									{ // let
										// let binding "v"
										tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp27 := tmp26.FindInternedVar(lang.NewSymbol("vec"))
										if tmp27.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
										}
										tmp28 := tmp27.Get()
										tmp29, ok := lang.FieldOrMethod(v12, "toArray")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "toArray")))
										}
										var tmp30 any
										switch reflect.TypeOf(tmp29).Kind() {
										case reflect.Func:
											tmp30 = lang.Apply(tmp29, nil)
										default:
											tmp30 = tmp29
										}
										tmp31 := lang.Apply(tmp28, []any{tmp30})
										var v32 any = tmp31
										_ = v32
										tmp33, ok := lang.FieldOrMethod(v12, "clear")
										if !ok {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v12, "clear")))
										}
										var tmp34 any
										switch reflect.TypeOf(tmp33).Kind() {
										case reflect.Func:
											tmp34 = lang.Apply(tmp33, nil)
										default:
											tmp34 = tmp33
										}
										_ = tmp34
										tmp35 := lang.Apply(v5, []any{v14, v32})
										tmp25 = tmp35
									} // end let
									tmp18 = tmp25
								} else {
									tmp18 = v14
								}
								return tmp18
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7231), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7247), lang.NewKeyword("end-column"), int(23))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp15
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7229), lang.NewKeyword("column"), int(4), lang.NewKeyword("end-line"), int(7247), lang.NewKeyword("end-column"), int(25))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("partition-all"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v3, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v5})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "s"
								var v15 any = v12
								_ = v15
								var tmp16 any
								{ // let
									// let binding "seg"
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("doall"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp21 := tmp20.FindInternedVar(lang.NewSymbol("take"))
									if tmp21.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
									}
									tmp22 := tmp21.Get()
									tmp23 := lang.Apply(tmp22, []any{v3, v15})
									tmp24 := lang.Apply(tmp19, []any{tmp23})
									var v25 any = tmp24
									_ = v25
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("cons"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("partition-all"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("nthrest"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v15, v4})
									tmp36 := lang.Apply(tmp31, []any{v3, v4, tmp35})
									tmp37 := lang.Apply(tmp28, []any{v25, tmp36})
									tmp16 = tmp37
								} // end let
								tmp14 = tmp16
							} // end let
							tmp13 = tmp14
						} else {
						}
						tmp7 = tmp13
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partition-by
	{
		tmp0 := lang.NewSymbol("partition-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7142), lang.NewKeyword("end-line"), int(7142))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "a"
						var v7 any = "unimplemented: new with non-constant class type"
						_ = v7
						// let binding "pv"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{lang.NewKeyword("glojure.core/none")})
						var v12 any = tmp11
						_ = v12
						var tmp13 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp14 := lang.Apply(v5, nil)
								return tmp14
							case 1:
								v14 := args[0]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "result"
									var tmp16 any
									tmp17, ok := lang.FieldOrMethod(v7, "isEmpty")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "isEmpty")))
									}
									var tmp18 any
									switch reflect.TypeOf(tmp17).Kind() {
									case reflect.Func:
										tmp18 = lang.Apply(tmp17, nil)
									default:
										tmp18 = tmp17
									}
									if lang.IsTruthy(tmp18) {
										tmp16 = v14
									} else {
										var tmp19 any
										{ // let
											// let binding "v"
											tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp21 := tmp20.FindInternedVar(lang.NewSymbol("vec"))
											if tmp21.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
											}
											tmp22 := tmp21.Get()
											tmp23, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp24 any
											switch reflect.TypeOf(tmp23).Kind() {
											case reflect.Func:
												tmp24 = lang.Apply(tmp23, nil)
											default:
												tmp24 = tmp23
											}
											tmp25 := lang.Apply(tmp22, []any{tmp24})
											var v26 any = tmp25
											_ = v26
											tmp27, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp28 any
											switch reflect.TypeOf(tmp27).Kind() {
											case reflect.Func:
												tmp28 = lang.Apply(tmp27, nil)
											default:
												tmp28 = tmp27
											}
											_ = tmp28
											tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp30 := tmp29.FindInternedVar(lang.NewSymbol("unreduced"))
											if tmp30.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
											}
											tmp31 := tmp30.Get()
											tmp32 := lang.Apply(v5, []any{v14, v26})
											tmp33 := lang.Apply(tmp31, []any{tmp32})
											tmp19 = tmp33
										} // end let
										tmp16 = tmp19
									}
									var v20 any = tmp16
									_ = v20
									tmp21 := lang.Apply(v5, []any{v20})
									tmp15 = tmp21
								} // end let
								return tmp15
							case 2:
								v14 := args[0]
								_ = v14
								v15 := args[1]
								_ = v15
								var tmp16 any
								{ // let
									// let binding "pval"
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("deref"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.Apply(tmp19, []any{v12})
									var v21 any = tmp20
									_ = v21
									// let binding "val"
									tmp22 := lang.Apply(v3, []any{v15})
									var v23 any = tmp22
									_ = v23
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("vreset!"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v12, v23})
									_ = tmp27
									var tmp28 any
									var tmp29 any
									{ // let
										// let binding "or__0__auto__"
										tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp31 := tmp30.FindInternedVar(lang.NewSymbol("identical?"))
										if tmp31.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
										}
										tmp32 := tmp31.Get()
										tmp33 := lang.Apply(tmp32, []any{v21, lang.NewKeyword("glojure.core/none")})
										var v34 any = tmp33
										_ = v34
										var tmp35 any
										if lang.IsTruthy(v34) {
											tmp35 = v34
										} else {
											tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp37 := tmp36.FindInternedVar(lang.NewSymbol("="))
											if tmp37.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
											}
											tmp38 := tmp37.Get()
											tmp39 := lang.Apply(tmp38, []any{v23, v21})
											tmp35 = tmp39
										}
										tmp29 = tmp35
									} // end let
									if lang.IsTruthy(tmp29) {
										tmp30, _ := lang.FieldOrMethod(v7, "add")
										if reflect.TypeOf(tmp30).Kind() != reflect.Func {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
										}
										tmp31 := lang.Apply(tmp30, []any{v15})
										_ = tmp31
										tmp28 = v14
									} else {
										var tmp32 any
										{ // let
											// let binding "v"
											tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp34 := tmp33.FindInternedVar(lang.NewSymbol("vec"))
											if tmp34.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
											}
											tmp35 := tmp34.Get()
											tmp36, ok := lang.FieldOrMethod(v7, "toArray")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "toArray")))
											}
											var tmp37 any
											switch reflect.TypeOf(tmp36).Kind() {
											case reflect.Func:
												tmp37 = lang.Apply(tmp36, nil)
											default:
												tmp37 = tmp36
											}
											tmp38 := lang.Apply(tmp35, []any{tmp37})
											var v39 any = tmp38
											_ = v39
											tmp40, ok := lang.FieldOrMethod(v7, "clear")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "clear")))
											}
											var tmp41 any
											switch reflect.TypeOf(tmp40).Kind() {
											case reflect.Func:
												tmp41 = lang.Apply(tmp40, nil)
											default:
												tmp41 = tmp40
											}
											_ = tmp41
											var tmp42 any
											{ // let
												// let binding "ret"
												tmp43 := lang.Apply(v5, []any{v14, v39})
												var v44 any = tmp43
												_ = v44
												var tmp45 any
												tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp47 := tmp46.FindInternedVar(lang.NewSymbol("reduced?"))
												if tmp47.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
												}
												tmp48 := tmp47.Get()
												tmp49 := lang.Apply(tmp48, []any{v44})
												if lang.IsTruthy(tmp49) {
												} else {
													tmp50, _ := lang.FieldOrMethod(v7, "add")
													if reflect.TypeOf(tmp50).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("add is not a function")))
													}
													tmp51 := lang.Apply(tmp50, []any{v15})
													tmp45 = tmp51
												}
												_ = tmp45
												tmp42 = v44
											} // end let
											tmp32 = tmp42
										} // end let
										tmp28 = tmp32
									}
									tmp16 = tmp28
								} // end let
								return tmp16
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7152), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7176), lang.NewKeyword("end-column"), int(28))
						tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp15
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7149), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7176), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								{ // let
									// let binding "fst"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19 := lang.Apply(tmp18, []any{v14})
									var v20 any = tmp19
									_ = v20
									// let binding "fv"
									tmp21 := lang.Apply(v3, []any{v20})
									var v22 any = tmp21
									_ = v22
									// let binding "run"
									tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp24 := tmp23.FindInternedVar(lang.NewSymbol("cons"))
									if tmp24.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
									}
									tmp25 := tmp24.Get()
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("take-while"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									var tmp29 lang.FnFunc
									tmp29 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v30 := args[0]
										_ = v30
										tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp32 := tmp31.FindInternedVar(lang.NewSymbol("="))
										if tmp32.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
										}
										tmp33 := tmp32.Get()
										tmp34 := lang.Apply(v3, []any{v30})
										tmp35 := lang.Apply(tmp33, []any{v22, tmp34})
										return tmp35
									})
									tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7182), lang.NewKeyword("column"), int(41), lang.NewKeyword("end-line"), int(7182), lang.NewKeyword("end-column"), int(53))
									tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("next"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v14})
									tmp36 := lang.Apply(tmp28, []any{tmp31, tmp35})
									tmp37 := lang.Apply(tmp25, []any{v20, tmp36})
									var v38 any = tmp37
									_ = v38
									tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp40 := tmp39.FindInternedVar(lang.NewSymbol("cons"))
									if tmp40.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
									}
									tmp41 := tmp40.Get()
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("partition-by"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									var tmp45 lang.FnFunc
									tmp45 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 0 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp47 := tmp46.FindInternedVar(lang.NewSymbol("drop"))
										if tmp47.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
										}
										tmp48 := tmp47.Get()
										tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp50 := tmp49.FindInternedVar(lang.NewSymbol("count"))
										if tmp50.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
										}
										tmp51 := tmp50.Get()
										tmp52 := lang.Apply(tmp51, []any{v38})
										tmp53 := lang.Apply(tmp48, []any{tmp52, v14})
										return tmp53
									})
									tmp46 := lang.Apply(lang.NewLazySeq, []any{tmp45})
									tmp47 := lang.Apply(tmp44, []any{v3, tmp46})
									tmp48 := lang.Apply(tmp41, []any{v38, tmp47})
									tmp15 = tmp48
								} // end let
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv
	{
		tmp0 := lang.NewSymbol("partitionv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("pad"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of vectors of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7262), lang.NewKeyword("end-line"), int(7262))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("partitionv"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v3, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v5})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "s"
								var v15 any = v12
								_ = v15
								var tmp16 any
								{ // let
									// let binding "p"
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("into"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.NewVector()
									tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7274), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(7274), lang.NewKeyword("end-column"), int(23))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp24 := tmp23.FindInternedVar(lang.NewSymbol("take"))
									if tmp24.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
									}
									tmp25 := tmp24.Get()
									tmp26 := lang.Apply(tmp25, []any{v3})
									tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26, v15})
									var v28 any = tmp27
									_ = v28
									var tmp29 any
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
									if tmp34.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
									}
									tmp35 := tmp34.Get()
									tmp36 := lang.Apply(tmp35, []any{v28})
									tmp37 := lang.Apply(tmp32, []any{v3, tmp36})
									if lang.IsTruthy(tmp37) {
										tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp39 := tmp38.FindInternedVar(lang.NewSymbol("cons"))
										if tmp39.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
										}
										tmp40 := tmp39.Get()
										tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp42 := tmp41.FindInternedVar(lang.NewSymbol("partitionv"))
										if tmp42.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
										}
										tmp43 := tmp42.Get()
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("nthrest"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.Apply(tmp46, []any{v15, v4})
										tmp48 := lang.Apply(tmp43, []any{v3, v4, tmp47})
										tmp49 := lang.Apply(tmp40, []any{v28, tmp48})
										tmp29 = tmp49
									} else {
									}
									tmp16 = tmp29
								} // end let
								tmp14 = tmp16
							} // end let
							tmp13 = tmp14
						} else {
						}
						tmp7 = tmp13
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp8 any
					{ // let
						// let binding "temp__0__auto__"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v6})
						var v13 any = tmp12
						_ = v13
						var tmp14 any
						if lang.IsTruthy(v13) {
							var tmp15 any
							{ // let
								// let binding "s"
								var v16 any = v13
								_ = v16
								var tmp17 any
								{ // let
									// let binding "p"
									tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp19 := tmp18.FindInternedVar(lang.NewSymbol("into"))
									if tmp19.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
									}
									tmp20 := tmp19.Get()
									tmp21 := lang.NewVector()
									tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7280), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(7280), lang.NewKeyword("end-column"), int(23))
									tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("take"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v3})
									tmp28 := lang.Apply(tmp20, []any{tmp23, tmp27, v16})
									var v29 any = tmp28
									_ = v29
									var tmp30 any
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("="))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp35 := tmp34.FindInternedVar(lang.NewSymbol("count"))
									if tmp35.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
									}
									tmp36 := tmp35.Get()
									tmp37 := lang.Apply(tmp36, []any{v29})
									tmp38 := lang.Apply(tmp33, []any{v3, tmp37})
									if lang.IsTruthy(tmp38) {
										tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp40 := tmp39.FindInternedVar(lang.NewSymbol("cons"))
										if tmp40.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
										}
										tmp41 := tmp40.Get()
										tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp43 := tmp42.FindInternedVar(lang.NewSymbol("partitionv"))
										if tmp43.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
										}
										tmp44 := tmp43.Get()
										tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp46 := tmp45.FindInternedVar(lang.NewSymbol("nthrest"))
										if tmp46.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
										}
										tmp47 := tmp46.Get()
										tmp48 := lang.Apply(tmp47, []any{v16, v4})
										tmp49 := lang.Apply(tmp44, []any{v3, v4, v5, tmp48})
										tmp50 := lang.Apply(tmp41, []any{v29, tmp49})
										tmp30 = tmp50
									} else {
										tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp52 := tmp51.FindInternedVar(lang.NewSymbol("list"))
										if tmp52.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
										}
										tmp53 := tmp52.Get()
										tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp55 := tmp54.FindInternedVar(lang.NewSymbol("into"))
										if tmp55.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
										}
										tmp56 := tmp55.Get()
										tmp57 := lang.NewVector()
										tmp58 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7283), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7283), lang.NewKeyword("end-column"), int(25))
										tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp61 := tmp60.FindInternedVar(lang.NewSymbol("take"))
										if tmp61.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
										}
										tmp62 := tmp61.Get()
										tmp63 := lang.Apply(tmp62, []any{v3})
										tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp65 := tmp64.FindInternedVar(lang.NewSymbol("concat"))
										if tmp65.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
										}
										tmp66 := tmp65.Get()
										tmp67 := lang.Apply(tmp66, []any{v29, v5})
										tmp68 := lang.Apply(tmp56, []any{tmp59, tmp63, tmp67})
										tmp69 := lang.Apply(tmp53, []any{tmp68})
										tmp30 = tmp69
									}
									tmp17 = tmp30
								} // end let
								tmp15 = tmp17
							} // end let
							tmp14 = tmp15
						} else {
						}
						tmp8 = tmp14
					} // end let
					return tmp8
				})
				tmp8 := lang.Apply(lang.NewLazySeq, []any{tmp7})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// partitionv-all
	{
		tmp0 := lang.NewSymbol("partitionv-all").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("step"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of vector partitions, but may include\n  partitions with fewer than n items at the end.\n  Returns a stateful transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7285), lang.NewKeyword("end-line"), int(7285))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("partition-all"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("partitionv-all"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3, v3, v4})
				return tmp8
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp7 any
					{ // let
						// let binding "temp__0__auto__"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("seq"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.Apply(tmp10, []any{v5})
						var v12 any = tmp11
						_ = v12
						var tmp13 any
						if lang.IsTruthy(v12) {
							var tmp14 any
							{ // let
								// let binding "s"
								var v15 any = v12
								_ = v15
								var tmp16 any
								{ // let
									// let binding "seg"
									tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp18 := tmp17.FindInternedVar(lang.NewSymbol("into"))
									if tmp18.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
									}
									tmp19 := tmp18.Get()
									tmp20 := lang.NewVector()
									tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7297), lang.NewKeyword("column"), int(24), lang.NewKeyword("end-line"), int(7297), lang.NewKeyword("end-column"), int(25))
									tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp24 := tmp23.FindInternedVar(lang.NewSymbol("take"))
									if tmp24.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
									}
									tmp25 := tmp24.Get()
									tmp26 := lang.Apply(tmp25, []any{v3})
									tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26, v5})
									var v28 any = tmp27
									_ = v28
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("cons"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("partitionv-all"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp36 := tmp35.FindInternedVar(lang.NewSymbol("drop"))
									if tmp36.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
									}
									tmp37 := tmp36.Get()
									tmp38 := lang.Apply(tmp37, []any{v4, v15})
									tmp39 := lang.Apply(tmp34, []any{v3, v4, tmp38})
									tmp40 := lang.Apply(tmp31, []any{v28, tmp39})
									tmp16 = tmp40
								} // end let
								tmp14 = tmp16
							} // end let
							tmp13 = tmp14
						} else {
						}
						tmp7 = tmp13
					} // end let
					return tmp7
				})
				tmp7 := lang.Apply(lang.NewLazySeq, []any{tmp6})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pcalls
	{
		tmp0 := lang.NewSymbol("pcalls").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("fns"))), lang.NewKeyword("doc"), "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7056), lang.NewKeyword("end-line"), int(7056))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("pmap"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					tmp9 := lang.Apply(v8, nil)
					return tmp9
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7061), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(7061), lang.NewKeyword("end-column"), int(20))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// peek
	{
		tmp0 := lang.NewSymbol("peek").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1455), lang.NewKeyword("end-line"), int(1455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.RT, "Peek")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Peek is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// persistent!
	{
		tmp0 := lang.NewSymbol("persistent!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3350), lang.NewKeyword("end-line"), int(3350))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "Persistent")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "Persistent")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pmap
	{
		tmp0 := lang.NewSymbol("pmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7031), lang.NewKeyword("end-line"), int(7031))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "n"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("+"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(runtime11.NumCPU, nil)
					tmp10 := lang.Apply(tmp8, []any{int64(2), tmp9})
					var v11 any = tmp10
					_ = v11
					// let binding "rets"
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("map"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					var tmp15 lang.FnFunc
					tmp15 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v16 := args[0]
						_ = v16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("future-call"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						var tmp20 lang.FnFunc
						tmp20 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp21 := lang.Apply(v3, []any{v16})
							return tmp21
						})
						tmp21 := lang.Apply(tmp19, []any{tmp20})
						return tmp21
					})
					tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7041), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7041), lang.NewKeyword("end-column"), int(34))
					tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp18 := lang.Apply(tmp14, []any{tmp17, v4})
					var v19 any = tmp18
					_ = v19
					// let binding "step"
					var tmp20 lang.FnFunc
					{ // function step
						var v21 lang.FnFunc
						tmp20 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v22 := args[0]
							_ = v22
							v23 := args[1]
							_ = v23
							var tmp24 any
							{ // let
								// let binding "vec__323"
								var v25 any = v22
								_ = v25
								// let binding "seq__324"
								tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
								if tmp27.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
								}
								tmp28 := tmp27.Get()
								tmp29 := lang.Apply(tmp28, []any{v25})
								var v30 any = tmp29
								_ = v30
								// let binding "first__325"
								tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp32 := tmp31.FindInternedVar(lang.NewSymbol("first"))
								if tmp32.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
								}
								tmp33 := tmp32.Get()
								tmp34 := lang.Apply(tmp33, []any{v30})
								var v35 any = tmp34
								_ = v35
								// let binding "seq__324"
								tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp37 := tmp36.FindInternedVar(lang.NewSymbol("next"))
								if tmp37.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
								}
								tmp38 := tmp37.Get()
								tmp39 := lang.Apply(tmp38, []any{v30})
								var v40 any = tmp39
								_ = v40
								// let binding "x"
								var v41 any = v35
								_ = v41
								// let binding "xs"
								var v42 any = v40
								_ = v42
								// let binding "vs"
								var v43 any = v25
								_ = v43
								var tmp44 lang.FnFunc
								tmp44 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 0 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									var tmp45 any
									{ // let
										// let binding "temp__0__auto__"
										tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp47 := tmp46.FindInternedVar(lang.NewSymbol("seq"))
										if tmp47.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
										}
										tmp48 := tmp47.Get()
										tmp49 := lang.Apply(tmp48, []any{v23})
										var v50 any = tmp49
										_ = v50
										var tmp51 any
										if lang.IsTruthy(v50) {
											var tmp52 any
											{ // let
												// let binding "s"
												var v53 any = v50
												_ = v53
												tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp55 := tmp54.FindInternedVar(lang.NewSymbol("cons"))
												if tmp55.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
												}
												tmp56 := tmp55.Get()
												tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp58 := tmp57.FindInternedVar(lang.NewSymbol("deref"))
												if tmp58.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
												}
												tmp59 := tmp58.Get()
												tmp60 := lang.Apply(tmp59, []any{v41})
												tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp62 := tmp61.FindInternedVar(lang.NewSymbol("rest"))
												if tmp62.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
												}
												tmp63 := tmp62.Get()
												tmp64 := lang.Apply(tmp63, []any{v53})
												tmp65 := lang.Apply(v21, []any{v42, tmp64})
												tmp66 := lang.Apply(tmp56, []any{tmp60, tmp65})
												tmp52 = tmp66
											} // end let
											tmp51 = tmp52
										} else {
											tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp54 := tmp53.FindInternedVar(lang.NewSymbol("map"))
											if tmp54.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
											}
											tmp55 := tmp54.Get()
											tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp57 := tmp56.FindInternedVar(lang.NewSymbol("deref"))
											if tmp57.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
											}
											tmp58 := tmp57.Get()
											tmp59 := lang.Apply(tmp55, []any{tmp58, v43})
											tmp51 = tmp59
										}
										tmp45 = tmp51
									} // end let
									return tmp45
								})
								tmp45 := lang.Apply(lang.NewLazySeq, []any{tmp44})
								tmp24 = tmp45
							} // end let
							return tmp24
						})
						v21 = tmp20
						_ = v21
					}
					tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7042), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7046), lang.NewKeyword("end-column"), int(36))
					tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v23 any = tmp22
					_ = v23
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("drop"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v11, v19})
					tmp28 := lang.Apply(v23, []any{v19, tmp27})
					tmp5 = tmp28
				} // end let
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "step"
					var tmp7 lang.FnFunc
					{ // function step
						var v8 lang.FnFunc
						tmp7 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v9 := args[0]
							_ = v9
							var tmp10 lang.FnFunc
							tmp10 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp11 any
								{ // let
									// let binding "ss"
									tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp13 := tmp12.FindInternedVar(lang.NewSymbol("map"))
									if tmp13.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
									}
									tmp14 := tmp13.Get()
									tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp16 := tmp15.FindInternedVar(lang.NewSymbol("seq"))
									if tmp16.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
									}
									tmp17 := tmp16.Get()
									tmp18 := lang.Apply(tmp14, []any{tmp17, v9})
									var v19 any = tmp18
									_ = v19
									var tmp20 any
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("every?"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("identity"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp23, []any{tmp26, v19})
									if lang.IsTruthy(tmp27) {
										tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp29 := tmp28.FindInternedVar(lang.NewSymbol("cons"))
										if tmp29.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
										}
										tmp30 := tmp29.Get()
										tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp32 := tmp31.FindInternedVar(lang.NewSymbol("map"))
										if tmp32.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
										}
										tmp33 := tmp32.Get()
										tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
										if tmp35.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
										}
										tmp36 := tmp35.Get()
										tmp37 := lang.Apply(tmp33, []any{tmp36, v19})
										tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp39 := tmp38.FindInternedVar(lang.NewSymbol("map"))
										if tmp39.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
										}
										tmp40 := tmp39.Get()
										tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp42 := tmp41.FindInternedVar(lang.NewSymbol("rest"))
										if tmp42.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
										}
										tmp43 := tmp42.Get()
										tmp44 := lang.Apply(tmp40, []any{tmp43, v19})
										tmp45 := lang.Apply(v8, []any{tmp44})
										tmp46 := lang.Apply(tmp30, []any{tmp37, tmp45})
										tmp20 = tmp46
									} else {
									}
									tmp11 = tmp20
								} // end let
								return tmp11
							})
							tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
							return tmp11
						})
						v8 = tmp7
						_ = v8
					}
					tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7049), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7053), lang.NewKeyword("end-column"), int(67))
					tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v10 any = tmp9
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("pmap"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					var tmp14 lang.FnFunc
					tmp14 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v15 := args[0]
						_ = v15
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("apply"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v3, v15})
						return tmp19
					})
					tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7054), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(7054), lang.NewKeyword("end-column"), int(23))
					tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("cons"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v4, v5})
					tmp21 := lang.Apply(v10, []any{tmp20})
					tmp22 := lang.Apply(tmp13, []any{tmp16, tmp21})
					tmp6 = tmp22
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop
	{
		tmp0 := lang.NewSymbol("pop").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1462), lang.NewKeyword("end-line"), int(1462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.RT, "Pop")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Pop is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop!
	{
		tmp0 := lang.NewSymbol("pop!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3393), lang.NewKeyword("end-line"), int(3393))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "pop")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "pop")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pop-thread-bindings
	{
		tmp0 := lang.NewSymbol("pop-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1929), lang.NewKeyword("end-line"), int(1929))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(lang.PopThreadBindings, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos-int?
	{
		tmp0 := lang.NewSymbol("pos-int?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a positive fixed precision integer", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1403), lang.NewKeyword("end-line"), int(1403))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("int?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("pos?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3})
					tmp10 = tmp14
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pos?
	{
		var tmp1 lang.FnFunc
		{ // function pos?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/IsPos")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("pos?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is greater than zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1252), lang.NewKeyword("end-line"), int(1252))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsPos")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsPos is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr
	{
		tmp0 := lang.NewSymbol("pr").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3678), lang.NewKeyword("end-line"), int(3678), lang.NewKeyword("dynamic"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return nil
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("pr-on"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*out*"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{v3, tmp9})
				return tmp10
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
			recur_loop_671:
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("pr"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				_ = tmp8
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("*out*"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(lang.AppendWriter, []any{tmp11, lang.NewChar(32)})
				_ = tmp12
				var tmp13 any
				{ // let
					// let binding "temp__0__auto__"
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("next"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v4})
					var v18 any = tmp17
					_ = v18
					var tmp19 any
					if lang.IsTruthy(v18) {
						var tmp20 any
						{ // let
							// let binding "nmore"
							var v21 any = v18
							_ = v21
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.Apply(tmp25, []any{v4})
							var tmp22 any = tmp26
							var tmp27 any = v21
							v3 = tmp22
							v4 = tmp27
							goto recur_loop_671
						} // end let
						tmp19 = tmp20
					} else {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("apply"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("pr"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp23, []any{tmp26, v4})
						tmp19 = tmp27
					}
					tmp13 = tmp19
				} // end let
				return tmp13
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-on
	{
		tmp0 := lang.NewSymbol("pr-on").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("w"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3669), lang.NewKeyword("end-line"), int(3669), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*print-dup*"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("print-dup"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3, v4})
				tmp5 = tmp12
			} else {
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("print-method"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3, v4})
				tmp5 = tmp16
			}
			_ = tmp5
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pr-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("pr-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "pr to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4758), lang.NewKeyword("end-line"), int(4758))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v6})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						_ = tmp16
						var tmp17 any
						func() {
							defer func() {
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, nil)
								_ = tmp21
							}()
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("apply"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("pr"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp24, []any{tmp27, v4})
							_ = tmp28
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("str"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v6})
							tmp17 = tmp32
						}()
						tmp7 = tmp17
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefer-method
	{
		tmp0 := lang.NewSymbol("prefer-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val-x"), lang.NewSymbol("dispatch-val-y"))), lang.NewKeyword("doc"), "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1801), lang.NewKeyword("end-line"), int(1801))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(v3, "PreferMethod")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("PreferMethod is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prefers
	{
		tmp0 := lang.NewSymbol("prefers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Given a multimethod, returns a map of preferred value -> set of other values", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1822), lang.NewKeyword("end-line"), int(1822))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getPreferTable")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getPreferTable")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-hashes
	{
		tmp0 := lang.NewSymbol("prep-hashes").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr-sym"), lang.NewSymbol("default"), lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6683), lang.NewKeyword("end-line"), int(6683), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			var tmp7 any
			{ // let
				// let binding "hashcode"
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v9 := args[0]
					_ = v9
					tmp10 := lang.Apply(lang.Hash, []any{v9})
					return tmp10
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6691), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6691), lang.NewKeyword("end-column"), int(66))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v11 any = tmp10
				_ = v11
				// let binding "hashes"
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("into1"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
				tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6692), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(6692), lang.NewKeyword("end-column"), int(25))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("map"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{v11, v5})
				tmp22 := lang.Apply(tmp14, []any{tmp17, tmp21})
				var v23 any = tmp22
				_ = v23
				var tmp24 any
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("=="))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("count"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{v5})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("count"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v23})
				tmp36 := lang.Apply(tmp27, []any{tmp31, tmp35})
				if lang.IsTruthy(tmp36) {
					var tmp37 any
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("fits-table?"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp40, []any{v23})
					if lang.IsTruthy(tmp41) {
						tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp43 := tmp42.FindInternedVar(lang.NewSymbol("case-map"))
						if tmp43.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
						}
						tmp44 := tmp43.Get()
						tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp46 := tmp45.FindInternedVar(lang.NewSymbol("identity"))
						if tmp46.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
						}
						tmp47 := tmp46.Get()
						tmp48 := lang.Apply(tmp44, []any{v11, tmp47, v5, v6})
						tmp49 := lang.NewVector(int64(0), int64(0), tmp48, lang.NewKeyword("compact"))
						tmp50 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6696), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6696), lang.NewKeyword("end-column"), int(63))
						tmp51, err := lang.WithMeta(tmp49, tmp50.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp37 = tmp51
					} else {
						var tmp52 any
						{ // let
							// let binding "vec__167"
							var tmp53 any
							{ // let
								// let binding "or__0__auto__"
								tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp55 := tmp54.FindInternedVar(lang.NewSymbol("maybe-min-hash"))
								if tmp55.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
								}
								tmp56 := tmp55.Get()
								tmp57 := lang.Apply(tmp56, []any{v23})
								var v58 any = tmp57
								_ = v58
								var tmp59 any
								if lang.IsTruthy(v58) {
									tmp59 = v58
								} else {
									tmp60 := lang.NewVector(int64(0), int64(0))
									tmp61 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6697), lang.NewKeyword("column"), int(56), lang.NewKeyword("end-line"), int(6697), lang.NewKeyword("end-column"), int(60))
									tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp59 = tmp62
								}
								tmp53 = tmp59
							} // end let
							var v54 any = tmp53
							_ = v54
							// let binding "shift"
							tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp56 := tmp55.FindInternedVar(lang.NewSymbol("nth"))
							if tmp56.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
							}
							tmp57 := tmp56.Get()
							tmp58 := lang.Apply(tmp57, []any{v54, int64(0), nil})
							var v59 any = tmp58
							_ = v59
							// let binding "mask"
							tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp61 := tmp60.FindInternedVar(lang.NewSymbol("nth"))
							if tmp61.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
							}
							tmp62 := tmp61.Get()
							tmp63 := lang.Apply(tmp62, []any{v54, int64(1), nil})
							var v64 any = tmp63
							_ = v64
							var tmp65 any
							tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp67 := tmp66.FindInternedVar(lang.NewSymbol("zero?"))
							if tmp67.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
							}
							tmp68 := tmp67.Get()
							tmp69 := lang.Apply(tmp68, []any{v64})
							if lang.IsTruthy(tmp69) {
								tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp71 := tmp70.FindInternedVar(lang.NewSymbol("case-map"))
								if tmp71.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
								}
								tmp72 := tmp71.Get()
								tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp74 := tmp73.FindInternedVar(lang.NewSymbol("identity"))
								if tmp74.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
								}
								tmp75 := tmp74.Get()
								tmp76 := lang.Apply(tmp72, []any{v11, tmp75, v5, v6})
								tmp77 := lang.NewVector(int64(0), int64(0), tmp76, lang.NewKeyword("sparse"))
								tmp78 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6700), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6700), lang.NewKeyword("end-column"), int(66))
								tmp79, err := lang.WithMeta(tmp77, tmp78.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp65 = tmp79
							} else {
								tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp81 := tmp80.FindInternedVar(lang.NewSymbol("case-map"))
								if tmp81.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
								}
								tmp82 := tmp81.Get()
								var tmp83 lang.FnFunc
								tmp83 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v84 := args[0]
									_ = v84
									tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp86 := tmp85.FindInternedVar(lang.NewSymbol("shift-mask"))
									if tmp86.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
									}
									tmp87 := tmp86.Get()
									tmp88 := lang.Apply(v11, []any{v84})
									tmp89 := lang.Apply(tmp87, []any{v59, v64, tmp88})
									return tmp89
								})
								tmp84 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6702), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(6702), lang.NewKeyword("end-column"), int(71))
								tmp85, err := lang.WithMeta(tmp83, tmp84.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp87 := tmp86.FindInternedVar(lang.NewSymbol("identity"))
								if tmp87.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
								}
								tmp88 := tmp87.Get()
								tmp89 := lang.Apply(tmp82, []any{tmp85, tmp88, v5, v6})
								tmp90 := lang.NewVector(v59, v64, tmp89, lang.NewKeyword("compact"))
								tmp91 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6702), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(6702), lang.NewKeyword("end-column"), int(103))
								tmp92, err := lang.WithMeta(tmp90, tmp91.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp65 = tmp92
							}
							tmp52 = tmp65
						} // end let
						tmp37 = tmp52
					}
					tmp24 = tmp37
				} else {
					var tmp53 any
					{ // let
						// let binding "vec__170"
						tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp55 := tmp54.FindInternedVar(lang.NewSymbol("merge-hash-collisions"))
						if tmp55.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
						}
						tmp56 := tmp55.Get()
						tmp57 := lang.Apply(tmp56, []any{v3, v4, v5, v6})
						var v58 any = tmp57
						_ = v58
						// let binding "tests"
						tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp60 := tmp59.FindInternedVar(lang.NewSymbol("nth"))
						if tmp60.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
						}
						tmp61 := tmp60.Get()
						tmp62 := lang.Apply(tmp61, []any{v58, int64(0), nil})
						var v63 any = tmp62
						_ = v63
						// let binding "thens"
						tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp65 := tmp64.FindInternedVar(lang.NewSymbol("nth"))
						if tmp65.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
						}
						tmp66 := tmp65.Get()
						tmp67 := lang.Apply(tmp66, []any{v58, int64(1), nil})
						var v68 any = tmp67
						_ = v68
						// let binding "skip-check"
						tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp70 := tmp69.FindInternedVar(lang.NewSymbol("nth"))
						if tmp70.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
						}
						tmp71 := tmp70.Get()
						tmp72 := lang.Apply(tmp71, []any{v58, int64(2), nil})
						var v73 any = tmp72
						_ = v73
						// let binding "vec__173"
						tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp75 := tmp74.FindInternedVar(lang.NewSymbol("prep-hashes"))
						if tmp75.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
						}
						tmp76 := tmp75.Get()
						tmp77 := lang.Apply(tmp76, []any{v3, v4, v63, v68})
						var v78 any = tmp77
						_ = v78
						// let binding "shift"
						tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp80 := tmp79.FindInternedVar(lang.NewSymbol("nth"))
						if tmp80.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
						}
						tmp81 := tmp80.Get()
						tmp82 := lang.Apply(tmp81, []any{v78, int64(0), nil})
						var v83 any = tmp82
						_ = v83
						// let binding "mask"
						tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp85 := tmp84.FindInternedVar(lang.NewSymbol("nth"))
						if tmp85.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
						}
						tmp86 := tmp85.Get()
						tmp87 := lang.Apply(tmp86, []any{v78, int64(1), nil})
						var v88 any = tmp87
						_ = v88
						// let binding "case-map"
						tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp90 := tmp89.FindInternedVar(lang.NewSymbol("nth"))
						if tmp90.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
						}
						tmp91 := tmp90.Get()
						tmp92 := lang.Apply(tmp91, []any{v78, int64(2), nil})
						var v93 any = tmp92
						_ = v93
						// let binding "switch-type"
						tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp95 := tmp94.FindInternedVar(lang.NewSymbol("nth"))
						if tmp95.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
						}
						tmp96 := tmp95.Get()
						tmp97 := lang.Apply(tmp96, []any{v78, int64(3), nil})
						var v98 any = tmp97
						_ = v98
						// let binding "skip-check"
						var tmp99 any
						tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp101 := tmp100.FindInternedVar(lang.NewSymbol("zero?"))
						if tmp101.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
						}
						tmp102 := tmp101.Get()
						tmp103 := lang.Apply(tmp102, []any{v88})
						if lang.IsTruthy(tmp103) {
							tmp99 = v73
						} else {
							tmp104 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp105 := tmp104.FindInternedVar(lang.NewSymbol("into1"))
							if tmp105.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp105)))
							}
							tmp106 := tmp105.Get()
							tmp107 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
							tmp108 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6708), lang.NewKeyword("column"), int(33), lang.NewKeyword("end-line"), int(6708), lang.NewKeyword("end-column"), int(35))
							tmp109, err := lang.WithMeta(tmp107, tmp108.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp111 := tmp110.FindInternedVar(lang.NewSymbol("map"))
							if tmp111.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
							}
							tmp112 := tmp111.Get()
							var tmp113 lang.FnFunc
							tmp113 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 1 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v114 := args[0]
								_ = v114
								tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp116 := tmp115.FindInternedVar(lang.NewSymbol("shift-mask"))
								if tmp116.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
								}
								tmp117 := tmp116.Get()
								tmp118 := lang.Apply(tmp117, []any{v83, v88, v114})
								return tmp118
							})
							tmp114 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6708), lang.NewKeyword("column"), int(42), lang.NewKeyword("end-line"), int(6708), lang.NewKeyword("end-column"), int(67))
							tmp115, err := lang.WithMeta(tmp113, tmp114.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp116 := lang.Apply(tmp112, []any{tmp115, v73})
							tmp117 := lang.Apply(tmp106, []any{tmp109, tmp116})
							tmp99 = tmp117
						}
						var v118 any = tmp99
						_ = v118
						tmp119 := lang.NewVector(v83, v88, v93, v98, v118)
						tmp120 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6709), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6709), lang.NewKeyword("end-column"), int(52))
						tmp121, err := lang.WithMeta(tmp119, tmp120.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp53 = tmp121
					} // end let
					tmp24 = tmp53
				}
				tmp7 = tmp24
			} // end let
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prep-ints
	{
		tmp0 := lang.NewSymbol("prep-ints").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tests"), lang.NewSymbol("thens"))), lang.NewKeyword("doc"), "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6631), lang.NewKeyword("end-line"), int(6631), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("fits-table?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v3})
			if lang.IsTruthy(tmp9) {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("case-map"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("int"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("int"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp12, []any{tmp15, tmp18, v3, v4})
				tmp20 := lang.NewVector(int64(0), int64(0), tmp19, lang.NewKeyword("compact"))
				tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6639), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(6639), lang.NewKeyword("end-column"), int(49))
				tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp5 = tmp22
			} else {
				var tmp23 any
				{ // let
					// let binding "vec__160"
					var tmp24 any
					{ // let
						// let binding "or__0__auto__"
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("maybe-min-hash"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("map"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("int"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp30, []any{tmp33, v3})
						tmp35 := lang.Apply(tmp27, []any{tmp34})
						var v36 any = tmp35
						_ = v36
						var tmp37 any
						if lang.IsTruthy(v36) {
							tmp37 = v36
						} else {
							tmp38 := lang.NewVector(int64(0), int64(0))
							tmp39 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6640), lang.NewKeyword("column"), int(61), lang.NewKeyword("end-line"), int(6640), lang.NewKeyword("end-column"), int(65))
							tmp40, err := lang.WithMeta(tmp38, tmp39.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp37 = tmp40
						}
						tmp24 = tmp37
					} // end let
					var v25 any = tmp24
					_ = v25
					// let binding "shift"
					tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp27 := tmp26.FindInternedVar(lang.NewSymbol("nth"))
					if tmp27.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
					}
					tmp28 := tmp27.Get()
					tmp29 := lang.Apply(tmp28, []any{v25, int64(0), nil})
					var v30 any = tmp29
					_ = v30
					// let binding "mask"
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("nth"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{v25, int64(1), nil})
					var v35 any = tmp34
					_ = v35
					var tmp36 any
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("zero?"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp39, []any{v35})
					if lang.IsTruthy(tmp40) {
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("case-map"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("int"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp48 := tmp47.FindInternedVar(lang.NewSymbol("int"))
						if tmp48.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
						}
						tmp49 := tmp48.Get()
						tmp50 := lang.Apply(tmp43, []any{tmp46, tmp49, v3, v4})
						tmp51 := lang.NewVector(int64(0), int64(0), tmp50, lang.NewKeyword("sparse"))
						tmp52 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6643), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6643), lang.NewKeyword("end-column"), int(52))
						tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp36 = tmp53
					} else {
						tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp55 := tmp54.FindInternedVar(lang.NewSymbol("case-map"))
						if tmp55.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
						}
						tmp56 := tmp55.Get()
						var tmp57 lang.FnFunc
						tmp57 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v58 := args[0]
							_ = v58
							tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp60 := tmp59.FindInternedVar(lang.NewSymbol("shift-mask"))
							if tmp60.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
							}
							tmp61 := tmp60.Get()
							tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp63 := tmp62.FindInternedVar(lang.NewSymbol("int"))
							if tmp63.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
							}
							tmp64 := tmp63.Get()
							tmp65 := lang.Apply(tmp64, []any{v58})
							tmp66 := lang.Apply(tmp61, []any{v30, v35, tmp65})
							return tmp66
						})
						tmp58 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6645), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(6645), lang.NewKeyword("end-column"), int(62))
						tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp61 := tmp60.FindInternedVar(lang.NewSymbol("int"))
						if tmp61.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
						}
						tmp62 := tmp61.Get()
						tmp63 := lang.Apply(tmp56, []any{tmp59, tmp62, v3, v4})
						tmp64 := lang.NewVector(v30, v35, tmp63, lang.NewKeyword("compact"))
						tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6645), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(6645), lang.NewKeyword("end-column"), int(89))
						tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp36 = tmp66
					}
					tmp23 = tmp36
				} // end let
				tmp5 = tmp23
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prependss
	{
		tmp0 := lang.NewSymbol("prependss").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Prepends a symbol or a seq to coll", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5857), lang.NewKeyword("end-line"), int(5857), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("symbol?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v3})
			if lang.IsTruthy(tmp9) {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("cons"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v3, v4})
				tmp5 = tmp13
			} else {
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("concat"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3, v4})
				tmp5 = tmp17
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// preserving-reduced
	{
		tmp0 := lang.NewSymbol("preserving-reduced").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7638), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7638), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rf"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 lang.FnFunc
			tmp4 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				v6 := args[1]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ret"
					tmp8 := lang.Apply(v3, []any{v5, v6})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduced?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v9})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("reduced"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v9})
						tmp10 = tmp18
					} else {
						tmp10 = v9
					}
					tmp7 = tmp10
				} // end let
				return tmp7
			})
			tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7640), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7643), lang.NewKeyword("end-column"), int(12))
			tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print
	{
		tmp0 := lang.NewSymbol("print").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3725), lang.NewKeyword("end-line"), int(3725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-readably*"))
					tmp12 := lang.Apply(tmp10, []any{tmp11, nil})
					tmp13 := lang.Apply(tmp7, []any{tmp12})
					_ = tmp13
					var tmp14 any
					func() {
						defer func() {
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, nil)
							_ = tmp18
						}()
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("apply"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("pr"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp21, []any{tmp24, v3})
						tmp14 = tmp25
					}()
					tmp4 = tmp14
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-ctor
	{
		tmp0 := lang.NewSymbol("print-ctor").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(95), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(95), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("print-args"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.Apply(lang.WriteWriter, []any{v5, "#=("})
			_ = tmp6
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("class"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp9, []any{v3})
			tmp11, ok := lang.FieldOrMethod(tmp10, "Name")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp10, "Name")))
			}
			var tmp12 any
			switch reflect.TypeOf(tmp11).Kind() {
			case reflect.Func:
				tmp12 = lang.Apply(tmp11, nil)
			default:
				tmp12 = tmp11
			}
			tmp13 := lang.Apply(lang.WriteWriter, []any{v5, tmp12})
			_ = tmp13
			tmp14 := lang.Apply(lang.WriteWriter, []any{v5, ". "})
			_ = tmp14
			tmp15 := lang.Apply(v4, []any{v3, v5})
			_ = tmp15
			tmp16 := lang.Apply(lang.WriteWriter, []any{v5, ")"})
			return tmp16
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-dup
	{
		tmp0 := lang.NewSymbol("print-dup").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3667), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(3667), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-initialized
	{
		tmp0 := lang.NewSymbol("print-initialized").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(520), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(520), lang.NewKeyword("end-column"), int(39), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, true, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-map
	{
		tmp0 := lang.NewSymbol("print-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(252), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(252), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("print-one"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("print-prefix-map"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{nil, v3, v4, v5})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-meta
	{
		tmp0 := lang.NewSymbol("print-meta").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(70), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(70), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("meta"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				if lang.IsTruthy(v10) {
					var tmp12 any
					{ // let
						// let binding "m"
						var v13 any = v10
						_ = v13
						var tmp14 any
						var tmp15 any
						{ // let
							// let binding "and__0__auto__"
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("pos?"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("count"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.Apply(tmp21, []any{v13})
							tmp23 := lang.Apply(tmp18, []any{tmp22})
							var v24 any = tmp23
							_ = v24
							var tmp25 any
							if lang.IsTruthy(v24) {
								var tmp26 any
								{ // let
									// let binding "or__0__auto__"
									tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp28 := tmp27.FindInternedVar(lang.NewSymbol("*print-dup*"))
									if tmp28.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
									}
									tmp29 := tmp28.Get()
									var v30 any = tmp29
									_ = v30
									var tmp31 any
									if lang.IsTruthy(v30) {
										tmp31 = v30
									} else {
										var tmp32 any
										{ // let
											// let binding "and__0__auto__"
											tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp34 := tmp33.FindInternedVar(lang.NewSymbol("*print-meta*"))
											if tmp34.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
											}
											tmp35 := tmp34.Get()
											var v36 any = tmp35
											_ = v36
											var tmp37 any
											if lang.IsTruthy(v36) {
												tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp39 := tmp38.FindInternedVar(lang.NewSymbol("*print-readably*"))
												if tmp39.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
												}
												tmp40 := tmp39.Get()
												tmp37 = tmp40
											} else {
												tmp37 = v36
											}
											tmp32 = tmp37
										} // end let
										tmp31 = tmp32
									}
									tmp26 = tmp31
								} // end let
								tmp25 = tmp26
							} else {
								tmp25 = v24
							}
							tmp15 = tmp25
						} // end let
						if lang.IsTruthy(tmp15) {
							tmp16 := lang.Apply(lang.WriteWriter, []any{v4, "^"})
							_ = tmp16
							var tmp17 any
							var tmp18 any
							{ // let
								// let binding "and__0__auto__"
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("="))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("count"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v13})
								tmp26 := lang.Apply(tmp21, []any{tmp25, int64(1)})
								var v27 any = tmp26
								_ = v27
								var tmp28 any
								if lang.IsTruthy(v27) {
									tmp29 := lang.Apply(lang.NewKeyword("tag"), []any{v13})
									tmp28 = tmp29
								} else {
									tmp28 = v27
								}
								tmp18 = tmp28
							} // end let
							if lang.IsTruthy(tmp18) {
								tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp20 := tmp19.FindInternedVar(lang.NewSymbol("pr-on"))
								if tmp20.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
								}
								tmp21 := tmp20.Get()
								tmp22 := lang.Apply(lang.NewKeyword("tag"), []any{v13})
								tmp23 := lang.Apply(tmp21, []any{tmp22, v4})
								tmp17 = tmp23
							} else {
								tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp25 := tmp24.FindInternedVar(lang.NewSymbol("pr-on"))
								if tmp25.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
								}
								tmp26 := tmp25.Get()
								tmp27 := lang.Apply(tmp26, []any{v13, v4})
								tmp17 = tmp27
							}
							_ = tmp17
							tmp28 := lang.Apply(lang.WriteWriter, []any{v4, " "})
							tmp14 = tmp28
						} else {
						}
						tmp12 = tmp14
					} // end let
					tmp11 = tmp12
				} else {
				}
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-method
	{
		tmp0 := lang.NewSymbol("print-method").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3664), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(3664), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, nil, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-object
	{
		tmp0 := lang.NewSymbol("print-object").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(115), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(115), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("print-tagged-object"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("str"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v3})
			tmp12 := lang.Apply(tmp7, []any{v3, tmp11, v4})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-prefix-map
	{
		tmp0 := lang.NewSymbol("print-prefix-map").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(243), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(243), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prefix"), lang.NewSymbol("kvs"), lang.NewSymbol("print-one"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 4 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("print-sequential"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("str"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp12, []any{v3, "{"})
			var tmp14 lang.FnFunc
			tmp14 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v15 := args[0]
				_ = v15
				v16 := args[1]
				_ = v16
				var tmp17 any
				{ // let
					// let binding "vec__212"
					var v18 any = v15
					_ = v18
					// let binding "k"
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("nth"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v18, int64(0), nil})
					var v23 any = tmp22
					_ = v23
					// let binding "v"
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("nth"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v18, int64(1), nil})
					var v28 any = tmp27
					_ = v28
					tmp29 := lang.Apply(v5, []any{v23, v16})
					_ = tmp29
					tmp30 := lang.Apply(lang.AppendWriter, []any{v16, lang.NewChar(32)})
					_ = tmp30
					tmp31 := lang.Apply(v5, []any{v28, v16})
					tmp17 = tmp31
				} // end let
				return tmp17
			})
			tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(246), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(247), lang.NewKeyword("end-column"), int(107))
			tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp17 := lang.Apply(tmp9, []any{tmp13, tmp16, ", ", "}", v4, v6})
			return tmp17
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-sequential
	{
		tmp0 := lang.NewSymbol("print-sequential").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(46), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(46), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("begin"), lang.NewSymbol("print-one"), lang.NewSymbol("sep"), lang.NewSymbol("end"), lang.NewSymbol("sequence"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 6 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			v6 := args[3]
			_ = v6
			v7 := args[4]
			_ = v7
			v8 := args[5]
			_ = v8
			var tmp9 any
			{ // let
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("hash-map"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-level*"))
				var tmp17 any
				{ // let
					// let binding "and__0__auto__"
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("not"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("*print-dup*"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp20, []any{tmp23})
					var v25 any = tmp24
					_ = v25
					var tmp26 any
					if lang.IsTruthy(v25) {
						var tmp27 any
						{ // let
							// let binding "and__0__auto__"
							tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp29 := tmp28.FindInternedVar(lang.NewSymbol("*print-level*"))
							if tmp29.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
							}
							tmp30 := tmp29.Get()
							var v31 any = tmp30
							_ = v31
							var tmp32 any
							if lang.IsTruthy(v31) {
								tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp34 := tmp33.FindInternedVar(lang.NewSymbol("dec"))
								if tmp34.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
								}
								tmp35 := tmp34.Get()
								tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp37 := tmp36.FindInternedVar(lang.NewSymbol("*print-level*"))
								if tmp37.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
								}
								tmp38 := tmp37.Get()
								tmp39 := lang.Apply(tmp35, []any{tmp38})
								tmp32 = tmp39
							} else {
								tmp32 = v31
							}
							tmp27 = tmp32
						} // end let
						tmp26 = tmp27
					} else {
						tmp26 = v25
					}
					tmp17 = tmp26
				} // end let
				tmp18 := lang.Apply(tmp15, []any{tmp16, tmp17})
				tmp19 := lang.Apply(tmp12, []any{tmp18})
				_ = tmp19
				var tmp20 any
				func() {
					defer func() {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, nil)
						_ = tmp24
					}()
					var tmp25 any
					var tmp26 any
					{ // let
						// let binding "and__0__auto__"
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("*print-level*"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						var v30 any = tmp29
						_ = v30
						var tmp31 any
						if lang.IsTruthy(v30) {
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("neg?"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp36 := tmp35.FindInternedVar(lang.NewSymbol("*print-level*"))
							if tmp36.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
							}
							tmp37 := tmp36.Get()
							tmp38 := lang.Apply(tmp34, []any{tmp37})
							tmp31 = tmp38
						} else {
							tmp31 = v30
						}
						tmp26 = tmp31
					} // end let
					if lang.IsTruthy(tmp26) {
						tmp27 := lang.Apply(lang.WriteWriter, []any{v8, "#"})
						tmp25 = tmp27
					} else {
						tmp28 := lang.Apply(lang.WriteWriter, []any{v8, v3})
						_ = tmp28
						var tmp29 any
						{ // let
							// let binding "temp__0__auto__"
							tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp31 := tmp30.FindInternedVar(lang.NewSymbol("seq"))
							if tmp31.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
							}
							tmp32 := tmp31.Get()
							tmp33 := lang.Apply(tmp32, []any{v7})
							var v34 any = tmp33
							_ = v34
							var tmp35 any
							if lang.IsTruthy(v34) {
								var tmp36 any
								{ // let
									// let binding "xs"
									var v37 any = v34
									_ = v37
									var tmp38 any
									var tmp39 any
									{ // let
										// let binding "and__0__auto__"
										tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp41 := tmp40.FindInternedVar(lang.NewSymbol("not"))
										if tmp41.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
										}
										tmp42 := tmp41.Get()
										tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp44 := tmp43.FindInternedVar(lang.NewSymbol("*print-dup*"))
										if tmp44.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
										}
										tmp45 := tmp44.Get()
										tmp46 := lang.Apply(tmp42, []any{tmp45})
										var v47 any = tmp46
										_ = v47
										var tmp48 any
										if lang.IsTruthy(v47) {
											tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp50 := tmp49.FindInternedVar(lang.NewSymbol("*print-length*"))
											if tmp50.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
											}
											tmp51 := tmp50.Get()
											tmp48 = tmp51
										} else {
											tmp48 = v47
										}
										tmp39 = tmp48
									} // end let
									if lang.IsTruthy(tmp39) {
										var tmp40 any
										{ // let
											// let binding "G__194"
											var v41 any = v37
											_ = v41
											// let binding "vec__195"
											var v42 any = v41
											_ = v42
											// let binding "seq__196"
											tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
											if tmp44.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
											}
											tmp45 := tmp44.Get()
											tmp46 := lang.Apply(tmp45, []any{v42})
											var v47 any = tmp46
											_ = v47
											// let binding "first__197"
											tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp49 := tmp48.FindInternedVar(lang.NewSymbol("first"))
											if tmp49.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
											}
											tmp50 := tmp49.Get()
											tmp51 := lang.Apply(tmp50, []any{v47})
											var v52 any = tmp51
											_ = v52
											// let binding "seq__196"
											tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp54 := tmp53.FindInternedVar(lang.NewSymbol("next"))
											if tmp54.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
											}
											tmp55 := tmp54.Get()
											tmp56 := lang.Apply(tmp55, []any{v47})
											var v57 any = tmp56
											_ = v57
											// let binding "x"
											var v58 any = v52
											_ = v58
											// let binding "xs"
											var v59 any = v57
											_ = v59
											// let binding "print-length"
											tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp61 := tmp60.FindInternedVar(lang.NewSymbol("*print-length*"))
											if tmp61.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
											}
											tmp62 := tmp61.Get()
											var v63 any = tmp62
											_ = v63
											var tmp64 any
											{ // let
												// let binding "G__194"
												var v65 any = v41
												_ = v65
												// let binding "print-length"
												var v66 any = v63
												_ = v66
												for {
													var tmp67 any
													{ // let
														// let binding "vec__198"
														var v68 any = v65
														_ = v68
														// let binding "seq__199"
														tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp70 := tmp69.FindInternedVar(lang.NewSymbol("seq"))
														if tmp70.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
														}
														tmp71 := tmp70.Get()
														tmp72 := lang.Apply(tmp71, []any{v68})
														var v73 any = tmp72
														_ = v73
														// let binding "first__200"
														tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp75 := tmp74.FindInternedVar(lang.NewSymbol("first"))
														if tmp75.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
														}
														tmp76 := tmp75.Get()
														tmp77 := lang.Apply(tmp76, []any{v73})
														var v78 any = tmp77
														_ = v78
														// let binding "seq__199"
														tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp80 := tmp79.FindInternedVar(lang.NewSymbol("next"))
														if tmp80.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
														}
														tmp81 := tmp80.Get()
														tmp82 := lang.Apply(tmp81, []any{v73})
														var v83 any = tmp82
														_ = v83
														// let binding "x"
														var v84 any = v78
														_ = v84
														// let binding "xs"
														var v85 any = v83
														_ = v85
														// let binding "print-length"
														var v86 any = v66
														_ = v86
														var tmp87 any
														tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp89 := tmp88.FindInternedVar(lang.NewSymbol("zero?"))
														if tmp89.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
														}
														tmp90 := tmp89.Get()
														tmp91 := lang.Apply(tmp90, []any{v86})
														if lang.IsTruthy(tmp91) {
															tmp92 := lang.Apply(lang.WriteWriter, []any{v8, "..."})
															tmp87 = tmp92
														} else {
															tmp93 := lang.Apply(v4, []any{v84, v8})
															_ = tmp93
															var tmp94 any
															if lang.IsTruthy(v85) {
																tmp95 := lang.Apply(lang.WriteWriter, []any{v8, v5})
																_ = tmp95
																var tmp96 any = v85
																tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp99 := tmp98.FindInternedVar(lang.NewSymbol("dec"))
																if tmp99.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
																}
																tmp100 := tmp99.Get()
																tmp101 := lang.Apply(tmp100, []any{v86})
																var tmp97 any = tmp101
																v65 = tmp96
																v66 = tmp97
																continue
															} else {
															}
															tmp87 = tmp94
														}
														tmp67 = tmp87
													} // end let
													tmp64 = tmp67
													break
												}
											} // end let
											tmp40 = tmp64
										} // end let
										tmp38 = tmp40
									} else {
										var tmp41 any
										{ // let
											// let binding "G__204"
											var v42 any = v37
											_ = v42
											// let binding "vec__205"
											var v43 any = v42
											_ = v43
											// let binding "seq__206"
											tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq"))
											if tmp45.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
											}
											tmp46 := tmp45.Get()
											tmp47 := lang.Apply(tmp46, []any{v43})
											var v48 any = tmp47
											_ = v48
											// let binding "first__207"
											tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp50 := tmp49.FindInternedVar(lang.NewSymbol("first"))
											if tmp50.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
											}
											tmp51 := tmp50.Get()
											tmp52 := lang.Apply(tmp51, []any{v48})
											var v53 any = tmp52
											_ = v53
											// let binding "seq__206"
											tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp55 := tmp54.FindInternedVar(lang.NewSymbol("next"))
											if tmp55.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
											}
											tmp56 := tmp55.Get()
											tmp57 := lang.Apply(tmp56, []any{v48})
											var v58 any = tmp57
											_ = v58
											// let binding "x"
											var v59 any = v53
											_ = v59
											// let binding "xs"
											var v60 any = v58
											_ = v60
											var tmp61 any
											{ // let
												// let binding "G__204"
												var v62 any = v42
												_ = v62
												for {
													var tmp63 any
													{ // let
														// let binding "vec__208"
														var v64 any = v62
														_ = v64
														// let binding "seq__209"
														tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp66 := tmp65.FindInternedVar(lang.NewSymbol("seq"))
														if tmp66.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
														}
														tmp67 := tmp66.Get()
														tmp68 := lang.Apply(tmp67, []any{v64})
														var v69 any = tmp68
														_ = v69
														// let binding "first__210"
														tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp71 := tmp70.FindInternedVar(lang.NewSymbol("first"))
														if tmp71.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
														}
														tmp72 := tmp71.Get()
														tmp73 := lang.Apply(tmp72, []any{v69})
														var v74 any = tmp73
														_ = v74
														// let binding "seq__209"
														tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp76 := tmp75.FindInternedVar(lang.NewSymbol("next"))
														if tmp76.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
														}
														tmp77 := tmp76.Get()
														tmp78 := lang.Apply(tmp77, []any{v69})
														var v79 any = tmp78
														_ = v79
														// let binding "x"
														var v80 any = v74
														_ = v80
														// let binding "xs"
														var v81 any = v79
														_ = v81
														tmp82 := lang.Apply(v4, []any{v80, v8})
														_ = tmp82
														var tmp83 any
														if lang.IsTruthy(v81) {
															tmp84 := lang.Apply(lang.WriteWriter, []any{v8, v5})
															_ = tmp84
															var tmp85 any = v81
															v62 = tmp85
															continue
														} else {
														}
														tmp63 = tmp83
													} // end let
													tmp61 = tmp63
													break
												}
											} // end let
											tmp41 = tmp61
										} // end let
										tmp38 = tmp41
									}
									tmp36 = tmp38
								} // end let
								tmp35 = tmp36
							} else {
							}
							tmp29 = tmp35
						} // end let
						_ = tmp29
						tmp30 := lang.Apply(lang.WriteWriter, []any{v8, v6})
						tmp25 = tmp30
					}
					tmp20 = tmp25
				}()
				tmp9 = tmp20
			} // end let
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-simple
	{
		tmp0 := lang.NewSymbol("print-simple").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(81), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(81), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("print-meta"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			_ = tmp8
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("str"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp11, []any{v3})
			tmp13 := lang.Apply(lang.WriteWriter, []any{v4, tmp12})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("print-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "print to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4776), lang.NewKeyword("end-line"), int(4776))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v6})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						_ = tmp16
						var tmp17 any
						func() {
							defer func() {
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, nil)
								_ = tmp21
							}()
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("apply"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("print"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp24, []any{tmp27, v4})
							_ = tmp28
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("str"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v6})
							tmp17 = tmp32
						}()
						tmp7 = tmp17
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-tagged-object
	{
		tmp0 := lang.NewSymbol("print-tagged-object").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(102), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(102), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("rep"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := reflect.TypeOf((*lang.IMeta)(nil)).Elem()
			tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
			if lang.IsTruthy(tmp11) {
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("print-meta"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3, v5})
				tmp6 = tmp15
			} else {
			}
			_ = tmp6
			tmp16 := lang.Apply(lang.WriteWriter, []any{v5, "#object["})
			_ = tmp16
			var tmp17 any
			{ // let
				// let binding "c"
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("class"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{v3})
				var v22 any = tmp21
				_ = v22
				var tmp23 any
				if lang.IsTruthy(false) {
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("print-method"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27, ok := lang.FieldOrMethod(v22, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v22, "Name")))
					}
					var tmp28 any
					switch reflect.TypeOf(tmp27).Kind() {
					case reflect.Func:
						tmp28 = lang.Apply(tmp27, nil)
					default:
						tmp28 = tmp27
					}
					tmp29 := lang.Apply(tmp26, []any{tmp28, v5})
					tmp23 = tmp29
				} else {
					tmp30, ok := lang.FieldOrMethod(v22, "Name")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v22, "Name")))
					}
					var tmp31 any
					switch reflect.TypeOf(tmp30).Kind() {
					case reflect.Func:
						tmp31 = lang.Apply(tmp30, nil)
					default:
						tmp31 = tmp30
					}
					tmp32 := lang.Apply(lang.WriteWriter, []any{v5, tmp31})
					tmp23 = tmp32
				}
				tmp17 = tmp23
			} // end let
			_ = tmp17
			tmp18 := lang.Apply(lang.WriteWriter, []any{v5, " "})
			_ = tmp18
			tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp20 := tmp19.FindInternedVar(lang.NewSymbol("format"))
			if tmp20.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
			}
			tmp21 := tmp20.Get()
			tmp22 := lang.Apply(lang.IdentityHash, []any{v3})
			tmp23 := lang.Apply(tmp21, []any{"0x%x ", tmp22})
			tmp24 := lang.Apply(lang.WriteWriter, []any{v5, tmp23})
			_ = tmp24
			tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp26 := tmp25.FindInternedVar(lang.NewSymbol("print-method"))
			if tmp26.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
			}
			tmp27 := tmp26.Get()
			tmp28 := lang.Apply(tmp27, []any{v4, v5})
			_ = tmp28
			tmp29 := lang.Apply(lang.WriteWriter, []any{v5, "]"})
			return tmp29
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// print-throwable
	{
		tmp0 := lang.NewSymbol("print-throwable").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(478), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(478), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("o"), lang.NewSymbol("w"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(lang.WriteWriter, []any{v4, "#error {\n :cause "})
			_ = tmp5
			var tmp6 any
			{ // let
				// let binding "map__253"
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("Throwable->map"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v3})
				var v11 any = tmp10
				_ = v11
				// let binding "map__253"
				var tmp12 any
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("seq?"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v11})
				if lang.IsTruthy(tmp16) {
					var tmp17 any
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("next"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{v11})
					if lang.IsTruthy(tmp21) {
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("to-array"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v11})
						tmp26 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp25})
						tmp17 = tmp26
					} else {
						var tmp27 any
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("seq"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.Apply(tmp30, []any{v11})
						if lang.IsTruthy(tmp31) {
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("first"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := lang.Apply(tmp34, []any{v11})
							tmp27 = tmp35
						} else {
						}
						tmp17 = tmp27
					}
					tmp12 = tmp17
				} else {
					tmp12 = v11
				}
				var v36 any = tmp12
				_ = v36
				// let binding "cause"
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("get"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.Apply(tmp39, []any{v36, lang.NewKeyword("cause")})
				var v41 any = tmp40
				_ = v41
				// let binding "data"
				tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp43 := tmp42.FindInternedVar(lang.NewSymbol("get"))
				if tmp43.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
				}
				tmp44 := tmp43.Get()
				tmp45 := lang.Apply(tmp44, []any{v36, lang.NewKeyword("data")})
				var v46 any = tmp45
				_ = v46
				// let binding "via"
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("get"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.Apply(tmp49, []any{v36, lang.NewKeyword("via")})
				var v51 any = tmp50
				_ = v51
				// let binding "trace"
				tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp53 := tmp52.FindInternedVar(lang.NewSymbol("get"))
				if tmp53.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
				}
				tmp54 := tmp53.Get()
				tmp55 := lang.Apply(tmp54, []any{v36, lang.NewKeyword("trace")})
				var v56 any = tmp55
				_ = v56
				// let binding "print-via"
				var tmp57 lang.FnFunc
				tmp57 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v58 := args[0]
					_ = v58
					tmp59 := lang.Apply(lang.WriteWriter, []any{v4, "{:type "})
					_ = tmp59
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("print-method"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.Apply(lang.NewKeyword("type"), []any{v58})
					tmp64 := lang.Apply(tmp62, []any{tmp63, v4})
					_ = tmp64
					tmp65 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :message "})
					_ = tmp65
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("print-method"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(lang.NewKeyword("message"), []any{v58})
					tmp70 := lang.Apply(tmp68, []any{tmp69, v4})
					_ = tmp70
					var tmp71 any
					{ // let
						// let binding "temp__0__auto__"
						tmp72 := lang.Apply(lang.NewKeyword("data"), []any{v58})
						var v73 any = tmp72
						_ = v73
						var tmp74 any
						if lang.IsTruthy(v73) {
							var tmp75 any
							{ // let
								// let binding "data"
								var v76 any = v73
								_ = v76
								tmp77 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :data "})
								_ = tmp77
								tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp79 := tmp78.FindInternedVar(lang.NewSymbol("print-method"))
								if tmp79.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
								}
								tmp80 := tmp79.Get()
								tmp81 := lang.Apply(tmp80, []any{v76, v4})
								tmp75 = tmp81
							} // end let
							tmp74 = tmp75
						} else {
						}
						tmp71 = tmp74
					} // end let
					_ = tmp71
					var tmp72 any
					{ // let
						// let binding "temp__0__auto__"
						tmp73 := lang.Apply(lang.NewKeyword("at"), []any{v58})
						var v74 any = tmp73
						_ = v74
						var tmp75 any
						if lang.IsTruthy(v74) {
							var tmp76 any
							{ // let
								// let binding "at"
								var v77 any = v74
								_ = v77
								tmp78 := lang.Apply(lang.WriteWriter, []any{v4, "\n   :at "})
								_ = tmp78
								tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp80 := tmp79.FindInternedVar(lang.NewSymbol("print-method"))
								if tmp80.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
								}
								tmp81 := tmp80.Get()
								tmp82 := lang.Apply(lang.NewKeyword("at"), []any{v58})
								tmp83 := lang.Apply(tmp81, []any{tmp82, v4})
								tmp76 = tmp83
							} // end let
							tmp75 = tmp76
						} else {
						}
						tmp72 = tmp75
					} // end let
					_ = tmp72
					tmp73 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
					return tmp73
				})
				tmp58 := lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(481), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(491), lang.NewKeyword("end-column"), int(73))
				tmp59, err := lang.WithMeta(tmp57, tmp58.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v60 any = tmp59
				_ = v60
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("print-method"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.Apply(tmp63, []any{v41, v4})
				_ = tmp64
				var tmp65 any
				if lang.IsTruthy(v46) {
					tmp66 := lang.Apply(lang.WriteWriter, []any{v4, "\n :data "})
					_ = tmp66
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("print-method"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.Apply(tmp69, []any{v46, v4})
					tmp65 = tmp70
				} else {
				}
				_ = tmp65
				var tmp71 any
				if lang.IsTruthy(v51) {
					tmp72 := lang.Apply(lang.WriteWriter, []any{v4, "\n :via\n ["})
					_ = tmp72
					var tmp73 any
					{ // let
						// let binding "temp__0__auto__"
						tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp75 := tmp74.FindInternedVar(lang.NewSymbol("first"))
						if tmp75.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
						}
						tmp76 := tmp75.Get()
						tmp77 := lang.Apply(tmp76, []any{v51})
						var v78 any = tmp77
						_ = v78
						var tmp79 any
						if lang.IsTruthy(v78) {
							var tmp80 any
							{ // let
								// let binding "fv"
								var v81 any = v78
								_ = v81
								tmp82 := lang.Apply(v60, []any{v81})
								_ = tmp82
								var tmp83 any
								{ // let
									// let binding "seq_254"
									tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp85 := tmp84.FindInternedVar(lang.NewSymbol("seq"))
									if tmp85.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
									}
									tmp86 := tmp85.Get()
									tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp88 := tmp87.FindInternedVar(lang.NewSymbol("rest"))
									if tmp88.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
									}
									tmp89 := tmp88.Get()
									tmp90 := lang.Apply(tmp89, []any{v51})
									tmp91 := lang.Apply(tmp86, []any{tmp90})
									var v92 any = tmp91
									_ = v92
									// let binding "chunk_255"
									var v93 any = nil
									_ = v93
									// let binding "count_256"
									var v94 any = int64(0)
									_ = v94
									// let binding "i_257"
									var v95 any = int64(0)
									_ = v95
									for {
										var tmp96 any
										tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp98 := tmp97.FindInternedVar(lang.NewSymbol("<"))
										if tmp98.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
										}
										tmp99 := tmp98.Get()
										tmp100 := lang.Apply(tmp99, []any{v95, v94})
										if lang.IsTruthy(tmp100) {
											var tmp101 any
											{ // let
												// let binding "v"
												tmp102, _ := lang.FieldOrMethod(v93, "nth")
												if reflect.TypeOf(tmp102).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp103 := lang.Apply(tmp102, []any{v95})
												var v104 any = tmp103
												_ = v104
												tmp105 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp105
												tmp106 := lang.Apply(v60, []any{v104})
												_ = tmp106
												var tmp107 any = v92
												var tmp108 any = v93
												var tmp109 any = v94
												tmp111 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp112 := tmp111.FindInternedVar(lang.NewSymbol("unchecked-inc"))
												if tmp112.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp112)))
												}
												tmp113 := tmp112.Get()
												tmp114 := lang.Apply(tmp113, []any{v95})
												var tmp110 any = tmp114
												v92 = tmp107
												v93 = tmp108
												v94 = tmp109
												v95 = tmp110
												continue
											} // end let
											tmp96 = tmp101
										} else {
											var tmp102 any
											{ // let
												// let binding "temp__0__auto__"
												tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp104 := tmp103.FindInternedVar(lang.NewSymbol("seq"))
												if tmp104.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
												}
												tmp105 := tmp104.Get()
												tmp106 := lang.Apply(tmp105, []any{v92})
												var v107 any = tmp106
												_ = v107
												var tmp108 any
												if lang.IsTruthy(v107) {
													var tmp109 any
													{ // let
														// let binding "seq_254"
														var v110 any = v107
														_ = v110
														var tmp111 any
														tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp113 := tmp112.FindInternedVar(lang.NewSymbol("chunked-seq?"))
														if tmp113.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
														}
														tmp114 := tmp113.Get()
														tmp115 := lang.Apply(tmp114, []any{v110})
														if lang.IsTruthy(tmp115) {
															var tmp116 any
															{ // let
																// let binding "c__0__auto__"
																tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp118 := tmp117.FindInternedVar(lang.NewSymbol("chunk-first"))
																if tmp118.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
																}
																tmp119 := tmp118.Get()
																tmp120 := lang.Apply(tmp119, []any{v110})
																var v121 any = tmp120
																_ = v121
																tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp124 := tmp123.FindInternedVar(lang.NewSymbol("chunk-rest"))
																if tmp124.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
																}
																tmp125 := tmp124.Get()
																tmp126 := lang.Apply(tmp125, []any{v110})
																var tmp122 any = tmp126
																var tmp127 any = v121
																tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp130 := tmp129.FindInternedVar(lang.NewSymbol("int"))
																if tmp130.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
																}
																tmp131 := tmp130.Get()
																tmp132 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp133 := tmp132.FindInternedVar(lang.NewSymbol("count"))
																if tmp133.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp133)))
																}
																tmp134 := tmp133.Get()
																tmp135 := lang.Apply(tmp134, []any{v121})
																tmp136 := lang.Apply(tmp131, []any{tmp135})
																var tmp128 any = tmp136
																tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp139 := tmp138.FindInternedVar(lang.NewSymbol("int"))
																if tmp139.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
																}
																tmp140 := tmp139.Get()
																tmp141 := lang.Apply(tmp140, []any{int64(0)})
																var tmp137 any = tmp141
																v92 = tmp122
																v93 = tmp127
																v94 = tmp128
																v95 = tmp137
																continue
															} // end let
															tmp111 = tmp116
														} else {
															var tmp117 any
															{ // let
																// let binding "v"
																tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp119 := tmp118.FindInternedVar(lang.NewSymbol("first"))
																if tmp119.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
																}
																tmp120 := tmp119.Get()
																tmp121 := lang.Apply(tmp120, []any{v110})
																var v122 any = tmp121
																_ = v122
																tmp123 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp123
																tmp124 := lang.Apply(v60, []any{v122})
																_ = tmp124
																tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp127 := tmp126.FindInternedVar(lang.NewSymbol("next"))
																if tmp127.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
																}
																tmp128 := tmp127.Get()
																tmp129 := lang.Apply(tmp128, []any{v110})
																var tmp125 any = tmp129
																var tmp130 any = nil
																var tmp131 any = int64(0)
																var tmp132 any = int64(0)
																v92 = tmp125
																v93 = tmp130
																v94 = tmp131
																v95 = tmp132
																continue
															} // end let
															tmp111 = tmp117
														}
														tmp109 = tmp111
													} // end let
													tmp108 = tmp109
												} else {
												}
												tmp102 = tmp108
											} // end let
											tmp96 = tmp102
										}
										tmp83 = tmp96
										break
									}
								} // end let
								tmp80 = tmp83
							} // end let
							tmp79 = tmp80
						} else {
						}
						tmp73 = tmp79
					} // end let
					_ = tmp73
					tmp74 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp71 = tmp74
				} else {
				}
				_ = tmp71
				var tmp75 any
				if lang.IsTruthy(v56) {
					tmp76 := lang.Apply(lang.WriteWriter, []any{v4, "\n :trace\n ["})
					_ = tmp76
					var tmp77 any
					{ // let
						// let binding "temp__0__auto__"
						tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp79 := tmp78.FindInternedVar(lang.NewSymbol("first"))
						if tmp79.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
						}
						tmp80 := tmp79.Get()
						tmp81 := lang.Apply(tmp80, []any{v56})
						var v82 any = tmp81
						_ = v82
						var tmp83 any
						if lang.IsTruthy(v82) {
							var tmp84 any
							{ // let
								// let binding "ft"
								var v85 any = v82
								_ = v85
								tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp87 := tmp86.FindInternedVar(lang.NewSymbol("print-method"))
								if tmp87.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
								}
								tmp88 := tmp87.Get()
								tmp89 := lang.Apply(tmp88, []any{v85, v4})
								_ = tmp89
								var tmp90 any
								{ // let
									// let binding "seq_258"
									tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp92 := tmp91.FindInternedVar(lang.NewSymbol("seq"))
									if tmp92.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
									}
									tmp93 := tmp92.Get()
									tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp95 := tmp94.FindInternedVar(lang.NewSymbol("rest"))
									if tmp95.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
									}
									tmp96 := tmp95.Get()
									tmp97 := lang.Apply(tmp96, []any{v56})
									tmp98 := lang.Apply(tmp93, []any{tmp97})
									var v99 any = tmp98
									_ = v99
									// let binding "chunk_259"
									var v100 any = nil
									_ = v100
									// let binding "count_260"
									var v101 any = int64(0)
									_ = v101
									// let binding "i_261"
									var v102 any = int64(0)
									_ = v102
									for {
										var tmp103 any
										tmp104 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp105 := tmp104.FindInternedVar(lang.NewSymbol("<"))
										if tmp105.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp105)))
										}
										tmp106 := tmp105.Get()
										tmp107 := lang.Apply(tmp106, []any{v102, v101})
										if lang.IsTruthy(tmp107) {
											var tmp108 any
											{ // let
												// let binding "t"
												tmp109, _ := lang.FieldOrMethod(v100, "nth")
												if reflect.TypeOf(tmp109).Kind() != reflect.Func {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
												}
												tmp110 := lang.Apply(tmp109, []any{v102})
												var v111 any = tmp110
												_ = v111
												tmp112 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
												_ = tmp112
												tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp114 := tmp113.FindInternedVar(lang.NewSymbol("print-method"))
												if tmp114.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
												}
												tmp115 := tmp114.Get()
												tmp116 := lang.Apply(tmp115, []any{v111, v4})
												_ = tmp116
												var tmp117 any = v99
												var tmp118 any = v100
												var tmp119 any = v101
												tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp122 := tmp121.FindInternedVar(lang.NewSymbol("unchecked-inc"))
												if tmp122.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
												}
												tmp123 := tmp122.Get()
												tmp124 := lang.Apply(tmp123, []any{v102})
												var tmp120 any = tmp124
												v99 = tmp117
												v100 = tmp118
												v101 = tmp119
												v102 = tmp120
												continue
											} // end let
											tmp103 = tmp108
										} else {
											var tmp109 any
											{ // let
												// let binding "temp__0__auto__"
												tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
												tmp111 := tmp110.FindInternedVar(lang.NewSymbol("seq"))
												if tmp111.IsMacro() {
													panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
												}
												tmp112 := tmp111.Get()
												tmp113 := lang.Apply(tmp112, []any{v99})
												var v114 any = tmp113
												_ = v114
												var tmp115 any
												if lang.IsTruthy(v114) {
													var tmp116 any
													{ // let
														// let binding "seq_258"
														var v117 any = v114
														_ = v117
														var tmp118 any
														tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp120 := tmp119.FindInternedVar(lang.NewSymbol("chunked-seq?"))
														if tmp120.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
														}
														tmp121 := tmp120.Get()
														tmp122 := lang.Apply(tmp121, []any{v117})
														if lang.IsTruthy(tmp122) {
															var tmp123 any
															{ // let
																// let binding "c__0__auto__"
																tmp124 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp125 := tmp124.FindInternedVar(lang.NewSymbol("chunk-first"))
																if tmp125.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp125)))
																}
																tmp126 := tmp125.Get()
																tmp127 := lang.Apply(tmp126, []any{v117})
																var v128 any = tmp127
																_ = v128
																tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp131 := tmp130.FindInternedVar(lang.NewSymbol("chunk-rest"))
																if tmp131.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
																}
																tmp132 := tmp131.Get()
																tmp133 := lang.Apply(tmp132, []any{v117})
																var tmp129 any = tmp133
																var tmp134 any = v128
																tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp137 := tmp136.FindInternedVar(lang.NewSymbol("int"))
																if tmp137.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
																}
																tmp138 := tmp137.Get()
																tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp140 := tmp139.FindInternedVar(lang.NewSymbol("count"))
																if tmp140.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
																}
																tmp141 := tmp140.Get()
																tmp142 := lang.Apply(tmp141, []any{v128})
																tmp143 := lang.Apply(tmp138, []any{tmp142})
																var tmp135 any = tmp143
																tmp145 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp146 := tmp145.FindInternedVar(lang.NewSymbol("int"))
																if tmp146.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp146)))
																}
																tmp147 := tmp146.Get()
																tmp148 := lang.Apply(tmp147, []any{int64(0)})
																var tmp144 any = tmp148
																v99 = tmp129
																v100 = tmp134
																v101 = tmp135
																v102 = tmp144
																continue
															} // end let
															tmp118 = tmp123
														} else {
															var tmp124 any
															{ // let
																// let binding "t"
																tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp126 := tmp125.FindInternedVar(lang.NewSymbol("first"))
																if tmp126.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
																}
																tmp127 := tmp126.Get()
																tmp128 := lang.Apply(tmp127, []any{v117})
																var v129 any = tmp128
																_ = v129
																tmp130 := lang.Apply(lang.WriteWriter, []any{v4, "\n  "})
																_ = tmp130
																tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp132 := tmp131.FindInternedVar(lang.NewSymbol("print-method"))
																if tmp132.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
																}
																tmp133 := tmp132.Get()
																tmp134 := lang.Apply(tmp133, []any{v129, v4})
																_ = tmp134
																tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
																tmp137 := tmp136.FindInternedVar(lang.NewSymbol("next"))
																if tmp137.IsMacro() {
																	panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
																}
																tmp138 := tmp137.Get()
																tmp139 := lang.Apply(tmp138, []any{v117})
																var tmp135 any = tmp139
																var tmp140 any = nil
																var tmp141 any = int64(0)
																var tmp142 any = int64(0)
																v99 = tmp135
																v100 = tmp140
																v101 = tmp141
																v102 = tmp142
																continue
															} // end let
															tmp118 = tmp124
														}
														tmp116 = tmp118
													} // end let
													tmp115 = tmp116
												} else {
												}
												tmp109 = tmp115
											} // end let
											tmp103 = tmp109
										}
										tmp90 = tmp103
										break
									}
								} // end let
								tmp84 = tmp90
							} // end let
							tmp83 = tmp84
						} else {
						}
						tmp77 = tmp83
					} // end let
					_ = tmp77
					tmp78 := lang.Apply(lang.WriteWriter, []any{v4, "]"})
					tmp75 = tmp78
				} else {
				}
				tmp6 = tmp75
			} // end let
			_ = tmp6
			tmp7 := lang.Apply(lang.WriteWriter, []any{v4, "}"})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// printf
	{
		tmp0 := lang.NewSymbol("printf").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Prints formatted output, as per format", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5725), lang.NewKeyword("end-line"), int(5725))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("print"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("format"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp10, []any{tmp13, v3, v4})
				tmp15 := lang.Apply(tmp7, []any{tmp14})
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println
	{
		tmp0 := lang.NewSymbol("println").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as print followed by (newline)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3734), lang.NewKeyword("end-line"), int(3734))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*print-readably*"))
					tmp12 := lang.Apply(tmp10, []any{tmp11, nil})
					tmp13 := lang.Apply(tmp7, []any{tmp12})
					_ = tmp13
					var tmp14 any
					func() {
						defer func() {
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, nil)
							_ = tmp18
						}()
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("apply"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("prn"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp21, []any{tmp24, v3})
						tmp14 = tmp25
					}()
					tmp4 = tmp14
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// println-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("println-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "println to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4785), lang.NewKeyword("end-line"), int(4785))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v6})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						_ = tmp16
						var tmp17 any
						func() {
							defer func() {
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, nil)
								_ = tmp21
							}()
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("apply"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("println"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp24, []any{tmp27, v4})
							_ = tmp28
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("str"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v6})
							tmp17 = tmp32
						}()
						tmp7 = tmp17
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn
	{
		tmp0 := lang.NewSymbol("prn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "Same as pr followed by (newline). Observes *flush-on-newline*", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3715), lang.NewKeyword("end-line"), int(3715))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("apply"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("pr"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				_ = tmp10
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("newline"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, nil)
				_ = tmp14
				var tmp15 any
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("*flush-on-newline*"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				if lang.IsTruthy(tmp18) {
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("flush"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, nil)
					tmp15 = tmp22
				} else {
				}
				return tmp15
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// prn-str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("prn-str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("xs"))), lang.NewKeyword("doc"), "prn to a string, returning it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4767), lang.NewKeyword("end-line"), int(4767))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v4 any = lang.NewList(args[0:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s__0__auto__"
					var v6 any = "unimplemented: new with non-constant class type"
					_ = v6
					var tmp7 any
					{ // let
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*out*"))
						tmp15 := lang.Apply(tmp13, []any{tmp14, v6})
						tmp16 := lang.Apply(tmp10, []any{tmp15})
						_ = tmp16
						var tmp17 any
						func() {
							defer func() {
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, nil)
								_ = tmp21
							}()
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("apply"))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("prn"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp24, []any{tmp27, v4})
							_ = tmp28
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("str"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v6})
							tmp17 = tmp32
						}()
						tmp7 = tmp17
					} // end let
					tmp5 = tmp7
				} // end let
				return tmp5
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// promise
	{
		tmp0 := lang.NewSymbol("promise").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7078), lang.NewKeyword("end-line"), int(7078))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			var tmp3 any
			{ // let
				// let binding "d"
				tmp4 := lang.Apply(nil, []any{int64(1)})
				var v5 any = tmp4
				_ = v5
				// let binding "v"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("atom"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v5})
				var v10 any = tmp9
				_ = v10
				tmp11 := reflect.TypeOf((*lang.IDeref)(nil)).Elem()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("deref"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.NewVector(nil)
				tmp16 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7091), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(7091), lang.NewKeyword("end-column"), int(17))
				tmp17, err := lang.WithMeta(tmp15, tmp16.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp18, ok := lang.FieldOrMethod(v5, "await")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "await")))
				}
				var tmp19 any
				switch reflect.TypeOf(tmp18).Kind() {
				case reflect.Func:
					tmp19 = lang.Apply(tmp18, nil)
				default:
					tmp19 = tmp18
				}
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("deref"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.Apply(tmp22, []any{v10})
				tmp24 := lang.Apply(tmp14, []any{tmp17, tmp19, tmp23})
				tmp25 := reflect.TypeOf((*lang.IBlockingDeref)(nil)).Elem()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("deref"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.NewVector(nil, nil, nil)
				tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7094), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(7094), lang.NewKeyword("end-column"), int(34))
				tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp32 any
				tmp33, _ := lang.FieldOrMethod(v5, "await")
				if reflect.TypeOf(tmp33).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("await is not a function")))
				}
				tmp34 := lang.Apply(tmp33, []any{nil, time7.Millisecond})
				if lang.IsTruthy(tmp34) {
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("deref"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{v10})
					tmp32 = tmp38
				} else {
				}
				tmp39 := lang.Apply(tmp28, []any{tmp31, tmp32})
				tmp40 := reflect.TypeOf((*lang.IPending)(nil)).Elem()
				tmp41 := lang.NewVector(nil)
				tmp42 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7099), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7099), lang.NewKeyword("end-column"), int(24))
				tmp43, err := lang.WithMeta(tmp41, tmp42.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("zero?"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47, ok := lang.FieldOrMethod(v5, "getCount")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
				}
				var tmp48 any
				switch reflect.TypeOf(tmp47).Kind() {
				case reflect.Func:
					tmp48 = lang.Apply(tmp47, nil)
				default:
					tmp48 = tmp47
				}
				tmp49 := lang.Apply(tmp46, []any{tmp48})
				tmp50 := lang.Apply(nil, []any{tmp43, tmp49})
				tmp51 := lang.NewVector(nil, nil)
				tmp52 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7103), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(7103), lang.NewKeyword("end-column"), int(14))
				tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var tmp54 any
				var tmp55 any
				{ // let
					// let binding "and__0__auto__"
					tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp57 := tmp56.FindInternedVar(lang.NewSymbol("pos?"))
					if tmp57.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
					}
					tmp58 := tmp57.Get()
					tmp59, ok := lang.FieldOrMethod(v5, "getCount")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "getCount")))
					}
					var tmp60 any
					switch reflect.TypeOf(tmp59).Kind() {
					case reflect.Func:
						tmp60 = lang.Apply(tmp59, nil)
					default:
						tmp60 = tmp59
					}
					tmp61 := lang.Apply(tmp58, []any{tmp60})
					var v62 any = tmp61
					_ = v62
					var tmp63 any
					if lang.IsTruthy(v62) {
						tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp65 := tmp64.FindInternedVar(lang.NewSymbol("compare-and-set!"))
						if tmp65.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
						}
						tmp66 := tmp65.Get()
						tmp67 := lang.Apply(tmp66, []any{v10, v5, nil})
						tmp63 = tmp67
					} else {
						tmp63 = v62
					}
					tmp55 = tmp63
				} // end let
				if lang.IsTruthy(tmp55) {
					tmp56, ok := lang.FieldOrMethod(v5, "countDown")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "countDown")))
					}
					var tmp57 any
					switch reflect.TypeOf(tmp56).Kind() {
					case reflect.Func:
						tmp57 = lang.Apply(tmp56, nil)
					default:
						tmp57 = tmp56
					}
					_ = tmp57
				} else {
				}
				tmp58 := lang.Apply(nil, []any{tmp53, tmp54})
				tmp59 := lang.Apply(nil, []any{tmp11, tmp24, tmp25, tmp39, tmp40, tmp50, nil, tmp58})
				tmp3 = tmp59
			} // end let
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// protocol?
	{
		tmp0 := lang.NewSymbol("protocol?").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_deftype.glj", lang.NewKeyword("line"), int(110), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(110), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("maybe-p"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := reflect.TypeOf((*lang.IAtom)(nil)).Elem()
			tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
			if lang.IsTruthy(tmp9) {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("boolean"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("deref"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(lang.NewKeyword("on-interface"), []any{tmp16})
				tmp18 := lang.Apply(tmp12, []any{tmp17})
				tmp4 = tmp18
			} else {
				tmp4 = false
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// push-thread-bindings
	{
		tmp0 := lang.NewSymbol("push-thread-bindings").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"))), lang.NewKeyword("doc"), "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1911), lang.NewKeyword("end-line"), int(1911))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.PushThreadBindings, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// pvalues
	{
		tmp0 := lang.NewSymbol("pvalues").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7063), lang.NewKeyword("end-line"), int(7063))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/pcalls")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("map"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				var tmp19 lang.FnFunc
				tmp19 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v20 := args[0]
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.NewVector()
					tmp25 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7069), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7069), lang.NewKeyword("end-column"), int(31))
					tmp26, err := lang.WithMeta(tmp24, tmp25.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp27 := lang.Apply(tmp23, []any{lang.NewSymbol("glojure.core/fn"), tmp26, v20})
					return tmp27
				})
				tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7069), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7069), lang.NewKeyword("end-column"), int(34))
				tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp22 := lang.Apply(tmp18, []any{tmp21, v5})
				tmp23 := lang.Apply(tmp11, []any{tmp15, tmp22})
				tmp24 := lang.Apply(tmp8, []any{tmp23})
				return tmp24
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-ident?
	{
		tmp0 := lang.NewSymbol("qualified-ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1618), lang.NewKeyword("end-line"), int(1618))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("boolean"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			var tmp7 any
			{ // let
				// let binding "and__0__auto__"
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("ident?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				if lang.IsTruthy(v12) {
					var tmp14 any
					{ // let
						// let binding "and__0__auto__"
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("namespace"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v3})
						var v19 any = tmp18
						_ = v19
						var tmp20 any
						if lang.IsTruthy(v19) {
							tmp20 = true
						} else {
							tmp20 = v19
						}
						tmp14 = tmp20
					} // end let
					tmp13 = tmp14
				} else {
					tmp13 = v12
				}
				tmp7 = tmp13
			} // end let
			tmp8 := lang.Apply(tmp6, []any{tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-keyword?
	{
		tmp0 := lang.NewSymbol("qualified-keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a keyword with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1638), lang.NewKeyword("end-line"), int(1638))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("boolean"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			var tmp7 any
			{ // let
				// let binding "and__0__auto__"
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("keyword?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				if lang.IsTruthy(v12) {
					var tmp14 any
					{ // let
						// let binding "and__0__auto__"
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("namespace"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v3})
						var v19 any = tmp18
						_ = v19
						var tmp20 any
						if lang.IsTruthy(v19) {
							tmp20 = true
						} else {
							tmp20 = v19
						}
						tmp14 = tmp20
					} // end let
					tmp13 = tmp14
				} else {
					tmp13 = v12
				}
				tmp7 = tmp13
			} // end let
			tmp8 := lang.Apply(tmp6, []any{tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// qualified-symbol?
	{
		tmp0 := lang.NewSymbol("qualified-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol with a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1628), lang.NewKeyword("end-line"), int(1628))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("boolean"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			var tmp7 any
			{ // let
				// let binding "and__0__auto__"
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("symbol?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				var v12 any = tmp11
				_ = v12
				var tmp13 any
				if lang.IsTruthy(v12) {
					var tmp14 any
					{ // let
						// let binding "and__0__auto__"
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("namespace"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v3})
						var v19 any = tmp18
						_ = v19
						var tmp20 any
						if lang.IsTruthy(v19) {
							tmp20 = true
						} else {
							tmp20 = v19
						}
						tmp14 = tmp20
					} // end let
					tmp13 = tmp14
				} else {
					tmp13 = v12
				}
				tmp7 = tmp13
			} // end let
			tmp8 := lang.Apply(tmp6, []any{tmp7})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// quot
	{
		var tmp1 lang.FnFunc
		{ // function quot__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Quotient")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("quot").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "quot[ient] of dividing numerator by denominator.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1266), lang.NewKeyword("end-line"), int(1266))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Quotient")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Quotient is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand
	{
		tmp0 := lang.NewSymbol("rand").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4935), lang.NewKeyword("end-line"), int(4935))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.Apply(rand12.Float64, nil)
				return tmp3
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("*"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("rand"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, nil)
				tmp11 := lang.Apply(tmp6, []any{v3, tmp10})
				return tmp11
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-int
	{
		tmp0 := lang.NewSymbol("rand-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns a random integer between 0 (inclusive) and n (exclusive).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4943), lang.NewKeyword("end-line"), int(4943))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("int"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("rand"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp9, []any{v3})
			tmp11 := lang.Apply(tmp6, []any{tmp10})
			return tmp11
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rand-nth
	{
		tmp0 := lang.NewSymbol("rand-nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7213), lang.NewKeyword("end-line"), int(7213))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("nth"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("rand-int"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("count"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp12, []any{v3})
			tmp14 := lang.Apply(tmp9, []any{tmp13})
			tmp15 := lang.Apply(tmp6, []any{v3, tmp14})
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-sample
	{
		tmp0 := lang.NewSymbol("random-sample").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("prob")), lang.NewVector(lang.NewSymbol("prob"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7699), lang.NewKeyword("end-line"), int(7699))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("filter"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("<"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("rand"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, nil)
					tmp16 := lang.Apply(tmp11, []any{tmp15, v3})
					return tmp16
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7704), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(7704), lang.NewKeyword("end-column"), int(37))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("filter"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v9 := args[0]
					_ = v9
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("<"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("rand"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, nil)
					tmp17 := lang.Apply(tmp12, []any{tmp16, v3})
					return tmp17
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7706), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(7706), lang.NewKeyword("end-column"), int(37))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{tmp10, v4})
				return tmp11
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// random-uuid
	{
		tmp0 := lang.NewSymbol("random-uuid").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\n\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6852), lang.NewKeyword("end-line"), int(6852))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(uuid10.NewV7, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// range
	{
		tmp0 := lang.NewSymbol("range").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("end")), lang.NewVector(lang.NewSymbol("start"), lang.NewSymbol("end")), lang.NewVector(lang.NewSymbol("start"), lang.NewSymbol("end"), lang.NewSymbol("step"))), lang.NewKeyword("doc"), "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3018), lang.NewKeyword("end-line"), int(3018))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("iterate"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("inc'"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp5, []any{tmp8, int64(0)})
				return tmp9
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("int?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				if lang.IsTruthy(tmp8) {
					tmp9 := lang.Apply(lang.NewLongRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp9
				} else {
					tmp10 := lang.Apply(lang.NewRange, []any{int64(0), v3, int64(1)})
					tmp4 = tmp10
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				var tmp6 any
				{ // let
					// let binding "and__0__auto__"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("int?"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp14 := tmp13.FindInternedVar(lang.NewSymbol("int?"))
						if tmp14.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
						}
						tmp15 := tmp14.Get()
						tmp16 := lang.Apply(tmp15, []any{v4})
						tmp12 = tmp16
					} else {
						tmp12 = v11
					}
					tmp6 = tmp12
				} // end let
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.Apply(lang.NewLongRange, []any{v3, v4, int64(1)})
					tmp5 = tmp7
				} else {
					tmp8 := lang.Apply(lang.NewRange, []any{v3, v4, int64(1)})
					tmp5 = tmp8
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				var tmp7 any
				{ // let
					// let binding "and__0__auto__"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("int?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v3})
					var v12 any = tmp11
					_ = v12
					var tmp13 any
					if lang.IsTruthy(v12) {
						var tmp14 any
						{ // let
							// let binding "and__0__auto__"
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("int?"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, []any{v4})
							var v19 any = tmp18
							_ = v19
							var tmp20 any
							if lang.IsTruthy(v19) {
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("int?"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(tmp23, []any{v5})
								tmp20 = tmp24
							} else {
								tmp20 = v19
							}
							tmp14 = tmp20
						} // end let
						tmp13 = tmp14
					} else {
						tmp13 = v12
					}
					tmp7 = tmp13
				} // end let
				if lang.IsTruthy(tmp7) {
					tmp8 := lang.Apply(lang.NewLongRange, []any{v3, v4, v5})
					tmp6 = tmp8
				} else {
					tmp9 := lang.Apply(lang.NewRange, []any{v3, v4, v5})
					tmp6 = tmp9
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ratio?
	{
		tmp0 := lang.NewSymbol("ratio?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a Ratio", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3577), lang.NewKeyword("end-line"), int(3577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Ratio)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rational?
	{
		tmp0 := lang.NewSymbol("rational?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Returns true if n is a rational number", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3613), lang.NewKeyword("end-line"), int(3613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("integer?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp10 = v9
				} else {
					var tmp11 any
					{ // let
						// let binding "or__0__auto__"
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("ratio?"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v3})
						var v16 any = tmp15
						_ = v16
						var tmp17 any
						if lang.IsTruthy(v16) {
							tmp17 = v16
						} else {
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("decimal?"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.Apply(tmp20, []any{v3})
							tmp17 = tmp21
						}
						tmp11 = tmp17
					} // end let
					tmp10 = tmp11
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rationalize
	{
		tmp0 := lang.NewSymbol("rationalize").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("doc"), "returns the rational value of num", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1282), lang.NewKeyword("end-line"), int(1282))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(lang.Numbers, "Rationalize")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Rationalize is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-find
	{
		tmp0 := lang.NewSymbol("re-find").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m")), lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4922), lang.NewKeyword("end-line"), int(4922))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5, _ := lang.FieldOrMethod(v3, "find")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				if lang.IsTruthy(tmp6) {
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("re-groups"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3})
					tmp4 = tmp10
				} else {
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "m"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("re-matcher"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(tmp8, []any{v3, v4})
					var v10 any = tmp9
					_ = v10
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("re-find"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v10})
					tmp5 = tmp14
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-groups
	{
		tmp0 := lang.NewSymbol("re-groups").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4882), lang.NewKeyword("end-line"), int(4882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "gc"
				tmp5, _ := lang.FieldOrMethod(v3, "groupCount")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupCount is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				var tmp8 any
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("zero?"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v7})
				if lang.IsTruthy(tmp12) {
					tmp13, _ := lang.FieldOrMethod(v3, "group")
					if reflect.TypeOf(tmp13).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("group is not a function")))
					}
					tmp14 := lang.Apply(tmp13, []any{})
					tmp8 = tmp14
				} else {
					var tmp15 any
					{ // let
						// let binding "ret"
						tmp16 := lang.NewVector()
						tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4893), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(4893), lang.NewKeyword("end-column"), int(21))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v19 any = tmp18
						_ = v19
						// let binding "c"
						var v20 any = int64(0)
						_ = v20
						for {
							var tmp21 any
							tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp23 := tmp22.FindInternedVar(lang.NewSymbol("<="))
							if tmp23.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
							}
							tmp24 := tmp23.Get()
							tmp25 := lang.Apply(tmp24, []any{v20, v7})
							if lang.IsTruthy(tmp25) {
								tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp28 := tmp27.FindInternedVar(lang.NewSymbol("conj"))
								if tmp28.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
								}
								tmp29 := tmp28.Get()
								tmp30, _ := lang.FieldOrMethod(v3, "groupInt")
								if reflect.TypeOf(tmp30).Kind() != reflect.Func {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("groupInt is not a function")))
								}
								tmp31 := lang.Apply(tmp30, []any{v20})
								tmp32 := lang.Apply(tmp29, []any{v19, tmp31})
								var tmp26 any = tmp32
								tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp35 := tmp34.FindInternedVar(lang.NewSymbol("inc"))
								if tmp35.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
								}
								tmp36 := tmp35.Get()
								tmp37 := lang.Apply(tmp36, []any{v20})
								var tmp33 any = tmp37
								v19 = tmp26
								v20 = tmp33
								continue
							} else {
								tmp21 = v19
							}
							tmp15 = tmp21
							break
						}
					} // end let
					tmp8 = tmp15
				}
				tmp4 = tmp8
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matcher
	{
		tmp1 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp0 := lang.NewSymbol("re-matcher").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4873), lang.NewKeyword("end-line"), int(4873))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6 := lang.Apply(lang.NewRegexpMatcher, []any{v4, v5})
			return tmp6
		})
		tmp4 := reflect.TypeOf((*lang.RegexpMatcher)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-matches
	{
		tmp0 := lang.NewSymbol("re-matches").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4910), lang.NewKeyword("end-line"), int(4910))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("re-matcher"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				tmp12, _ := lang.FieldOrMethod(v10, "matches")
				if reflect.TypeOf(tmp12).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("matches is not a function")))
				}
				tmp13 := lang.Apply(tmp12, []any{})
				if lang.IsTruthy(tmp13) {
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("re-groups"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v10})
					tmp11 = tmp17
				} else {
				}
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-pattern
	{
		tmp1 := reflect.TypeOf((*regexp13.Regexp)(nil))
		tmp0 := lang.NewSymbol("re-pattern").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4863), lang.NewKeyword("end-line"), int(4863))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			var tmp5 any
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := reflect.TypeOf((*regexp13.Regexp)(nil))
			tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
			if lang.IsTruthy(tmp10) {
				tmp5 = v4
			} else {
				tmp11 := lang.Apply(regexp13.MustCompile, []any{v4})
				tmp5 = tmp11
			}
			return tmp5
		})
		tmp4 := reflect.TypeOf((*regexp13.Regexp)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// re-seq
	{
		tmp0 := lang.NewSymbol("re-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("re"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4898), lang.NewKeyword("end-line"), int(4898))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "m"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("re-matcher"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3, v4})
				var v10 any = tmp9
				_ = v10
				var tmp11 lang.FnFunc
				{ // function step
					var v12 lang.FnFunc
					tmp11 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp13 any
						tmp14, _ := lang.FieldOrMethod(v10, "find")
						if reflect.TypeOf(tmp14).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("find is not a function")))
						}
						tmp15 := lang.Apply(tmp14, []any{})
						if lang.IsTruthy(tmp15) {
							tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp17 := tmp16.FindInternedVar(lang.NewSymbol("cons"))
							if tmp17.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
							}
							tmp18 := tmp17.Get()
							tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp20 := tmp19.FindInternedVar(lang.NewSymbol("re-groups"))
							if tmp20.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
							}
							tmp21 := tmp20.Get()
							tmp22 := lang.Apply(tmp21, []any{v10})
							var tmp23 lang.FnFunc
							tmp23 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								tmp24 := lang.Apply(v12, nil)
								return tmp24
							})
							tmp24 := lang.Apply(lang.NewLazySeq, []any{tmp23})
							tmp25 := lang.Apply(tmp18, []any{tmp22, tmp24})
							tmp13 = tmp25
						} else {
						}
						return tmp13
					})
					v12 = tmp11
					_ = v12
				}
				tmp12 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4906), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4908), lang.NewKeyword("end-column"), int(49))
				tmp13, err := lang.WithMeta(tmp11, tmp12.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp14 := lang.Apply(tmp13, nil)
				tmp5 = tmp14
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read
	{
		tmp0 := lang.NewSymbol("read").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value"), lang.NewSymbol("recursive?")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3742), lang.NewKeyword("end-line"), int(3742))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("read"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*in*"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("read"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3, true, nil})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("read"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, false})
				return tmp9
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("boolean"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v4})
				tmp11, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp11).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp12 := lang.Apply(tmp11, []any{v3, tmp10, v5, v6})
				return tmp12
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(nil, "read")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("read is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4, v3})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read+string
	{
		tmp0 := lang.NewSymbol("read+string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value")), lang.NewVector(lang.NewSymbol("stream"), lang.NewSymbol("eof-error?"), lang.NewSymbol("eof-value"), lang.NewSymbol("recursive?")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3771), lang.NewKeyword("end-line"), int(3771))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp4 := tmp3.FindInternedVar(lang.NewSymbol("read+string"))
				if tmp4.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp4)))
				}
				tmp5 := tmp4.Get()
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("*in*"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp5, []any{tmp8})
				return tmp9
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("read+string"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{v3, true, nil})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("read+string"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3, v4, v5, false})
				return tmp9
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v8 := r
								_ = v8
								tmp9, ok := lang.FieldOrMethod(v3, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
								}
								var tmp10 any
								switch reflect.TypeOf(tmp9).Kind() {
								case reflect.Func:
									tmp10 = lang.Apply(tmp9, nil)
								default:
									tmp10 = tmp9
								}
								_ = tmp10
								panic(v8)
							} else {
								panic(r)
							}
						}
					}()
					tmp8, ok := lang.FieldOrMethod(v3, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "captureString")))
					}
					var tmp9 any
					switch reflect.TypeOf(tmp8).Kind() {
					case reflect.Func:
						tmp9 = lang.Apply(tmp8, nil)
					default:
						tmp9 = tmp8
					}
					_ = tmp9
					var tmp10 any
					{ // let
						// let binding "o"
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("read"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v3, v4, v5, v6})
						var v15 any = tmp14
						_ = v15
						// let binding "s"
						tmp16, ok := lang.FieldOrMethod(v3, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getString")))
						}
						var tmp17 any
						switch reflect.TypeOf(tmp16).Kind() {
						case reflect.Func:
							tmp17 = lang.Apply(tmp16, nil)
						default:
							tmp17 = tmp16
						}
						tmp18, ok := lang.FieldOrMethod(tmp17, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp17, "trim")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						var v20 any = tmp19
						_ = v20
						tmp21 := lang.NewVector(v15, v20)
						tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3783), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(3783), lang.NewKeyword("end-column"), int(12))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp10 = tmp23
					} // end let
					tmp7 = tmp10
				}()
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				func() {
					defer func() {
						if r := recover(); r != nil {
							if lang.CatchMatches(r, lang.Throwable) {
								v6 := r
								_ = v6
								tmp7, ok := lang.FieldOrMethod(v4, "getString")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
								}
								var tmp8 any
								switch reflect.TypeOf(tmp7).Kind() {
								case reflect.Func:
									tmp8 = lang.Apply(tmp7, nil)
								default:
									tmp8 = tmp7
								}
								_ = tmp8
								panic(v6)
							} else {
								panic(r)
							}
						}
					}()
					tmp6, ok := lang.FieldOrMethod(v4, "captureString")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "captureString")))
					}
					var tmp7 any
					switch reflect.TypeOf(tmp6).Kind() {
					case reflect.Func:
						tmp7 = lang.Apply(tmp6, nil)
					default:
						tmp7 = tmp6
					}
					_ = tmp7
					var tmp8 any
					{ // let
						// let binding "o"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("read"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v3, v4})
						var v13 any = tmp12
						_ = v13
						// let binding "s"
						tmp14, ok := lang.FieldOrMethod(v4, "getString")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "getString")))
						}
						var tmp15 any
						switch reflect.TypeOf(tmp14).Kind() {
						case reflect.Func:
							tmp15 = lang.Apply(tmp14, nil)
						default:
							tmp15 = tmp14
						}
						tmp16, ok := lang.FieldOrMethod(tmp15, "trim")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp15, "trim")))
						}
						var tmp17 any
						switch reflect.TypeOf(tmp16).Kind() {
						case reflect.Func:
							tmp17 = lang.Apply(tmp16, nil)
						default:
							tmp17 = tmp16
						}
						var v18 any = tmp17
						_ = v18
						tmp19 := lang.NewVector(v13, v18)
						tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3792), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(3792), lang.NewKeyword("end-column"), int(12))
						tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp21
					} // end let
					tmp5 = tmp8
				}()
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-line
	{
		tmp0 := lang.NewSymbol("read-line").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Reads the next line from stream that is the current value of *in* .", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3797), lang.NewKeyword("end-line"), int(3797))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			var tmp3 any
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*in*"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp6, []any{nil, tmp9})
			if lang.IsTruthy(tmp10) {
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("*in*"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14, ok := lang.FieldOrMethod(tmp13, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp13, "readLine")))
				}
				var tmp15 any
				switch reflect.TypeOf(tmp14).Kind() {
				case reflect.Func:
					tmp15 = lang.Apply(tmp14, nil)
				default:
					tmp15 = tmp14
				}
				tmp3 = tmp15
			} else {
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("*in*"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19, ok := lang.FieldOrMethod(tmp18, "readLine")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp18, "readLine")))
				}
				var tmp20 any
				switch reflect.TypeOf(tmp19).Kind() {
				case reflect.Func:
					tmp20 = lang.Apply(tmp19, nil)
				default:
					tmp20 = tmp19
				}
				tmp3 = tmp20
			}
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// read-string
	{
		tmp0 := lang.NewSymbol("read-string").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("opts"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use glojure.edn/read-string", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3806), lang.NewKeyword("end-line"), int(3806))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(runtime4.RTReadString, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(runtime4.RTReadString, []any{v4, v3})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional
	{
		tmp0 := lang.NewSymbol("reader-conditional").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("form"), lang.NewSymbol("splicing?"))), lang.NewKeyword("doc"), "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7782), lang.NewKeyword("end-line"), int(7782))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reader-conditional?
	{
		tmp0 := lang.NewSymbol("reader-conditional?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("value"))), lang.NewKeyword("doc"), "Return true if the value is the data representation of a reader conditional", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7776), lang.NewKeyword("end-line"), int(7776))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// realized?
	{
		tmp0 := lang.NewSymbol("realized?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7559), lang.NewKeyword("end-line"), int(7559))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "isRealized")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "isRealized")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce
	{
		tmp0 := lang.NewSymbol("reduce").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("val"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6860), lang.NewKeyword("end-line"), int(6860))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := reflect.TypeOf((*lang.IReduce)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v4})
				if lang.IsTruthy(tmp10) {
					tmp11, _ := lang.FieldOrMethod(v4, "Reduce")
					if reflect.TypeOf(tmp11).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("Reduce is not a function")))
					}
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp5 = tmp12
				} else {
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core.protocols"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("coll-reduce"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v4, v3})
					tmp5 = tmp16
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp11 := lang.Apply(tmp9, []any{tmp10, v5})
				if lang.IsTruthy(tmp11) {
					tmp12, _ := lang.FieldOrMethod(v5, "ReduceInit")
					if reflect.TypeOf(tmp12).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp13 := lang.Apply(tmp12, []any{v3, v4})
					tmp6 = tmp13
				} else {
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core.protocols"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("coll-reduce"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v5, v3, v4})
					tmp6 = tmp17
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce-kv
	{
		tmp0 := lang.NewSymbol("reduce-kv").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.4", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6882), lang.NewKeyword("end-line"), int(6882))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core.protocols"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("kv-reduce"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.Apply(tmp8, []any{v5, v3, v4})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduce1
	{
		tmp0 := lang.NewSymbol("reduce1").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(923), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(924), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("val"), lang.NewSymbol("coll"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "s"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.Apply(tmp8, []any{v4})
					var v10 any = tmp9
					_ = v10
					var tmp11 any
					if lang.IsTruthy(v10) {
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("reduce1"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v10})
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("next"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.Apply(tmp21, []any{v10})
						tmp23 := lang.Apply(tmp14, []any{v3, tmp18, tmp22})
						tmp11 = tmp23
					} else {
						tmp24 := lang.Apply(v3, nil)
						tmp11 = tmp24
					}
					tmp5 = tmp11
				} // end let
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
			recur_loop_156:
				var tmp6 any
				{ // let
					// let binding "s"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v5})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("chunked-seq?"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v11})
						if lang.IsTruthy(tmp17) {
							var tmp18 any = v3
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("chunk-first"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{v11})
							tmp24, _ := lang.FieldOrMethod(tmp23, "ReduceInit")
							if reflect.TypeOf(tmp24).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
							}
							tmp25 := lang.Apply(tmp24, []any{v3, v4})
							var tmp19 any = tmp25
							tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp28 := tmp27.FindInternedVar(lang.NewSymbol("chunk-next"))
							if tmp28.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
							}
							tmp29 := tmp28.Get()
							tmp30 := lang.Apply(tmp29, []any{v11})
							var tmp26 any = tmp30
							v3 = tmp18
							v4 = tmp19
							v5 = tmp26
							goto recur_loop_156
						} else {
							var tmp31 any = v3
							tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp34 := tmp33.FindInternedVar(lang.NewSymbol("first"))
							if tmp34.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
							}
							tmp35 := tmp34.Get()
							tmp36 := lang.Apply(tmp35, []any{v11})
							tmp37 := lang.Apply(v3, []any{v4, tmp36})
							var tmp32 any = tmp37
							tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp40 := tmp39.FindInternedVar(lang.NewSymbol("next"))
							if tmp40.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
							}
							tmp41 := tmp40.Get()
							tmp42 := lang.Apply(tmp41, []any{v11})
							var tmp38 any = tmp42
							v3 = tmp31
							v4 = tmp32
							v5 = tmp38
							goto recur_loop_156
						}
						tmp12 = tmp13
					} else {
						tmp12 = v4
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced
	{
		tmp0 := lang.NewSymbol("reduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Wraps x in a way such that a reduce will terminate with the value x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2828), lang.NewKeyword("end-line"), int(2828))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.NewReduced, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reduced?
	{
		var tmp1 lang.FnFunc
		{ // function reduced?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.IsReduced")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3})
				tmp18 := lang.Apply(tmp9, []any{tmp13, tmp17})
				tmp19 := lang.Apply(tmp6, []any{tmp18})
				return tmp19
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("reduced?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if x is the result of a call to reduced", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1)})), lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2834), lang.NewKeyword("end-line"), int(2834))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.IsReduced, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reductions
	{
		tmp0 := lang.NewSymbol("reductions").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7196), lang.NewKeyword("end-line"), int(7196))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp16 := tmp15.FindInternedVar(lang.NewSymbol("reductions"))
								if tmp16.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
								}
								tmp17 := tmp16.Get()
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("first"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v14})
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("rest"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.Apply(tmp24, []any{v14})
								tmp26 := lang.Apply(tmp17, []any{v3, tmp21, tmp25})
								tmp13 = tmp26
							} // end let
							tmp12 = tmp13
						} else {
							tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
							if tmp15.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
							}
							tmp16 := tmp15.Get()
							tmp17 := lang.Apply(v3, nil)
							tmp18 := lang.Apply(tmp16, []any{tmp17})
							tmp12 = tmp18
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("reduced?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v4})
				if lang.IsTruthy(tmp10) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("deref"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v4})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					tmp6 = tmp18
				} else {
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("cons"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					var tmp22 lang.FnFunc
					tmp22 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp23 any
						{ // let
							// let binding "temp__0__auto__"
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{v5})
							var v28 any = tmp27
							_ = v28
							var tmp29 any
							if lang.IsTruthy(v28) {
								var tmp30 any
								{ // let
									// let binding "s"
									var v31 any = v28
									_ = v31
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("reductions"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp36 := tmp35.FindInternedVar(lang.NewSymbol("first"))
									if tmp36.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
									}
									tmp37 := tmp36.Get()
									tmp38 := lang.Apply(tmp37, []any{v31})
									tmp39 := lang.Apply(v3, []any{v4, tmp38})
									tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp41 := tmp40.FindInternedVar(lang.NewSymbol("rest"))
									if tmp41.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
									}
									tmp42 := tmp41.Get()
									tmp43 := lang.Apply(tmp42, []any{v31})
									tmp44 := lang.Apply(tmp34, []any{v3, tmp39, tmp43})
									tmp30 = tmp44
								} // end let
								tmp29 = tmp30
							} else {
							}
							tmp23 = tmp29
						} // end let
						return tmp23
					})
					tmp23 := lang.Apply(lang.NewLazySeq, []any{tmp22})
					tmp24 := lang.Apply(tmp21, []any{v4, tmp23})
					tmp6 = tmp24
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref
	{
		tmp0 := lang.NewSymbol("ref").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2260), lang.NewKeyword("end-line"), int(2260))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRef, []any{v3})
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "r"
					tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp7 := tmp6.FindInternedVar(lang.NewSymbol("setup-reference"))
					if tmp7.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
					}
					tmp8 := tmp7.Get()
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("ref"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := lang.Apply(tmp8, []any{tmp12, v4})
					var v14 any = tmp13
					_ = v14
					// let binding "opts"
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("apply"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp17, []any{tmp20, v4})
					var v22 any = tmp21
					_ = v22
					var tmp23 any
					tmp24 := lang.Apply(lang.NewKeyword("max-history"), []any{v22})
					if lang.IsTruthy(tmp24) {
						tmp25 := lang.Apply(lang.NewKeyword("max-history"), []any{v22})
						tmp26, _ := lang.FieldOrMethod(v14, "setMaxHistory")
						if reflect.TypeOf(tmp26).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
						}
						tmp27 := lang.Apply(tmp26, []any{tmp25})
						tmp23 = tmp27
					} else {
					}
					_ = tmp23
					var tmp28 any
					tmp29 := lang.Apply(lang.NewKeyword("min-history"), []any{v22})
					if lang.IsTruthy(tmp29) {
						tmp30 := lang.Apply(lang.NewKeyword("min-history"), []any{v22})
						tmp31, _ := lang.FieldOrMethod(v14, "setMinHistory")
						if reflect.TypeOf(tmp31).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
						}
						tmp32 := lang.Apply(tmp31, []any{tmp30})
						tmp28 = tmp32
					} else {
					}
					_ = tmp28
					tmp5 = v14
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-history-count
	{
		tmp0 := lang.NewSymbol("ref-history-count").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"))), lang.NewKeyword("doc"), "Returns the history count of a ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2455), lang.NewKeyword("end-line"), int(2455))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "getHistoryCount")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getHistoryCount")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-max-history
	{
		tmp0 := lang.NewSymbol("ref-max-history").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Gets the max-history of a ref, or sets it and returns the ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2471), lang.NewKeyword("end-line"), int(2471))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMaxHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMaxHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMaxHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMaxHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-min-history
	{
		tmp0 := lang.NewSymbol("ref-min-history").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref")), lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("n"))), lang.NewKeyword("doc"), "Gets the min-history of a ref, or sets it and returns the ref", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2462), lang.NewKeyword("end-line"), int(2462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4, ok := lang.FieldOrMethod(v3, "getMinHistory")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "getMinHistory")))
				}
				var tmp5 any
				switch reflect.TypeOf(tmp4).Kind() {
				case reflect.Func:
					tmp5 = lang.Apply(tmp4, nil)
				default:
					tmp5 = tmp4
				}
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(v3, "setMinHistory")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("setMinHistory is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// ref-set
	{
		tmp0 := lang.NewSymbol("ref-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ref"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Must be called in a transaction. Sets the value of ref.\n  Returns val.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2447), lang.NewKeyword("end-line"), int(2447))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer
	{
		tmp0 := lang.NewSymbol("refer").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("ns-sym"), lang.NewSymbol("&"), lang.NewSymbol("filters"))), lang.NewKeyword("doc"), "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4216), lang.NewKeyword("end-line"), int(4216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				var tmp5 any
				{ // let
					// let binding "ns"
					var tmp6 any
					{ // let
						// let binding "or__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("find-ns"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							tmp12 = v11
						} else {
							tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp14 := tmp13.FindInternedVar(lang.NewSymbol("str"))
							if tmp14.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
							}
							tmp15 := tmp14.Get()
							tmp16 := lang.Apply(tmp15, []any{"No namespace: ", v3})
							tmp17 := lang.Apply(errors5.New, []any{tmp16})
							panic(tmp17)
						}
						tmp6 = tmp12
					} // end let
					var v7 any = tmp6
					_ = v7
					// let binding "fs"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp10, []any{tmp13, v4})
					var v15 any = tmp14
					_ = v15
					// let binding "nspublics"
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("ns-publics"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v7})
					var v20 any = tmp19
					_ = v20
					// let binding "rename"
					var tmp21 any
					{ // let
						// let binding "or__0__auto__"
						tmp22 := lang.Apply(lang.NewKeyword("rename"), []any{v15})
						var v23 any = tmp22
						_ = v23
						var tmp24 any
						if lang.IsTruthy(v23) {
							tmp24 = v23
						} else {
							tmp25 := lang.NewMap()
							tmp26 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4236), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(4236), lang.NewKeyword("end-column"), int(36))
							tmp27, err := lang.WithMeta(tmp25, tmp26.(lang.IPersistentMap))
							if err != nil {
								panic(err)
							}
							tmp24 = tmp27
						}
						tmp21 = tmp24
					} // end let
					var v22 any = tmp21
					_ = v22
					// let binding "exclude"
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("set"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(lang.NewKeyword("exclude"), []any{v15})
					tmp27 := lang.Apply(tmp25, []any{tmp26})
					var v28 any = tmp27
					_ = v28
					// let binding "to-do"
					var tmp29 any
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.Apply(lang.NewKeyword("refer"), []any{v15})
					tmp34 := lang.Apply(tmp32, []any{lang.NewKeyword("all"), tmp33})
					if lang.IsTruthy(tmp34) {
						tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp36 := tmp35.FindInternedVar(lang.NewSymbol("keys"))
						if tmp36.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
						}
						tmp37 := tmp36.Get()
						tmp38 := lang.Apply(tmp37, []any{v20})
						tmp29 = tmp38
					} else {
						var tmp39 any
						{ // let
							// let binding "or__0__auto__"
							tmp40 := lang.Apply(lang.NewKeyword("refer"), []any{v15})
							var v41 any = tmp40
							_ = v41
							var tmp42 any
							if lang.IsTruthy(v41) {
								tmp42 = v41
							} else {
								var tmp43 any
								{ // let
									// let binding "or__0__auto__"
									tmp44 := lang.Apply(lang.NewKeyword("only"), []any{v15})
									var v45 any = tmp44
									_ = v45
									var tmp46 any
									if lang.IsTruthy(v45) {
										tmp46 = v45
									} else {
										tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp48 := tmp47.FindInternedVar(lang.NewSymbol("keys"))
										if tmp48.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
										}
										tmp49 := tmp48.Get()
										tmp50 := lang.Apply(tmp49, []any{v20})
										tmp46 = tmp50
									}
									tmp43 = tmp46
								} // end let
								tmp42 = tmp43
							}
							tmp39 = tmp42
						} // end let
						tmp29 = tmp39
					}
					var v40 any = tmp29
					_ = v40
					var tmp41 any
					var tmp42 any
					{ // let
						// let binding "and__0__auto__"
						var v43 any = v40
						_ = v43
						var tmp44 any
						if lang.IsTruthy(v43) {
							tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp46 := tmp45.FindInternedVar(lang.NewSymbol("not"))
							if tmp46.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
							}
							tmp47 := tmp46.Get()
							tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp49 := tmp48.FindInternedVar(lang.NewSymbol("instance?"))
							if tmp49.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
							}
							tmp50 := tmp49.Get()
							tmp51 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
							tmp52 := lang.Apply(tmp50, []any{tmp51, v40})
							tmp53 := lang.Apply(tmp47, []any{tmp52})
							tmp44 = tmp53
						} else {
							tmp44 = v43
						}
						tmp42 = tmp44
					} // end let
					if lang.IsTruthy(tmp42) {
						tmp43 := lang.Apply(errors5.New, []any{":only/:refer value must be a sequential collection of symbols"})
						panic(tmp43)
					} else {
					}
					_ = tmp41
					var tmp44 any
					{ // let
						// let binding "seq_9"
						tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp46 := tmp45.FindInternedVar(lang.NewSymbol("seq"))
						if tmp46.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
						}
						tmp47 := tmp46.Get()
						tmp48 := lang.Apply(tmp47, []any{v40})
						var v49 any = tmp48
						_ = v49
						// let binding "chunk_10"
						var v50 any = nil
						_ = v50
						// let binding "count_11"
						var v51 any = int64(0)
						_ = v51
						// let binding "i_12"
						var v52 any = int64(0)
						_ = v52
						for {
							var tmp53 any
							tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp55 := tmp54.FindInternedVar(lang.NewSymbol("<"))
							if tmp55.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
							}
							tmp56 := tmp55.Get()
							tmp57 := lang.Apply(tmp56, []any{v52, v51})
							if lang.IsTruthy(tmp57) {
								var tmp58 any
								{ // let
									// let binding "sym"
									tmp59, _ := lang.FieldOrMethod(v50, "nth")
									if reflect.TypeOf(tmp59).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp60 := lang.Apply(tmp59, []any{v52})
									var v61 any = tmp60
									_ = v61
									var tmp62 any
									tmp63 := lang.Apply(v28, []any{v61})
									if lang.IsTruthy(tmp63) {
									} else {
										var tmp64 any
										{ // let
											// let binding "v"
											tmp65 := lang.Apply(v20, []any{v61})
											var v66 any = tmp65
											_ = v66
											var tmp67 any
											if lang.IsTruthy(v66) {
											} else {
												panic("unimplemented: new with non-constant class type")
											}
											_ = tmp67
											tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp69 := tmp68.FindInternedVar(lang.NewSymbol("*ns*"))
											if tmp69.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
											}
											tmp70 := tmp69.Get()
											var tmp71 any
											{ // let
												// let binding "or__0__auto__"
												tmp72 := lang.Apply(v22, []any{v61})
												var v73 any = tmp72
												_ = v73
												var tmp74 any
												if lang.IsTruthy(v73) {
													tmp74 = v73
												} else {
													tmp74 = v61
												}
												tmp71 = tmp74
											} // end let
											tmp72, _ := lang.FieldOrMethod(tmp70, "Refer")
											if reflect.TypeOf(tmp72).Kind() != reflect.Func {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
											}
											tmp73 := lang.Apply(tmp72, []any{tmp71, v66})
											tmp64 = tmp73
										} // end let
										tmp62 = tmp64
									}
									_ = tmp62
									var tmp65 any = v49
									var tmp66 any = v50
									var tmp67 any = v51
									tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp70 := tmp69.FindInternedVar(lang.NewSymbol("unchecked-inc"))
									if tmp70.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
									}
									tmp71 := tmp70.Get()
									tmp72 := lang.Apply(tmp71, []any{v52})
									var tmp68 any = tmp72
									v49 = tmp65
									v50 = tmp66
									v51 = tmp67
									v52 = tmp68
									continue
								} // end let
								tmp53 = tmp58
							} else {
								var tmp59 any
								{ // let
									// let binding "temp__0__auto__"
									tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
									if tmp61.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
									}
									tmp62 := tmp61.Get()
									tmp63 := lang.Apply(tmp62, []any{v49})
									var v64 any = tmp63
									_ = v64
									var tmp65 any
									if lang.IsTruthy(v64) {
										var tmp66 any
										{ // let
											// let binding "seq_9"
											var v67 any = v64
											_ = v67
											var tmp68 any
											tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp70 := tmp69.FindInternedVar(lang.NewSymbol("chunked-seq?"))
											if tmp70.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
											}
											tmp71 := tmp70.Get()
											tmp72 := lang.Apply(tmp71, []any{v67})
											if lang.IsTruthy(tmp72) {
												var tmp73 any
												{ // let
													// let binding "c__0__auto__"
													tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp75 := tmp74.FindInternedVar(lang.NewSymbol("chunk-first"))
													if tmp75.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
													}
													tmp76 := tmp75.Get()
													tmp77 := lang.Apply(tmp76, []any{v67})
													var v78 any = tmp77
													_ = v78
													tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp81 := tmp80.FindInternedVar(lang.NewSymbol("chunk-rest"))
													if tmp81.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
													}
													tmp82 := tmp81.Get()
													tmp83 := lang.Apply(tmp82, []any{v67})
													var tmp79 any = tmp83
													var tmp84 any = v78
													tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp87 := tmp86.FindInternedVar(lang.NewSymbol("int"))
													if tmp87.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
													}
													tmp88 := tmp87.Get()
													tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp90 := tmp89.FindInternedVar(lang.NewSymbol("count"))
													if tmp90.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
													}
													tmp91 := tmp90.Get()
													tmp92 := lang.Apply(tmp91, []any{v78})
													tmp93 := lang.Apply(tmp88, []any{tmp92})
													var tmp85 any = tmp93
													tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp96 := tmp95.FindInternedVar(lang.NewSymbol("int"))
													if tmp96.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
													}
													tmp97 := tmp96.Get()
													tmp98 := lang.Apply(tmp97, []any{int64(0)})
													var tmp94 any = tmp98
													v49 = tmp79
													v50 = tmp84
													v51 = tmp85
													v52 = tmp94
													continue
												} // end let
												tmp68 = tmp73
											} else {
												var tmp74 any
												{ // let
													// let binding "sym"
													tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp76 := tmp75.FindInternedVar(lang.NewSymbol("first"))
													if tmp76.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
													}
													tmp77 := tmp76.Get()
													tmp78 := lang.Apply(tmp77, []any{v67})
													var v79 any = tmp78
													_ = v79
													var tmp80 any
													tmp81 := lang.Apply(v28, []any{v79})
													if lang.IsTruthy(tmp81) {
													} else {
														var tmp82 any
														{ // let
															// let binding "v"
															tmp83 := lang.Apply(v20, []any{v79})
															var v84 any = tmp83
															_ = v84
															var tmp85 any
															if lang.IsTruthy(v84) {
															} else {
																panic("unimplemented: new with non-constant class type")
															}
															_ = tmp85
															tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
															tmp87 := tmp86.FindInternedVar(lang.NewSymbol("*ns*"))
															if tmp87.IsMacro() {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
															}
															tmp88 := tmp87.Get()
															var tmp89 any
															{ // let
																// let binding "or__0__auto__"
																tmp90 := lang.Apply(v22, []any{v79})
																var v91 any = tmp90
																_ = v91
																var tmp92 any
																if lang.IsTruthy(v91) {
																	tmp92 = v91
																} else {
																	tmp92 = v79
																}
																tmp89 = tmp92
															} // end let
															tmp90, _ := lang.FieldOrMethod(tmp88, "Refer")
															if reflect.TypeOf(tmp90).Kind() != reflect.Func {
																panic(lang.NewIllegalArgumentError(fmt.Sprintf("Refer is not a function")))
															}
															tmp91 := lang.Apply(tmp90, []any{tmp89, v84})
															tmp82 = tmp91
														} // end let
														tmp80 = tmp82
													}
													_ = tmp80
													tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp85 := tmp84.FindInternedVar(lang.NewSymbol("next"))
													if tmp85.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
													}
													tmp86 := tmp85.Get()
													tmp87 := lang.Apply(tmp86, []any{v67})
													var tmp83 any = tmp87
													var tmp88 any = nil
													var tmp89 any = int64(0)
													var tmp90 any = int64(0)
													v49 = tmp83
													v50 = tmp88
													v51 = tmp89
													v52 = tmp90
													continue
												} // end let
												tmp68 = tmp74
											}
											tmp66 = tmp68
										} // end let
										tmp65 = tmp66
									} else {
									}
									tmp59 = tmp65
								} // end let
								tmp53 = tmp59
							}
							tmp44 = tmp53
							break
						}
					} // end let
					tmp5 = tmp44
				} // end let
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// refer-glojure
	{
		tmp0 := lang.NewSymbol("refer-glojure").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("filters"))), lang.NewKeyword("doc"), "Same as (refer 'glojure.core <filters>)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5800), lang.NewKeyword("end-line"), int(5800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/refer")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("concat"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("quote")})
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp31, []any{lang.NewSymbol("glojure.core")})
				tmp33 := lang.Apply(tmp24, []any{tmp28, tmp32})
				tmp34 := lang.Apply(tmp21, []any{tmp33})
				tmp35 := lang.Apply(tmp18, []any{tmp34})
				tmp36 := lang.Apply(tmp11, []any{tmp15, tmp35, v5})
				tmp37 := lang.Apply(tmp8, []any{tmp36})
				return tmp37
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// release-pending-sends
	{
		tmp0 := lang.NewSymbol("release-pending-sends").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(27), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2131), lang.NewKeyword("end-line"), int(2131))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(nil, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rem
	{
		var tmp1 lang.FnFunc
		{ // function rem__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Remainder")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("rem").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"), lang.NewSymbol("div"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "remainder of dividing numerator by denominator.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1274), lang.NewKeyword("end-line"), int(1274))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove
	{
		tmp0 := lang.NewSymbol("remove").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2818), lang.NewKeyword("end-line"), int(2818))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("filter"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("complement"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp9, []any{v3})
				tmp11 := lang.Apply(tmp6, []any{tmp10})
				return tmp11
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("filter"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("complement"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				tmp12 := lang.Apply(tmp7, []any{tmp11, v4})
				return tmp12
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-all-methods
	{
		tmp0 := lang.NewSymbol("remove-all-methods").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"))), lang.NewKeyword("doc"), "Removes all of the methods of multimethod.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1787), lang.NewKeyword("end-line"), int(1787))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "reset")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "reset")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-method
	{
		tmp0 := lang.NewSymbol("remove-method").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("multifn"), lang.NewSymbol("dispatch-val"))), lang.NewKeyword("doc"), "Removes the method of multimethod associated with dispatch-value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1794), lang.NewKeyword("end-line"), int(1794))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeMethod")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeMethod is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-ns
	{
		tmp0 := lang.NewSymbol("remove-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the glojure namespace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4139), lang.NewKeyword("end-line"), int(4139))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.RemoveNamespace, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-tap
	{
		tmp0 := lang.NewSymbol("remove-tap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Remove f from the tap set.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7883), lang.NewKeyword("end-line"), int(7883))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("swap!"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("tapset"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("disj"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp6, []any{tmp9, tmp12, v3})
			_ = tmp13
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// remove-watch
	{
		tmp0 := lang.NewSymbol("remove-watch").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("reference"), lang.NewSymbol("key"))), lang.NewKeyword("doc"), "Removes a watch (set by add-watch) from a reference", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2160), lang.NewKeyword("end-line"), int(2160))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "removeWatch")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("removeWatch is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeat
	{
		tmp0 := lang.NewSymbol("repeat").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2997), lang.NewKeyword("end-line"), int(2997))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.Apply(lang.NewRepeat, []any{v3})
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.NewRepeatN, []any{v3, v4})
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// repeatedly
	{
		tmp0 := lang.NewSymbol("repeatedly").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5167), lang.NewKeyword("end-line"), int(5167))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp6 := tmp5.FindInternedVar(lang.NewSymbol("cons"))
					if tmp6.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
					}
					tmp7 := tmp6.Get()
					tmp8 := lang.Apply(v3, nil)
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("repeatedly"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{v3})
					tmp13 := lang.Apply(tmp7, []any{tmp8, tmp12})
					return tmp13
				})
				tmp5 := lang.Apply(lang.NewLazySeq, []any{tmp4})
				return tmp5
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("take"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("repeatedly"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{v3, tmp11})
				return tmp12
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replace
	{
		tmp0 := lang.NewSymbol("replace").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("smap")), lang.NewVector(lang.NewSymbol("smap"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5082), lang.NewKeyword("end-line"), int(5082))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("map"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					var tmp9 any
					{ // let
						// let binding "temp__0__auto__"
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("find"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v3, v8})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							var tmp16 any
							{ // let
								// let binding "e"
								var v17 any = v14
								_ = v17
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("val"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v17})
								tmp16 = tmp21
							} // end let
							tmp15 = tmp16
						} else {
							tmp15 = v8
						}
						tmp9 = tmp15
					} // end let
					return tmp9
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5090), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5090), lang.NewKeyword("end-column"), int(47))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					var tmp13 lang.FnFunc
					tmp13 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v14 := args[0]
						_ = v14
						v15 := args[1]
						_ = v15
						var tmp16 any
						{ // let
							// let binding "temp__0__auto__"
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("find"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp21 := tmp20.FindInternedVar(lang.NewSymbol("nth"))
							if tmp21.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
							}
							tmp22 := tmp21.Get()
							tmp23 := lang.Apply(tmp22, []any{v14, v15})
							tmp24 := lang.Apply(tmp19, []any{v3, tmp23})
							var v25 any = tmp24
							_ = v25
							var tmp26 any
							if lang.IsTruthy(v25) {
								var tmp27 any
								{ // let
									// let binding "e"
									var v28 any = v25
									_ = v28
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp33 := tmp32.FindInternedVar(lang.NewSymbol("val"))
									if tmp33.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
									}
									tmp34 := tmp33.Get()
									tmp35 := lang.Apply(tmp34, []any{v28})
									tmp36 := lang.Apply(tmp31, []any{v14, v15, tmp35})
									tmp27 = tmp36
								} // end let
								tmp26 = tmp27
							} else {
								tmp26 = v14
							}
							tmp16 = tmp26
						} // end let
						return tmp16
					})
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5093), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(5096), lang.NewKeyword("end-column"), int(23))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("range"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("count"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v4})
					tmp23 := lang.Apply(tmp18, []any{tmp22})
					tmp24 := lang.Apply(tmp12, []any{tmp15, v4, tmp23})
					tmp5 = tmp24
				} else {
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("map"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					var tmp28 lang.FnFunc
					tmp28 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v29 := args[0]
						_ = v29
						var tmp30 any
						{ // let
							// let binding "temp__0__auto__"
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("find"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.Apply(tmp33, []any{v3, v29})
							var v35 any = tmp34
							_ = v35
							var tmp36 any
							if lang.IsTruthy(v35) {
								var tmp37 any
								{ // let
									// let binding "e"
									var v38 any = v35
									_ = v38
									tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp40 := tmp39.FindInternedVar(lang.NewSymbol("val"))
									if tmp40.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
									}
									tmp41 := tmp40.Get()
									tmp42 := lang.Apply(tmp41, []any{v38})
									tmp37 = tmp42
								} // end let
								tmp36 = tmp37
							} else {
								tmp36 = v29
							}
							tmp30 = tmp36
						} // end let
						return tmp30
					})
					tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5098), lang.NewKeyword("column"), int(13), lang.NewKeyword("end-line"), int(5098), lang.NewKeyword("end-column"), int(49))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.Apply(tmp27, []any{tmp30, v4})
					tmp5 = tmp31
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// replicate
	{
		tmp0 := lang.NewSymbol("replicate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("x"))), lang.NewKeyword("doc"), "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("deprecated"), "1.3", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3004), lang.NewKeyword("end-line"), int(3004))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("take"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("repeat"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v4})
			tmp12 := lang.Apply(tmp7, []any{v3, tmp11})
			return tmp12
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// require
	{
		tmp0 := lang.NewSymbol("require").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :as-alias takes a symbol as its argument and aliases like :as, however\n    the lib will not be loaded. If the lib has not been loaded, a new\n    empty namespace will be created (as with create-ns).\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded (has no effect on libspecs using :as-alias)\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n    (has no effect on libspecs using :as-alias)\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries glojure.zip and glojure.set\n  abbreviated as 's'.\n\n  (require '(glojure zip [set :as s]))", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5989), lang.NewKeyword("end-line"), int(5989))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("apply"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("load-libs"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, lang.NewKeyword("require"), v3})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// requiring-resolve
	{
		tmp0 := lang.NewSymbol("requiring-resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6068), lang.NewKeyword("end-line"), int(6068))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("qualified-symbol?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				{ // let
					// let binding "or__0__auto__"
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("resolve"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{v3})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					if lang.IsTruthy(v14) {
						tmp15 = v14
					} else {
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("serialized-require"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp20 := tmp19.FindInternedVar(lang.NewSymbol("symbol"))
						if tmp20.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
						}
						tmp21 := tmp20.Get()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("namespace"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v3})
						tmp26 := lang.Apply(tmp21, []any{tmp25})
						tmp27 := lang.Apply(tmp18, []any{tmp26})
						_ = tmp27
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("resolve"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.Apply(tmp30, []any{v3})
						tmp15 = tmp31
					}
					tmp9 = tmp15
				} // end let
				tmp4 = tmp9
			} else {
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("str"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{"Not a qualified symbol: ", v3})
				tmp14 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp13})
				panic(tmp14)
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset!
	{
		tmp0 := lang.NewSymbol("reset!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2368), lang.NewKeyword("end-line"), int(2368))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-meta!
	{
		tmp0 := lang.NewSymbol("reset-meta!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("metadata-map"))), lang.NewKeyword("doc"), "Atomically resets the metadata for a namespace/var/ref/agent/atom", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2408), lang.NewKeyword("end-line"), int(2408))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "ResetMeta")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reset-vals!
	{
		tmp0 := lang.NewSymbol("reset-vals!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2375), lang.NewKeyword("end-line"), int(2375))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "resetVals")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("resetVals is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resolve
	{
		tmp0 := lang.NewSymbol("resolve").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sym")), lang.NewVector(lang.NewSymbol("env"), lang.NewSymbol("sym"))), lang.NewKeyword("doc"), "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4371), lang.NewKeyword("end-line"), int(4371))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("ns-resolve"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("*ns*"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("ns-resolve"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("*ns*"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp7, []any{tmp10, v3, v4})
				return tmp11
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rest
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("rest").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(64), lang.NewKeyword("end-line"), int(70))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function rest
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Rest, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(70), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(70), lang.NewKeyword("end-column"), int(77))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// restart-agent
	{
		tmp0 := lang.NewSymbol("restart-agent").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("new-state"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2175), lang.NewKeyword("end-line"), int(2175))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp9, []any{tmp12, v5})
					var v14 any = tmp13
					_ = v14
					var tmp15 any
					tmp16 := lang.Apply(lang.NewKeyword("clear-actions"), []any{v14})
					if lang.IsTruthy(tmp16) {
						tmp15 = true
					} else {
						tmp15 = false
					}
					tmp17, _ := lang.FieldOrMethod(v3, "restart")
					if reflect.TypeOf(tmp17).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("restart is not a function")))
					}
					tmp18 := lang.Apply(tmp17, []any{v4, tmp15})
					tmp6 = tmp18
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// resultset-seq
	{
		tmp0 := lang.NewSymbol("resultset-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rs"))), lang.NewKeyword("doc"), "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5681), lang.NewKeyword("end-line"), int(5681))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "rsmeta"
				tmp5, _ := lang.FieldOrMethod(v3, "getMetaData")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getMetaData is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{})
				var v7 any = tmp6
				_ = v7
				// let binding "idxs"
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("range"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("inc"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14, _ := lang.FieldOrMethod(v7, "getColumnCount")
				if reflect.TypeOf(tmp14).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnCount is not a function")))
				}
				tmp15 := lang.Apply(tmp14, []any{})
				tmp16 := lang.Apply(tmp13, []any{tmp15})
				tmp17 := lang.Apply(tmp10, []any{int64(1), tmp16})
				var v18 any = tmp17
				_ = v18
				// let binding "keys"
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("map"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("comp"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("keyword"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				var tmp28 lang.FnFunc
				tmp28 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v29 := args[0]
					_ = v29
					tmp30, ok := lang.FieldOrMethod(v29, "toLowerCase")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v29, "toLowerCase")))
					}
					var tmp31 any
					switch reflect.TypeOf(tmp30).Kind() {
					case reflect.Func:
						tmp31 = lang.Apply(tmp30, nil)
					default:
						tmp31 = tmp30
					}
					return tmp31
				})
				tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5688), lang.NewKeyword("column"), int(35), lang.NewKeyword("end-line"), int(5688), lang.NewKeyword("end-column"), int(62))
				tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp31 := lang.Apply(tmp24, []any{tmp27, tmp30})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("map"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				var tmp35 lang.FnFunc
				tmp35 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v36 := args[0]
					_ = v36
					tmp37, _ := lang.FieldOrMethod(v7, "getColumnLabel")
					if reflect.TypeOf(tmp37).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("getColumnLabel is not a function")))
					}
					tmp38 := lang.Apply(tmp37, []any{v36})
					return tmp38
				})
				tmp36 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5689), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(5689), lang.NewKeyword("end-column"), int(63))
				tmp37, err := lang.WithMeta(tmp35, tmp36.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp38 := lang.Apply(tmp34, []any{tmp37, v18})
				tmp39 := lang.Apply(tmp21, []any{tmp31, tmp38})
				var v40 any = tmp39
				_ = v40
				// let binding "check-keys"
				var tmp41 any
				{ // let
					// let binding "or__0__auto__"
					tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp43 := tmp42.FindInternedVar(lang.NewSymbol("apply"))
					if tmp43.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
					}
					tmp44 := tmp43.Get()
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("distinct?"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.Apply(tmp44, []any{tmp47, v40})
					var v49 any = tmp48
					_ = v49
					var tmp50 any
					if lang.IsTruthy(v49) {
						tmp50 = v49
					} else {
						tmp51 := lang.Apply(lang.NewError, []any{"ResultSet must have unique column labels"})
						panic(tmp51)
					}
					tmp41 = tmp50
				} // end let
				var v42 any = tmp41
				_ = v42
				// let binding "row-struct"
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("apply"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp47 := tmp46.FindInternedVar(lang.NewSymbol("create-struct"))
				if tmp47.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
				}
				tmp48 := tmp47.Get()
				tmp49 := lang.Apply(tmp45, []any{tmp48, v40})
				var v50 any = tmp49
				_ = v50
				// let binding "row-values"
				var tmp51 lang.FnFunc
				tmp51 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp53 := tmp52.FindInternedVar(lang.NewSymbol("map"))
					if tmp53.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
					}
					tmp54 := tmp53.Get()
					var tmp55 lang.FnFunc
					tmp55 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v56 := args[0]
						_ = v56
						tmp57, _ := lang.FieldOrMethod(v3, "getObject")
						if reflect.TypeOf(tmp57).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("getObject is not a function")))
						}
						tmp58 := lang.Apply(tmp57, []any{v56})
						return tmp58
					})
					tmp56 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5694), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(5694), lang.NewKeyword("end-column"), int(71))
					tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp58 := lang.Apply(tmp54, []any{tmp57, v18})
					return tmp58
				})
				tmp52 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5694), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(5694), lang.NewKeyword("end-column"), int(78))
				tmp53, err := lang.WithMeta(tmp51, tmp52.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v54 any = tmp53
				_ = v54
				// let binding "rows"
				var tmp55 lang.FnFunc
				{ // function thisfn
					var v56 lang.FnFunc
					tmp55 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						var tmp57 any
						tmp58, _ := lang.FieldOrMethod(v3, "next")
						if reflect.TypeOf(tmp58).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("next is not a function")))
						}
						tmp59 := lang.Apply(tmp58, []any{})
						if lang.IsTruthy(tmp59) {
							tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp61 := tmp60.FindInternedVar(lang.NewSymbol("cons"))
							if tmp61.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
							}
							tmp62 := tmp61.Get()
							tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp64 := tmp63.FindInternedVar(lang.NewSymbol("apply"))
							if tmp64.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
							}
							tmp65 := tmp64.Get()
							tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp67 := tmp66.FindInternedVar(lang.NewSymbol("struct"))
							if tmp67.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
							}
							tmp68 := tmp67.Get()
							tmp69 := lang.Apply(v54, nil)
							tmp70 := lang.Apply(tmp65, []any{tmp68, v50, tmp69})
							var tmp71 lang.FnFunc
							tmp71 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								tmp72 := lang.Apply(v56, nil)
								return tmp72
							})
							tmp72 := lang.Apply(lang.NewLazySeq, []any{tmp71})
							tmp73 := lang.Apply(tmp62, []any{tmp70, tmp72})
							tmp57 = tmp73
						} else {
						}
						return tmp57
					})
					v56 = tmp55
					_ = v56
				}
				tmp56 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5695), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5697), lang.NewKeyword("end-column"), int(86))
				tmp57, err := lang.WithMeta(tmp55, tmp56.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v58 any = tmp57
				_ = v58
				tmp59 := lang.Apply(v58, nil)
				tmp4 = tmp59
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reverse
	{
		tmp0 := lang.NewSymbol("reverse").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the items in coll in reverse order. Not lazy.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(940), lang.NewKeyword("end-line"), int(940))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("reduce1"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("conj"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.Apply(tmp6, []any{tmp9, lang.NewList(), v3})
			return tmp10
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// reversible?
	{
		tmp0 := lang.NewSymbol("reversible?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Reversible", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6257), lang.NewKeyword("end-line"), int(6257))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-directory
	{
		tmp0 := lang.NewSymbol("root-directory").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Returns the root resource path for a lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5871), lang.NewKeyword("end-line"), int(5871), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "d"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("root-resource"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("subs"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(strings8.LastIndex, []any{v9, "/"})
				tmp14 := lang.Apply(tmp12, []any{v9, int64(0), tmp13})
				tmp4 = tmp14
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// root-resource
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("root-resource").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("lib"))), lang.NewKeyword("doc"), "Returns the root directory path for a lib", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5864), lang.NewKeyword("end-line"), int(5864), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("str"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("name"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v4})
			tmp12 := lang.Apply(strings8.ReplaceAll, []any{tmp11, "-", "_"})
			tmp13 := lang.Apply(strings8.ReplaceAll, []any{tmp12, ".", "/"})
			tmp14 := lang.Apply(tmp7, []any{lang.NewChar(47), tmp13})
			return tmp14
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rseq
	{
		tmp0 := lang.NewSymbol("rseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("rev"))), lang.NewKeyword("doc"), "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1577), lang.NewKeyword("end-line"), int(1577))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "rseq")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("rseq is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// rsubseq
	{
		tmp0 := lang.NewSymbol("rsubseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("start-test"), lang.NewSymbol("start-key"), lang.NewSymbol("end-test"), lang.NewSymbol("end-key"))), lang.NewKeyword("doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5150), lang.NewKeyword("end-line"), int(5150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3, v4, v5})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("<"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("<="))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp15, tmp18}))
					tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5158), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5158), lang.NewKeyword("end-column"), int(17))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp22 := lang.Apply(tmp21, []any{v4})
					if lang.IsTruthy(tmp22) {
						var tmp23 any
						{ // let
							// let binding "temp__0__auto__"
							tmp24, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp24).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp25 := lang.Apply(tmp24, []any{v5, false})
							var v26 any = tmp25
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								var tmp28 any
								{ // let
									// let binding "vec__74"
									var v29 any = v26
									_ = v29
									// let binding "e"
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("nth"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v29, int64(0), nil})
									var v34 any = tmp33
									_ = v34
									// let binding "s"
									var v35 any = v29
									_ = v35
									var tmp36 any
									tmp37 := lang.Apply(v11, []any{v34})
									if lang.IsTruthy(tmp37) {
										tmp36 = v35
									} else {
										tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp39 := tmp38.FindInternedVar(lang.NewSymbol("next"))
										if tmp39.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
										}
										tmp40 := tmp39.Get()
										tmp41 := lang.Apply(tmp40, []any{v35})
										tmp36 = tmp41
									}
									tmp28 = tmp36
								} // end let
								tmp27 = tmp28
							} else {
							}
							tmp23 = tmp27
						} // end let
						tmp12 = tmp23
					} else {
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("take-while"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp27).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp28 := lang.Apply(tmp27, []any{false})
						tmp29 := lang.Apply(tmp26, []any{v11, tmp28})
						tmp12 = tmp29
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v7, false})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__77"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("nth"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, []any{v14, int64(0), nil})
							var v19 any = tmp18
							_ = v19
							// let binding "s"
							var v20 any = v14
							_ = v20
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("take-while"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{v3, v4, v5})
							var tmp28 any
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v3, v6, v7})
							tmp33 := lang.Apply(tmp32, []any{v19})
							if lang.IsTruthy(tmp33) {
								tmp28 = v20
							} else {
								tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp35 := tmp34.FindInternedVar(lang.NewSymbol("next"))
								if tmp35.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
								}
								tmp36 := tmp35.Get()
								tmp37 := lang.Apply(tmp36, []any{v20})
								tmp28 = tmp37
							}
							tmp38 := lang.Apply(tmp23, []any{tmp27, tmp28})
							tmp13 = tmp38
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// run!
	{
		tmp0 := lang.NewSymbol("run!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("proc"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7708), lang.NewKeyword("end-line"), int(7708))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("reduce"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			var tmp8 lang.FnFunc
			tmp8 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v9 := args[0]
				_ = v9
				v10 := args[1]
				_ = v10
				tmp11 := lang.Apply(v3, []any{v10})
				return tmp11
			})
			tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7713), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(7713), lang.NewKeyword("end-column"), int(20))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.Apply(tmp7, []any{tmp10, nil, v4})
			_ = tmp11
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// second
	{
		tmp0 := lang.NewSymbol("second").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Same as (first (next x))", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(7), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(91), lang.NewKeyword("end-line"), int(95))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function second
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("first"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("next"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v4})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				return tmp12
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(95), lang.NewKeyword("column"), int(9), lang.NewKeyword("end-line"), int(95), lang.NewKeyword("end-column"), int(49))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// select-keys
	{
		tmp0 := lang.NewSymbol("select-keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"), lang.NewSymbol("keyseq"))), lang.NewKeyword("doc"), "Returns a map containing only those entries in map whose key is in keys", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1536), lang.NewKeyword("end-line"), int(1536))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := lang.NewMap()
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(1541), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(1541), lang.NewKeyword("end-column"), int(17))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "keys"
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v4})
				var v14 any = tmp13
				_ = v14
				for {
					var tmp15 any
					if lang.IsTruthy(v14) {
						var tmp16 any
						{ // let
							// let binding "entry"
							tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp18 := tmp17.FindInternedVar(lang.NewSymbol("first"))
							if tmp18.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
							}
							tmp19 := tmp18.Get()
							tmp20 := lang.Apply(tmp19, []any{v14})
							tmp21, _ := lang.FieldOrMethod(runtime4.RT, "Find")
							if reflect.TypeOf(tmp21).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("Find is not a function")))
							}
							tmp22 := lang.Apply(tmp21, []any{v3, tmp20})
							var v23 any = tmp22
							_ = v23
							var tmp25 any
							if lang.IsTruthy(v23) {
								tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp27 := tmp26.FindInternedVar(lang.NewSymbol("conj"))
								if tmp27.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
								}
								tmp28 := tmp27.Get()
								tmp29 := lang.Apply(tmp28, []any{v9, v23})
								tmp25 = tmp29
							} else {
								tmp25 = v9
							}
							var tmp24 any = tmp25
							tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp32 := tmp31.FindInternedVar(lang.NewSymbol("next"))
							if tmp32.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
							}
							tmp33 := tmp32.Get()
							tmp34 := lang.Apply(tmp33, []any{v14})
							var tmp30 any = tmp34
							v9 = tmp24
							v14 = tmp30
							continue
						} // end let
						tmp15 = tmp16
					} else {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("with-meta"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("meta"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v3})
						tmp24 := lang.Apply(tmp19, []any{v9, tmp23})
						tmp15 = tmp24
					}
					tmp5 = tmp15
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send
	{
		tmp0 := lang.NewSymbol("send").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2109), lang.NewKeyword("end-line"), int(2109))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("apply"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("send-via"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp8, []any{tmp11, nil, v3, v4, v5})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-off
	{
		tmp0 := lang.NewSymbol("send-off").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2120), lang.NewKeyword("end-line"), int(2120))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("apply"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("send-via"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp8, []any{tmp11, nil, v3, v4, v5})
				return tmp12
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// send-via
	{
		tmp0 := lang.NewSymbol("send-via").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"), lang.NewSymbol("a"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2099), lang.NewKeyword("end-line"), int(2099))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("hash-map"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("*agent*"))
					tmp15 := lang.Apply(tmp13, []any{tmp14, v4})
					tmp16 := lang.Apply(tmp10, []any{tmp15})
					_ = tmp16
					var tmp17 any
					func() {
						defer func() {
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.Apply(tmp20, nil)
							_ = tmp21
						}()
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("binding-conveyor-fn"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v5})
						tmp17 = tmp25
					}()
					tmp7 = tmp17
				} // end let
				tmp8, _ := lang.FieldOrMethod(v4, "dispatch")
				if reflect.TypeOf(tmp8).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("dispatch is not a function")))
				}
				tmp9 := lang.Apply(tmp8, []any{tmp7, v6, v3})
				return tmp9
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq
	{
		tmp1 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
		tmp0 := lang.NewSymbol("seq").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(4), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(126), lang.NewKeyword("end-line"), int(136))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		{ // function seq
			var v4 lang.FnFunc
			tmp3 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v5 := args[0]
				_ = v5
				tmp6 := lang.Apply(lang.Seq, []any{v5})
				return tmp6
			})
			tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(136), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(136), lang.NewKeyword("end-column"), int(126))).(lang.FnFunc)
			v4 = tmp3
			_ = v4
		}
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq-to-map-for-destructuring
	{
		tmp0 := lang.NewSymbol("seq-to-map-for-destructuring").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Builds a map from a seq as described in\n  https://glojure.org/reference/special_forms#keyword-arguments", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4390), lang.NewKeyword("end-line"), int(4390))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("next"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("to-array"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp13 := lang.Apply(lang.NewPersistentArrayMapAsIfByAssoc, []any{tmp12})
				tmp4 = tmp13
			} else {
				var tmp14 any
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("seq"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{v3})
				if lang.IsTruthy(tmp18) {
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("first"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.Apply(tmp21, []any{v3})
					tmp14 = tmp22
				} else {
				}
				tmp4 = tmp14
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seq?
	{
		tmp0 := lang.NewSymbol("seq?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements ISeq", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(146), lang.NewKeyword("end-line"), int(150))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function seq?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf((*lang.ISeq)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
				return tmp9
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(150), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(150), lang.NewKeyword("end-column"), int(87))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seqable?
	{
		tmp0 := lang.NewSymbol("seqable?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if the seq function is supported for x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6204), lang.NewKeyword("end-line"), int(6204))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(nil, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// seque
	{
		tmp0 := lang.NewSymbol("seque").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("n-or-q"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5419), lang.NewKeyword("end-line"), int(5419))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seque"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.Apply(tmp6, []any{int64(100), v3})
				return tmp7
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "q"
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{nil, v3})
					if lang.IsTruthy(tmp10) {
						tmp6 = v3
					} else {
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("int"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v3})
						tmp15 := lang.Apply(nil, []any{tmp14})
						tmp6 = tmp15
					}
					var v16 any = tmp6
					_ = v16
					// let binding "NIL"
					tmp17 := lang.Apply(reflect.StructOf, []any{nil})
					tmp18 := lang.Apply(reflect.New, []any{tmp17})
					tmp19, ok := lang.FieldOrMethod(tmp18, "Interface")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", tmp18, "Interface")))
					}
					var tmp20 any
					switch reflect.TypeOf(tmp19).Kind() {
					case reflect.Func:
						tmp20 = lang.Apply(tmp19, nil)
					default:
						tmp20 = tmp19
					}
					var v21 any = tmp20
					_ = v21
					// let binding "agt"
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("agent"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					var tmp25 lang.FnFunc
					tmp25 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 0 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						return v4
					})
					tmp26 := lang.Apply(lang.NewLazySeq, []any{tmp25})
					tmp27 := lang.Apply(tmp24, []any{tmp26})
					var v28 any = tmp27
					_ = v28
					// let binding "log-error"
					var tmp29 lang.FnFunc
					tmp29 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 2 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v30 := args[0]
						_ = v30
						v31 := args[1]
						_ = v31
						var tmp32 any
						tmp33, _ := lang.FieldOrMethod(v30, "offer")
						if reflect.TypeOf(tmp33).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
						}
						tmp34 := lang.Apply(tmp33, []any{v30})
						if lang.IsTruthy(tmp34) {
							panic(v31)
						} else {
							tmp32 = v31
						}
						return tmp32
					})
					tmp30 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5435), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(5438), lang.NewKeyword("end-column"), int(26))
					tmp31, err := lang.WithMeta(tmp29, tmp30.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v32 any = tmp31
					_ = v32
					// let binding "fill"
					var tmp33 lang.FnFunc
					tmp33 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v34 := args[0]
						_ = v34
						var tmp35 any
						if lang.IsTruthy(v34) {
							var tmp36 any
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("instance?"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.Apply(tmp39, []any{nil, v34})
							if lang.IsTruthy(tmp40) {
								tmp41 := lang.Apply(v32, []any{v16, v34})
								tmp36 = tmp41
							} else {
								var tmp42 any
								func() {
									defer func() {
										if r := recover(); r != nil {
											if lang.CatchMatches(r, lang.Builtins["any"]) {
												v43 := r
												_ = v43
												tmp44 := lang.Apply(v32, []any{v16, v43})
												tmp42 = tmp44
											} else {
												panic(r)
											}
										}
									}()
									var tmp43 any
									{ // let
										// let binding "G__89"
										tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp45 := tmp44.FindInternedVar(lang.NewSymbol("seq"))
										if tmp45.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
										}
										tmp46 := tmp45.Get()
										tmp47 := lang.Apply(tmp46, []any{v34})
										var v48 any = tmp47
										_ = v48
										// let binding "vec__90"
										var v49 any = v48
										_ = v49
										// let binding "seq__91"
										tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp51 := tmp50.FindInternedVar(lang.NewSymbol("seq"))
										if tmp51.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
										}
										tmp52 := tmp51.Get()
										tmp53 := lang.Apply(tmp52, []any{v49})
										var v54 any = tmp53
										_ = v54
										// let binding "first__92"
										tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp56 := tmp55.FindInternedVar(lang.NewSymbol("first"))
										if tmp56.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
										}
										tmp57 := tmp56.Get()
										tmp58 := lang.Apply(tmp57, []any{v54})
										var v59 any = tmp58
										_ = v59
										// let binding "seq__91"
										tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp61 := tmp60.FindInternedVar(lang.NewSymbol("next"))
										if tmp61.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
										}
										tmp62 := tmp61.Get()
										tmp63 := lang.Apply(tmp62, []any{v54})
										var v64 any = tmp63
										_ = v64
										// let binding "x"
										var v65 any = v59
										_ = v65
										// let binding "xs"
										var v66 any = v64
										_ = v66
										// let binding "s"
										var v67 any = v49
										_ = v67
										var tmp68 any
										{ // let
											// let binding "G__89"
											var v69 any = v48
											_ = v69
											for {
												var tmp70 any
												{ // let
													// let binding "vec__93"
													var v71 any = v69
													_ = v71
													// let binding "seq__94"
													tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp73 := tmp72.FindInternedVar(lang.NewSymbol("seq"))
													if tmp73.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
													}
													tmp74 := tmp73.Get()
													tmp75 := lang.Apply(tmp74, []any{v71})
													var v76 any = tmp75
													_ = v76
													// let binding "first__95"
													tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp78 := tmp77.FindInternedVar(lang.NewSymbol("first"))
													if tmp78.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
													}
													tmp79 := tmp78.Get()
													tmp80 := lang.Apply(tmp79, []any{v76})
													var v81 any = tmp80
													_ = v81
													// let binding "seq__94"
													tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp83 := tmp82.FindInternedVar(lang.NewSymbol("next"))
													if tmp83.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
													}
													tmp84 := tmp83.Get()
													tmp85 := lang.Apply(tmp84, []any{v76})
													var v86 any = tmp85
													_ = v86
													// let binding "x"
													var v87 any = v81
													_ = v87
													// let binding "xs"
													var v88 any = v86
													_ = v88
													// let binding "s"
													var v89 any = v71
													_ = v89
													var tmp90 any
													if lang.IsTruthy(v89) {
														var tmp91 any
														var tmp92 any
														tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
														tmp94 := tmp93.FindInternedVar(lang.NewSymbol("nil?"))
														if tmp94.IsMacro() {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
														}
														tmp95 := tmp94.Get()
														tmp96 := lang.Apply(tmp95, []any{v87})
														if lang.IsTruthy(tmp96) {
															tmp92 = v21
														} else {
															tmp92 = v87
														}
														tmp97, _ := lang.FieldOrMethod(v16, "offer")
														if reflect.TypeOf(tmp97).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp98 := lang.Apply(tmp97, []any{tmp92})
														if lang.IsTruthy(tmp98) {
															var tmp99 any = v88
															v69 = tmp99
															continue
														} else {
															tmp91 = v89
														}
														tmp90 = tmp91
													} else {
														var tmp100 any
														tmp101, _ := lang.FieldOrMethod(v16, "offer")
														if reflect.TypeOf(tmp101).Kind() != reflect.Func {
															panic(lang.NewIllegalArgumentError(fmt.Sprintf("offer is not a function")))
														}
														tmp102 := lang.Apply(tmp101, []any{v16})
														if lang.IsTruthy(tmp102) {
														} else {
															tmp100 = lang.NewList()
														}
														tmp90 = tmp100
													}
													tmp70 = tmp90
												} // end let
												tmp68 = tmp70
												break
											}
										} // end let
										tmp43 = tmp68
									} // end let
									tmp42 = tmp43
								}()
								tmp36 = tmp42
							}
							tmp35 = tmp36
						} else {
						}
						return tmp35
					})
					tmp34 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5439), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(5452), lang.NewKeyword("end-column"), int(44))
					tmp35, err := lang.WithMeta(tmp33, tmp34.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v36 any = tmp35
					_ = v36
					// let binding "drain"
					var tmp37 lang.FnFunc
					{ // function drain
						var v38 lang.FnFunc
						tmp37 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							var tmp39 lang.FnFunc
							tmp39 = lang.NewFnFunc(func(args ...any) any {
								if len(args) != 0 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								var tmp40 any
								{ // let
									// let binding "x"
									tmp41, ok := lang.FieldOrMethod(v16, "take")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v16, "take")))
									}
									var tmp42 any
									switch reflect.TypeOf(tmp41).Kind() {
									case reflect.Func:
										tmp42 = lang.Apply(tmp41, nil)
									default:
										tmp42 = tmp41
									}
									var v43 any = tmp42
									_ = v43
									var tmp44 any
									tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp46 := tmp45.FindInternedVar(lang.NewSymbol("identical?"))
									if tmp46.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
									}
									tmp47 := tmp46.Get()
									tmp48 := lang.Apply(tmp47, []any{v43, v16})
									if lang.IsTruthy(tmp48) {
										tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp50 := tmp49.FindInternedVar(lang.NewSymbol("deref"))
										if tmp50.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
										}
										tmp51 := tmp50.Get()
										tmp52 := lang.Apply(tmp51, []any{v28})
										_ = tmp52
									} else {
										tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp54 := tmp53.FindInternedVar(lang.NewSymbol("send-off"))
										if tmp54.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
										}
										tmp55 := tmp54.Get()
										tmp56 := lang.Apply(tmp55, []any{v28, v36})
										_ = tmp56
										tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp58 := tmp57.FindInternedVar(lang.NewSymbol("release-pending-sends"))
										if tmp58.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
										}
										tmp59 := tmp58.Get()
										tmp60 := lang.Apply(tmp59, nil)
										_ = tmp60
										tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp62 := tmp61.FindInternedVar(lang.NewSymbol("cons"))
										if tmp62.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
										}
										tmp63 := tmp62.Get()
										var tmp64 any
										tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp66 := tmp65.FindInternedVar(lang.NewSymbol("identical?"))
										if tmp66.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
										}
										tmp67 := tmp66.Get()
										tmp68 := lang.Apply(tmp67, []any{v43, v21})
										if lang.IsTruthy(tmp68) {
										} else {
											tmp64 = v43
										}
										tmp69 := lang.Apply(v38, nil)
										tmp70 := lang.Apply(tmp63, []any{tmp64, tmp69})
										tmp44 = tmp70
									}
									tmp40 = tmp44
								} // end let
								return tmp40
							})
							tmp40 := lang.Apply(lang.NewLazySeq, []any{tmp39})
							return tmp40
						})
						v38 = tmp37
						_ = v38
					}
					tmp38 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5453), lang.NewKeyword("column"), int(16), lang.NewKeyword("end-line"), int(5461), lang.NewKeyword("end-column"), int(73))
					tmp39, err := lang.WithMeta(tmp37, tmp38.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v40 any = tmp39
					_ = v40
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("send-off"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v28, v36})
					_ = tmp44
					tmp45 := lang.Apply(v40, nil)
					tmp5 = tmp45
				} // end let
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequence
	{
		tmp0 := lang.NewSymbol("sequence").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("coll"), lang.NewSymbol("&"), lang.NewSymbol("colls"))), lang.NewKeyword("doc"), "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2639), lang.NewKeyword("end-line"), int(2639))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 any
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				if lang.IsTruthy(tmp8) {
					tmp4 = v3
				} else {
					var tmp9 any
					{ // let
						// let binding "or__0__auto__"
						tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp11 := tmp10.FindInternedVar(lang.NewSymbol("seq"))
						if tmp11.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
						}
						tmp12 := tmp11.Get()
						tmp13 := lang.Apply(tmp12, []any{v3})
						var v14 any = tmp13
						_ = v14
						var tmp15 any
						if lang.IsTruthy(v14) {
							tmp15 = v14
						} else {
							tmp15 = lang.NewList()
						}
						tmp9 = tmp15
					} // end let
					tmp4 = tmp9
				}
				return tmp4
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				{ // let
					// let binding "or__0__auto__"
					tmp6 := lang.Apply(nil, []any{v4})
					tmp7 := lang.Apply(nil, []any{v3, tmp6})
					tmp8 := lang.Apply(nil, []any{tmp7})
					var v9 any = tmp8
					_ = v9
					var tmp10 any
					if lang.IsTruthy(v9) {
						tmp10 = v9
					} else {
						tmp10 = lang.NewList()
					}
					tmp5 = tmp10
				} // end let
				return tmp5
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "or__0__auto__"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("map"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					var tmp10 lang.FnFunc
					tmp10 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v11 := args[0]
						_ = v11
						tmp12 := lang.Apply(nil, []any{v11})
						return tmp12
					})
					tmp11 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2661), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(2661), lang.NewKeyword("end-column"), int(41))
					tmp12, err := lang.WithMeta(tmp10, tmp11.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("cons"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.Apply(tmp15, []any{v4, v5})
					tmp17 := lang.Apply(tmp9, []any{tmp12, tmp16})
					tmp18 := lang.Apply(nil, []any{v3, tmp17})
					tmp19 := lang.Apply(nil, []any{tmp18})
					var v20 any = tmp19
					_ = v20
					var tmp21 any
					if lang.IsTruthy(v20) {
						tmp21 = v20
					} else {
						tmp21 = lang.NewList()
					}
					tmp6 = tmp21
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sequential?
	{
		tmp0 := lang.NewSymbol("sequential?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Sequential", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6229), lang.NewKeyword("end-line"), int(6229))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Sequential)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// serialized-require
	{
		tmp0 := lang.NewSymbol("serialized-require").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.10", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(6059), lang.NewKeyword("end-line"), int(6059), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				var tmp4 any
				{ // let
					// let binding "lockee__0__auto__"
					var v5 any = nil
					_ = v5
					var tmp6 any
					func() {
						var tmp7 any
						{ // let
							// let binding "locklocal__1__auto__"
							var v8 any = v5
							_ = v8
							tmp9 := lang.Apply(nil, []any{v8})
							_ = tmp9
							var tmp10 any
							func() {
								defer func() {
									tmp11 := lang.Apply(nil, []any{v8})
									_ = tmp11
								}()
								tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp13 := tmp12.FindInternedVar(lang.NewSymbol("apply"))
								if tmp13.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
								}
								tmp14 := tmp13.Get()
								tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp16 := tmp15.FindInternedVar(lang.NewSymbol("require"))
								if tmp16.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
								}
								tmp17 := tmp16.Get()
								tmp18 := lang.Apply(tmp14, []any{tmp17, v3})
								tmp10 = tmp18
							}()
							tmp7 = tmp10
						} // end let
						tmp6 = tmp7
					}()
					tmp4 = tmp6
				} // end let
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set
	{
		tmp0 := lang.NewSymbol("set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a set of the distinct elements of coll.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4104), lang.NewKeyword("end-line"), int(4104))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("set?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("with-meta"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3, nil})
				tmp4 = tmp12
			} else {
				var tmp13 any
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
				tmp18 := lang.Apply(tmp16, []any{tmp17, v3})
				if lang.IsTruthy(tmp18) {
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("persistent!"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("transient"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp29 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4112), lang.NewKeyword("column"), int(108), lang.NewKeyword("end-line"), int(4112), lang.NewKeyword("end-column"), int(110))
					tmp30, err := lang.WithMeta(tmp28, tmp29.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp31 := lang.Apply(tmp27, []any{tmp30})
					tmp32, _ := lang.FieldOrMethod(v3, "ReduceInit")
					if reflect.TypeOf(tmp32).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
					}
					tmp33 := lang.Apply(tmp32, []any{tmp24, tmp31})
					tmp34 := lang.Apply(tmp21, []any{tmp33})
					tmp13 = tmp34
				} else {
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("persistent!"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("reduce1"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("transient"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
					tmp48 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4113), lang.NewKeyword("column"), int(46), lang.NewKeyword("end-line"), int(4113), lang.NewKeyword("end-column"), int(48))
					tmp49, err := lang.WithMeta(tmp47, tmp48.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp50 := lang.Apply(tmp46, []any{tmp49})
					tmp51 := lang.Apply(tmp40, []any{tmp43, tmp50, v3})
					tmp52 := lang.Apply(tmp37, []any{tmp51})
					tmp13 = tmp52
				}
				tmp4 = tmp13
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-executor!
	{
		tmp0 := lang.NewSymbol("set-agent-send-executor!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"))), lang.NewKeyword("doc"), "Sets the ExecutorService to be used by send", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2087), lang.NewKeyword("end-line"), int(2087))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-agent-send-off-executor!
	{
		tmp0 := lang.NewSymbol("set-agent-send-off-executor!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("executor"))), lang.NewKeyword("doc"), "Sets the ExecutorService to be used by send-off", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(34), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2093), lang.NewKeyword("end-line"), int(2093))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			return nil
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-handler!
	{
		tmp0 := lang.NewSymbol("set-error-handler!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("handler-fn"))), lang.NewKeyword("doc"), "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2192), lang.NewKeyword("end-line"), int(2192))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorHandler")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorHandler is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-error-mode!
	{
		tmp0 := lang.NewSymbol("set-error-mode!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("mode-keyword"))), lang.NewKeyword("doc"), "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2210), lang.NewKeyword("end-line"), int(2210))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setErrorMode")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setErrorMode is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set-validator!
	{
		tmp0 := lang.NewSymbol("set-validator!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("iref"), lang.NewSymbol("validator-fn"))), lang.NewKeyword("doc"), "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2381), lang.NewKeyword("end-line"), int(2381))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "setValidator")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// set?
	{
		tmp0 := lang.NewSymbol("set?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x implements IPersistentSet", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4098), lang.NewKeyword("end-line"), int(4098))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.IPersistentSet)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// setup-reference
	{
		tmp0 := lang.NewSymbol("setup-reference").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2043), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(2044), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("r"), lang.NewSymbol("options"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "opts"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("apply"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("hash-map"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp8, []any{tmp11, v4})
				var v13 any = tmp12
				_ = v13
				var tmp14 any
				tmp15 := lang.Apply(lang.NewKeyword("meta"), []any{v13})
				if lang.IsTruthy(tmp15) {
					tmp16 := lang.Apply(lang.NewKeyword("meta"), []any{v13})
					tmp17, _ := lang.FieldOrMethod(v3, "ResetMeta")
					if reflect.TypeOf(tmp17).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("ResetMeta is not a function")))
					}
					tmp18 := lang.Apply(tmp17, []any{tmp16})
					tmp14 = tmp18
				} else {
				}
				_ = tmp14
				var tmp19 any
				tmp20 := lang.Apply(lang.NewKeyword("validator"), []any{v13})
				if lang.IsTruthy(tmp20) {
					tmp21 := lang.Apply(lang.NewKeyword("validator"), []any{v13})
					tmp22, _ := lang.FieldOrMethod(v3, "setValidator")
					if reflect.TypeOf(tmp22).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("setValidator is not a function")))
					}
					tmp23 := lang.Apply(tmp22, []any{tmp21})
					tmp19 = tmp23
				} else {
				}
				_ = tmp19
				tmp5 = v3
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shift-mask
	{
		tmp0 := lang.NewSymbol("shift-mask").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6598), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(6598), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("shift"), lang.NewSymbol("mask"), lang.NewSymbol("x"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("bit-and"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("bit-shift-right"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp11, []any{v5, v3})
			tmp13 := lang.Apply(tmp8, []any{tmp12, v4})
			return tmp13
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short
	{
		var tmp1 lang.FnFunc
		{ // function short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				var tmp30 any
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("*unchecked-math*"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				if lang.IsTruthy(tmp33) {
					tmp30 = lang.NewSymbol("uncheckedShortCast")
				} else {
					tmp30 = lang.NewSymbol("shortCast")
				}
				tmp34 := lang.Apply(tmp29, []any{tmp30})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.Apply(tmp37, []any{v3})
				tmp39 := lang.Apply(tmp26, []any{tmp34, tmp38})
				tmp40 := lang.Apply(tmp23, []any{tmp39})
				tmp41 := lang.Apply(tmp20, []any{tmp40})
				tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp41})
				tmp43 := lang.Apply(tmp6, []any{tmp42})
				return tmp43
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to short", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3499), lang.NewKeyword("end-line"), int(3499))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.ShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// short-array
	{
		var tmp1 lang.FnFunc
		{ // function short-array__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				switch len(args) {
				default:
					if len(args) < 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var v3 any = lang.NewList(args[0:]...)
					_ = v3
					tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
					if tmp5.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
					}
					tmp6 := tmp5.Get()
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/ShortArray")})
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
					if tmp26.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
					}
					tmp27 := tmp26.Get()
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("glojure.core/unquote-splicing")})
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.Apply(tmp37, []any{lang.NewSymbol("glojure.core/args")})
					tmp39 := lang.Apply(tmp30, []any{tmp34, tmp38})
					tmp40 := lang.Apply(tmp27, []any{tmp39})
					tmp41 := lang.Apply(tmp24, []any{tmp40})
					tmp42 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp41})
					tmp43 := lang.Apply(tmp6, []any{tmp42})
					return tmp43
				}
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("short-array").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("size-or-seq")), lang.NewVector(lang.NewSymbol("size"), lang.NewSymbol("init-val-or-seq"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Creates an array of shorts", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("inline-arities"), lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{int64(1), int64(2)})), lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5333), lang.NewKeyword("end-line"), int(5333))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				tmp5, _ := lang.FieldOrMethod(lang.Numbers, "ShortArray")
				if reflect.TypeOf(tmp5).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArray is not a function")))
				}
				tmp6 := lang.Apply(tmp5, []any{v4})
				return tmp6
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(lang.Numbers, "ShortArrayInit")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("ShortArrayInit is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shorts
	{
		var tmp1 lang.FnFunc
		{ // function shorts
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(tmp20, []any{lang.NewSymbol("glojure.core/Shorts")})
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("list"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.Apply(tmp24, []any{v3})
				tmp26 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp21, tmp25})
				tmp27 := lang.Apply(tmp6, []any{tmp26})
				return tmp27
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("shorts").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xs"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Casts to shorts[]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(12), lang.NewKeyword("line"), int(5387), lang.NewKeyword("end-line"), int(5387))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Shorts")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Shorts is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shuffle
	{
		tmp0 := lang.NewSymbol("shuffle").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Return a random permutation of coll", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7300), lang.NewKeyword("end-line"), int(7300))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "al"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("to-array"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(lang.NewArrayList, []any{tmp8})
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.Apply(nil, []any{v10})
				_ = tmp11
				tmp12, ok := lang.FieldOrMethod(v10, "toArray")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v10, "toArray")))
				}
				var tmp13 any
				switch reflect.TypeOf(tmp12).Kind() {
				case reflect.Func:
					tmp13 = lang.Apply(tmp12, nil)
				default:
					tmp13 = tmp12
				}
				tmp14 := lang.Apply(nil, []any{tmp13})
				tmp4 = tmp14
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// shutdown-agents
	{
		tmp0 := lang.NewSymbol("shutdown-agents").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector()), lang.NewKeyword("doc"), "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2252), lang.NewKeyword("end-line"), int(2252))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 0 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			tmp3 := lang.Apply(lang.ShutdownAgents, nil)
			return tmp3
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sigs
	{
		tmp0 := lang.NewSymbol("sigs").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(223), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(224), lang.NewKeyword("end-column"), int(5), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("assert-valid-fdecl"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{v3})
			_ = tmp7
			var tmp8 any
			{ // let
				// let binding "asig"
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v10 := args[0]
					_ = v10
					var tmp11 any
					{ // let
						// let binding "arglist"
						tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
						if tmp13.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
						}
						tmp14 := tmp13.Get()
						tmp15 := lang.Apply(tmp14, []any{v10})
						var v16 any = tmp15
						_ = v16
						// let binding "arglist"
						var tmp17 any
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("first"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v16})
						tmp22 := lang.Apply(lang.Equals, []any{lang.NewSymbol("&form"), tmp21})
						if lang.IsTruthy(tmp22) {
							tmp23 := lang.Apply(lang.Count, []any{v16})
							tmp24 := lang.Apply(lang.Subvec, []any{v16, int64(2), tmp23})
							tmp17 = tmp24
						} else {
							tmp17 = v16
						}
						var v25 any = tmp17
						_ = v25
						// let binding "body"
						tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp27 := tmp26.FindInternedVar(lang.NewSymbol("next"))
						if tmp27.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
						}
						tmp28 := tmp27.Get()
						tmp29 := lang.Apply(tmp28, []any{v10})
						var v30 any = tmp29
						_ = v30
						var tmp31 any
						tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp33 := tmp32.FindInternedVar(lang.NewSymbol("map?"))
						if tmp33.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
						}
						tmp34 := tmp33.Get()
						tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp36 := tmp35.FindInternedVar(lang.NewSymbol("first"))
						if tmp36.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
						}
						tmp37 := tmp36.Get()
						tmp38 := lang.Apply(tmp37, []any{v30})
						tmp39 := lang.Apply(tmp34, []any{tmp38})
						if lang.IsTruthy(tmp39) {
							var tmp40 any
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("next"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(tmp43, []any{v30})
							if lang.IsTruthy(tmp44) {
								tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp46 := tmp45.FindInternedVar(lang.NewSymbol("with-meta"))
								if tmp46.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
								}
								tmp47 := tmp46.Get()
								tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp49 := tmp48.FindInternedVar(lang.NewSymbol("conj"))
								if tmp49.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
								}
								tmp50 := tmp49.Get()
								var tmp51 any
								tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp53 := tmp52.FindInternedVar(lang.NewSymbol("meta"))
								if tmp53.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
								}
								tmp54 := tmp53.Get()
								tmp55 := lang.Apply(tmp54, []any{v25})
								if lang.IsTruthy(tmp55) {
									tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp57 := tmp56.FindInternedVar(lang.NewSymbol("meta"))
									if tmp57.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
									}
									tmp58 := tmp57.Get()
									tmp59 := lang.Apply(tmp58, []any{v25})
									tmp51 = tmp59
								} else {
									tmp60 := lang.NewMap()
									tmp61 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(237), lang.NewKeyword("column"), int(77), lang.NewKeyword("end-line"), int(237), lang.NewKeyword("end-column"), int(78))
									tmp62, err := lang.WithMeta(tmp60, tmp61.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp51 = tmp62
								}
								tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp64 := tmp63.FindInternedVar(lang.NewSymbol("first"))
								if tmp64.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
								}
								tmp65 := tmp64.Get()
								tmp66 := lang.Apply(tmp65, []any{v30})
								tmp67 := lang.Apply(tmp50, []any{tmp51, tmp66})
								tmp68 := lang.Apply(tmp47, []any{v25, tmp67})
								tmp40 = tmp68
							} else {
								tmp40 = v25
							}
							tmp31 = tmp40
						} else {
							tmp31 = v25
						}
						tmp11 = tmp31
					} // end let
					return tmp11
				})
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(228), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(239), lang.NewKeyword("end-column"), int(25))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v12 any = tmp11
				_ = v12
				// let binding "resolve-tag"
				var tmp13 lang.FnFunc
				tmp13 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v14 := args[0]
					_ = v14
					var tmp15 any
					{ // let
						// let binding "m"
						tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp17 := tmp16.FindInternedVar(lang.NewSymbol("meta"))
						if tmp17.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
						}
						tmp18 := tmp17.Get()
						tmp19 := lang.Apply(tmp18, []any{v14})
						var v20 any = tmp19
						_ = v20
						// let binding "tag"
						tmp21 := lang.Apply(lang.NewKeyword("tag"), []any{v20})
						var v22 any = tmp21
						_ = v22
						var tmp23 any
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := reflect.TypeOf((*lang.Symbol)(nil))
						tmp28 := lang.Apply(tmp26, []any{tmp27, v22})
						if lang.IsTruthy(tmp28) {
							var tmp29 any
							tmp30, ok := lang.FieldOrMethod(v22, "Name")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v22, "Name")))
							}
							var tmp31 any
							switch reflect.TypeOf(tmp30).Kind() {
							case reflect.Func:
								tmp31 = lang.Apply(tmp30, nil)
							default:
								tmp31 = tmp30
							}
							tmp32 := lang.Apply(strings8.Index, []any{tmp31, "."})
							tmp33 := lang.Apply(lang.Equiv, []any{tmp32, int64(-1)})
							if lang.IsTruthy(tmp33) {
								var tmp34 any
								tmp35 := lang.Apply(lang.Equals, []any{nil, nil})
								if lang.IsTruthy(tmp35) {
									var tmp36 any
									{ // let
										// let binding "c"
										var v37 any = nil
										_ = v37
										var tmp38 any
										if lang.IsTruthy(v37) {
											tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp40 := tmp39.FindInternedVar(lang.NewSymbol("with-meta"))
											if tmp40.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
											}
											tmp41 := tmp40.Get()
											tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp43 := tmp42.FindInternedVar(lang.NewSymbol("assoc"))
											if tmp43.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
											}
											tmp44 := tmp43.Get()
											tmp45, ok := lang.FieldOrMethod(v37, "Name")
											if !ok {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v37, "Name")))
											}
											var tmp46 any
											switch reflect.TypeOf(tmp45).Kind() {
											case reflect.Func:
												tmp46 = lang.Apply(tmp45, nil)
											default:
												tmp46 = tmp45
											}
											tmp47 := lang.Apply(lang.NewSymbol, []any{tmp46})
											tmp48 := lang.Apply(tmp44, []any{v20, lang.NewKeyword("tag"), tmp47})
											tmp49 := lang.Apply(tmp41, []any{v14, tmp48})
											tmp38 = tmp49
										} else {
											tmp38 = v14
										}
										tmp36 = tmp38
									} // end let
									tmp34 = tmp36
								} else {
									tmp34 = v14
								}
								tmp29 = tmp34
							} else {
								tmp29 = v14
							}
							tmp23 = tmp29
						} else {
							tmp23 = v14
						}
						tmp15 = tmp23
					} // end let
					return tmp15
				})
				tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(240), lang.NewKeyword("column"), int(22), lang.NewKeyword("end-line"), int(252), lang.NewKeyword("end-column"), int(37))
				tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v16 any = tmp15
				_ = v16
				var tmp17 any
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq?"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{v3})
				tmp25 := lang.Apply(tmp20, []any{tmp24})
				if lang.IsTruthy(tmp25) {
					var tmp26 any
					{ // let
						// let binding "ret"
						tmp27 := lang.NewVector()
						tmp28 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(254), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(254), lang.NewKeyword("end-column"), int(20))
						tmp29, err := lang.WithMeta(tmp27, tmp28.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v30 any = tmp29
						_ = v30
						// let binding "fdecls"
						var v31 any = v3
						_ = v31
						for {
							var tmp32 any
							if lang.IsTruthy(v31) {
								tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp35 := tmp34.FindInternedVar(lang.NewSymbol("conj"))
								if tmp35.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
								}
								tmp36 := tmp35.Get()
								tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp38 := tmp37.FindInternedVar(lang.NewSymbol("first"))
								if tmp38.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
								}
								tmp39 := tmp38.Get()
								tmp40 := lang.Apply(tmp39, []any{v31})
								tmp41 := lang.Apply(v12, []any{tmp40})
								tmp42 := lang.Apply(v16, []any{tmp41})
								tmp43 := lang.Apply(tmp36, []any{v30, tmp42})
								var tmp33 any = tmp43
								tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp46 := tmp45.FindInternedVar(lang.NewSymbol("next"))
								if tmp46.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
								}
								tmp47 := tmp46.Get()
								tmp48 := lang.Apply(tmp47, []any{v31})
								var tmp44 any = tmp48
								v30 = tmp33
								v31 = tmp44
								continue
							} else {
								tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp50 := tmp49.FindInternedVar(lang.NewSymbol("seq"))
								if tmp50.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
								}
								tmp51 := tmp50.Get()
								tmp52 := lang.Apply(tmp51, []any{v30})
								tmp32 = tmp52
							}
							tmp26 = tmp32
							break
						}
					} // end let
					tmp17 = tmp26
				} else {
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(v12, []any{v3})
					tmp31 := lang.Apply(v16, []any{tmp30})
					tmp32 := lang.Apply(tmp29, []any{tmp31})
					tmp17 = tmp32
				}
				tmp8 = tmp17
			} // end let
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(225), lang.NewKeyword("column"), int(2), lang.NewKeyword("end-line"), int(258), lang.NewKeyword("end-column"), int(43))).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-ident?
	{
		tmp0 := lang.NewSymbol("simple-ident?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol or keyword without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1613), lang.NewKeyword("end-line"), int(1613))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("ident?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("nil?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("namespace"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					tmp10 = tmp18
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-keyword?
	{
		tmp0 := lang.NewSymbol("simple-keyword?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a keyword without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1633), lang.NewKeyword("end-line"), int(1633))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("keyword?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("nil?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("namespace"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					tmp10 = tmp18
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// simple-symbol?
	{
		tmp0 := lang.NewSymbol("simple-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a symbol without a namespace", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1623), lang.NewKeyword("end-line"), int(1623))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "and__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("symbol?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				var v9 any = tmp8
				_ = v9
				var tmp10 any
				if lang.IsTruthy(v9) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("nil?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("namespace"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.Apply(tmp16, []any{v3})
					tmp18 := lang.Apply(tmp13, []any{tmp17})
					tmp10 = tmp18
				} else {
					tmp10 = v9
				}
				tmp4 = tmp10
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// slurp
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("slurp").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("opts"))), lang.NewKeyword("doc"), "Opens a reader on f and reads all its contents, returning a string.\n  See glojure.java.io/reader for a complete list of supported arguments.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6982), lang.NewKeyword("end-line"), int(6982))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "opts"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("normalize-slurp-opts"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v5})
					var v11 any = tmp10
					_ = v11
					// let binding "sw"
					var v12 any = "unimplemented: new with non-constant class type"
					_ = v12
					var tmp13 any
					{ // let
						// let binding "r"
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("apply"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.go.io"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("reader"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp16, []any{tmp19, v4, v11})
						var v21 any = tmp20
						_ = v21
						var tmp22 any
						func() {
							defer func() {
								tmp23, ok := lang.FieldOrMethod(v21, "close")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v21, "close")))
								}
								var tmp24 any
								switch reflect.TypeOf(tmp23).Kind() {
								case reflect.Func:
									tmp24 = lang.Apply(tmp23, nil)
								default:
									tmp24 = tmp23
								}
								_ = tmp24
							}()
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.go.io"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("copy"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := lang.Apply(tmp27, []any{v21, v12})
							_ = tmp28
							tmp29 := lang.Apply(lang.ToString, []any{v12})
							tmp22 = tmp29
						}()
						tmp13 = tmp22
					} // end let
					tmp6 = tmp13
				} // end let
				return tmp6
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some
	{
		tmp0 := lang.NewSymbol("some").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2684), lang.NewKeyword("end-line"), int(2684))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
		recur_loop_481:
			var tmp5 any
			{ // let
				// let binding "temp__0__auto__"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				if lang.IsTruthy(v10) {
					var tmp12 any
					{ // let
						// let binding "s"
						var v13 any = v10
						_ = v13
						var tmp14 any
						{ // let
							// let binding "or__0__auto__"
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, []any{v13})
							tmp19 := lang.Apply(v3, []any{tmp18})
							var v20 any = tmp19
							_ = v20
							var tmp21 any
							if lang.IsTruthy(v20) {
								tmp21 = v20
							} else {
								var tmp22 any = v3
								tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp25 := tmp24.FindInternedVar(lang.NewSymbol("next"))
								if tmp25.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
								}
								tmp26 := tmp25.Get()
								tmp27 := lang.Apply(tmp26, []any{v13})
								var tmp23 any = tmp27
								v3 = tmp22
								v4 = tmp23
								goto recur_loop_481
							}
							tmp14 = tmp21
						} // end let
						tmp12 = tmp14
					} // end let
					tmp11 = tmp12
				} else {
				}
				tmp5 = tmp11
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->
	{
		tmp0 := lang.NewSymbol("some->").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7610), lang.NewKeyword("end-line"), int(7610))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, nil)
					var v12 any = tmp11
					_ = v12
					// let binding "steps"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v17 := args[0]
						_ = v17
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("concat"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("if")})
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("seq"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("concat"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("glojure.core/nil?")})
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.Apply(tmp43, []any{v12})
						tmp45 := lang.Apply(tmp36, []any{tmp40, tmp44})
						tmp46 := lang.Apply(tmp33, []any{tmp45})
						tmp47 := lang.Apply(tmp30, []any{tmp46})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{nil})
						tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
						if tmp53.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
						}
						tmp54 := tmp53.Get()
						tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp56 := tmp55.FindInternedVar(lang.NewSymbol("seq"))
						if tmp56.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
						}
						tmp57 := tmp56.Get()
						tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp59 := tmp58.FindInternedVar(lang.NewSymbol("concat"))
						if tmp59.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
						}
						tmp60 := tmp59.Get()
						tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
						if tmp62.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
						}
						tmp63 := tmp62.Get()
						tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("glojure.core/->")})
						tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
						if tmp66.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
						}
						tmp67 := tmp66.Get()
						tmp68 := lang.Apply(tmp67, []any{v12})
						tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
						if tmp70.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
						}
						tmp71 := tmp70.Get()
						tmp72 := lang.Apply(tmp71, []any{v17})
						tmp73 := lang.Apply(tmp60, []any{tmp64, tmp68, tmp72})
						tmp74 := lang.Apply(tmp57, []any{tmp73})
						tmp75 := lang.Apply(tmp54, []any{tmp74})
						tmp76 := lang.Apply(tmp23, []any{tmp27, tmp47, tmp51, tmp75})
						tmp77 := lang.Apply(tmp20, []any{tmp76})
						return tmp77
					})
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7616), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7616), lang.NewKeyword("end-column"), int(64))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{tmp18, v6})
					var v20 any = tmp19
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/let")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("apply"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("vector"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v12})
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.Apply(tmp52, []any{v5})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("interleave"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("repeat"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v12})
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("butlast"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.Apply(tmp63, []any{v20})
					tmp65 := lang.Apply(tmp56, []any{tmp60, tmp64})
					tmp66 := lang.Apply(tmp45, []any{tmp49, tmp53, tmp65})
					tmp67 := lang.Apply(tmp42, []any{tmp66})
					tmp68 := lang.Apply(tmp36, []any{tmp39, tmp67})
					tmp69 := lang.Apply(tmp33, []any{tmp68})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					var tmp73 any
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("empty?"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.Apply(tmp76, []any{v20})
					if lang.IsTruthy(tmp77) {
						tmp73 = v12
					} else {
						tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp79 := tmp78.FindInternedVar(lang.NewSymbol("last"))
						if tmp79.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
						}
						tmp80 := tmp79.Get()
						tmp81 := lang.Apply(tmp80, []any{v20})
						tmp73 = tmp81
					}
					tmp82 := lang.Apply(tmp72, []any{tmp73})
					tmp83 := lang.Apply(tmp26, []any{tmp30, tmp69, tmp82})
					tmp84 := lang.Apply(tmp23, []any{tmp83})
					tmp7 = tmp84
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some->>
	{
		tmp0 := lang.NewSymbol("some->>").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"), lang.NewSymbol("&"), lang.NewSymbol("forms"))), lang.NewKeyword("doc"), "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.5", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7624), lang.NewKeyword("end-line"), int(7624))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "g"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("gensym"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, nil)
					var v12 any = tmp11
					_ = v12
					// let binding "steps"
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol("map"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					var tmp16 lang.FnFunc
					tmp16 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v17 := args[0]
						_ = v17
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("concat"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("list"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{lang.NewSymbol("if")})
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("seq"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("concat"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("list"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.Apply(tmp39, []any{lang.NewSymbol("glojure.core/nil?")})
						tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp42 := tmp41.FindInternedVar(lang.NewSymbol("list"))
						if tmp42.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
						}
						tmp43 := tmp42.Get()
						tmp44 := lang.Apply(tmp43, []any{v12})
						tmp45 := lang.Apply(tmp36, []any{tmp40, tmp44})
						tmp46 := lang.Apply(tmp33, []any{tmp45})
						tmp47 := lang.Apply(tmp30, []any{tmp46})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.Apply(tmp50, []any{nil})
						tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp53 := tmp52.FindInternedVar(lang.NewSymbol("list"))
						if tmp53.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
						}
						tmp54 := tmp53.Get()
						tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp56 := tmp55.FindInternedVar(lang.NewSymbol("seq"))
						if tmp56.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
						}
						tmp57 := tmp56.Get()
						tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp59 := tmp58.FindInternedVar(lang.NewSymbol("concat"))
						if tmp59.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
						}
						tmp60 := tmp59.Get()
						tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
						if tmp62.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
						}
						tmp63 := tmp62.Get()
						tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("glojure.core/->>")})
						tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
						if tmp66.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
						}
						tmp67 := tmp66.Get()
						tmp68 := lang.Apply(tmp67, []any{v12})
						tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
						if tmp70.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
						}
						tmp71 := tmp70.Get()
						tmp72 := lang.Apply(tmp71, []any{v17})
						tmp73 := lang.Apply(tmp60, []any{tmp64, tmp68, tmp72})
						tmp74 := lang.Apply(tmp57, []any{tmp73})
						tmp75 := lang.Apply(tmp54, []any{tmp74})
						tmp76 := lang.Apply(tmp23, []any{tmp27, tmp47, tmp51, tmp75})
						tmp77 := lang.Apply(tmp20, []any{tmp76})
						return tmp77
					})
					tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7630), lang.NewKeyword("column"), int(20), lang.NewKeyword("end-line"), int(7630), lang.NewKeyword("end-column"), int(65))
					tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp19 := lang.Apply(tmp15, []any{tmp18, v6})
					var v20 any = tmp19
					_ = v20
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/let")})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("apply"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("vector"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("seq"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("concat"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp47 := tmp46.FindInternedVar(lang.NewSymbol("list"))
					if tmp47.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
					}
					tmp48 := tmp47.Get()
					tmp49 := lang.Apply(tmp48, []any{v12})
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("list"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.Apply(tmp52, []any{v5})
					tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp55 := tmp54.FindInternedVar(lang.NewSymbol("interleave"))
					if tmp55.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
					}
					tmp56 := tmp55.Get()
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("repeat"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v12})
					tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp62 := tmp61.FindInternedVar(lang.NewSymbol("butlast"))
					if tmp62.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
					}
					tmp63 := tmp62.Get()
					tmp64 := lang.Apply(tmp63, []any{v20})
					tmp65 := lang.Apply(tmp56, []any{tmp60, tmp64})
					tmp66 := lang.Apply(tmp45, []any{tmp49, tmp53, tmp65})
					tmp67 := lang.Apply(tmp42, []any{tmp66})
					tmp68 := lang.Apply(tmp36, []any{tmp39, tmp67})
					tmp69 := lang.Apply(tmp33, []any{tmp68})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					var tmp73 any
					tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp75 := tmp74.FindInternedVar(lang.NewSymbol("empty?"))
					if tmp75.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
					}
					tmp76 := tmp75.Get()
					tmp77 := lang.Apply(tmp76, []any{v20})
					if lang.IsTruthy(tmp77) {
						tmp73 = v12
					} else {
						tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp79 := tmp78.FindInternedVar(lang.NewSymbol("last"))
						if tmp79.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
						}
						tmp80 := tmp79.Get()
						tmp81 := lang.Apply(tmp80, []any{v20})
						tmp73 = tmp81
					}
					tmp82 := lang.Apply(tmp72, []any{tmp73})
					tmp83 := lang.Apply(tmp26, []any{tmp30, tmp69, tmp82})
					tmp84 := lang.Apply(tmp23, []any{tmp83})
					tmp7 = tmp84
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some-fn
	{
		tmp0 := lang.NewSymbol("some-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("p")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3")), lang.NewVector(lang.NewSymbol("p1"), lang.NewSymbol("p2"), lang.NewSymbol("p3"), lang.NewSymbol("&"), lang.NewSymbol("ps"))), lang.NewKeyword("doc"), "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7462), lang.NewKeyword("end-line"), int(7462))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				{ // function sp1
					var v5 lang.FnFunc
					tmp4 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v6 := args[0]
							_ = v6
							tmp7 := lang.Apply(v3, []any{v6})
							return tmp7
						case 2:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v6})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v3, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 3:
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v6})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v7})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v3, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v6 := args[0]
							_ = v6
							v7 := args[1]
							_ = v7
							v8 := args[2]
							_ = v8
							var v9 any = lang.NewList(args[3:]...)
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v5, []any{v6, v7, v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp15 := tmp14.FindInternedVar(lang.NewSymbol("some"))
									if tmp15.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
									}
									tmp16 := tmp15.Get()
									tmp17 := lang.Apply(tmp16, []any{v3, v9})
									tmp13 = tmp17
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						}
					})
					v5 = tmp4
					_ = v5
				}
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7469), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7475), lang.NewKeyword("end-column"), int(43))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				{ // function sp2
					var v6 lang.FnFunc
					tmp5 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v7 := args[0]
							_ = v7
							var tmp8 any
							{ // let
								// let binding "or__0__auto__"
								tmp9 := lang.Apply(v3, []any{v7})
								var v10 any = tmp9
								_ = v10
								var tmp11 any
								if lang.IsTruthy(v10) {
									tmp11 = v10
								} else {
									tmp12 := lang.Apply(v4, []any{v7})
									tmp11 = tmp12
								}
								tmp8 = tmp11
							} // end let
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v7})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v3, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											var tmp17 any
											{ // let
												// let binding "or__0__auto__"
												tmp18 := lang.Apply(v4, []any{v7})
												var v19 any = tmp18
												_ = v19
												var tmp20 any
												if lang.IsTruthy(v19) {
													tmp20 = v19
												} else {
													tmp21 := lang.Apply(v4, []any{v8})
													tmp20 = tmp21
												}
												tmp17 = tmp20
											} // end let
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 3:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v7})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v8})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v3, []any{v9})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v7})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v4, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v4, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							v9 := args[2]
							_ = v9
							var v10 any = lang.NewList(args[3:]...)
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v6, []any{v7, v8, v9})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp16 := tmp15.FindInternedVar(lang.NewSymbol("some"))
									if tmp16.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
									}
									tmp17 := tmp16.Get()
									var tmp18 lang.FnFunc
									tmp18 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v19 := args[0]
										_ = v19
										var tmp20 any
										{ // let
											// let binding "or__0__auto__"
											tmp21 := lang.Apply(v3, []any{v19})
											var v22 any = tmp21
											_ = v22
											var tmp23 any
											if lang.IsTruthy(v22) {
												tmp23 = v22
											} else {
												tmp24 := lang.Apply(v4, []any{v19})
												tmp23 = tmp24
											}
											tmp20 = tmp23
										} // end let
										return tmp20
									})
									tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7483), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7483), lang.NewKeyword("end-column"), int(52))
									tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp21 := lang.Apply(tmp17, []any{tmp20, v10})
									tmp14 = tmp21
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						}
					})
					v6 = tmp5
					_ = v6
				}
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7477), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7483), lang.NewKeyword("end-column"), int(61))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 lang.FnFunc
				{ // function sp3
					var v7 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							return nil
						case 1:
							v8 := args[0]
							_ = v8
							var tmp9 any
							{ // let
								// let binding "or__0__auto__"
								tmp10 := lang.Apply(v3, []any{v8})
								var v11 any = tmp10
								_ = v11
								var tmp12 any
								if lang.IsTruthy(v11) {
									tmp12 = v11
								} else {
									var tmp13 any
									{ // let
										// let binding "or__0__auto__"
										tmp14 := lang.Apply(v4, []any{v8})
										var v15 any = tmp14
										_ = v15
										var tmp16 any
										if lang.IsTruthy(v15) {
											tmp16 = v15
										} else {
											tmp17 := lang.Apply(v5, []any{v8})
											tmp16 = tmp17
										}
										tmp13 = tmp16
									} // end let
									tmp12 = tmp13
								}
								tmp9 = tmp12
							} // end let
							return tmp9
						case 2:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							var tmp10 any
							{ // let
								// let binding "or__0__auto__"
								tmp11 := lang.Apply(v3, []any{v8})
								var v12 any = tmp11
								_ = v12
								var tmp13 any
								if lang.IsTruthy(v12) {
									tmp13 = v12
								} else {
									var tmp14 any
									{ // let
										// let binding "or__0__auto__"
										tmp15 := lang.Apply(v3, []any{v9})
										var v16 any = tmp15
										_ = v16
										var tmp17 any
										if lang.IsTruthy(v16) {
											tmp17 = v16
										} else {
											var tmp18 any
											{ // let
												// let binding "or__0__auto__"
												tmp19 := lang.Apply(v4, []any{v8})
												var v20 any = tmp19
												_ = v20
												var tmp21 any
												if lang.IsTruthy(v20) {
													tmp21 = v20
												} else {
													var tmp22 any
													{ // let
														// let binding "or__0__auto__"
														tmp23 := lang.Apply(v4, []any{v9})
														var v24 any = tmp23
														_ = v24
														var tmp25 any
														if lang.IsTruthy(v24) {
															tmp25 = v24
														} else {
															var tmp26 any
															{ // let
																// let binding "or__0__auto__"
																tmp27 := lang.Apply(v5, []any{v8})
																var v28 any = tmp27
																_ = v28
																var tmp29 any
																if lang.IsTruthy(v28) {
																	tmp29 = v28
																} else {
																	tmp30 := lang.Apply(v5, []any{v9})
																	tmp29 = tmp30
																}
																tmp26 = tmp29
															} // end let
															tmp25 = tmp26
														}
														tmp22 = tmp25
													} // end let
													tmp21 = tmp22
												}
												tmp18 = tmp21
											} // end let
											tmp17 = tmp18
										}
										tmp14 = tmp17
									} // end let
									tmp13 = tmp14
								}
								tmp10 = tmp13
							} // end let
							return tmp10
						case 3:
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var tmp11 any
							{ // let
								// let binding "or__0__auto__"
								tmp12 := lang.Apply(v3, []any{v8})
								var v13 any = tmp12
								_ = v13
								var tmp14 any
								if lang.IsTruthy(v13) {
									tmp14 = v13
								} else {
									var tmp15 any
									{ // let
										// let binding "or__0__auto__"
										tmp16 := lang.Apply(v3, []any{v9})
										var v17 any = tmp16
										_ = v17
										var tmp18 any
										if lang.IsTruthy(v17) {
											tmp18 = v17
										} else {
											var tmp19 any
											{ // let
												// let binding "or__0__auto__"
												tmp20 := lang.Apply(v3, []any{v10})
												var v21 any = tmp20
												_ = v21
												var tmp22 any
												if lang.IsTruthy(v21) {
													tmp22 = v21
												} else {
													var tmp23 any
													{ // let
														// let binding "or__0__auto__"
														tmp24 := lang.Apply(v4, []any{v8})
														var v25 any = tmp24
														_ = v25
														var tmp26 any
														if lang.IsTruthy(v25) {
															tmp26 = v25
														} else {
															var tmp27 any
															{ // let
																// let binding "or__0__auto__"
																tmp28 := lang.Apply(v4, []any{v9})
																var v29 any = tmp28
																_ = v29
																var tmp30 any
																if lang.IsTruthy(v29) {
																	tmp30 = v29
																} else {
																	var tmp31 any
																	{ // let
																		// let binding "or__0__auto__"
																		tmp32 := lang.Apply(v4, []any{v10})
																		var v33 any = tmp32
																		_ = v33
																		var tmp34 any
																		if lang.IsTruthy(v33) {
																			tmp34 = v33
																		} else {
																			var tmp35 any
																			{ // let
																				// let binding "or__0__auto__"
																				tmp36 := lang.Apply(v5, []any{v8})
																				var v37 any = tmp36
																				_ = v37
																				var tmp38 any
																				if lang.IsTruthy(v37) {
																					tmp38 = v37
																				} else {
																					var tmp39 any
																					{ // let
																						// let binding "or__0__auto__"
																						tmp40 := lang.Apply(v5, []any{v9})
																						var v41 any = tmp40
																						_ = v41
																						var tmp42 any
																						if lang.IsTruthy(v41) {
																							tmp42 = v41
																						} else {
																							tmp43 := lang.Apply(v5, []any{v10})
																							tmp42 = tmp43
																						}
																						tmp39 = tmp42
																					} // end let
																					tmp38 = tmp39
																				}
																				tmp35 = tmp38
																			} // end let
																			tmp34 = tmp35
																		}
																		tmp31 = tmp34
																	} // end let
																	tmp30 = tmp31
																}
																tmp27 = tmp30
															} // end let
															tmp26 = tmp27
														}
														tmp23 = tmp26
													} // end let
													tmp22 = tmp23
												}
												tmp19 = tmp22
											} // end let
											tmp18 = tmp19
										}
										tmp15 = tmp18
									} // end let
									tmp14 = tmp15
								}
								tmp11 = tmp14
							} // end let
							return tmp11
						default:
							if len(args) < 3 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v8 := args[0]
							_ = v8
							v9 := args[1]
							_ = v9
							v10 := args[2]
							_ = v10
							var v11 any = lang.NewList(args[3:]...)
							_ = v11
							var tmp12 any
							{ // let
								// let binding "or__0__auto__"
								tmp13 := lang.Apply(v7, []any{v8, v9, v10})
								var v14 any = tmp13
								_ = v14
								var tmp15 any
								if lang.IsTruthy(v14) {
									tmp15 = v14
								} else {
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("some"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									var tmp19 lang.FnFunc
									tmp19 = lang.NewFnFunc(func(args ...any) any {
										if len(args) != 1 {
											panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
										}
										v20 := args[0]
										_ = v20
										var tmp21 any
										{ // let
											// let binding "or__0__auto__"
											tmp22 := lang.Apply(v3, []any{v20})
											var v23 any = tmp22
											_ = v23
											var tmp24 any
											if lang.IsTruthy(v23) {
												tmp24 = v23
											} else {
												var tmp25 any
												{ // let
													// let binding "or__0__auto__"
													tmp26 := lang.Apply(v4, []any{v20})
													var v27 any = tmp26
													_ = v27
													var tmp28 any
													if lang.IsTruthy(v27) {
														tmp28 = v27
													} else {
														tmp29 := lang.Apply(v5, []any{v20})
														tmp28 = tmp29
													}
													tmp25 = tmp28
												} // end let
												tmp24 = tmp25
											}
											tmp21 = tmp24
										} // end let
										return tmp21
									})
									tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7491), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7491), lang.NewKeyword("end-column"), int(59))
									tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
									if err != nil {
										panic(err)
									}
									tmp22 := lang.Apply(tmp18, []any{tmp21, v11})
									tmp15 = tmp22
								}
								tmp12 = tmp15
							} // end let
							return tmp12
						}
					})
					v7 = tmp6
					_ = v7
				}
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7485), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(7491), lang.NewKeyword("end-column"), int(68))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "ps"
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("list*"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v3, v4, v5, v6})
					var v12 any = tmp11
					_ = v12
					var tmp13 lang.FnFunc
					{ // function spn
						var v14 lang.FnFunc
						tmp13 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								return nil
							case 1:
								v15 := args[0]
								_ = v15
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("some"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								var tmp19 lang.FnFunc
								tmp19 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v20 := args[0]
									_ = v20
									tmp21 := lang.Apply(v20, []any{v15})
									return tmp21
								})
								tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7496), lang.NewKeyword("column"), int(21), lang.NewKeyword("end-line"), int(7496), lang.NewKeyword("end-column"), int(26))
								tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp22 := lang.Apply(tmp18, []any{tmp21, v12})
								return tmp22
							case 2:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp18 := tmp17.FindInternedVar(lang.NewSymbol("some"))
								if tmp18.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
								}
								tmp19 := tmp18.Get()
								var tmp20 lang.FnFunc
								tmp20 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v21 := args[0]
									_ = v21
									var tmp22 any
									{ // let
										// let binding "or__0__auto__"
										tmp23 := lang.Apply(v21, []any{v15})
										var v24 any = tmp23
										_ = v24
										var tmp25 any
										if lang.IsTruthy(v24) {
											tmp25 = v24
										} else {
											tmp26 := lang.Apply(v21, []any{v16})
											tmp25 = tmp26
										}
										tmp22 = tmp25
									} // end let
									return tmp22
								})
								tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7497), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(7497), lang.NewKeyword("end-column"), int(39))
								tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp23 := lang.Apply(tmp19, []any{tmp22, v12})
								return tmp23
							case 3:
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("some"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								var tmp21 lang.FnFunc
								tmp21 = lang.NewFnFunc(func(args ...any) any {
									if len(args) != 1 {
										panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
									}
									v22 := args[0]
									_ = v22
									var tmp23 any
									{ // let
										// let binding "or__0__auto__"
										tmp24 := lang.Apply(v22, []any{v15})
										var v25 any = tmp24
										_ = v25
										var tmp26 any
										if lang.IsTruthy(v25) {
											tmp26 = v25
										} else {
											var tmp27 any
											{ // let
												// let binding "or__0__auto__"
												tmp28 := lang.Apply(v22, []any{v16})
												var v29 any = tmp28
												_ = v29
												var tmp30 any
												if lang.IsTruthy(v29) {
													tmp30 = v29
												} else {
													tmp31 := lang.Apply(v22, []any{v17})
													tmp30 = tmp31
												}
												tmp27 = tmp30
											} // end let
											tmp26 = tmp27
										}
										tmp23 = tmp26
									} // end let
									return tmp23
								})
								tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7498), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7498), lang.NewKeyword("end-column"), int(47))
								tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
								if err != nil {
									panic(err)
								}
								tmp24 := lang.Apply(tmp20, []any{tmp23, v12})
								return tmp24
							default:
								if len(args) < 3 {
									panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
								}
								v15 := args[0]
								_ = v15
								v16 := args[1]
								_ = v16
								v17 := args[2]
								_ = v17
								var v18 any = lang.NewList(args[3:]...)
								_ = v18
								var tmp19 any
								{ // let
									// let binding "or__0__auto__"
									tmp20 := lang.Apply(v14, []any{v15, v16, v17})
									var v21 any = tmp20
									_ = v21
									var tmp22 any
									if lang.IsTruthy(v21) {
										tmp22 = v21
									} else {
										tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp24 := tmp23.FindInternedVar(lang.NewSymbol("some"))
										if tmp24.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
										}
										tmp25 := tmp24.Get()
										var tmp26 lang.FnFunc
										tmp26 = lang.NewFnFunc(func(args ...any) any {
											if len(args) != 1 {
												panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
											}
											v27 := args[0]
											_ = v27
											tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp29 := tmp28.FindInternedVar(lang.NewSymbol("some"))
											if tmp29.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
											}
											tmp30 := tmp29.Get()
											tmp31 := lang.Apply(tmp30, []any{v27, v18})
											return tmp31
										})
										tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7500), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(7500), lang.NewKeyword("end-column"), int(49))
										tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
										if err != nil {
											panic(err)
										}
										tmp29 := lang.Apply(tmp25, []any{tmp28, v12})
										tmp22 = tmp29
									}
									tmp19 = tmp22
								} // end let
								return tmp19
							}
						})
						v14 = tmp13
						_ = v14
					}
					tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7494), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(7500), lang.NewKeyword("end-column"), int(56))
					tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp7 = tmp15
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// some?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("some?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is not nil, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(530), lang.NewKeyword("end-line"), int(530))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("not"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.Apply(tmp10, []any{v4})
			tmp12 := lang.Apply(tmp7, []any{tmp11})
			return tmp12
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort
	{
		tmp0 := lang.NewSymbol("sort").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("comp"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3085), lang.NewKeyword("end-line"), int(3085))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("sort"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("compare"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					var tmp10 any
					{ // let
						// let binding "a"
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("to-array"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, []any{v4})
						var v15 any = tmp14
						_ = v15
						tmp16 := lang.Apply(lang.SortSlice, []any{v15, v3})
						_ = tmp16
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("with-meta"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("seq"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v15})
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("meta"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27 := lang.Apply(tmp26, []any{v4})
						tmp28 := lang.Apply(tmp19, []any{tmp23, tmp27})
						tmp10 = tmp28
					} // end let
					tmp5 = tmp10
				} else {
					tmp5 = lang.NewList()
				}
				return tmp5
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sort-by
	{
		tmp0 := lang.NewSymbol("sort-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("keyfn"), lang.NewSymbol("comp"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3102), lang.NewKeyword("end-line"), int(3102))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("sort-by"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("compare"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp7, []any{v3, tmp10, v4})
				return tmp11
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("sort"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				var tmp9 lang.FnFunc
				tmp9 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v10 := args[0]
					_ = v10
					v11 := args[1]
					_ = v11
					tmp12 := lang.Apply(v3, []any{v10})
					tmp13 := lang.Apply(v3, []any{v11})
					tmp14 := lang.Apply(v4, []any{tmp12, tmp13})
					return tmp14
				})
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3114), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(3114), lang.NewKeyword("end-column"), int(46))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp8, []any{tmp11, v5})
				return tmp12
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map
	{
		tmp0 := lang.NewSymbol("sorted-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(397), lang.NewKeyword("end-line"), int(397))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeMap, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-map-by
	{
		tmp0 := lang.NewSymbol("sorted-map-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("comparator"), lang.NewSymbol("&"), lang.NewSymbol("keyvals"))), lang.NewKeyword("doc"), "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(406), lang.NewKeyword("end-line"), int(406))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(nil, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set
	{
		tmp0 := lang.NewSymbol("sorted-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(416), lang.NewKeyword("end-line"), int(416))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.Apply(lang.CreatePersistentTreeSet, []any{v3})
				return tmp4
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted-set-by
	{
		tmp0 := lang.NewSymbol("sorted-set-by").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("comparator"), lang.NewSymbol("&"), lang.NewSymbol("keys"))), lang.NewKeyword("doc"), "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(424), lang.NewKeyword("end-line"), int(424))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentTreeSetWithComparator, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sorted?
	{
		tmp0 := lang.NewSymbol("sorted?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns true if coll implements Sorted", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6235), lang.NewKeyword("end-line"), int(6235))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// special-symbol?
	{
		tmp0 := lang.NewSymbol("special-symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Returns true if s names a special form", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4992), lang.NewKeyword("end-line"), int(4992))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("contains?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7, ok := lang.FieldOrMethod(runtime4.Compiler, "specials")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", runtime4.Compiler, "specials")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(tmp6, []any{tmp8, v3})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spit
	{
		tmp0 := lang.NewSymbol("spit").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("content"), lang.NewSymbol("&"), lang.NewSymbol("options"))), lang.NewKeyword("doc"), "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to glojure.java.io/writer.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6994), lang.NewKeyword("end-line"), int(6994))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				{ // let
					// let binding "w"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("apply"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{nil, v3, v5})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					func() {
						defer func() {
							tmp13, ok := lang.FieldOrMethod(v11, "close")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "close")))
							}
							var tmp14 any
							switch reflect.TypeOf(tmp13).Kind() {
							case reflect.Func:
								tmp14 = lang.Apply(tmp13, nil)
							default:
								tmp14 = tmp13
							}
							_ = tmp14
						}()
						tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp16 := tmp15.FindInternedVar(lang.NewSymbol("str"))
						if tmp16.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
						}
						tmp17 := tmp16.Get()
						tmp18 := lang.Apply(tmp17, []any{v4})
						tmp19 := lang.Apply(lang.WriteWriter, []any{v11, tmp18})
						tmp12 = tmp19
					}()
					tmp6 = tmp12
				} // end let
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-at
	{
		tmp0 := lang.NewSymbol("split-at").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(take n coll) (drop n coll)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2983), lang.NewKeyword("end-line"), int(2983))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("take"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("drop"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp11, []any{v3, v4})
			tmp13 := lang.NewVector(tmp8, tmp12)
			tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2988), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2988), lang.NewKeyword("end-column"), int(33))
			tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// split-with
	{
		tmp0 := lang.NewSymbol("split-with").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2990), lang.NewKeyword("end-line"), int(2990))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("take-while"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3, v4})
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("drop-while"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.Apply(tmp11, []any{v3, v4})
			tmp13 := lang.NewVector(tmp8, tmp12)
			tmp14 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2995), lang.NewKeyword("column"), int(5), lang.NewKeyword("end-line"), int(2995), lang.NewKeyword("end-column"), int(51))
			tmp15, err := lang.WithMeta(tmp13, tmp14.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp15
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// splitv-at
	{
		tmp0 := lang.NewSymbol("splitv-at").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a vector of [(into [] (take n) coll) (drop n coll)]", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7256), lang.NewKeyword("end-line"), int(7256))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("into"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.NewVector()
			tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7260), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7260), lang.NewKeyword("end-column"), int(11))
			tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp12 := tmp11.FindInternedVar(lang.NewSymbol("take"))
			if tmp12.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
			}
			tmp13 := tmp12.Get()
			tmp14 := lang.Apply(tmp13, []any{v3})
			tmp15 := lang.Apply(tmp7, []any{tmp10, tmp14, v4})
			tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp17 := tmp16.FindInternedVar(lang.NewSymbol("drop"))
			if tmp17.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
			}
			tmp18 := tmp17.Get()
			tmp19 := lang.Apply(tmp18, []any{v3, v4})
			tmp20 := lang.NewVector(tmp15, tmp19)
			tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7260), lang.NewKeyword("column"), int(3), lang.NewKeyword("end-line"), int(7260), lang.NewKeyword("end-column"), int(41))
			tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			return tmp22
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// spread
	{
		tmp0 := lang.NewSymbol("spread").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("arglist"))), lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(632), lang.NewKeyword("end-line"), int(632), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("nil?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
			} else {
				var tmp9 any
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("nil?"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("next"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.Apply(tmp12, []any{tmp16})
				if lang.IsTruthy(tmp17) {
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("seq"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v3})
					tmp25 := lang.Apply(tmp20, []any{tmp24})
					tmp9 = tmp25
				} else {
					var tmp26 any
					if lang.IsTruthy(lang.NewKeyword("else")) {
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("cons"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("first"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.Apply(tmp32, []any{v3})
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("spread"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("next"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.Apply(tmp39, []any{v3})
						tmp41 := lang.Apply(tmp36, []any{tmp40})
						tmp42 := lang.Apply(tmp29, []any{tmp33, tmp41})
						tmp26 = tmp42
					} else {
					}
					tmp9 = tmp26
				}
				tmp4 = tmp9
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// str
	{
		tmp1 := reflect.TypeOf("")
		tmp0 := lang.NewSymbol("str").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("&"), lang.NewSymbol("ys"))), lang.NewKeyword("doc"), "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(543), lang.NewKeyword("end-line"), int(543))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				return ""
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("nil?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp5 = ""
				} else {
					tmp10 := lang.Apply(lang.ToString, []any{v4})
					tmp5 = tmp10
				}
				return tmp5
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				var v5 any = lang.NewList(args[1:]...)
				_ = v5
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 2 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					v8 := args[1]
					_ = v8
				recur_loop_74:
					var tmp9 any
					if lang.IsTruthy(v8) {
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("str"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp15 := tmp14.FindInternedVar(lang.NewSymbol("first"))
						if tmp15.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
						}
						tmp16 := tmp15.Get()
						tmp17 := lang.Apply(tmp16, []any{v8})
						tmp18 := lang.Apply(tmp13, []any{tmp17})
						tmp19, _ := lang.FieldOrMethod(v7, "WriteString")
						if reflect.TypeOf(tmp19).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("WriteString is not a function")))
						}
						tmp20 := lang.Apply(tmp19, []any{tmp18})
						_ = tmp20
						var tmp10 any = v7
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v8})
						var tmp21 any = tmp25
						v7 = tmp10
						v8 = tmp21
						goto recur_loop_74
					} else {
						tmp26, ok := lang.FieldOrMethod(v7, "String")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v7, "String")))
						}
						var tmp27 any
						switch reflect.TypeOf(tmp26).Kind() {
						case reflect.Func:
							tmp27 = lang.Apply(tmp26, nil)
						default:
							tmp27 = tmp26
						}
						tmp9 = tmp27
					}
					return tmp9
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(554), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(554), lang.NewKeyword("end-column"), int(127))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("cons"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v4, v5})
				tmp13 := lang.Apply(tmp8, []any{"unimplemented: new with non-constant class type", tmp12})
				return tmp13
			}
		})
		tmp4 := reflect.TypeOf("")
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-into!
	{
		tmp0 := lang.NewSymbol("stream-into!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("to"), lang.NewSymbol("xform"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Returns a new coll consisting of coll with all of the items of the\n  stream conjoined. This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6810), lang.NewKeyword("end-line"), int(6810))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp10 := lang.Apply(tmp8, []any{tmp9, v3})
				if lang.IsTruthy(tmp10) {
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp15 := tmp14.FindInternedVar(lang.NewSymbol("persistent!"))
					if tmp15.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
					}
					tmp16 := tmp15.Get()
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("stream-reduce!"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("transient"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{v3})
					tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26, v4})
					tmp28 := lang.Apply(tmp16, []any{tmp27})
					tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp30 := tmp29.FindInternedVar(lang.NewSymbol("meta"))
					if tmp30.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
					}
					tmp31 := tmp30.Get()
					tmp32 := lang.Apply(tmp31, []any{v3})
					tmp33 := lang.Apply(tmp13, []any{tmp28, tmp32})
					tmp5 = tmp33
				} else {
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("stream-reduce!"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("conj"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.Apply(tmp36, []any{tmp39, v3, v4})
					tmp5 = tmp40
				}
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
				tmp11 := lang.Apply(tmp9, []any{tmp10, v3})
				if lang.IsTruthy(tmp11) {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("persistent!"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp19 := tmp18.FindInternedVar(lang.NewSymbol("stream-transduce!"))
					if tmp19.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
					}
					tmp20 := tmp19.Get()
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("conj!"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp25 := tmp24.FindInternedVar(lang.NewSymbol("transient"))
					if tmp25.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
					}
					tmp26 := tmp25.Get()
					tmp27 := lang.Apply(tmp26, []any{v3})
					tmp28 := lang.Apply(tmp20, []any{v4, tmp23, tmp27, v5})
					tmp29 := lang.Apply(tmp17, []any{tmp28})
					tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp31 := tmp30.FindInternedVar(lang.NewSymbol("meta"))
					if tmp31.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
					}
					tmp32 := tmp31.Get()
					tmp33 := lang.Apply(tmp32, []any{v3})
					tmp34 := lang.Apply(tmp14, []any{tmp29, tmp33})
					tmp6 = tmp34
				} else {
					tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp36 := tmp35.FindInternedVar(lang.NewSymbol("stream-transduce!"))
					if tmp36.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
					}
					tmp37 := tmp36.Get()
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("conj"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.Apply(tmp37, []any{v4, tmp40, v3, v5})
					tmp6 = tmp41
				}
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-reduce!
	{
		tmp0 := lang.NewSymbol("stream-reduce!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("s")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("s"))), lang.NewKeyword("doc"), "Works like reduce but takes a java.util.stream.BaseStream as its source.\n  Honors 'reduced', is a terminal operation on the stream", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6784), lang.NewKeyword("end-line"), int(6784))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5, ok := lang.FieldOrMethod(v4, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "iterator")))
				}
				var tmp6 any
				switch reflect.TypeOf(tmp5).Kind() {
				case reflect.Func:
					tmp6 = lang.Apply(tmp5, nil)
				default:
					tmp6 = tmp5
				}
				tmp7 := lang.Apply(nil, []any{tmp6, v3})
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, ok := lang.FieldOrMethod(v5, "iterator")
				if !ok {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v5, "iterator")))
				}
				var tmp7 any
				switch reflect.TypeOf(tmp6).Kind() {
				case reflect.Func:
					tmp7 = lang.Apply(tmp6, nil)
				default:
					tmp7 = tmp6
				}
				tmp8 := lang.Apply(nil, []any{tmp7, v3, v4})
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-seq!
	{
		tmp0 := lang.NewSymbol("stream-seq!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Takes a java.util.stream.BaseStream instance s and returns a seq of its\n  contents. This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6793), lang.NewKeyword("end-line"), int(6793))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("iterator-seq"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7, ok := lang.FieldOrMethod(v3, "iterator")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "iterator")))
			}
			var tmp8 any
			switch reflect.TypeOf(tmp7).Kind() {
			case reflect.Func:
				tmp8 = lang.Apply(tmp7, nil)
			default:
				tmp8 = tmp7
			}
			tmp9 := lang.Apply(tmp6, []any{tmp8})
			return tmp9
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// stream-transduce!
	{
		tmp0 := lang.NewSymbol("stream-transduce!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("stream")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("stream"))), lang.NewKeyword("doc"), "Works like transduce but takes a java.util.stream.BaseStream as its source.\n  This is a terminal operation on the stream.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.12", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6800), lang.NewKeyword("end-line"), int(6800))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("stream-transduce!"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(v4, nil)
				tmp10 := lang.Apply(tmp8, []any{v3, v4, tmp9, v5})
				return tmp10
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp11 := tmp10.FindInternedVar(lang.NewSymbol("stream-reduce!"))
					if tmp11.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
					}
					tmp12 := tmp11.Get()
					tmp13 := lang.Apply(tmp12, []any{v9, v5, v6})
					var v14 any = tmp13
					_ = v14
					tmp15 := lang.Apply(v9, []any{v14})
					tmp7 = tmp15
				} // end let
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// string?
	{
		tmp0 := lang.NewSymbol("string?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a String", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(160), lang.NewKeyword("end-line"), int(164))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function string?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{lang.Builtins["string"], v4})
				return tmp8
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(164), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(164), lang.NewKeyword("end-column"), int(58))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// strip-ns
	{
		tmp0 := lang.NewSymbol("strip-ns").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core_print.glj", lang.NewKeyword("line"), int(255), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(255), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("private"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("named"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("symbol?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("symbol"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("name"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16 := lang.Apply(tmp11, []any{nil, tmp15})
				tmp4 = tmp16
			} else {
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("keyword"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("name"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.Apply(tmp22, []any{v3})
				tmp24 := lang.Apply(tmp19, []any{nil, tmp23})
				tmp4 = tmp24
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct
	{
		tmp0 := lang.NewSymbol("struct").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("vals"))), lang.NewKeyword("doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4061), lang.NewKeyword("end-line"), int(4061))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.ConstructPersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// struct-map
	{
		tmp0 := lang.NewSymbol("struct-map").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("inits"))), lang.NewKeyword("doc"), "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4051), lang.NewKeyword("end-line"), int(4051))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.Apply(lang.CreatePersistentStructMap, []any{v3, v4})
				return tmp5
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subs
	{
		tmp0 := lang.NewSymbol("subs").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("start")), lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("start"), lang.NewSymbol("end"))), lang.NewKeyword("doc"), "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5005), lang.NewKeyword("end-line"), int(5005))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.Apply(lang.Builtins["slice"], []any{v3, v4})
				return tmp5
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.Apply(lang.Builtins["slice"], []any{v3, v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subseq
	{
		tmp0 := lang.NewSymbol("subseq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("test"), lang.NewSymbol("key")), lang.NewVector(lang.NewSymbol("sc"), lang.NewSymbol("start-test"), lang.NewSymbol("start-key"), lang.NewSymbol("end-test"), lang.NewSymbol("end-key"))), lang.NewKeyword("doc"), "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5133), lang.NewKeyword("end-line"), int(5133))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "include"
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3, v4, v5})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp14 := tmp13.FindInternedVar(lang.NewSymbol(">"))
					if tmp14.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
					}
					tmp15 := tmp14.Get()
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol(">="))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{tmp15, tmp18}))
					tmp20 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5141), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5141), lang.NewKeyword("end-column"), int(17))
					tmp21, err := lang.WithMeta(tmp19, tmp20.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp22 := lang.Apply(tmp21, []any{v4})
					if lang.IsTruthy(tmp22) {
						var tmp23 any
						{ // let
							// let binding "temp__0__auto__"
							tmp24, _ := lang.FieldOrMethod(v3, "seqFrom")
							if reflect.TypeOf(tmp24).Kind() != reflect.Func {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
							}
							tmp25 := lang.Apply(tmp24, []any{v5, true})
							var v26 any = tmp25
							_ = v26
							var tmp27 any
							if lang.IsTruthy(v26) {
								var tmp28 any
								{ // let
									// let binding "vec__68"
									var v29 any = v26
									_ = v29
									// let binding "e"
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("nth"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v29, int64(0), nil})
									var v34 any = tmp33
									_ = v34
									// let binding "s"
									var v35 any = v29
									_ = v35
									var tmp36 any
									tmp37 := lang.Apply(v11, []any{v34})
									if lang.IsTruthy(tmp37) {
										tmp36 = v35
									} else {
										tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp39 := tmp38.FindInternedVar(lang.NewSymbol("next"))
										if tmp39.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
										}
										tmp40 := tmp39.Get()
										tmp41 := lang.Apply(tmp40, []any{v35})
										tmp36 = tmp41
									}
									tmp28 = tmp36
								} // end let
								tmp27 = tmp28
							} else {
							}
							tmp23 = tmp27
						} // end let
						tmp12 = tmp23
					} else {
						tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp25 := tmp24.FindInternedVar(lang.NewSymbol("take-while"))
						if tmp25.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
						}
						tmp26 := tmp25.Get()
						tmp27, _ := lang.FieldOrMethod(v3, "seq")
						if reflect.TypeOf(tmp27).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("seq is not a function")))
						}
						tmp28 := lang.Apply(tmp27, []any{true})
						tmp29 := lang.Apply(tmp26, []any{v11, tmp28})
						tmp12 = tmp29
					}
					tmp6 = tmp12
				} // end let
				return tmp6
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				var tmp8 any
				{ // let
					// let binding "temp__0__auto__"
					tmp9, _ := lang.FieldOrMethod(v3, "seqFrom")
					if reflect.TypeOf(tmp9).Kind() != reflect.Func {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("seqFrom is not a function")))
					}
					tmp10 := lang.Apply(tmp9, []any{v5, true})
					var v11 any = tmp10
					_ = v11
					var tmp12 any
					if lang.IsTruthy(v11) {
						var tmp13 any
						{ // let
							// let binding "vec__71"
							var v14 any = v11
							_ = v14
							// let binding "e"
							tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp16 := tmp15.FindInternedVar(lang.NewSymbol("nth"))
							if tmp16.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
							}
							tmp17 := tmp16.Get()
							tmp18 := lang.Apply(tmp17, []any{v14, int64(0), nil})
							var v19 any = tmp18
							_ = v19
							// let binding "s"
							var v20 any = v14
							_ = v20
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("take-while"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp25 := tmp24.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
							if tmp25.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
							}
							tmp26 := tmp25.Get()
							tmp27 := lang.Apply(tmp26, []any{v3, v6, v7})
							var tmp28 any
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("mk-bound-fn"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v3, v4, v5})
							tmp33 := lang.Apply(tmp32, []any{v19})
							if lang.IsTruthy(tmp33) {
								tmp28 = v20
							} else {
								tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp35 := tmp34.FindInternedVar(lang.NewSymbol("next"))
								if tmp35.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
								}
								tmp36 := tmp35.Get()
								tmp37 := lang.Apply(tmp36, []any{v20})
								tmp28 = tmp37
							}
							tmp38 := lang.Apply(tmp23, []any{tmp27, tmp28})
							tmp13 = tmp38
						} // end let
						tmp12 = tmp13
					} else {
					}
					tmp8 = tmp12
				} // end let
				return tmp8
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// subvec
	{
		tmp0 := lang.NewSymbol("subvec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("start")), lang.NewVector(lang.NewSymbol("v"), lang.NewSymbol("start"), lang.NewSymbol("end"))), lang.NewKeyword("doc"), "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3819), lang.NewKeyword("end-line"), int(3819))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("subvec"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("count"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				tmp12 := lang.Apply(tmp7, []any{v3, v4, tmp11})
				return tmp12
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(runtime4.RT, "Subvec")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("Subvec is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v3, v4, v5})
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// supers
	{
		tmp0 := lang.NewSymbol("supers").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("class"))), lang.NewKeyword("doc"), "Returns the immediate and indirect superclasses and interfaces of c, if any", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5532), lang.NewKeyword("end-line"), int(5532))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("set"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("bases"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				tmp12 := lang.Apply(tmp7, []any{tmp11})
				var v13 any = tmp12
				_ = v13
				// let binding "cs"
				var v14 any = v13
				_ = v14
				for {
					var tmp15 any
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("seq"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(tmp18, []any{v14})
					if lang.IsTruthy(tmp19) {
						var tmp20 any
						{ // let
							// let binding "c"
							tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
							if tmp22.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
							}
							tmp23 := tmp22.Get()
							tmp24 := lang.Apply(tmp23, []any{v14})
							var v25 any = tmp24
							_ = v25
							// let binding "bs"
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("bases"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.Apply(tmp28, []any{v25})
							var v30 any = tmp29
							_ = v30
							tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp33 := tmp32.FindInternedVar(lang.NewSymbol("into1"))
							if tmp33.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
							}
							tmp34 := tmp33.Get()
							tmp35 := lang.Apply(tmp34, []any{v13, v30})
							var tmp31 any = tmp35
							tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp38 := tmp37.FindInternedVar(lang.NewSymbol("into1"))
							if tmp38.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
							}
							tmp39 := tmp38.Get()
							tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp41 := tmp40.FindInternedVar(lang.NewSymbol("disj"))
							if tmp41.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
							}
							tmp42 := tmp41.Get()
							tmp43 := lang.Apply(tmp42, []any{v14, v25})
							tmp44 := lang.Apply(tmp39, []any{tmp43, v30})
							var tmp36 any = tmp44
							v13 = tmp31
							v14 = tmp36
							continue
						} // end let
						tmp15 = tmp20
					} else {
						tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp22 := tmp21.FindInternedVar(lang.NewSymbol("not-empty"))
						if tmp22.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
						}
						tmp23 := tmp22.Get()
						tmp24 := lang.Apply(tmp23, []any{v13})
						tmp15 = tmp24
					}
					tmp4 = tmp15
					break
				}
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap!
	{
		tmp0 := lang.NewSymbol("swap!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2343), lang.NewKeyword("end-line"), int(2343))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swap")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swap is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// swap-vals!
	{
		tmp0 := lang.NewSymbol("swap-vals!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("atom"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2352), lang.NewKeyword("end-line"), int(2352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v3, "swapVals")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("swapVals is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v4, v5})
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol
	{
		tmp1 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp0 := lang.NewSymbol("symbol").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name")), lang.NewVector(lang.NewSymbol("ns"), lang.NewSymbol("name"))), lang.NewKeyword("doc"), "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(584), lang.NewKeyword("end-line"), int(584))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v4 := args[0]
				_ = v4
				var tmp5 any
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("symbol?"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				if lang.IsTruthy(tmp9) {
					tmp5 = v4
				} else {
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{lang.Builtins["string"], v4})
					if lang.IsTruthy(tmp14) {
						tmp15 := lang.Apply(lang.NewSymbol, []any{v4})
						tmp10 = tmp15
					} else {
						var tmp16 any
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("instance?"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := reflect.TypeOf((*lang.Var)(nil))
						tmp21 := lang.Apply(tmp19, []any{tmp20, v4})
						if lang.IsTruthy(tmp21) {
							tmp22, ok := lang.FieldOrMethod(v4, "toSymbol")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "toSymbol")))
							}
							var tmp23 any
							switch reflect.TypeOf(tmp22).Kind() {
							case reflect.Func:
								tmp23 = lang.Apply(tmp22, nil)
							default:
								tmp23 = tmp22
							}
							tmp16 = tmp23
						} else {
							var tmp24 any
							tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp26 := tmp25.FindInternedVar(lang.NewSymbol("instance?"))
							if tmp26.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
							}
							tmp27 := tmp26.Get()
							tmp28 := reflect.TypeOf((*lang.Keyword)(nil)).Elem()
							tmp29 := lang.Apply(tmp27, []any{tmp28, v4})
							if lang.IsTruthy(tmp29) {
								tmp30, ok := lang.FieldOrMethod(v4, "sym")
								if !ok {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v4, "sym")))
								}
								var tmp31 any
								switch reflect.TypeOf(tmp30).Kind() {
								case reflect.Func:
									tmp31 = lang.Apply(tmp30, nil)
								default:
									tmp31 = tmp30
								}
								tmp24 = tmp31
							} else {
								var tmp32 any
								if lang.IsTruthy(lang.NewKeyword("else")) {
									tmp33 := lang.Apply(lang.NewIllegalArgumentError, []any{"no conversion to symbol"})
									panic(tmp33)
								} else {
								}
								tmp24 = tmp32
							}
							tmp16 = tmp24
						}
						tmp10 = tmp16
					}
					tmp5 = tmp10
				}
				return tmp5
			case 2:
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6 := lang.Apply(lang.InternSymbol, []any{v4, v5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp4 := reflect.TypeOf((*lang.Symbol)(nil))
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// symbol?
	{
		tmp0 := lang.NewSymbol("symbol?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a Symbol", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(557), lang.NewKeyword("end-line"), int(557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Symbol)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// sync
	{
		tmp0 := lang.NewSymbol("sync").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("flags-ignored-for-now"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2490), lang.NewKeyword("end-line"), int(2490))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol(".")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.LockingTransaction")})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("concat"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("list"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/RunInTransaction")})
				tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp35 := tmp34.FindInternedVar(lang.NewSymbol("list"))
				if tmp35.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
				}
				tmp36 := tmp35.Get()
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("seq"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp41 := tmp40.FindInternedVar(lang.NewSymbol("concat"))
				if tmp41.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
				}
				tmp42 := tmp41.Get()
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("list"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.Apply(tmp45, []any{lang.NewSymbol("glojure.core/fn")})
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("list"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("apply"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("vector"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp57 := tmp56.FindInternedVar(lang.NewSymbol("seq"))
				if tmp57.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
				}
				tmp58 := tmp57.Get()
				tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp60 := tmp59.FindInternedVar(lang.NewSymbol("concat"))
				if tmp60.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
				}
				tmp61 := tmp60.Get()
				tmp62 := lang.Apply(tmp61, nil)
				tmp63 := lang.Apply(tmp58, []any{tmp62})
				tmp64 := lang.Apply(tmp52, []any{tmp55, tmp63})
				tmp65 := lang.Apply(tmp49, []any{tmp64})
				tmp66 := lang.Apply(tmp42, []any{tmp46, tmp65, v6})
				tmp67 := lang.Apply(tmp39, []any{tmp66})
				tmp68 := lang.Apply(tmp36, []any{tmp67})
				tmp69 := lang.Apply(tmp29, []any{tmp33, tmp68})
				tmp70 := lang.Apply(tmp26, []any{tmp69})
				tmp71 := lang.Apply(tmp23, []any{tmp70})
				tmp72 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp71})
				tmp73 := lang.Apply(tmp9, []any{tmp72})
				return tmp73
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// system-newline
	{
		tmp0 := lang.NewSymbol("system-newline").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(3695), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(3695), lang.NewKeyword("end-column"), int(40), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp1 := ns.InternWithValue(tmp0, "\n", true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal
	{
		tmp0 := lang.NewSymbol("tagged-literal").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("form"))), lang.NewKeyword("doc"), "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7769), lang.NewKeyword("end-line"), int(7769))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.Apply(nil, []any{v3, v4})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tagged-literal?
	{
		tmp0 := lang.NewSymbol("tagged-literal?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("value"))), lang.NewKeyword("doc"), "Return true if the value is the data representation of a tagged literal", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7763), lang.NewKeyword("end-line"), int(7763))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.Apply(tmp6, []any{nil, v3})
			return tmp7
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take
	{
		tmp0 := lang.NewSymbol("take").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2853), lang.NewKeyword("end-line"), int(2853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "nv"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v3})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "n"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("deref"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19 := lang.Apply(tmp18, []any{v11})
									var v20 any = tmp19
									_ = v20
									// let binding "nn"
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("dec"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp25 any
									switch reflect.TypeOf(tmp24).Kind() {
									case reflect.Func:
										tmp25 = lang.Apply(tmp24, nil)
									default:
										tmp25 = tmp24
									}
									tmp26 := lang.Apply(tmp23, []any{tmp25})
									tmp27, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp27).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp28 := lang.Apply(tmp27, []any{tmp26})
									var v29 any = tmp28
									_ = v29
									// let binding "result"
									var tmp30 any
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("pos?"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.Apply(tmp33, []any{v20})
									if lang.IsTruthy(tmp34) {
										tmp35 := lang.Apply(v5, []any{v13, v14})
										tmp30 = tmp35
									} else {
										tmp30 = v13
									}
									var v36 any = tmp30
									_ = v36
									var tmp37 any
									tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp39 := tmp38.FindInternedVar(lang.NewSymbol("not"))
									if tmp39.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
									}
									tmp40 := tmp39.Get()
									tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp42 := tmp41.FindInternedVar(lang.NewSymbol("pos?"))
									if tmp42.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
									}
									tmp43 := tmp42.Get()
									tmp44 := lang.Apply(tmp43, []any{v29})
									tmp45 := lang.Apply(tmp40, []any{tmp44})
									if lang.IsTruthy(tmp45) {
										tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
										tmp47 := tmp46.FindInternedVar(lang.NewSymbol("ensure-reduced"))
										if tmp47.IsMacro() {
											panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
										}
										tmp48 := tmp47.Get()
										tmp49 := lang.Apply(tmp48, []any{v36})
										tmp37 = tmp49
									} else {
										tmp37 = v36
									}
									tmp15 = tmp37
								} // end let
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2862), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(2873), lang.NewKeyword("end-column"), int(28))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2860), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2873), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp8 := tmp7.FindInternedVar(lang.NewSymbol("pos?"))
					if tmp8.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
					}
					tmp9 := tmp8.Get()
					tmp10 := lang.Apply(tmp9, []any{v3})
					if lang.IsTruthy(tmp10) {
						var tmp11 any
						{ // let
							// let binding "temp__0__auto__"
							tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp13 := tmp12.FindInternedVar(lang.NewSymbol("seq"))
							if tmp13.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
							}
							tmp14 := tmp13.Get()
							tmp15 := lang.Apply(tmp14, []any{v4})
							var v16 any = tmp15
							_ = v16
							var tmp17 any
							if lang.IsTruthy(v16) {
								var tmp18 any
								{ // let
									// let binding "s"
									var v19 any = v16
									_ = v19
									tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp21 := tmp20.FindInternedVar(lang.NewSymbol("cons"))
									if tmp21.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
									}
									tmp22 := tmp21.Get()
									tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp24 := tmp23.FindInternedVar(lang.NewSymbol("first"))
									if tmp24.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
									}
									tmp25 := tmp24.Get()
									tmp26 := lang.Apply(tmp25, []any{v19})
									tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp28 := tmp27.FindInternedVar(lang.NewSymbol("take"))
									if tmp28.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
									}
									tmp29 := tmp28.Get()
									tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp31 := tmp30.FindInternedVar(lang.NewSymbol("dec"))
									if tmp31.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
									}
									tmp32 := tmp31.Get()
									tmp33 := lang.Apply(tmp32, []any{v3})
									tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp35 := tmp34.FindInternedVar(lang.NewSymbol("rest"))
									if tmp35.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
									}
									tmp36 := tmp35.Get()
									tmp37 := lang.Apply(tmp36, []any{v19})
									tmp38 := lang.Apply(tmp29, []any{tmp33, tmp37})
									tmp39 := lang.Apply(tmp22, []any{tmp26, tmp38})
									tmp18 = tmp39
								} // end let
								tmp17 = tmp18
							} else {
							}
							tmp11 = tmp17
						} // end let
						tmp6 = tmp11
					} else {
					}
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-last
	{
		tmp0 := lang.NewSymbol("take-last").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2939), lang.NewKeyword("end-line"), int(2939))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "s"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v4})
				var v10 any = tmp9
				_ = v10
				// let binding "lead"
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("seq"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("drop"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3, v4})
				tmp18 := lang.Apply(tmp13, []any{tmp17})
				var v19 any = tmp18
				_ = v19
				for {
					var tmp20 any
					if lang.IsTruthy(v19) {
						tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp23 := tmp22.FindInternedVar(lang.NewSymbol("next"))
						if tmp23.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
						}
						tmp24 := tmp23.Get()
						tmp25 := lang.Apply(tmp24, []any{v10})
						var tmp21 any = tmp25
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("next"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.Apply(tmp29, []any{v19})
						var tmp26 any = tmp30
						v10 = tmp21
						v19 = tmp26
						continue
					} else {
						tmp20 = v10
					}
					tmp5 = tmp20
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-nth
	{
		tmp0 := lang.NewSymbol("take-nth").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("n")), lang.NewVector(lang.NewSymbol("n"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4287), lang.NewKeyword("end-line"), int(4287))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 any
					{ // let
						// let binding "iv"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("volatile!"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{int64(-1)})
						var v11 any = tmp10
						_ = v11
						var tmp12 lang.FnFunc
						tmp12 = lang.NewFnFunc(func(args ...any) any {
							switch len(args) {
							case 0:
								tmp13 := lang.Apply(v5, nil)
								return tmp13
							case 1:
								v13 := args[0]
								_ = v13
								tmp14 := lang.Apply(v5, []any{v13})
								return tmp14
							case 2:
								v13 := args[0]
								_ = v13
								v14 := args[1]
								_ = v14
								var tmp15 any
								{ // let
									// let binding "i"
									tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp17 := tmp16.FindInternedVar(lang.NewSymbol("inc"))
									if tmp17.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
									}
									tmp18 := tmp17.Get()
									tmp19, ok := lang.FieldOrMethod(v11, "Deref")
									if !ok {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v11, "Deref")))
									}
									var tmp20 any
									switch reflect.TypeOf(tmp19).Kind() {
									case reflect.Func:
										tmp20 = lang.Apply(tmp19, nil)
									default:
										tmp20 = tmp19
									}
									tmp21 := lang.Apply(tmp18, []any{tmp20})
									tmp22, _ := lang.FieldOrMethod(v11, "reset")
									if reflect.TypeOf(tmp22).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
									}
									tmp23 := lang.Apply(tmp22, []any{tmp21})
									var v24 any = tmp23
									_ = v24
									var tmp25 any
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("zero?"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp30 := tmp29.FindInternedVar(lang.NewSymbol("rem"))
									if tmp30.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
									}
									tmp31 := tmp30.Get()
									tmp32 := lang.Apply(tmp31, []any{v24, v3})
									tmp33 := lang.Apply(tmp28, []any{tmp32})
									if lang.IsTruthy(tmp33) {
										tmp34 := lang.Apply(v5, []any{v13, v14})
										tmp25 = tmp34
									} else {
										tmp25 = v13
									}
									tmp15 = tmp25
								} // end let
								return tmp15
							default:
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
						})
						tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4295), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(4302), lang.NewKeyword("end-column"), int(28))
						tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp6 = tmp14
					} // end let
					return tmp6
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4293), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(4302), lang.NewKeyword("end-column"), int(30))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp16 := tmp15.FindInternedVar(lang.NewSymbol("cons"))
								if tmp16.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
								}
								tmp17 := tmp16.Get()
								tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp19 := tmp18.FindInternedVar(lang.NewSymbol("first"))
								if tmp19.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
								}
								tmp20 := tmp19.Get()
								tmp21 := lang.Apply(tmp20, []any{v14})
								tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp23 := tmp22.FindInternedVar(lang.NewSymbol("take-nth"))
								if tmp23.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
								}
								tmp24 := tmp23.Get()
								tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp26 := tmp25.FindInternedVar(lang.NewSymbol("drop"))
								if tmp26.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
								}
								tmp27 := tmp26.Get()
								tmp28 := lang.Apply(tmp27, []any{v3, v14})
								tmp29 := lang.Apply(tmp24, []any{v3, tmp28})
								tmp30 := lang.Apply(tmp17, []any{tmp21, tmp29})
								tmp13 = tmp30
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// take-while
	{
		tmp0 := lang.NewSymbol("take-while").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred")), lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2880), lang.NewKeyword("end-line"), int(2880))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
				var tmp4 lang.FnFunc
				tmp4 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v5 := args[0]
					_ = v5
					var tmp6 lang.FnFunc
					tmp6 = lang.NewFnFunc(func(args ...any) any {
						switch len(args) {
						case 0:
							tmp7 := lang.Apply(v5, nil)
							return tmp7
						case 1:
							v7 := args[0]
							_ = v7
							tmp8 := lang.Apply(v5, []any{v7})
							return tmp8
						case 2:
							v7 := args[0]
							_ = v7
							v8 := args[1]
							_ = v8
							var tmp9 any
							tmp10 := lang.Apply(v3, []any{v8})
							if lang.IsTruthy(tmp10) {
								tmp11 := lang.Apply(v5, []any{v7, v8})
								tmp9 = tmp11
							} else {
								tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp13 := tmp12.FindInternedVar(lang.NewSymbol("reduced"))
								if tmp13.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
								}
								tmp14 := tmp13.Get()
								tmp15 := lang.Apply(tmp14, []any{v7})
								tmp9 = tmp15
							}
							return tmp9
						default:
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
					})
					tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2888), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(2894), lang.NewKeyword("end-column"), int(33))
					tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					return tmp8
				})
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2887), lang.NewKeyword("column"), int(6), lang.NewKeyword("end-line"), int(2894), lang.NewKeyword("end-column"), int(34))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var tmp5 lang.FnFunc
				tmp5 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					var tmp6 any
					{ // let
						// let binding "temp__0__auto__"
						tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
						if tmp8.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
						}
						tmp9 := tmp8.Get()
						tmp10 := lang.Apply(tmp9, []any{v4})
						var v11 any = tmp10
						_ = v11
						var tmp12 any
						if lang.IsTruthy(v11) {
							var tmp13 any
							{ // let
								// let binding "s"
								var v14 any = v11
								_ = v14
								var tmp15 any
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("first"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v14})
								tmp20 := lang.Apply(v3, []any{tmp19})
								if lang.IsTruthy(tmp20) {
									tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp22 := tmp21.FindInternedVar(lang.NewSymbol("cons"))
									if tmp22.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
									}
									tmp23 := tmp22.Get()
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("first"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v14})
									tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp29 := tmp28.FindInternedVar(lang.NewSymbol("take-while"))
									if tmp29.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
									}
									tmp30 := tmp29.Get()
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("rest"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.Apply(tmp33, []any{v14})
									tmp35 := lang.Apply(tmp30, []any{v3, tmp34})
									tmp36 := lang.Apply(tmp23, []any{tmp27, tmp35})
									tmp15 = tmp36
								} else {
								}
								tmp13 = tmp15
							} // end let
							tmp12 = tmp13
						} else {
						}
						tmp6 = tmp12
					} // end let
					return tmp6
				})
				tmp6 := lang.Apply(lang.NewLazySeq, []any{tmp5})
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tapset
	{
		tmp0 := lang.NewSymbol("tapset").WithMeta(lang.NewMap(lang.NewKeyword("private"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7882), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(7882), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")))).(*lang.Symbol)
		tmp2 := lang.NewAtom(lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{})))
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// test
	{
		tmp0 := lang.NewSymbol("test").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"))), lang.NewKeyword("doc"), "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4853), lang.NewKeyword("end-line"), int(4853))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "f"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("meta"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.Apply(tmp7, []any{v3})
				tmp9 := lang.Apply(lang.NewKeyword("test"), []any{tmp8})
				var v10 any = tmp9
				_ = v10
				var tmp11 any
				if lang.IsTruthy(v10) {
					tmp12 := lang.Apply(v10, nil)
					_ = tmp12
					tmp11 = lang.NewKeyword("ok")
				} else {
					tmp11 = lang.NewKeyword("no-test")
				}
				tmp4 = tmp11
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// the-ns
	{
		tmp0 := lang.NewSymbol("the-ns").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4152), lang.NewKeyword("end-line"), int(4152))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := reflect.TypeOf((*lang.Namespace)(nil))
			tmp9 := lang.Apply(tmp7, []any{tmp8, v3})
			if lang.IsTruthy(tmp9) {
				tmp4 = v3
			} else {
				var tmp10 any
				{ // let
					// let binding "or__0__auto__"
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("find-ns"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := lang.Apply(tmp13, []any{v3})
					var v15 any = tmp14
					_ = v15
					var tmp16 any
					if lang.IsTruthy(v15) {
						tmp16 = v15
					} else {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("str"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.Apply(tmp19, []any{"No namespace: ", v3, " found"})
						tmp21 := lang.Apply(lang.NewError, []any{tmp20})
						panic(tmp21)
					}
					tmp10 = tmp16
				} // end let
				tmp4 = tmp10
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// thread-bound?
	{
		tmp0 := lang.NewSymbol("thread-bound?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("vars"))), lang.NewKeyword("doc"), "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.2", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5499), lang.NewKeyword("end-line"), int(5499))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("every?"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				var tmp7 lang.FnFunc
				tmp7 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v8 := args[0]
					_ = v8
					tmp9, ok := lang.FieldOrMethod(v8, "getThreadBinding")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v8, "getThreadBinding")))
					}
					var tmp10 any
					switch reflect.TypeOf(tmp9).Kind() {
					case reflect.Func:
						tmp10 = lang.Apply(tmp9, nil)
					default:
						tmp10 = tmp9
					}
					return tmp10
				})
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5505), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5505), lang.NewKeyword("end-column"), int(78))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp10 := lang.Apply(tmp6, []any{tmp9, v3})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// throw-if
	{
		tmp0 := lang.NewSymbol("throw-if").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("pred"), lang.NewSymbol("fmt"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Throws a CompilerException with a message if pred is true", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(8), lang.NewKeyword("line"), int(5832), lang.NewKeyword("end-line"), int(5832), lang.NewKeyword("private"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				var tmp6 any
				if lang.IsTruthy(v3) {
					var tmp7 any
					{ // let
						// let binding "message"
						tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp9 := tmp8.FindInternedVar(lang.NewSymbol("apply"))
						if tmp9.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
						}
						tmp10 := tmp9.Get()
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("format"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp10, []any{tmp13, v4, v5})
						var v15 any = tmp14
						_ = v15
						// let binding "exception"
						tmp16 := lang.Apply(lang.NewError, []any{v15})
						var v17 any = tmp16
						_ = v17
						// let binding "raw-trace"
						tmp18, ok := lang.FieldOrMethod(v17, "getStackTrace")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v17, "getStackTrace")))
						}
						var tmp19 any
						switch reflect.TypeOf(tmp18).Kind() {
						case reflect.Func:
							tmp19 = lang.Apply(tmp18, nil)
						default:
							tmp19 = tmp18
						}
						var v20 any = tmp19
						_ = v20
						// let binding "boring?"
						var tmp21 lang.FnFunc
						tmp21 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 1 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v22 := args[0]
							_ = v22
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("not="))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26, ok := lang.FieldOrMethod(v22, "getMethodName")
							if !ok {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v22, "getMethodName")))
							}
							var tmp27 any
							switch reflect.TypeOf(tmp26).Kind() {
							case reflect.Func:
								tmp27 = lang.Apply(tmp26, nil)
							default:
								tmp27 = tmp26
							}
							tmp28 := lang.Apply(tmp25, []any{tmp27, "doInvoke"})
							return tmp28
						})
						tmp22 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5839), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(5839), lang.NewKeyword("end-column"), int(74))
						tmp23, err := lang.WithMeta(tmp21, tmp22.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						var v24 any = tmp23
						_ = v24
						// let binding "trace"
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("into-array"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("drop"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("drop-while"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.Apply(tmp33, []any{v24, v20})
						tmp35 := lang.Apply(tmp30, []any{int64(2), tmp34})
						tmp36 := lang.Apply(tmp27, []any{nil, tmp35})
						var v37 any = tmp36
						_ = v37
						tmp38, _ := lang.FieldOrMethod(v17, "setStackTrace")
						if reflect.TypeOf(tmp38).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("setStackTrace is not a function")))
						}
						tmp39 := lang.Apply(tmp38, []any{v37})
						_ = tmp39
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("*file*"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp44 any
						switch reflect.TypeOf(tmp43).Kind() {
						case reflect.Func:
							tmp44 = lang.Apply(tmp43, nil)
						default:
							tmp44 = tmp43
						}
						tmp45, ok := lang.FieldOrMethod(nil, "Deref")
						if !ok {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", nil, "Deref")))
						}
						var tmp46 any
						switch reflect.TypeOf(tmp45).Kind() {
						case reflect.Func:
							tmp46 = lang.Apply(tmp45, nil)
						default:
							tmp46 = tmp45
						}
						tmp47 := lang.Apply(lang.NewCompilerError, []any{tmp42, tmp44, tmp46, v17})
						panic(tmp47)
					} // end let
					tmp6 = tmp7
				} else {
				}
				return tmp6
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// time
	{
		tmp0 := lang.NewSymbol("time").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("expr"))), lang.NewKeyword("doc"), "Evaluates expr and prints the time it took.  Returns the value of\n expr.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3885), lang.NewKeyword("end-line"), int(3885))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
			if tmp7.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
			}
			tmp8 := tmp7.Get()
			tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
			if tmp10.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
			}
			tmp11 := tmp10.Get()
			tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
			if tmp13.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
			}
			tmp14 := tmp13.Get()
			tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/let")})
			tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
			if tmp17.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
			}
			tmp18 := tmp17.Get()
			tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp20 := tmp19.FindInternedVar(lang.NewSymbol("apply"))
			if tmp20.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
			}
			tmp21 := tmp20.Get()
			tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp23 := tmp22.FindInternedVar(lang.NewSymbol("vector"))
			if tmp23.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
			}
			tmp24 := tmp23.Get()
			tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
			if tmp26.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
			}
			tmp27 := tmp26.Get()
			tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
			if tmp29.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
			}
			tmp30 := tmp29.Get()
			tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
			if tmp32.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
			}
			tmp33 := tmp32.Get()
			tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("start__0__auto__")})
			tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
			if tmp36.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
			}
			tmp37 := tmp36.Get()
			tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
			if tmp39.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
			}
			tmp40 := tmp39.Get()
			tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
			if tmp42.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
			}
			tmp43 := tmp42.Get()
			tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
			if tmp45.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
			}
			tmp46 := tmp45.Get()
			tmp47 := lang.Apply(tmp46, []any{lang.NewSymbol(".UnixNano")})
			tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
			if tmp49.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
			}
			tmp50 := tmp49.Get()
			tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp52 := tmp51.FindInternedVar(lang.NewSymbol("seq"))
			if tmp52.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
			}
			tmp53 := tmp52.Get()
			tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp55 := tmp54.FindInternedVar(lang.NewSymbol("concat"))
			if tmp55.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
			}
			tmp56 := tmp55.Get()
			tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
			if tmp58.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
			}
			tmp59 := tmp58.Get()
			tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("time.Now")})
			tmp61 := lang.Apply(tmp56, []any{tmp60})
			tmp62 := lang.Apply(tmp53, []any{tmp61})
			tmp63 := lang.Apply(tmp50, []any{tmp62})
			tmp64 := lang.Apply(tmp43, []any{tmp47, tmp63})
			tmp65 := lang.Apply(tmp40, []any{tmp64})
			tmp66 := lang.Apply(tmp37, []any{tmp65})
			tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp68 := tmp67.FindInternedVar(lang.NewSymbol("list"))
			if tmp68.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
			}
			tmp69 := tmp68.Get()
			tmp70 := lang.Apply(tmp69, []any{lang.NewSymbol("ret__1__auto__")})
			tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp72 := tmp71.FindInternedVar(lang.NewSymbol("list"))
			if tmp72.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
			}
			tmp73 := tmp72.Get()
			tmp74 := lang.Apply(tmp73, []any{v5})
			tmp75 := lang.Apply(tmp30, []any{tmp34, tmp66, tmp70, tmp74})
			tmp76 := lang.Apply(tmp27, []any{tmp75})
			tmp77 := lang.Apply(tmp21, []any{tmp24, tmp76})
			tmp78 := lang.Apply(tmp18, []any{tmp77})
			tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp80 := tmp79.FindInternedVar(lang.NewSymbol("list"))
			if tmp80.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
			}
			tmp81 := tmp80.Get()
			tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp83 := tmp82.FindInternedVar(lang.NewSymbol("seq"))
			if tmp83.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
			}
			tmp84 := tmp83.Get()
			tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp86 := tmp85.FindInternedVar(lang.NewSymbol("concat"))
			if tmp86.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
			}
			tmp87 := tmp86.Get()
			tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp89 := tmp88.FindInternedVar(lang.NewSymbol("list"))
			if tmp89.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
			}
			tmp90 := tmp89.Get()
			tmp91 := lang.Apply(tmp90, []any{lang.NewSymbol("glojure.core/prn")})
			tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp93 := tmp92.FindInternedVar(lang.NewSymbol("list"))
			if tmp93.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
			}
			tmp94 := tmp93.Get()
			tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp96 := tmp95.FindInternedVar(lang.NewSymbol("seq"))
			if tmp96.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
			}
			tmp97 := tmp96.Get()
			tmp98 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp99 := tmp98.FindInternedVar(lang.NewSymbol("concat"))
			if tmp99.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp99)))
			}
			tmp100 := tmp99.Get()
			tmp101 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp102 := tmp101.FindInternedVar(lang.NewSymbol("list"))
			if tmp102.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp102)))
			}
			tmp103 := tmp102.Get()
			tmp104 := lang.Apply(tmp103, []any{lang.NewSymbol("glojure.core/str")})
			tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp106 := tmp105.FindInternedVar(lang.NewSymbol("list"))
			if tmp106.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
			}
			tmp107 := tmp106.Get()
			tmp108 := lang.Apply(tmp107, []any{"Elapsed time: "})
			tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
			if tmp110.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
			}
			tmp111 := tmp110.Get()
			tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp113 := tmp112.FindInternedVar(lang.NewSymbol("seq"))
			if tmp113.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
			}
			tmp114 := tmp113.Get()
			tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp116 := tmp115.FindInternedVar(lang.NewSymbol("concat"))
			if tmp116.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
			}
			tmp117 := tmp116.Get()
			tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp119 := tmp118.FindInternedVar(lang.NewSymbol("list"))
			if tmp119.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
			}
			tmp120 := tmp119.Get()
			tmp121 := lang.Apply(tmp120, []any{lang.NewSymbol("glojure.core//")})
			tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
			if tmp123.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
			}
			tmp124 := tmp123.Get()
			tmp125 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp126 := tmp125.FindInternedVar(lang.NewSymbol("seq"))
			if tmp126.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp126)))
			}
			tmp127 := tmp126.Get()
			tmp128 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp129 := tmp128.FindInternedVar(lang.NewSymbol("concat"))
			if tmp129.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp129)))
			}
			tmp130 := tmp129.Get()
			tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
			if tmp132.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
			}
			tmp133 := tmp132.Get()
			tmp134 := lang.Apply(tmp133, []any{lang.NewSymbol("glojure.core/double")})
			tmp135 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp136 := tmp135.FindInternedVar(lang.NewSymbol("list"))
			if tmp136.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp136)))
			}
			tmp137 := tmp136.Get()
			tmp138 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp139 := tmp138.FindInternedVar(lang.NewSymbol("seq"))
			if tmp139.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp139)))
			}
			tmp140 := tmp139.Get()
			tmp141 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp142 := tmp141.FindInternedVar(lang.NewSymbol("concat"))
			if tmp142.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp142)))
			}
			tmp143 := tmp142.Get()
			tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp145 := tmp144.FindInternedVar(lang.NewSymbol("list"))
			if tmp145.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
			}
			tmp146 := tmp145.Get()
			tmp147 := lang.Apply(tmp146, []any{lang.NewSymbol("glojure.core/-")})
			tmp148 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp149 := tmp148.FindInternedVar(lang.NewSymbol("list"))
			if tmp149.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp149)))
			}
			tmp150 := tmp149.Get()
			tmp151 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp152 := tmp151.FindInternedVar(lang.NewSymbol("seq"))
			if tmp152.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp152)))
			}
			tmp153 := tmp152.Get()
			tmp154 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp155 := tmp154.FindInternedVar(lang.NewSymbol("concat"))
			if tmp155.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp155)))
			}
			tmp156 := tmp155.Get()
			tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp158 := tmp157.FindInternedVar(lang.NewSymbol("list"))
			if tmp158.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
			}
			tmp159 := tmp158.Get()
			tmp160 := lang.Apply(tmp159, []any{lang.NewSymbol(".UnixNano")})
			tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp162 := tmp161.FindInternedVar(lang.NewSymbol("list"))
			if tmp162.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
			}
			tmp163 := tmp162.Get()
			tmp164 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp165 := tmp164.FindInternedVar(lang.NewSymbol("seq"))
			if tmp165.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp165)))
			}
			tmp166 := tmp165.Get()
			tmp167 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp168 := tmp167.FindInternedVar(lang.NewSymbol("concat"))
			if tmp168.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp168)))
			}
			tmp169 := tmp168.Get()
			tmp170 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp171 := tmp170.FindInternedVar(lang.NewSymbol("list"))
			if tmp171.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp171)))
			}
			tmp172 := tmp171.Get()
			tmp173 := lang.Apply(tmp172, []any{lang.NewSymbol("time.Now")})
			tmp174 := lang.Apply(tmp169, []any{tmp173})
			tmp175 := lang.Apply(tmp166, []any{tmp174})
			tmp176 := lang.Apply(tmp163, []any{tmp175})
			tmp177 := lang.Apply(tmp156, []any{tmp160, tmp176})
			tmp178 := lang.Apply(tmp153, []any{tmp177})
			tmp179 := lang.Apply(tmp150, []any{tmp178})
			tmp180 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp181 := tmp180.FindInternedVar(lang.NewSymbol("list"))
			if tmp181.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp181)))
			}
			tmp182 := tmp181.Get()
			tmp183 := lang.Apply(tmp182, []any{lang.NewSymbol("start__0__auto__")})
			tmp184 := lang.Apply(tmp143, []any{tmp147, tmp179, tmp183})
			tmp185 := lang.Apply(tmp140, []any{tmp184})
			tmp186 := lang.Apply(tmp137, []any{tmp185})
			tmp187 := lang.Apply(tmp130, []any{tmp134, tmp186})
			tmp188 := lang.Apply(tmp127, []any{tmp187})
			tmp189 := lang.Apply(tmp124, []any{tmp188})
			tmp190 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp191 := tmp190.FindInternedVar(lang.NewSymbol("list"))
			if tmp191.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp191)))
			}
			tmp192 := tmp191.Get()
			tmp193 := lang.Apply(tmp192, []any{nil})
			tmp194 := lang.Apply(tmp117, []any{tmp121, tmp189, tmp193})
			tmp195 := lang.Apply(tmp114, []any{tmp194})
			tmp196 := lang.Apply(tmp111, []any{tmp195})
			tmp197 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp198 := tmp197.FindInternedVar(lang.NewSymbol("list"))
			if tmp198.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp198)))
			}
			tmp199 := tmp198.Get()
			tmp200 := lang.Apply(tmp199, []any{" msecs"})
			tmp201 := lang.Apply(tmp100, []any{tmp104, tmp108, tmp196, tmp200})
			tmp202 := lang.Apply(tmp97, []any{tmp201})
			tmp203 := lang.Apply(tmp94, []any{tmp202})
			tmp204 := lang.Apply(tmp87, []any{tmp91, tmp203})
			tmp205 := lang.Apply(tmp84, []any{tmp204})
			tmp206 := lang.Apply(tmp81, []any{tmp205})
			tmp207 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp208 := tmp207.FindInternedVar(lang.NewSymbol("list"))
			if tmp208.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp208)))
			}
			tmp209 := tmp208.Get()
			tmp210 := lang.Apply(tmp209, []any{lang.NewSymbol("ret__1__auto__")})
			tmp211 := lang.Apply(tmp11, []any{tmp15, tmp78, tmp206, tmp210})
			tmp212 := lang.Apply(tmp8, []any{tmp211})
			return tmp212
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array
	{
		tmp0 := lang.NewSymbol("to-array").WithMeta(lang.NewMap(lang.NewKeyword("tag"), "[Ljava.lang.Object;", lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(337), lang.NewKeyword("end-line"), int(337))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(runtime4.RT, "ToArray")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("ToArray is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{v3})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), "[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// to-array-2d
	{
		tmp0 := lang.NewSymbol("to-array-2d").WithMeta(lang.NewMap(lang.NewKeyword("tag"), "[[Ljava.lang.Object;", lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4002), lang.NewKeyword("end-line"), int(4002))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "ret"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("make-array"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf((*reflect.Type)(nil)).Elem()
				tmp9, _ := lang.FieldOrMethod(tmp8, "forName")
				if reflect.TypeOf(tmp9).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("forName is not a function")))
				}
				tmp10 := lang.Apply(tmp9, []any{"[Ljava.lang.Object;"})
				tmp11, _ := lang.FieldOrMethod(v3, "size")
				if reflect.TypeOf(tmp11).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("size is not a function")))
				}
				tmp12 := lang.Apply(tmp11, []any{})
				tmp13 := lang.Apply(tmp7, []any{tmp10, tmp12})
				var v14 any = tmp13
				_ = v14
				var tmp15 any
				{ // let
					// let binding "i"
					var v16 any = int64(0)
					_ = v16
					// let binding "xs"
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.Apply(tmp19, []any{v3})
					var v21 any = tmp20
					_ = v21
					for {
						var tmp22 any
						if lang.IsTruthy(v21) {
							tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp24 := tmp23.FindInternedVar(lang.NewSymbol("aset"))
							if tmp24.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
							}
							tmp25 := tmp24.Get()
							tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp27 := tmp26.FindInternedVar(lang.NewSymbol("to-array"))
							if tmp27.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
							}
							tmp28 := tmp27.Get()
							tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp30 := tmp29.FindInternedVar(lang.NewSymbol("first"))
							if tmp30.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
							}
							tmp31 := tmp30.Get()
							tmp32 := lang.Apply(tmp31, []any{v21})
							tmp33 := lang.Apply(tmp28, []any{tmp32})
							tmp34 := lang.Apply(tmp25, []any{v14, v16, tmp33})
							_ = tmp34
							tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp37 := tmp36.FindInternedVar(lang.NewSymbol("inc"))
							if tmp37.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
							}
							tmp38 := tmp37.Get()
							tmp39 := lang.Apply(tmp38, []any{v16})
							var tmp35 any = tmp39
							tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp42 := tmp41.FindInternedVar(lang.NewSymbol("next"))
							if tmp42.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
							}
							tmp43 := tmp42.Get()
							tmp44 := lang.Apply(tmp43, []any{v21})
							var tmp40 any = tmp44
							v16 = tmp35
							v21 = tmp40
							continue
						} else {
						}
						tmp15 = tmp22
						break
					}
				} // end let
				_ = tmp15
				tmp4 = v14
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), "[[Ljava.lang.Object;")).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// trampoline
	{
		tmp0 := lang.NewSymbol("trampoline").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6293), lang.NewKeyword("end-line"), int(6293))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 1:
				v3 := args[0]
				_ = v3
			recur_loop_1073:
				var tmp4 any
				{ // let
					// let binding "ret"
					tmp5 := lang.Apply(v3, nil)
					var v6 any = tmp5
					_ = v6
					var tmp7 any
					tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp9 := tmp8.FindInternedVar(lang.NewSymbol("fn?"))
					if tmp9.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
					}
					tmp10 := tmp9.Get()
					tmp11 := lang.Apply(tmp10, []any{v6})
					if lang.IsTruthy(tmp11) {
						var tmp12 any = v6
						v3 = tmp12
						goto recur_loop_1073
					} else {
						tmp7 = v6
					}
					tmp4 = tmp7
				} // end let
				return tmp4
			default:
				if len(args) < 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				var v4 any = lang.NewList(args[1:]...)
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("trampoline"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				var tmp8 lang.FnFunc
				tmp8 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 0 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("apply"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.Apply(tmp11, []any{v3, v4})
					return tmp12
				})
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6309), lang.NewKeyword("column"), int(18), lang.NewKeyword("end-line"), int(6309), lang.NewKeyword("end-column"), int(32))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp11 := lang.Apply(tmp7, []any{tmp10})
				return tmp11
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transduce
	{
		tmp0 := lang.NewSymbol("transduce").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("coll")), lang.NewVector(lang.NewSymbol("xform"), lang.NewSymbol("f"), lang.NewSymbol("init"), lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6905), lang.NewKeyword("end-line"), int(6905))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("transduce"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(v4, nil)
				tmp10 := lang.Apply(tmp8, []any{v3, v4, tmp9, v5})
				return tmp10
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var tmp7 any
				{ // let
					// let binding "f"
					tmp8 := lang.Apply(v3, []any{v4})
					var v9 any = tmp8
					_ = v9
					// let binding "ret"
					var tmp10 any
					tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp12 := tmp11.FindInternedVar(lang.NewSymbol("instance?"))
					if tmp12.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
					}
					tmp13 := tmp12.Get()
					tmp14 := reflect.TypeOf((*lang.IReduceInit)(nil)).Elem()
					tmp15 := lang.Apply(tmp13, []any{tmp14, v6})
					if lang.IsTruthy(tmp15) {
						tmp16, _ := lang.FieldOrMethod(v6, "ReduceInit")
						if reflect.TypeOf(tmp16).Kind() != reflect.Func {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("ReduceInit is not a function")))
						}
						tmp17 := lang.Apply(tmp16, []any{v9, v5})
						tmp10 = tmp17
					} else {
						tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core.protocols"))
						tmp19 := tmp18.FindInternedVar(lang.NewSymbol("coll-reduce"))
						if tmp19.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
						}
						tmp20 := tmp19.Get()
						tmp21 := lang.Apply(tmp20, []any{v6, v9, v5})
						tmp10 = tmp21
					}
					var v22 any = tmp10
					_ = v22
					tmp23 := lang.Apply(v9, []any{v22})
					tmp7 = tmp23
				} // end let
				return tmp7
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// transient
	{
		tmp0 := lang.NewSymbol("transient").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Returns a new, transient version of the collection, in constant time.\n\n  Transients support a parallel set of 'changing' operations, with similar names\n  followed by ! - assoc!, conj! etc. These do the same things as their persistent\n  counterparts except the return values are themselves transient.\n\n  Note in particular that transients are not designed to be bashed in-place. You\n  must capture and use the return value in the next call. In this way, they support\n  the same code structure as the functional persistent code they replace.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3335), lang.NewKeyword("end-line"), int(3335))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, ok := lang.FieldOrMethod(v3, "AsTransient")
			if !ok {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v3, "AsTransient")))
			}
			var tmp5 any
			switch reflect.TypeOf(tmp4).Kind() {
			case reflect.Func:
				tmp5 = lang.Apply(tmp4, nil)
			default:
				tmp5 = tmp4
			}
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// tree-seq
	{
		tmp0 := lang.NewSymbol("tree-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("branch?"), lang.NewSymbol("children"), lang.NewSymbol("root"))), lang.NewKeyword("doc"), "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4955), lang.NewKeyword("end-line"), int(4955))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 3 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			v5 := args[2]
			_ = v5
			var tmp6 any
			{ // let
				// let binding "walk"
				var tmp7 lang.FnFunc
				{ // function walk
					var v8 lang.FnFunc
					tmp7 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v9 := args[0]
						_ = v9
						var tmp10 lang.FnFunc
						tmp10 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 0 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp12 := tmp11.FindInternedVar(lang.NewSymbol("cons"))
							if tmp12.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
							}
							tmp13 := tmp12.Get()
							var tmp14 any
							tmp15 := lang.Apply(v3, []any{v9})
							if lang.IsTruthy(tmp15) {
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("mapcat"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(v4, []any{v9})
								tmp20 := lang.Apply(tmp18, []any{v8, tmp19})
								tmp14 = tmp20
							} else {
							}
							tmp21 := lang.Apply(tmp13, []any{v9, tmp14})
							return tmp21
						})
						tmp11 := lang.Apply(lang.NewLazySeq, []any{tmp10})
						return tmp11
					})
					v8 = tmp7
					_ = v8
				}
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(4965), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(4969), lang.NewKeyword("end-column"), int(53))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v10 any = tmp9
				_ = v10
				tmp11 := lang.Apply(v10, []any{v5})
				tmp6 = tmp11
			} // end let
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// true?
	{
		tmp1 := reflect.TypeOf(false)
		tmp0 := lang.NewSymbol("true?").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is the value true, false otherwise.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(511), lang.NewKeyword("end-line"), int(511))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.Identical, []any{v4, true})
			return tmp5
		})
		tmp4 := reflect.TypeOf(false)
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// type
	{
		tmp0 := lang.NewSymbol("type").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns the :type metadata of x, or its Class if none", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3467), lang.NewKeyword("end-line"), int(3467))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			{ // let
				// let binding "or__0__auto__"
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("get"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("meta"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v3})
				tmp12 := lang.Apply(tmp7, []any{tmp11, lang.NewKeyword("type")})
				var v13 any = tmp12
				_ = v13
				var tmp14 any
				if lang.IsTruthy(v13) {
					tmp14 = v13
				} else {
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("class"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp14 = tmp18
				}
				tmp4 = tmp14
			} // end let
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/UncheckedAdd")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-add").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1203), lang.NewKeyword("end-line"), int(1203))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedAdd")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedAdd is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-add-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-add-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_int_add")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-add-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1196), lang.NewKeyword("end-line"), int(1196))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_add")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_add is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-byte
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-byte__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedByteCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-byte").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to byte. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3517), lang.NewKeyword("end-line"), int(3517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedByteCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-char
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-char__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedCharCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-char").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to char. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3529), lang.NewKeyword("end-line"), int(3529))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(runtime4.RT, "UncheckedCharCast")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedCharCast is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedDec")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-dec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1175), lang.NewKeyword("end-line"), int(1175))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedDec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedDec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-dec-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-dec-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Unchecked_int_dec")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-dec-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1168), lang.NewKeyword("end-line"), int(1168))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_dec")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_dec is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-divide-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-divide-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/UncheckedIntDivide")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-divide-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1238), lang.NewKeyword("end-line"), int(1238))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UncheckedIntDivide")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UncheckedIntDivide is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-double
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-double__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedDoubleCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-double").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to double. Subject to rounding.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3553), lang.NewKeyword("end-line"), int(3553))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.AsFloat64, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-float
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-float__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedFloatCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-float").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to float. Subject to rounding.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3547), lang.NewKeyword("end-line"), int(3547))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedFloatCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Unchecked_inc")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-inc").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1161), lang.NewKeyword("end-line"), int(1161))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-inc-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-inc-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Unchecked_int_inc")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-inc-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1154), lang.NewKeyword("end-line"), int(1154))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_inc")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_inc is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedIntCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to int. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3535), lang.NewKeyword("end-line"), int(3535))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedIntCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-long
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-long__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedLongCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-long").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to long. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3541), lang.NewKeyword("end-line"), int(3541))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedLongCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_multiply")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-multiply").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1231), lang.NewKeyword("end-line"), int(1231))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-multiply-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-multiply-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_int_multiply")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-multiply-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1224), lang.NewKeyword("end-line"), int(1224))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_multiply")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_multiply is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Unchecked_minus")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-negate").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1189), lang.NewKeyword("end-line"), int(1189))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-negate-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-negate-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/Unchecked_int_negate")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-negate-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(26), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1182), lang.NewKeyword("end-line"), int(1182))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_negate")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_negate is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-remainder-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-remainder-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_int_remainder")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-remainder-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(29), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1245), lang.NewKeyword("end-line"), int(1245))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_remainder")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_remainder is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-short
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-short__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$runtime.RT")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/UncheckedShortCast")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-short").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Coerce to short. Subject to rounding or truncation.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(3523), lang.NewKeyword("end-line"), int(3523))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.UncheckedShortCast, []any{v4})
			return tmp5
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_minus")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-subtract").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1217), lang.NewKeyword("end-line"), int(1217))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_minus")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_minus is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unchecked-subtract-int
	{
		var tmp1 lang.FnFunc
		{ // function unchecked-subtract-int__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/Unchecked_int_subtract")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unchecked-subtract-int").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("y"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(28), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1210), lang.NewKeyword("end-line"), int(1210))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "Unchecked_int_subtract")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Unchecked_int_subtract is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// underive
	{
		tmp0 := lang.NewSymbol("underive").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("tag"), lang.NewSymbol("parent")), lang.NewVector(lang.NewSymbol("h"), lang.NewSymbol("tag"), lang.NewSymbol("parent"))), lang.NewKeyword("doc"), "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(5643), lang.NewKeyword("end-line"), int(5643))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("alter-var-root"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.InternVarName(lang.NewSymbol("glojure.core"), lang.NewSymbol("global-hierarchy"))
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("underive"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp7, []any{tmp8, tmp11, v3, v4})
				_ = tmp12
				return nil
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var tmp6 any
				{ // let
					// let binding "parentMap"
					tmp7 := lang.Apply(lang.NewKeyword("parents"), []any{v3})
					var v8 any = tmp7
					_ = v8
					// let binding "childsParents"
					var tmp9 any
					tmp10 := lang.Apply(v8, []any{v4})
					if lang.IsTruthy(tmp10) {
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("disj"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(v8, []any{v4})
						tmp15 := lang.Apply(tmp13, []any{tmp14, v5})
						tmp9 = tmp15
					} else {
						tmp16 := lang.CreatePersistentTreeSet(lang.NewSliceSeq([]any{}))
						tmp17 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5652), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(5652), lang.NewKeyword("end-column"), int(38))
						tmp18, err := lang.WithMeta(tmp16, tmp17.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp9 = tmp18
					}
					var v19 any = tmp9
					_ = v19
					// let binding "newParents"
					var tmp20 any
					tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp22 := tmp21.FindInternedVar(lang.NewSymbol("not-empty"))
					if tmp22.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
					}
					tmp23 := tmp22.Get()
					tmp24 := lang.Apply(tmp23, []any{v19})
					if lang.IsTruthy(tmp24) {
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("assoc"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.Apply(tmp27, []any{v8, v4, v19})
						tmp20 = tmp28
					} else {
						tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp30 := tmp29.FindInternedVar(lang.NewSymbol("dissoc"))
						if tmp30.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
						}
						tmp31 := tmp30.Get()
						tmp32 := lang.Apply(tmp31, []any{v8, v4})
						tmp20 = tmp32
					}
					var v33 any = tmp20
					_ = v33
					// let binding "deriv-seq"
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("flatten"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("map"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					var tmp40 lang.FnFunc
					tmp40 = lang.NewFnFunc(func(args ...any) any {
						if len(args) != 1 {
							panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
						}
						v41 := args[0]
						_ = v41
						tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp43 := tmp42.FindInternedVar(lang.NewSymbol("cons"))
						if tmp43.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
						}
						tmp44 := tmp43.Get()
						tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp46 := tmp45.FindInternedVar(lang.NewSymbol("key"))
						if tmp46.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
						}
						tmp47 := tmp46.Get()
						tmp48 := lang.Apply(tmp47, []any{v41})
						tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp50 := tmp49.FindInternedVar(lang.NewSymbol("interpose"))
						if tmp50.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
						}
						tmp51 := tmp50.Get()
						tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp53 := tmp52.FindInternedVar(lang.NewSymbol("key"))
						if tmp53.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
						}
						tmp54 := tmp53.Get()
						tmp55 := lang.Apply(tmp54, []any{v41})
						tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp57 := tmp56.FindInternedVar(lang.NewSymbol("val"))
						if tmp57.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
						}
						tmp58 := tmp57.Get()
						tmp59 := lang.Apply(tmp58, []any{v41})
						tmp60 := lang.Apply(tmp51, []any{tmp55, tmp59})
						tmp61 := lang.Apply(tmp44, []any{tmp48, tmp60})
						return tmp61
					})
					tmp41 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5656), lang.NewKeyword("column"), int(28), lang.NewKeyword("end-line"), int(5656), lang.NewKeyword("end-column"), int(70))
					tmp42, err := lang.WithMeta(tmp40, tmp41.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
					if tmp44.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
					}
					tmp45 := tmp44.Get()
					tmp46 := lang.Apply(tmp45, []any{v33})
					tmp47 := lang.Apply(tmp39, []any{tmp42, tmp46})
					tmp48 := lang.Apply(tmp36, []any{tmp47})
					var v49 any = tmp48
					_ = v49
					var tmp50 any
					tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp52 := tmp51.FindInternedVar(lang.NewSymbol("contains?"))
					if tmp52.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
					}
					tmp53 := tmp52.Get()
					tmp54 := lang.Apply(v8, []any{v4})
					tmp55 := lang.Apply(tmp53, []any{tmp54, v5})
					if lang.IsTruthy(tmp55) {
						tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp57 := tmp56.FindInternedVar(lang.NewSymbol("reduce1"))
						if tmp57.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
						}
						tmp58 := tmp57.Get()
						var tmp59 lang.FnFunc
						tmp59 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 2 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v60 := args[0]
							_ = v60
							v61 := args[1]
							_ = v61
							tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp63 := tmp62.FindInternedVar(lang.NewSymbol("apply"))
							if tmp63.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
							}
							tmp64 := tmp63.Get()
							tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp66 := tmp65.FindInternedVar(lang.NewSymbol("derive"))
							if tmp66.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
							}
							tmp67 := tmp66.Get()
							tmp68 := lang.Apply(tmp64, []any{tmp67, v60, v61})
							return tmp68
						})
						tmp60 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5659), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5659), lang.NewKeyword("end-column"), int(31))
						tmp61, err := lang.WithMeta(tmp59, tmp60.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp63 := tmp62.FindInternedVar(lang.NewSymbol("make-hierarchy"))
						if tmp63.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
						}
						tmp64 := tmp63.Get()
						tmp65 := lang.Apply(tmp64, nil)
						tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp67 := tmp66.FindInternedVar(lang.NewSymbol("partition"))
						if tmp67.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
						}
						tmp68 := tmp67.Get()
						tmp69 := lang.Apply(tmp68, []any{int64(2), v49})
						tmp70 := lang.Apply(tmp58, []any{tmp61, tmp65, tmp69})
						tmp50 = tmp70
					} else {
						tmp50 = v3
					}
					tmp6 = tmp50
				} // end let
				return tmp6
			default:
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote
	{
		tmp0 := lang.NewSymbol("unquote").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unquote-splicing
	{
		tmp0 := lang.NewSymbol("unquote-splicing").WithMeta(lang.NewMap()).(*lang.Symbol)
		tmp1 := ns.Intern(tmp0)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unreduced
	{
		tmp0 := lang.NewSymbol("unreduced").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "If x is reduced?, returns (deref x), else returns x", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2847), lang.NewKeyword("end-line"), int(2847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("reduced?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("deref"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3})
				tmp4 = tmp12
			} else {
				tmp4 = v3
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// unsigned-bit-shift-right
	{
		var tmp1 lang.FnFunc
		{ // function unsigned-bit-shift-right__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("seq"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("concat"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("list"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{lang.NewSymbol(".")})
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("list"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.Apply(tmp17, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("list"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("seq"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("concat"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("glojure.core/UnsignedShiftRight")})
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{v3})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.Apply(tmp38, []any{v4})
				tmp40 := lang.Apply(tmp27, []any{tmp31, tmp35, tmp39})
				tmp41 := lang.Apply(tmp24, []any{tmp40})
				tmp42 := lang.Apply(tmp21, []any{tmp41})
				tmp43 := lang.Apply(tmp10, []any{tmp14, tmp18, tmp42})
				tmp44 := lang.Apply(tmp7, []any{tmp43})
				return tmp44
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("unsigned-bit-shift-right").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("n"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Bitwise shift right, without sign-extension.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1373), lang.NewKeyword("end-line"), int(1373))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			v5 := args[1]
			_ = v5
			tmp6, _ := lang.FieldOrMethod(lang.Numbers, "UnsignedShiftRight")
			if reflect.TypeOf(tmp6).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("UnsignedShiftRight is not a function")))
			}
			tmp7 := lang.Apply(tmp6, []any{v4, v5})
			return tmp7
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update
	{
		tmp0 := lang.NewSymbol("update").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z")), lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("k"), lang.NewSymbol("f"), lang.NewSymbol("x"), lang.NewSymbol("y"), lang.NewSymbol("z"), lang.NewSymbol("&"), lang.NewSymbol("more"))), lang.NewKeyword("doc"), "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6174), lang.NewKeyword("end-line"), int(6174))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("get"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.Apply(tmp11, []any{v3, v4})
				tmp13 := lang.Apply(v5, []any{tmp12})
				tmp14 := lang.Apply(tmp8, []any{v3, v4, tmp13})
				return tmp14
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("get"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{v3, v4})
				tmp14 := lang.Apply(v5, []any{tmp13, v6})
				tmp15 := lang.Apply(tmp9, []any{v3, v4, tmp14})
				return tmp15
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp12 := tmp11.FindInternedVar(lang.NewSymbol("get"))
				if tmp12.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
				}
				tmp13 := tmp12.Get()
				tmp14 := lang.Apply(tmp13, []any{v3, v4})
				tmp15 := lang.Apply(v5, []any{tmp14, v6, v7})
				tmp16 := lang.Apply(tmp10, []any{v3, v4, tmp15})
				return tmp16
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("get"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3, v4})
				tmp16 := lang.Apply(v5, []any{tmp15, v6, v7, v8})
				tmp17 := lang.Apply(tmp11, []any{v3, v4, tmp16})
				return tmp17
			default:
				if len(args) < 6 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("assoc"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("apply"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("get"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.Apply(tmp18, []any{v3, v4})
				tmp20 := lang.Apply(tmp15, []any{v5, tmp19, v6, v7, v8, v9})
				tmp21 := lang.Apply(tmp12, []any{v3, v4, tmp20})
				return tmp21
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-in
	{
		tmp0 := lang.NewSymbol("update-in").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("ks"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6158), lang.NewKeyword("end-line"), int(6158))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "up"
					var tmp8 lang.FnFunc
					{ // function up
						var v9 lang.FnFunc
						tmp8 = lang.NewFnFunc(func(args ...any) any {
							if len(args) != 4 {
								panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
							}
							v10 := args[0]
							_ = v10
							v11 := args[1]
							_ = v11
							v12 := args[2]
							_ = v12
							v13 := args[3]
							_ = v13
							var tmp14 any
							{ // let
								// let binding "vec__141"
								var v15 any = v11
								_ = v15
								// let binding "seq__142"
								tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp17 := tmp16.FindInternedVar(lang.NewSymbol("seq"))
								if tmp17.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
								}
								tmp18 := tmp17.Get()
								tmp19 := lang.Apply(tmp18, []any{v15})
								var v20 any = tmp19
								_ = v20
								// let binding "first__143"
								tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp22 := tmp21.FindInternedVar(lang.NewSymbol("first"))
								if tmp22.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
								}
								tmp23 := tmp22.Get()
								tmp24 := lang.Apply(tmp23, []any{v20})
								var v25 any = tmp24
								_ = v25
								// let binding "seq__142"
								tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
								tmp27 := tmp26.FindInternedVar(lang.NewSymbol("next"))
								if tmp27.IsMacro() {
									panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
								}
								tmp28 := tmp27.Get()
								tmp29 := lang.Apply(tmp28, []any{v20})
								var v30 any = tmp29
								_ = v30
								// let binding "k"
								var v31 any = v25
								_ = v31
								// let binding "ks"
								var v32 any = v30
								_ = v32
								var tmp33 any
								if lang.IsTruthy(v32) {
									tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp35 := tmp34.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp35.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
									}
									tmp36 := tmp35.Get()
									tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp38 := tmp37.FindInternedVar(lang.NewSymbol("get"))
									if tmp38.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
									}
									tmp39 := tmp38.Get()
									tmp40 := lang.Apply(tmp39, []any{v10, v31})
									tmp41 := lang.Apply(v9, []any{tmp40, v32, v12, v13})
									tmp42 := lang.Apply(tmp36, []any{v10, v31, tmp41})
									tmp33 = tmp42
								} else {
									tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp44 := tmp43.FindInternedVar(lang.NewSymbol("assoc"))
									if tmp44.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
									}
									tmp45 := tmp44.Get()
									tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp47 := tmp46.FindInternedVar(lang.NewSymbol("apply"))
									if tmp47.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
									}
									tmp48 := tmp47.Get()
									tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp50 := tmp49.FindInternedVar(lang.NewSymbol("get"))
									if tmp50.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
									}
									tmp51 := tmp50.Get()
									tmp52 := lang.Apply(tmp51, []any{v10, v31})
									tmp53 := lang.Apply(tmp48, []any{v12, tmp52, v13})
									tmp54 := lang.Apply(tmp45, []any{v10, v31, tmp53})
									tmp33 = tmp54
								}
								tmp14 = tmp33
							} // end let
							return tmp14
						})
						v9 = tmp8
						_ = v9
					}
					tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6167), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(6171), lang.NewKeyword("end-column"), int(59))
					tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					var v11 any = tmp10
					_ = v11
					tmp12 := lang.Apply(v11, []any{v3, v4, v5, v6})
					tmp7 = tmp12
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-keys
	{
		tmp0 := lang.NewSymbol("update-keys").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "m f => {(f k) v ...}\n\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7906), lang.NewKeyword("end-line"), int(7906))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "ret"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("persistent!"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("reduce-kv"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				var tmp12 lang.FnFunc
				tmp12 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 3 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v13 := args[0]
					_ = v13
					v14 := args[1]
					_ = v14
					v15 := args[2]
					_ = v15
					tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp17 := tmp16.FindInternedVar(lang.NewSymbol("assoc!"))
					if tmp17.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
					}
					tmp18 := tmp17.Get()
					tmp19 := lang.Apply(v4, []any{v14})
					tmp20 := lang.Apply(tmp18, []any{v13, tmp19, v15})
					return tmp20
				})
				tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7916), lang.NewKeyword("column"), int(25), lang.NewKeyword("end-line"), int(7916), lang.NewKeyword("end-column"), int(59))
				tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("transient"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.NewMap()
				tmp19 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7917), lang.NewKeyword("column"), int(36), lang.NewKeyword("end-line"), int(7917), lang.NewKeyword("end-column"), int(37))
				tmp20, err := lang.WithMeta(tmp18, tmp19.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp21 := lang.Apply(tmp17, []any{tmp20})
				tmp22 := lang.Apply(tmp11, []any{tmp14, tmp21, v3})
				tmp23 := lang.Apply(tmp8, []any{tmp22})
				var v24 any = tmp23
				_ = v24
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("with-meta"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("meta"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.Apply(tmp30, []any{v3})
				tmp32 := lang.Apply(tmp27, []any{v24, tmp31})
				tmp5 = tmp32
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// update-vals
	{
		tmp0 := lang.NewSymbol("update-vals").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("m"), lang.NewSymbol("f"))), lang.NewKeyword("doc"), "m f => {k (f v) ...}\n\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.11", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(17), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7890), lang.NewKeyword("end-line"), int(7890))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("with-meta"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp9 := tmp8.FindInternedVar(lang.NewSymbol("persistent!"))
			if tmp9.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
			}
			tmp10 := tmp9.Get()
			tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp12 := tmp11.FindInternedVar(lang.NewSymbol("reduce-kv"))
			if tmp12.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
			}
			tmp13 := tmp12.Get()
			var tmp14 lang.FnFunc
			tmp14 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v15 := args[0]
				_ = v15
				v16 := args[1]
				_ = v16
				v17 := args[2]
				_ = v17
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("assoc!"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.Apply(v4, []any{v17})
				tmp22 := lang.Apply(tmp20, []any{v15, v16, tmp21})
				return tmp22
			})
			tmp15 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7899), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(7899), lang.NewKeyword("end-column"), int(51))
			tmp16, err := lang.WithMeta(tmp14, tmp15.(lang.IPersistentMap))
			if err != nil {
				panic(err)
			}
			var tmp17 any
			tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp19 := tmp18.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp19.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
			}
			tmp20 := tmp19.Get()
			tmp21 := reflect.TypeOf((*lang.IEditableCollection)(nil)).Elem()
			tmp22 := lang.Apply(tmp20, []any{tmp21, v3})
			if lang.IsTruthy(tmp22) {
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("transient"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp17 = tmp26
			} else {
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("transient"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.NewMap()
				tmp31 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7902), lang.NewKeyword("column"), int(30), lang.NewKeyword("end-line"), int(7902), lang.NewKeyword("end-column"), int(31))
				tmp32, err := lang.WithMeta(tmp30, tmp31.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp33 := lang.Apply(tmp29, []any{tmp32})
				tmp17 = tmp33
			}
			tmp34 := lang.Apply(tmp13, []any{tmp16, tmp17, v3})
			tmp35 := lang.Apply(tmp10, []any{tmp34})
			tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp37 := tmp36.FindInternedVar(lang.NewSymbol("meta"))
			if tmp37.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
			}
			tmp38 := tmp37.Get()
			tmp39 := lang.Apply(tmp38, []any{v3})
			tmp40 := lang.Apply(tmp7, []any{tmp35, tmp39})
			return tmp40
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uri?
	{
		tmp0 := lang.NewSymbol("uri?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a java.net.URI", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7877), lang.NewKeyword("end-line"), int(7877))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*url14.URL)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// use
	{
		tmp0 := lang.NewSymbol("use").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Like 'require, but also refers to each lib's namespace using\n  glojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for glojure.core/refer.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6079), lang.NewKeyword("end-line"), int(6079))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 0 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				var v3 any = lang.NewList(args[0:]...)
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("apply"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("load-libs"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.Apply(tmp6, []any{tmp9, lang.NewKeyword("require"), lang.NewKeyword("use"), v3})
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// uuid?
	{
		tmp0 := lang.NewSymbol("uuid?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x is a java.util.UUID", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.9", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6847), lang.NewKeyword("end-line"), int(6847))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf([16]uint8{})
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// val
	{
		tmp0 := lang.NewSymbol("val").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("e"))), lang.NewKeyword("doc"), "Returns the value in the map entry.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1570), lang.NewKeyword("end-line"), int(1570))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "GetValue")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("GetValue is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vals
	{
		tmp0 := lang.NewSymbol("vals").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("map"))), lang.NewKeyword("doc"), "Returns a sequence of the map's values, in the same order as (seq map).", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1557), lang.NewKeyword("end-line"), int(1557))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.Apply(lang.Vals, []any{v3})
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-get
	{
		tmp0 := lang.NewSymbol("var-get").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Gets the value in the var object", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4326), lang.NewKeyword("end-line"), int(4326))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4, _ := lang.FieldOrMethod(v3, "Get")
			if reflect.TypeOf(tmp4).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Get is not a function")))
			}
			tmp5 := lang.Apply(tmp4, []any{})
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var-set
	{
		tmp0 := lang.NewSymbol("var-set").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"), lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Sets the value in the var object to val. The var must be\n thread-locally bound.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4332), lang.NewKeyword("end-line"), int(4332))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "Set")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("Set is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// var?
	{
		tmp0 := lang.NewSymbol("var?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("v"))), lang.NewKeyword("doc"), "Returns true if v is of type glojure.lang.Var", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4999), lang.NewKeyword("end-line"), int(4999))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Var)(nil))
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vary-meta
	{
		tmp0 := lang.NewSymbol("vary-meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(668), lang.NewKeyword("end-line"), int(668))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("with-meta"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("apply"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("meta"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{v3})
				tmp16 := lang.Apply(tmp11, []any{v4, tmp15, v5})
				tmp17 := lang.Apply(tmp8, []any{v3, tmp16})
				return tmp17
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vec
	{
		tmp0 := lang.NewSymbol("vec").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("coll"))), lang.NewKeyword("doc"), "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(9), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(366), lang.NewKeyword("end-line"), int(366))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			var tmp4 any
			tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp6 := tmp5.FindInternedVar(lang.NewSymbol("vector?"))
			if tmp6.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
			}
			tmp7 := tmp6.Get()
			tmp8 := lang.Apply(tmp7, []any{v3})
			if lang.IsTruthy(tmp8) {
				var tmp9 any
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := reflect.TypeOf((*lang.IObj)(nil)).Elem()
				tmp14 := lang.Apply(tmp12, []any{tmp13, v3})
				if lang.IsTruthy(tmp14) {
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3, nil})
					tmp9 = tmp18
				} else {
					tmp19 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
					tmp9 = tmp19
				}
				tmp4 = tmp9
			} else {
				tmp20 := lang.Apply(lang.CreateLazilyPersistentVector, []any{v3})
				tmp4 = tmp20
			}
			return tmp4
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector
	{
		tmp0 := lang.NewSymbol("vector").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(), lang.NewVector(lang.NewSymbol("a")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e"), lang.NewSymbol("f")), lang.NewVector(lang.NewSymbol("a"), lang.NewSymbol("b"), lang.NewSymbol("c"), lang.NewSymbol("d"), lang.NewSymbol("e"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Creates a new vector containing the args.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(352), lang.NewKeyword("end-line"), int(352))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			case 0:
				tmp3 := lang.NewVector()
				tmp4 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(356), lang.NewKeyword("column"), int(7), lang.NewKeyword("end-line"), int(356), lang.NewKeyword("end-column"), int(8))
				tmp5, err := lang.WithMeta(tmp3, tmp4.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp5
			case 1:
				v3 := args[0]
				_ = v3
				tmp4 := lang.NewVector(v3)
				tmp5 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(357), lang.NewKeyword("column"), int(8), lang.NewKeyword("end-line"), int(357), lang.NewKeyword("end-column"), int(10))
				tmp6, err := lang.WithMeta(tmp4, tmp5.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp6
			case 2:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				tmp5 := lang.NewVector(v3, v4)
				tmp6 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(358), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(358), lang.NewKeyword("end-column"), int(14))
				tmp7, err := lang.WithMeta(tmp5, tmp6.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp7
			case 3:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				tmp6 := lang.NewVector(v3, v4, v5)
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(359), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(359), lang.NewKeyword("end-column"), int(18))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp8
			case 4:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				tmp7 := lang.NewVector(v3, v4, v5, v6)
				tmp8 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(360), lang.NewKeyword("column"), int(14), lang.NewKeyword("end-line"), int(360), lang.NewKeyword("end-column"), int(22))
				tmp9, err := lang.WithMeta(tmp7, tmp8.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp9
			case 5:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				tmp8 := lang.NewVector(v3, v4, v5, v6, v7)
				tmp9 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(361), lang.NewKeyword("column"), int(15), lang.NewKeyword("end-line"), int(361), lang.NewKeyword("end-column"), int(25))
				tmp10, err := lang.WithMeta(tmp8, tmp9.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp10
			case 6:
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				tmp9 := lang.NewVector(v3, v4, v5, v6, v7, v8)
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(362), lang.NewKeyword("column"), int(17), lang.NewKeyword("end-line"), int(362), lang.NewKeyword("end-column"), int(29))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				return tmp11
			default:
				if len(args) < 6 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				v7 := args[4]
				_ = v7
				v8 := args[5]
				_ = v8
				var v9 any = lang.NewList(args[6:]...)
				_ = v9
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("cons"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("cons"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("cons"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("cons"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("cons"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("cons"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{v8, v9})
				tmp29 := lang.Apply(tmp24, []any{v7, tmp28})
				tmp30 := lang.Apply(tmp21, []any{v6, tmp29})
				tmp31 := lang.Apply(tmp18, []any{v5, tmp30})
				tmp32 := lang.Apply(tmp15, []any{v4, tmp31})
				tmp33 := lang.Apply(tmp12, []any{v3, tmp32})
				tmp34 := lang.Apply(lang.CreateLazilyPersistentVector, []any{tmp33})
				return tmp34
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vector?
	{
		tmp0 := lang.NewSymbol("vector?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Return true if x implements IPersistentVector", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(8), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(174), lang.NewKeyword("end-line"), int(178))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function vector?
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				tmp5 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp6 := tmp5.FindInternedVar(lang.NewSymbol("instance?"))
				if tmp6.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp6)))
				}
				tmp7 := tmp6.Get()
				tmp8 := reflect.TypeOf((*lang.IPersistentVector)(nil)).Elem()
				tmp9 := lang.Apply(tmp7, []any{tmp8, v4})
				return tmp9
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(178), lang.NewKeyword("column"), int(10), lang.NewKeyword("end-line"), int(178), lang.NewKeyword("end-column"), int(106))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile!
	{
		tmp1 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp0 := lang.NewSymbol("volatile!").WithMeta(lang.NewMap(lang.NewKeyword("tag"), tmp1, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("val"))), lang.NewKeyword("doc"), "Creates and returns a Volatile with an initial value of val.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2517), lang.NewKeyword("end-line"), int(2517))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5 := lang.Apply(lang.NewVolatile, []any{v4})
			return tmp5
		})
		tmp4 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), tmp4)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// volatile?
	{
		tmp0 := lang.NewSymbol("volatile?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("x"))), lang.NewKeyword("doc"), "Returns true if x is a volatile.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2540), lang.NewKeyword("end-line"), int(2540))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("instance?"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := reflect.TypeOf((*lang.Volatile)(nil)).Elem()
			tmp8 := lang.Apply(tmp6, []any{tmp7, v3})
			return tmp8
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vreset!
	{
		tmp0 := lang.NewSymbol("vreset!").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("vol"), lang.NewSymbol("newval"))), lang.NewKeyword("doc"), "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(2524), lang.NewKeyword("end-line"), int(2524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(v3, "reset")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("reset is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// vswap!
	{
		tmp0 := lang.NewSymbol("vswap!").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("vol"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.7", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(16), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(2531), lang.NewKeyword("end-line"), int(2531))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 4 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				v6 := args[3]
				_ = v6
				var v7 any = lang.NewList(args[4:]...)
				_ = v7
				var tmp8 any
				{ // let
					// let binding "v"
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("with-meta"))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.NewMap(lang.NewKeyword("tag"), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Volatile"))
					tmp13 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(2537), lang.NewKeyword("column"), int(26), lang.NewKeyword("end-line"), int(2537), lang.NewKeyword("end-column"), int(81))
					tmp14, err := lang.WithMeta(tmp12, tmp13.(lang.IPersistentMap))
					if err != nil {
						panic(err)
					}
					tmp15 := lang.Apply(tmp11, []any{v5, tmp14})
					var v16 any = tmp15
					_ = v16
					tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
					if tmp18.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
					}
					tmp19 := tmp18.Get()
					tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp21 := tmp20.FindInternedVar(lang.NewSymbol("concat"))
					if tmp21.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
					}
					tmp22 := tmp21.Get()
					tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp24 := tmp23.FindInternedVar(lang.NewSymbol("list"))
					if tmp24.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
					}
					tmp25 := tmp24.Get()
					tmp26 := lang.Apply(tmp25, []any{lang.NewSymbol(".reset")})
					tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
					if tmp28.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
					}
					tmp29 := tmp28.Get()
					tmp30 := lang.Apply(tmp29, []any{v16})
					tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
					if tmp32.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
					}
					tmp33 := tmp32.Get()
					tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
					if tmp35.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
					}
					tmp36 := tmp35.Get()
					tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
					if tmp38.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
					}
					tmp39 := tmp38.Get()
					tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
					if tmp41.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
					}
					tmp42 := tmp41.Get()
					tmp43 := lang.Apply(tmp42, []any{v6})
					tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
					if tmp45.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
					}
					tmp46 := tmp45.Get()
					tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
					if tmp48.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
					}
					tmp49 := tmp48.Get()
					tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
					if tmp51.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
					}
					tmp52 := tmp51.Get()
					tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
					if tmp54.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
					}
					tmp55 := tmp54.Get()
					tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol(".Deref")})
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v16})
					tmp61 := lang.Apply(tmp52, []any{tmp56, tmp60})
					tmp62 := lang.Apply(tmp49, []any{tmp61})
					tmp63 := lang.Apply(tmp46, []any{tmp62})
					tmp64 := lang.Apply(tmp39, []any{tmp43, tmp63, v7})
					tmp65 := lang.Apply(tmp36, []any{tmp64})
					tmp66 := lang.Apply(tmp33, []any{tmp65})
					tmp67 := lang.Apply(tmp22, []any{tmp26, tmp30, tmp66})
					tmp68 := lang.Apply(tmp19, []any{tmp67})
					tmp8 = tmp68
				} // end let
				return tmp8
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when
	{
		tmp0 := lang.NewSymbol("when").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates test. If logical true, evaluates body in an implicit do.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(14), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(492), lang.NewKeyword("end-line"), int(492))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("list"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("cons"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("do"), v6})
				tmp14 := lang.Apply(tmp9, []any{lang.NewSymbol("if"), v5, tmp13})
				return tmp14
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-first
	{
		tmp0 := lang.NewSymbol("when-first").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4622), lang.NewKeyword("end-line"), int(4622))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "exactly 2 forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "vec__20"
					var v56 any = v5
					_ = v56
					// let binding "x"
					tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp58 := tmp57.FindInternedVar(lang.NewSymbol("nth"))
					if tmp58.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
					}
					tmp59 := tmp58.Get()
					tmp60 := lang.Apply(tmp59, []any{v56, int64(0), nil})
					var v61 any = tmp60
					_ = v61
					// let binding "xs"
					tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp63 := tmp62.FindInternedVar(lang.NewSymbol("nth"))
					if tmp63.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
					}
					tmp64 := tmp63.Get()
					tmp65 := lang.Apply(tmp64, []any{v56, int64(1), nil})
					var v66 any = tmp65
					_ = v66
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("seq"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("concat"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("list"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.Apply(tmp75, []any{lang.NewSymbol("glojure.core/when-let")})
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("list"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp81 := tmp80.FindInternedVar(lang.NewSymbol("apply"))
					if tmp81.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
					}
					tmp82 := tmp81.Get()
					tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp84 := tmp83.FindInternedVar(lang.NewSymbol("vector"))
					if tmp84.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
					}
					tmp85 := tmp84.Get()
					tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp87 := tmp86.FindInternedVar(lang.NewSymbol("seq"))
					if tmp87.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
					}
					tmp88 := tmp87.Get()
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("concat"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp93 := tmp92.FindInternedVar(lang.NewSymbol("list"))
					if tmp93.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
					}
					tmp94 := tmp93.Get()
					tmp95 := lang.Apply(tmp94, []any{lang.NewSymbol("xs__0__auto__")})
					tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp97 := tmp96.FindInternedVar(lang.NewSymbol("list"))
					if tmp97.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
					}
					tmp98 := tmp97.Get()
					tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp100 := tmp99.FindInternedVar(lang.NewSymbol("seq"))
					if tmp100.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
					}
					tmp101 := tmp100.Get()
					tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp103 := tmp102.FindInternedVar(lang.NewSymbol("concat"))
					if tmp103.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
					}
					tmp104 := tmp103.Get()
					tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp106 := tmp105.FindInternedVar(lang.NewSymbol("list"))
					if tmp106.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
					}
					tmp107 := tmp106.Get()
					tmp108 := lang.Apply(tmp107, []any{lang.NewSymbol("glojure.core/seq")})
					tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
					if tmp110.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
					}
					tmp111 := tmp110.Get()
					tmp112 := lang.Apply(tmp111, []any{v66})
					tmp113 := lang.Apply(tmp104, []any{tmp108, tmp112})
					tmp114 := lang.Apply(tmp101, []any{tmp113})
					tmp115 := lang.Apply(tmp98, []any{tmp114})
					tmp116 := lang.Apply(tmp91, []any{tmp95, tmp115})
					tmp117 := lang.Apply(tmp88, []any{tmp116})
					tmp118 := lang.Apply(tmp82, []any{tmp85, tmp117})
					tmp119 := lang.Apply(tmp79, []any{tmp118})
					tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp121 := tmp120.FindInternedVar(lang.NewSymbol("list"))
					if tmp121.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
					}
					tmp122 := tmp121.Get()
					tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp124 := tmp123.FindInternedVar(lang.NewSymbol("seq"))
					if tmp124.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
					}
					tmp125 := tmp124.Get()
					tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp127 := tmp126.FindInternedVar(lang.NewSymbol("concat"))
					if tmp127.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
					}
					tmp128 := tmp127.Get()
					tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp130 := tmp129.FindInternedVar(lang.NewSymbol("list"))
					if tmp130.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
					}
					tmp131 := tmp130.Get()
					tmp132 := lang.Apply(tmp131, []any{lang.NewSymbol("glojure.core/let")})
					tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp134 := tmp133.FindInternedVar(lang.NewSymbol("list"))
					if tmp134.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
					}
					tmp135 := tmp134.Get()
					tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp137 := tmp136.FindInternedVar(lang.NewSymbol("apply"))
					if tmp137.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
					}
					tmp138 := tmp137.Get()
					tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp140 := tmp139.FindInternedVar(lang.NewSymbol("vector"))
					if tmp140.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
					}
					tmp141 := tmp140.Get()
					tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp143 := tmp142.FindInternedVar(lang.NewSymbol("seq"))
					if tmp143.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
					}
					tmp144 := tmp143.Get()
					tmp145 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp146 := tmp145.FindInternedVar(lang.NewSymbol("concat"))
					if tmp146.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp146)))
					}
					tmp147 := tmp146.Get()
					tmp148 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp149 := tmp148.FindInternedVar(lang.NewSymbol("list"))
					if tmp149.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp149)))
					}
					tmp150 := tmp149.Get()
					tmp151 := lang.Apply(tmp150, []any{v61})
					tmp152 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp153 := tmp152.FindInternedVar(lang.NewSymbol("list"))
					if tmp153.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp153)))
					}
					tmp154 := tmp153.Get()
					tmp155 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp156 := tmp155.FindInternedVar(lang.NewSymbol("seq"))
					if tmp156.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp156)))
					}
					tmp157 := tmp156.Get()
					tmp158 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp159 := tmp158.FindInternedVar(lang.NewSymbol("concat"))
					if tmp159.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp159)))
					}
					tmp160 := tmp159.Get()
					tmp161 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp162 := tmp161.FindInternedVar(lang.NewSymbol("list"))
					if tmp162.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp162)))
					}
					tmp163 := tmp162.Get()
					tmp164 := lang.Apply(tmp163, []any{lang.NewSymbol("glojure.core/first")})
					tmp165 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp166 := tmp165.FindInternedVar(lang.NewSymbol("list"))
					if tmp166.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp166)))
					}
					tmp167 := tmp166.Get()
					tmp168 := lang.Apply(tmp167, []any{lang.NewSymbol("xs__0__auto__")})
					tmp169 := lang.Apply(tmp160, []any{tmp164, tmp168})
					tmp170 := lang.Apply(tmp157, []any{tmp169})
					tmp171 := lang.Apply(tmp154, []any{tmp170})
					tmp172 := lang.Apply(tmp147, []any{tmp151, tmp171})
					tmp173 := lang.Apply(tmp144, []any{tmp172})
					tmp174 := lang.Apply(tmp138, []any{tmp141, tmp173})
					tmp175 := lang.Apply(tmp135, []any{tmp174})
					tmp176 := lang.Apply(tmp128, []any{tmp132, tmp175, v6})
					tmp177 := lang.Apply(tmp125, []any{tmp176})
					tmp178 := lang.Apply(tmp122, []any{tmp177})
					tmp179 := lang.Apply(tmp72, []any{tmp76, tmp119, tmp178})
					tmp180 := lang.Apply(tmp69, []any{tmp179})
					tmp55 = tmp180
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-let
	{
		tmp0 := lang.NewSymbol("when-let").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1859), lang.NewKeyword("end-line"), int(1859))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "exactly 2 forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "form"
					tmp56 := lang.Apply(v5, []any{int64(0)})
					var v57 any = tmp56
					_ = v57
					// let binding "tst"
					tmp58 := lang.Apply(v5, []any{int64(1)})
					var v59 any = tmp58
					_ = v59
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("concat"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/let")})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("apply"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("vector"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("seq"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp83 := tmp82.FindInternedVar(lang.NewSymbol("concat"))
					if tmp83.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
					}
					tmp84 := tmp83.Get()
					tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp86 := tmp85.FindInternedVar(lang.NewSymbol("list"))
					if tmp86.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
					}
					tmp87 := tmp86.Get()
					tmp88 := lang.Apply(tmp87, []any{lang.NewSymbol("temp__0__auto__")})
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.Apply(tmp91, []any{v59})
					tmp93 := lang.Apply(tmp84, []any{tmp88, tmp92})
					tmp94 := lang.Apply(tmp81, []any{tmp93})
					tmp95 := lang.Apply(tmp75, []any{tmp78, tmp94})
					tmp96 := lang.Apply(tmp72, []any{tmp95})
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("seq"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("concat"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.Apply(tmp108, []any{lang.NewSymbol("glojure.core/when")})
					tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp111 := tmp110.FindInternedVar(lang.NewSymbol("list"))
					if tmp111.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
					}
					tmp112 := tmp111.Get()
					tmp113 := lang.Apply(tmp112, []any{lang.NewSymbol("temp__0__auto__")})
					tmp114 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp115 := tmp114.FindInternedVar(lang.NewSymbol("list"))
					if tmp115.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp115)))
					}
					tmp116 := tmp115.Get()
					tmp117 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp118 := tmp117.FindInternedVar(lang.NewSymbol("seq"))
					if tmp118.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp118)))
					}
					tmp119 := tmp118.Get()
					tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp121 := tmp120.FindInternedVar(lang.NewSymbol("concat"))
					if tmp121.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
					}
					tmp122 := tmp121.Get()
					tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp124 := tmp123.FindInternedVar(lang.NewSymbol("list"))
					if tmp124.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
					}
					tmp125 := tmp124.Get()
					tmp126 := lang.Apply(tmp125, []any{lang.NewSymbol("glojure.core/let")})
					tmp127 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp128 := tmp127.FindInternedVar(lang.NewSymbol("list"))
					if tmp128.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp128)))
					}
					tmp129 := tmp128.Get()
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("apply"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp134 := tmp133.FindInternedVar(lang.NewSymbol("vector"))
					if tmp134.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp134)))
					}
					tmp135 := tmp134.Get()
					tmp136 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp137 := tmp136.FindInternedVar(lang.NewSymbol("seq"))
					if tmp137.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp137)))
					}
					tmp138 := tmp137.Get()
					tmp139 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp140 := tmp139.FindInternedVar(lang.NewSymbol("concat"))
					if tmp140.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp140)))
					}
					tmp141 := tmp140.Get()
					tmp142 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp143 := tmp142.FindInternedVar(lang.NewSymbol("list"))
					if tmp143.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp143)))
					}
					tmp144 := tmp143.Get()
					tmp145 := lang.Apply(tmp144, []any{v57})
					tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
					if tmp147.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
					}
					tmp148 := tmp147.Get()
					tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("temp__0__auto__")})
					tmp150 := lang.Apply(tmp141, []any{tmp145, tmp149})
					tmp151 := lang.Apply(tmp138, []any{tmp150})
					tmp152 := lang.Apply(tmp132, []any{tmp135, tmp151})
					tmp153 := lang.Apply(tmp129, []any{tmp152})
					tmp154 := lang.Apply(tmp122, []any{tmp126, tmp153, v6})
					tmp155 := lang.Apply(tmp119, []any{tmp154})
					tmp156 := lang.Apply(tmp116, []any{tmp155})
					tmp157 := lang.Apply(tmp105, []any{tmp109, tmp113, tmp156})
					tmp158 := lang.Apply(tmp102, []any{tmp157})
					tmp159 := lang.Apply(tmp99, []any{tmp158})
					tmp160 := lang.Apply(tmp65, []any{tmp69, tmp96, tmp159})
					tmp161 := lang.Apply(tmp62, []any{tmp160})
					tmp55 = tmp161
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-not
	{
		tmp0 := lang.NewSymbol("when-not").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates test. If logical false, evaluates body in an implicit do.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(18), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(498), lang.NewKeyword("end-line"), int(498))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("list"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("cons"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol("do"), v6})
				tmp14 := lang.Apply(tmp9, []any{lang.NewSymbol("if"), v5, nil, tmp13})
				return tmp14
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// when-some
	{
		tmp0 := lang.NewSymbol("when-some").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.6", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1894), lang.NewKeyword("end-line"), int(1894))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("="))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{int64(2), tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "exactly 2 forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				{ // let
					// let binding "form"
					tmp56 := lang.Apply(v5, []any{int64(0)})
					var v57 any = tmp56
					_ = v57
					// let binding "tst"
					tmp58 := lang.Apply(v5, []any{int64(1)})
					var v59 any = tmp58
					_ = v59
					tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp61 := tmp60.FindInternedVar(lang.NewSymbol("seq"))
					if tmp61.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
					}
					tmp62 := tmp61.Get()
					tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp64 := tmp63.FindInternedVar(lang.NewSymbol("concat"))
					if tmp64.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
					}
					tmp65 := tmp64.Get()
					tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp67 := tmp66.FindInternedVar(lang.NewSymbol("list"))
					if tmp67.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
					}
					tmp68 := tmp67.Get()
					tmp69 := lang.Apply(tmp68, []any{lang.NewSymbol("glojure.core/let")})
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("apply"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp77 := tmp76.FindInternedVar(lang.NewSymbol("vector"))
					if tmp77.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp77)))
					}
					tmp78 := tmp77.Get()
					tmp79 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp80 := tmp79.FindInternedVar(lang.NewSymbol("seq"))
					if tmp80.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp80)))
					}
					tmp81 := tmp80.Get()
					tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp83 := tmp82.FindInternedVar(lang.NewSymbol("concat"))
					if tmp83.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
					}
					tmp84 := tmp83.Get()
					tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp86 := tmp85.FindInternedVar(lang.NewSymbol("list"))
					if tmp86.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
					}
					tmp87 := tmp86.Get()
					tmp88 := lang.Apply(tmp87, []any{lang.NewSymbol("temp__0__auto__")})
					tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
					if tmp90.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
					}
					tmp91 := tmp90.Get()
					tmp92 := lang.Apply(tmp91, []any{v59})
					tmp93 := lang.Apply(tmp84, []any{tmp88, tmp92})
					tmp94 := lang.Apply(tmp81, []any{tmp93})
					tmp95 := lang.Apply(tmp75, []any{tmp78, tmp94})
					tmp96 := lang.Apply(tmp72, []any{tmp95})
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("list"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("seq"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("concat"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp107 := tmp106.FindInternedVar(lang.NewSymbol("list"))
					if tmp107.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
					}
					tmp108 := tmp107.Get()
					tmp109 := lang.Apply(tmp108, []any{lang.NewSymbol("if")})
					tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp111 := tmp110.FindInternedVar(lang.NewSymbol("list"))
					if tmp111.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
					}
					tmp112 := tmp111.Get()
					tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp114 := tmp113.FindInternedVar(lang.NewSymbol("seq"))
					if tmp114.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
					}
					tmp115 := tmp114.Get()
					tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp117 := tmp116.FindInternedVar(lang.NewSymbol("concat"))
					if tmp117.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
					}
					tmp118 := tmp117.Get()
					tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp120 := tmp119.FindInternedVar(lang.NewSymbol("list"))
					if tmp120.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
					}
					tmp121 := tmp120.Get()
					tmp122 := lang.Apply(tmp121, []any{lang.NewSymbol("glojure.core/nil?")})
					tmp123 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp124 := tmp123.FindInternedVar(lang.NewSymbol("list"))
					if tmp124.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp124)))
					}
					tmp125 := tmp124.Get()
					tmp126 := lang.Apply(tmp125, []any{lang.NewSymbol("temp__0__auto__")})
					tmp127 := lang.Apply(tmp118, []any{tmp122, tmp126})
					tmp128 := lang.Apply(tmp115, []any{tmp127})
					tmp129 := lang.Apply(tmp112, []any{tmp128})
					tmp130 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp131 := tmp130.FindInternedVar(lang.NewSymbol("list"))
					if tmp131.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp131)))
					}
					tmp132 := tmp131.Get()
					tmp133 := lang.Apply(tmp132, []any{nil})
					tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp135 := tmp134.FindInternedVar(lang.NewSymbol("list"))
					if tmp135.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
					}
					tmp136 := tmp135.Get()
					tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp138 := tmp137.FindInternedVar(lang.NewSymbol("seq"))
					if tmp138.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
					}
					tmp139 := tmp138.Get()
					tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp141 := tmp140.FindInternedVar(lang.NewSymbol("concat"))
					if tmp141.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
					}
					tmp142 := tmp141.Get()
					tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp144 := tmp143.FindInternedVar(lang.NewSymbol("list"))
					if tmp144.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
					}
					tmp145 := tmp144.Get()
					tmp146 := lang.Apply(tmp145, []any{lang.NewSymbol("glojure.core/let")})
					tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp148 := tmp147.FindInternedVar(lang.NewSymbol("list"))
					if tmp148.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
					}
					tmp149 := tmp148.Get()
					tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp151 := tmp150.FindInternedVar(lang.NewSymbol("apply"))
					if tmp151.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
					}
					tmp152 := tmp151.Get()
					tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp154 := tmp153.FindInternedVar(lang.NewSymbol("vector"))
					if tmp154.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
					}
					tmp155 := tmp154.Get()
					tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp157 := tmp156.FindInternedVar(lang.NewSymbol("seq"))
					if tmp157.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
					}
					tmp158 := tmp157.Get()
					tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp160 := tmp159.FindInternedVar(lang.NewSymbol("concat"))
					if tmp160.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
					}
					tmp161 := tmp160.Get()
					tmp162 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp163 := tmp162.FindInternedVar(lang.NewSymbol("list"))
					if tmp163.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp163)))
					}
					tmp164 := tmp163.Get()
					tmp165 := lang.Apply(tmp164, []any{v57})
					tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp167 := tmp166.FindInternedVar(lang.NewSymbol("list"))
					if tmp167.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
					}
					tmp168 := tmp167.Get()
					tmp169 := lang.Apply(tmp168, []any{lang.NewSymbol("temp__0__auto__")})
					tmp170 := lang.Apply(tmp161, []any{tmp165, tmp169})
					tmp171 := lang.Apply(tmp158, []any{tmp170})
					tmp172 := lang.Apply(tmp152, []any{tmp155, tmp171})
					tmp173 := lang.Apply(tmp149, []any{tmp172})
					tmp174 := lang.Apply(tmp142, []any{tmp146, tmp173, v6})
					tmp175 := lang.Apply(tmp139, []any{tmp174})
					tmp176 := lang.Apply(tmp136, []any{tmp175})
					tmp177 := lang.Apply(tmp105, []any{tmp109, tmp129, tmp133, tmp176})
					tmp178 := lang.Apply(tmp102, []any{tmp177})
					tmp179 := lang.Apply(tmp99, []any{tmp178})
					tmp180 := lang.Apply(tmp65, []any{tmp69, tmp96, tmp179})
					tmp181 := lang.Apply(tmp62, []any{tmp180})
					tmp55 = tmp181
				} // end let
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// while
	{
		tmp0 := lang.NewSymbol("while").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("test"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(15), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(6327), lang.NewKeyword("end-line"), int(6327))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/loop")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp31, nil)
				tmp33 := lang.Apply(tmp28, []any{tmp32})
				tmp34 := lang.Apply(tmp22, []any{tmp25, tmp33})
				tmp35 := lang.Apply(tmp19, []any{tmp34})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq"))
				if tmp40.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
				}
				tmp41 := tmp40.Get()
				tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp43 := tmp42.FindInternedVar(lang.NewSymbol("concat"))
				if tmp43.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
				}
				tmp44 := tmp43.Get()
				tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
				if tmp46.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
				}
				tmp47 := tmp46.Get()
				tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("glojure.core/when")})
				tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp50 := tmp49.FindInternedVar(lang.NewSymbol("list"))
				if tmp50.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
				}
				tmp51 := tmp50.Get()
				tmp52 := lang.Apply(tmp51, []any{v5})
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp57 := tmp56.FindInternedVar(lang.NewSymbol("seq"))
				if tmp57.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
				}
				tmp58 := tmp57.Get()
				tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp60 := tmp59.FindInternedVar(lang.NewSymbol("concat"))
				if tmp60.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
				}
				tmp61 := tmp60.Get()
				tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp63 := tmp62.FindInternedVar(lang.NewSymbol("list"))
				if tmp63.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
				}
				tmp64 := tmp63.Get()
				tmp65 := lang.Apply(tmp64, []any{lang.NewSymbol("recur")})
				tmp66 := lang.Apply(tmp61, []any{tmp65})
				tmp67 := lang.Apply(tmp58, []any{tmp66})
				tmp68 := lang.Apply(tmp55, []any{tmp67})
				tmp69 := lang.Apply(tmp44, []any{tmp48, tmp52, v6, tmp68})
				tmp70 := lang.Apply(tmp41, []any{tmp69})
				tmp71 := lang.Apply(tmp38, []any{tmp70})
				tmp72 := lang.Apply(tmp12, []any{tmp16, tmp35, tmp71})
				tmp73 := lang.Apply(tmp9, []any{tmp72})
				return tmp73
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings
	{
		tmp0 := lang.NewSymbol("with-bindings").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(23), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(1984), lang.NewKeyword("end-line"), int(1984))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/with-bindings*")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.Apply(tmp19, []any{v5})
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("concat"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("list"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.Apply(tmp32, []any{lang.NewSymbol("glojure.core/fn")})
				tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp35 := tmp34.FindInternedVar(lang.NewSymbol("list"))
				if tmp35.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
				}
				tmp36 := tmp35.Get()
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("apply"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp41 := tmp40.FindInternedVar(lang.NewSymbol("vector"))
				if tmp41.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
				}
				tmp42 := tmp41.Get()
				tmp43 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp44 := tmp43.FindInternedVar(lang.NewSymbol("seq"))
				if tmp44.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp44)))
				}
				tmp45 := tmp44.Get()
				tmp46 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp47 := tmp46.FindInternedVar(lang.NewSymbol("concat"))
				if tmp47.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp47)))
				}
				tmp48 := tmp47.Get()
				tmp49 := lang.Apply(tmp48, nil)
				tmp50 := lang.Apply(tmp45, []any{tmp49})
				tmp51 := lang.Apply(tmp39, []any{tmp42, tmp50})
				tmp52 := lang.Apply(tmp36, []any{tmp51})
				tmp53 := lang.Apply(tmp29, []any{tmp33, tmp52, v6})
				tmp54 := lang.Apply(tmp26, []any{tmp53})
				tmp55 := lang.Apply(tmp23, []any{tmp54})
				tmp56 := lang.Apply(tmp12, []any{tmp16, tmp20, tmp55})
				tmp57 := lang.Apply(tmp9, []any{tmp56})
				return tmp57
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-bindings*
	{
		tmp0 := lang.NewSymbol("with-bindings*").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("f"), lang.NewSymbol("&"), lang.NewSymbol("args"))), lang.NewKeyword("doc"), "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.1", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(1971), lang.NewKeyword("end-line"), int(1971))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("push-thread-bindings"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.Apply(tmp8, []any{v3})
				_ = tmp9
				var tmp10 any
				func() {
					defer func() {
						tmp11 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp12 := tmp11.FindInternedVar(lang.NewSymbol("pop-thread-bindings"))
						if tmp12.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp12)))
						}
						tmp13 := tmp12.Get()
						tmp14 := lang.Apply(tmp13, nil)
						_ = tmp14
					}()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("apply"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v4, v5})
					tmp10 = tmp18
				}()
				return tmp10
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-in-str
	{
		tmp0 := lang.NewSymbol("with-in-str").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("s"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4749), lang.NewKeyword("end-line"), int(4749))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/with-open")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("apply"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("vector"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp27 := tmp26.FindInternedVar(lang.NewSymbol("seq"))
				if tmp27.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
				}
				tmp28 := tmp27.Get()
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("concat"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("list"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.Apply(tmp34, []any{lang.NewSymbol("s__0__auto__")})
				tmp36 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp37 := tmp36.FindInternedVar(lang.NewSymbol("list"))
				if tmp37.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp37)))
				}
				tmp38 := tmp37.Get()
				tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp40 := tmp39.FindInternedVar(lang.NewSymbol("seq"))
				if tmp40.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
				}
				tmp41 := tmp40.Get()
				tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp43 := tmp42.FindInternedVar(lang.NewSymbol("concat"))
				if tmp43.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
				}
				tmp44 := tmp43.Get()
				tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp46 := tmp45.FindInternedVar(lang.NewSymbol("list"))
				if tmp46.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
				}
				tmp47 := tmp46.Get()
				tmp48 := lang.Apply(tmp47, []any{lang.NewSymbol("glojure.core/->")})
				tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp50 := tmp49.FindInternedVar(lang.NewSymbol("list"))
				if tmp50.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
				}
				tmp51 := tmp50.Get()
				tmp52 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp53 := tmp52.FindInternedVar(lang.NewSymbol("seq"))
				if tmp53.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp53)))
				}
				tmp54 := tmp53.Get()
				tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp56 := tmp55.FindInternedVar(lang.NewSymbol("concat"))
				if tmp56.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
				}
				tmp57 := tmp56.Get()
				tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp59 := tmp58.FindInternedVar(lang.NewSymbol("list"))
				if tmp59.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
				}
				tmp60 := tmp59.Get()
				tmp61 := lang.Apply(tmp60, []any{lang.NewSymbol("java.io.StringReader.")})
				tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp63 := tmp62.FindInternedVar(lang.NewSymbol("list"))
				if tmp63.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
				}
				tmp64 := tmp63.Get()
				tmp65 := lang.Apply(tmp64, []any{v5})
				tmp66 := lang.Apply(tmp57, []any{tmp61, tmp65})
				tmp67 := lang.Apply(tmp54, []any{tmp66})
				tmp68 := lang.Apply(tmp51, []any{tmp67})
				tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp70 := tmp69.FindInternedVar(lang.NewSymbol("list"))
				if tmp70.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
				}
				tmp71 := tmp70.Get()
				tmp72 := lang.Apply(tmp71, []any{lang.NewSymbol("glojure.lang.LineNumberingPushbackReader.")})
				tmp73 := lang.Apply(tmp44, []any{tmp48, tmp68, tmp72})
				tmp74 := lang.Apply(tmp41, []any{tmp73})
				tmp75 := lang.Apply(tmp38, []any{tmp74})
				tmp76 := lang.Apply(tmp31, []any{tmp35, tmp75})
				tmp77 := lang.Apply(tmp28, []any{tmp76})
				tmp78 := lang.Apply(tmp22, []any{tmp25, tmp77})
				tmp79 := lang.Apply(tmp19, []any{tmp78})
				tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp81 := tmp80.FindInternedVar(lang.NewSymbol("list"))
				if tmp81.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
				}
				tmp82 := tmp81.Get()
				tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp84 := tmp83.FindInternedVar(lang.NewSymbol("seq"))
				if tmp84.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
				}
				tmp85 := tmp84.Get()
				tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp87 := tmp86.FindInternedVar(lang.NewSymbol("concat"))
				if tmp87.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
				}
				tmp88 := tmp87.Get()
				tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp90 := tmp89.FindInternedVar(lang.NewSymbol("list"))
				if tmp90.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
				}
				tmp91 := tmp90.Get()
				tmp92 := lang.Apply(tmp91, []any{lang.NewSymbol("glojure.core/binding")})
				tmp93 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp94 := tmp93.FindInternedVar(lang.NewSymbol("list"))
				if tmp94.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp94)))
				}
				tmp95 := tmp94.Get()
				tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp97 := tmp96.FindInternedVar(lang.NewSymbol("apply"))
				if tmp97.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
				}
				tmp98 := tmp97.Get()
				tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp100 := tmp99.FindInternedVar(lang.NewSymbol("vector"))
				if tmp100.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
				}
				tmp101 := tmp100.Get()
				tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp103 := tmp102.FindInternedVar(lang.NewSymbol("seq"))
				if tmp103.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
				}
				tmp104 := tmp103.Get()
				tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp106 := tmp105.FindInternedVar(lang.NewSymbol("concat"))
				if tmp106.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
				}
				tmp107 := tmp106.Get()
				tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp109 := tmp108.FindInternedVar(lang.NewSymbol("list"))
				if tmp109.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
				}
				tmp110 := tmp109.Get()
				tmp111 := lang.Apply(tmp110, []any{lang.NewSymbol("glojure.core/*in*")})
				tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp113 := tmp112.FindInternedVar(lang.NewSymbol("list"))
				if tmp113.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
				}
				tmp114 := tmp113.Get()
				tmp115 := lang.Apply(tmp114, []any{lang.NewSymbol("s__0__auto__")})
				tmp116 := lang.Apply(tmp107, []any{tmp111, tmp115})
				tmp117 := lang.Apply(tmp104, []any{tmp116})
				tmp118 := lang.Apply(tmp98, []any{tmp101, tmp117})
				tmp119 := lang.Apply(tmp95, []any{tmp118})
				tmp120 := lang.Apply(tmp88, []any{tmp92, tmp119, v6})
				tmp121 := lang.Apply(tmp85, []any{tmp120})
				tmp122 := lang.Apply(tmp82, []any{tmp121})
				tmp123 := lang.Apply(tmp12, []any{tmp16, tmp79, tmp122})
				tmp124 := lang.Apply(tmp9, []any{tmp123})
				return tmp124
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-loading-context
	{
		tmp0 := lang.NewSymbol("with-loading-context").WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5734), lang.NewKeyword("column"), int(11), lang.NewKeyword("end-line"), int(5734), lang.NewKeyword("end-column"), int(30), lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("macro"), true)).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp16 := tmp15.FindInternedVar(lang.NewSymbol("seq"))
				if tmp16.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
				}
				tmp17 := tmp16.Get()
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("concat"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("list"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.Apply(tmp23, []any{lang.NewSymbol("glojure.core/fn")})
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("list"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.Apply(tmp27, []any{lang.NewSymbol("loading__0__auto__")})
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("list"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp33 := tmp32.FindInternedVar(lang.NewSymbol("apply"))
				if tmp33.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp33)))
				}
				tmp34 := tmp33.Get()
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("vector"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
				if tmp39.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
				}
				tmp40 := tmp39.Get()
				tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
				if tmp42.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
				}
				tmp43 := tmp42.Get()
				tmp44 := lang.Apply(tmp43, nil)
				tmp45 := lang.Apply(tmp40, []any{tmp44})
				tmp46 := lang.Apply(tmp34, []any{tmp37, tmp45})
				tmp47 := lang.Apply(tmp31, []any{tmp46})
				tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
				if tmp49.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
				}
				tmp50 := tmp49.Get()
				tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp52 := tmp51.FindInternedVar(lang.NewSymbol("seq"))
				if tmp52.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
				}
				tmp53 := tmp52.Get()
				tmp54 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp55 := tmp54.FindInternedVar(lang.NewSymbol("concat"))
				if tmp55.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp55)))
				}
				tmp56 := tmp55.Get()
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.Apply(tmp59, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")})
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp65 := tmp64.FindInternedVar(lang.NewSymbol("apply"))
				if tmp65.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
				}
				tmp66 := tmp65.Get()
				tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp68 := tmp67.FindInternedVar(lang.NewSymbol("hash-map"))
				if tmp68.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
				}
				tmp69 := tmp68.Get()
				tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp71 := tmp70.FindInternedVar(lang.NewSymbol("seq"))
				if tmp71.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
				}
				tmp72 := tmp71.Get()
				tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp74 := tmp73.FindInternedVar(lang.NewSymbol("concat"))
				if tmp74.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
				}
				tmp75 := tmp74.Get()
				tmp76 := lang.Apply(tmp75, nil)
				tmp77 := lang.Apply(tmp72, []any{tmp76})
				tmp78 := lang.Apply(tmp66, []any{tmp69, tmp77})
				tmp79 := lang.Apply(tmp63, []any{tmp78})
				tmp80 := lang.Apply(tmp56, []any{tmp60, tmp79})
				tmp81 := lang.Apply(tmp53, []any{tmp80})
				tmp82 := lang.Apply(tmp50, []any{tmp81})
				tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp84 := tmp83.FindInternedVar(lang.NewSymbol("list"))
				if tmp84.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
				}
				tmp85 := tmp84.Get()
				tmp86 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp87 := tmp86.FindInternedVar(lang.NewSymbol("seq"))
				if tmp87.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp87)))
				}
				tmp88 := tmp87.Get()
				tmp89 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp90 := tmp89.FindInternedVar(lang.NewSymbol("concat"))
				if tmp90.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp90)))
				}
				tmp91 := tmp90.Get()
				tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp93 := tmp92.FindInternedVar(lang.NewSymbol("list"))
				if tmp93.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
				}
				tmp94 := tmp93.Get()
				tmp95 := lang.Apply(tmp94, []any{lang.NewSymbol("try")})
				tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp97 := tmp96.FindInternedVar(lang.NewSymbol("list"))
				if tmp97.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
				}
				tmp98 := tmp97.Get()
				tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp100 := tmp99.FindInternedVar(lang.NewSymbol("seq"))
				if tmp100.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
				}
				tmp101 := tmp100.Get()
				tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp103 := tmp102.FindInternedVar(lang.NewSymbol("concat"))
				if tmp103.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
				}
				tmp104 := tmp103.Get()
				tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp106 := tmp105.FindInternedVar(lang.NewSymbol("list"))
				if tmp106.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
				}
				tmp107 := tmp106.Get()
				tmp108 := lang.Apply(tmp107, []any{lang.NewSymbol("finally")})
				tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
				if tmp110.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
				}
				tmp111 := tmp110.Get()
				tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp113 := tmp112.FindInternedVar(lang.NewSymbol("seq"))
				if tmp113.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
				}
				tmp114 := tmp113.Get()
				tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp116 := tmp115.FindInternedVar(lang.NewSymbol("concat"))
				if tmp116.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
				}
				tmp117 := tmp116.Get()
				tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp119 := tmp118.FindInternedVar(lang.NewSymbol("list"))
				if tmp119.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
				}
				tmp120 := tmp119.Get()
				tmp121 := lang.Apply(tmp120, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")})
				tmp122 := lang.Apply(tmp117, []any{tmp121})
				tmp123 := lang.Apply(tmp114, []any{tmp122})
				tmp124 := lang.Apply(tmp111, []any{tmp123})
				tmp125 := lang.Apply(tmp104, []any{tmp108, tmp124})
				tmp126 := lang.Apply(tmp101, []any{tmp125})
				tmp127 := lang.Apply(tmp98, []any{tmp126})
				tmp128 := lang.Apply(tmp91, []any{tmp95, v5, tmp127})
				tmp129 := lang.Apply(tmp88, []any{tmp128})
				tmp130 := lang.Apply(tmp85, []any{tmp129})
				tmp131 := lang.Apply(tmp20, []any{tmp24, tmp28, tmp47, tmp82, tmp130})
				tmp132 := lang.Apply(tmp17, []any{tmp131})
				tmp133 := lang.Apply(tmp14, []any{tmp132})
				tmp134 := lang.Apply(tmp11, []any{tmp133})
				tmp135 := lang.Apply(tmp8, []any{tmp134})
				return tmp135
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-local-vars
	{
		tmp0 := lang.NewSymbol("with-local-vars").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("name-vals-vec"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(25), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4339), lang.NewKeyword("end-line"), int(4339))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				tmp55 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp56 := tmp55.FindInternedVar(lang.NewSymbol("seq"))
				if tmp56.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp56)))
				}
				tmp57 := tmp56.Get()
				tmp58 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp59 := tmp58.FindInternedVar(lang.NewSymbol("concat"))
				if tmp59.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp59)))
				}
				tmp60 := tmp59.Get()
				tmp61 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp62 := tmp61.FindInternedVar(lang.NewSymbol("list"))
				if tmp62.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp62)))
				}
				tmp63 := tmp62.Get()
				tmp64 := lang.Apply(tmp63, []any{lang.NewSymbol("glojure.core/let")})
				tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp66 := tmp65.FindInternedVar(lang.NewSymbol("list"))
				if tmp66.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
				}
				tmp67 := tmp66.Get()
				tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp69 := tmp68.FindInternedVar(lang.NewSymbol("apply"))
				if tmp69.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
				}
				tmp70 := tmp69.Get()
				tmp71 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp72 := tmp71.FindInternedVar(lang.NewSymbol("vector"))
				if tmp72.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp72)))
				}
				tmp73 := tmp72.Get()
				tmp74 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp75 := tmp74.FindInternedVar(lang.NewSymbol("seq"))
				if tmp75.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp75)))
				}
				tmp76 := tmp75.Get()
				tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp78 := tmp77.FindInternedVar(lang.NewSymbol("concat"))
				if tmp78.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
				}
				tmp79 := tmp78.Get()
				tmp80 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp81 := tmp80.FindInternedVar(lang.NewSymbol("interleave"))
				if tmp81.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp81)))
				}
				tmp82 := tmp81.Get()
				tmp83 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp84 := tmp83.FindInternedVar(lang.NewSymbol("take-nth"))
				if tmp84.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp84)))
				}
				tmp85 := tmp84.Get()
				tmp86 := lang.Apply(tmp85, []any{int64(2), v5})
				tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp88 := tmp87.FindInternedVar(lang.NewSymbol("repeat"))
				if tmp88.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
				}
				tmp89 := tmp88.Get()
				tmp90 := lang.Apply(tmp89, []any{lang.NewList(lang.NewSymbol(".."), lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.*Var"), lang.NewSymbol("create"), lang.NewSymbol("setDynamic"))})
				tmp91 := lang.Apply(tmp82, []any{tmp86, tmp90})
				tmp92 := lang.Apply(tmp79, []any{tmp91})
				tmp93 := lang.Apply(tmp76, []any{tmp92})
				tmp94 := lang.Apply(tmp70, []any{tmp73, tmp93})
				tmp95 := lang.Apply(tmp67, []any{tmp94})
				tmp96 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp97 := tmp96.FindInternedVar(lang.NewSymbol("list"))
				if tmp97.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp97)))
				}
				tmp98 := tmp97.Get()
				tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp100 := tmp99.FindInternedVar(lang.NewSymbol("seq"))
				if tmp100.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
				}
				tmp101 := tmp100.Get()
				tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp103 := tmp102.FindInternedVar(lang.NewSymbol("concat"))
				if tmp103.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
				}
				tmp104 := tmp103.Get()
				tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp106 := tmp105.FindInternedVar(lang.NewSymbol("list"))
				if tmp106.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
				}
				tmp107 := tmp106.Get()
				tmp108 := lang.Apply(tmp107, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PushThreadBindings")})
				tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
				if tmp110.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
				}
				tmp111 := tmp110.Get()
				tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp113 := tmp112.FindInternedVar(lang.NewSymbol("apply"))
				if tmp113.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
				}
				tmp114 := tmp113.Get()
				tmp115 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp116 := tmp115.FindInternedVar(lang.NewSymbol("hash-map"))
				if tmp116.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp116)))
				}
				tmp117 := tmp116.Get()
				tmp118 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp119 := tmp118.FindInternedVar(lang.NewSymbol("seq"))
				if tmp119.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp119)))
				}
				tmp120 := tmp119.Get()
				tmp121 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp122 := tmp121.FindInternedVar(lang.NewSymbol("concat"))
				if tmp122.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp122)))
				}
				tmp123 := tmp122.Get()
				tmp124 := lang.Apply(tmp123, nil)
				tmp125 := lang.Apply(tmp120, []any{tmp124})
				tmp126 := lang.Apply(tmp114, []any{tmp117, tmp125})
				tmp127 := lang.Apply(tmp111, []any{tmp126})
				tmp128 := lang.Apply(tmp104, []any{tmp108, tmp127})
				tmp129 := lang.Apply(tmp101, []any{tmp128})
				tmp130 := lang.Apply(tmp98, []any{tmp129})
				tmp131 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp132 := tmp131.FindInternedVar(lang.NewSymbol("list"))
				if tmp132.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp132)))
				}
				tmp133 := tmp132.Get()
				tmp134 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp135 := tmp134.FindInternedVar(lang.NewSymbol("seq"))
				if tmp135.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp135)))
				}
				tmp136 := tmp135.Get()
				tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp138 := tmp137.FindInternedVar(lang.NewSymbol("concat"))
				if tmp138.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
				}
				tmp139 := tmp138.Get()
				tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp141 := tmp140.FindInternedVar(lang.NewSymbol("list"))
				if tmp141.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
				}
				tmp142 := tmp141.Get()
				tmp143 := lang.Apply(tmp142, []any{lang.NewSymbol("try")})
				tmp144 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp145 := tmp144.FindInternedVar(lang.NewSymbol("list"))
				if tmp145.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp145)))
				}
				tmp146 := tmp145.Get()
				tmp147 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp148 := tmp147.FindInternedVar(lang.NewSymbol("seq"))
				if tmp148.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp148)))
				}
				tmp149 := tmp148.Get()
				tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp151 := tmp150.FindInternedVar(lang.NewSymbol("concat"))
				if tmp151.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
				}
				tmp152 := tmp151.Get()
				tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp154 := tmp153.FindInternedVar(lang.NewSymbol("list"))
				if tmp154.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
				}
				tmp155 := tmp154.Get()
				tmp156 := lang.Apply(tmp155, []any{lang.NewSymbol("finally")})
				tmp157 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp158 := tmp157.FindInternedVar(lang.NewSymbol("list"))
				if tmp158.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp158)))
				}
				tmp159 := tmp158.Get()
				tmp160 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp161 := tmp160.FindInternedVar(lang.NewSymbol("seq"))
				if tmp161.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp161)))
				}
				tmp162 := tmp161.Get()
				tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp164 := tmp163.FindInternedVar(lang.NewSymbol("concat"))
				if tmp164.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
				}
				tmp165 := tmp164.Get()
				tmp166 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp167 := tmp166.FindInternedVar(lang.NewSymbol("list"))
				if tmp167.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp167)))
				}
				tmp168 := tmp167.Get()
				tmp169 := lang.Apply(tmp168, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.PopThreadBindings")})
				tmp170 := lang.Apply(tmp165, []any{tmp169})
				tmp171 := lang.Apply(tmp162, []any{tmp170})
				tmp172 := lang.Apply(tmp159, []any{tmp171})
				tmp173 := lang.Apply(tmp152, []any{tmp156, tmp172})
				tmp174 := lang.Apply(tmp149, []any{tmp173})
				tmp175 := lang.Apply(tmp146, []any{tmp174})
				tmp176 := lang.Apply(tmp139, []any{tmp143, v6, tmp175})
				tmp177 := lang.Apply(tmp136, []any{tmp176})
				tmp178 := lang.Apply(tmp133, []any{tmp177})
				tmp179 := lang.Apply(tmp60, []any{tmp64, tmp95, tmp130, tmp178})
				tmp180 := lang.Apply(tmp57, []any{tmp179})
				return tmp180
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-meta
	{
		tmp0 := lang.NewSymbol("with-meta").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("obj"), lang.NewSymbol("m"))), lang.NewKeyword("doc"), "Returns an object of the same type and value as obj, with\n    map m as its metadata.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(10), lang.NewKeyword("column"), int(2), lang.NewKeyword("line"), int(211), lang.NewKeyword("end-line"), int(216))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		{ // function with-meta
			var v3 lang.FnFunc
			tmp2 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v4 := args[0]
				_ = v4
				v5 := args[1]
				_ = v5
				tmp6, _ := lang.FieldOrMethod(v4, "WithMeta")
				if reflect.TypeOf(tmp6).Kind() != reflect.Func {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("WithMeta is not a function")))
				}
				tmp7 := lang.Apply(tmp6, []any{v5})
				return tmp7
			})
			tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(216), lang.NewKeyword("column"), int(12), lang.NewKeyword("end-line"), int(217), lang.NewKeyword("end-column"), int(32))).(lang.FnFunc)
			v3 = tmp2
			_ = v3
		}
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-open
	{
		tmp0 := lang.NewSymbol("with-open").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(19), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(3832), lang.NewKeyword("end-line"), int(3832))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				tmp8 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp9 := tmp8.FindInternedVar(lang.NewSymbol("vector?"))
				if tmp9.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp9)))
				}
				tmp10 := tmp9.Get()
				tmp11 := lang.Apply(tmp10, []any{v5})
				if lang.IsTruthy(tmp11) {
				} else {
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("str"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp16 := tmp15.FindInternedVar(lang.NewSymbol("first"))
					if tmp16.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp16)))
					}
					tmp17 := tmp16.Get()
					tmp18 := lang.Apply(tmp17, []any{v3})
					tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp20 := tmp19.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp20.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
					}
					tmp21 := tmp20.Get()
					tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp23 := tmp22.FindInternedVar(lang.NewSymbol("meta"))
					if tmp23.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
					}
					tmp24 := tmp23.Get()
					tmp25 := lang.Apply(tmp24, []any{v3})
					tmp26 := lang.Apply(lang.NewKeyword("line"), []any{tmp25})
					tmp27 := lang.Apply(tmp14, []any{tmp18, " requires ", "a vector for its binding", " in ", tmp21, ":", tmp26})
					tmp28 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp27})
					panic(tmp28)
				}
				_ = tmp7
				var tmp29 any
				tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp31 := tmp30.FindInternedVar(lang.NewSymbol("even?"))
				if tmp31.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
				}
				tmp32 := tmp31.Get()
				tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp34 := tmp33.FindInternedVar(lang.NewSymbol("count"))
				if tmp34.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
				}
				tmp35 := tmp34.Get()
				tmp36 := lang.Apply(tmp35, []any{v5})
				tmp37 := lang.Apply(tmp32, []any{tmp36})
				if lang.IsTruthy(tmp37) {
				} else {
					tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp39 := tmp38.FindInternedVar(lang.NewSymbol("str"))
					if tmp39.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
					}
					tmp40 := tmp39.Get()
					tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp42 := tmp41.FindInternedVar(lang.NewSymbol("first"))
					if tmp42.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
					}
					tmp43 := tmp42.Get()
					tmp44 := lang.Apply(tmp43, []any{v3})
					tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp46 := tmp45.FindInternedVar(lang.NewSymbol("*ns*"))
					if tmp46.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
					}
					tmp47 := tmp46.Get()
					tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp49 := tmp48.FindInternedVar(lang.NewSymbol("meta"))
					if tmp49.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
					}
					tmp50 := tmp49.Get()
					tmp51 := lang.Apply(tmp50, []any{v3})
					tmp52 := lang.Apply(lang.NewKeyword("line"), []any{tmp51})
					tmp53 := lang.Apply(tmp40, []any{tmp44, " requires ", "an even number of forms in binding vector", " in ", tmp47, ":", tmp52})
					tmp54 := lang.Apply(lang.NewIllegalArgumentError, []any{tmp53})
					panic(tmp54)
				}
				_ = tmp29
				var tmp55 any
				tmp56 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp57 := tmp56.FindInternedVar(lang.NewSymbol("="))
				if tmp57.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp57)))
				}
				tmp58 := tmp57.Get()
				tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp60 := tmp59.FindInternedVar(lang.NewSymbol("count"))
				if tmp60.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
				}
				tmp61 := tmp60.Get()
				tmp62 := lang.Apply(tmp61, []any{v5})
				tmp63 := lang.Apply(tmp58, []any{tmp62, int64(0)})
				if lang.IsTruthy(tmp63) {
					tmp64 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp65 := tmp64.FindInternedVar(lang.NewSymbol("seq"))
					if tmp65.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp65)))
					}
					tmp66 := tmp65.Get()
					tmp67 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp68 := tmp67.FindInternedVar(lang.NewSymbol("concat"))
					if tmp68.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp68)))
					}
					tmp69 := tmp68.Get()
					tmp70 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp71 := tmp70.FindInternedVar(lang.NewSymbol("list"))
					if tmp71.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp71)))
					}
					tmp72 := tmp71.Get()
					tmp73 := lang.Apply(tmp72, []any{lang.NewSymbol("do")})
					tmp74 := lang.Apply(tmp69, []any{tmp73, v6})
					tmp75 := lang.Apply(tmp66, []any{tmp74})
					tmp55 = tmp75
				} else {
					var tmp76 any
					tmp77 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp78 := tmp77.FindInternedVar(lang.NewSymbol("symbol?"))
					if tmp78.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp78)))
					}
					tmp79 := tmp78.Get()
					tmp80 := lang.Apply(v5, []any{int64(0)})
					tmp81 := lang.Apply(tmp79, []any{tmp80})
					if lang.IsTruthy(tmp81) {
						tmp82 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp83 := tmp82.FindInternedVar(lang.NewSymbol("seq"))
						if tmp83.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp83)))
						}
						tmp84 := tmp83.Get()
						tmp85 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp86 := tmp85.FindInternedVar(lang.NewSymbol("concat"))
						if tmp86.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp86)))
						}
						tmp87 := tmp86.Get()
						tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp89 := tmp88.FindInternedVar(lang.NewSymbol("list"))
						if tmp89.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
						}
						tmp90 := tmp89.Get()
						tmp91 := lang.Apply(tmp90, []any{lang.NewSymbol("glojure.core/let")})
						tmp92 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp93 := tmp92.FindInternedVar(lang.NewSymbol("list"))
						if tmp93.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp93)))
						}
						tmp94 := tmp93.Get()
						tmp95 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp96 := tmp95.FindInternedVar(lang.NewSymbol("subvec"))
						if tmp96.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp96)))
						}
						tmp97 := tmp96.Get()
						tmp98 := lang.Apply(tmp97, []any{v5, int64(0), int64(2)})
						tmp99 := lang.Apply(tmp94, []any{tmp98})
						tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp101 := tmp100.FindInternedVar(lang.NewSymbol("list"))
						if tmp101.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
						}
						tmp102 := tmp101.Get()
						tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp104 := tmp103.FindInternedVar(lang.NewSymbol("seq"))
						if tmp104.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
						}
						tmp105 := tmp104.Get()
						tmp106 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp107 := tmp106.FindInternedVar(lang.NewSymbol("concat"))
						if tmp107.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp107)))
						}
						tmp108 := tmp107.Get()
						tmp109 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp110 := tmp109.FindInternedVar(lang.NewSymbol("list"))
						if tmp110.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp110)))
						}
						tmp111 := tmp110.Get()
						tmp112 := lang.Apply(tmp111, []any{lang.NewSymbol("try")})
						tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp114 := tmp113.FindInternedVar(lang.NewSymbol("list"))
						if tmp114.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
						}
						tmp115 := tmp114.Get()
						tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp117 := tmp116.FindInternedVar(lang.NewSymbol("seq"))
						if tmp117.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
						}
						tmp118 := tmp117.Get()
						tmp119 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp120 := tmp119.FindInternedVar(lang.NewSymbol("concat"))
						if tmp120.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp120)))
						}
						tmp121 := tmp120.Get()
						tmp122 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp123 := tmp122.FindInternedVar(lang.NewSymbol("list"))
						if tmp123.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp123)))
						}
						tmp124 := tmp123.Get()
						tmp125 := lang.Apply(tmp124, []any{lang.NewSymbol("glojure.core/with-open")})
						tmp126 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp127 := tmp126.FindInternedVar(lang.NewSymbol("list"))
						if tmp127.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp127)))
						}
						tmp128 := tmp127.Get()
						tmp129 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp130 := tmp129.FindInternedVar(lang.NewSymbol("subvec"))
						if tmp130.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp130)))
						}
						tmp131 := tmp130.Get()
						tmp132 := lang.Apply(tmp131, []any{v5, int64(2)})
						tmp133 := lang.Apply(tmp128, []any{tmp132})
						tmp134 := lang.Apply(tmp121, []any{tmp125, tmp133, v6})
						tmp135 := lang.Apply(tmp118, []any{tmp134})
						tmp136 := lang.Apply(tmp115, []any{tmp135})
						tmp137 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp138 := tmp137.FindInternedVar(lang.NewSymbol("list"))
						if tmp138.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp138)))
						}
						tmp139 := tmp138.Get()
						tmp140 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp141 := tmp140.FindInternedVar(lang.NewSymbol("seq"))
						if tmp141.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp141)))
						}
						tmp142 := tmp141.Get()
						tmp143 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp144 := tmp143.FindInternedVar(lang.NewSymbol("concat"))
						if tmp144.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp144)))
						}
						tmp145 := tmp144.Get()
						tmp146 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp147 := tmp146.FindInternedVar(lang.NewSymbol("list"))
						if tmp147.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp147)))
						}
						tmp148 := tmp147.Get()
						tmp149 := lang.Apply(tmp148, []any{lang.NewSymbol("finally")})
						tmp150 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp151 := tmp150.FindInternedVar(lang.NewSymbol("list"))
						if tmp151.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp151)))
						}
						tmp152 := tmp151.Get()
						tmp153 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp154 := tmp153.FindInternedVar(lang.NewSymbol("seq"))
						if tmp154.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp154)))
						}
						tmp155 := tmp154.Get()
						tmp156 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp157 := tmp156.FindInternedVar(lang.NewSymbol("concat"))
						if tmp157.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp157)))
						}
						tmp158 := tmp157.Get()
						tmp159 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp160 := tmp159.FindInternedVar(lang.NewSymbol("list"))
						if tmp160.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp160)))
						}
						tmp161 := tmp160.Get()
						tmp162 := lang.Apply(tmp161, []any{lang.NewSymbol(".")})
						tmp163 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp164 := tmp163.FindInternedVar(lang.NewSymbol("list"))
						if tmp164.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp164)))
						}
						tmp165 := tmp164.Get()
						tmp166 := lang.Apply(v5, []any{int64(0)})
						tmp167 := lang.Apply(tmp165, []any{tmp166})
						tmp168 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp169 := tmp168.FindInternedVar(lang.NewSymbol("list"))
						if tmp169.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp169)))
						}
						tmp170 := tmp169.Get()
						tmp171 := lang.Apply(tmp170, []any{lang.NewSymbol("close")})
						tmp172 := lang.Apply(tmp158, []any{tmp162, tmp167, tmp171})
						tmp173 := lang.Apply(tmp155, []any{tmp172})
						tmp174 := lang.Apply(tmp152, []any{tmp173})
						tmp175 := lang.Apply(tmp145, []any{tmp149, tmp174})
						tmp176 := lang.Apply(tmp142, []any{tmp175})
						tmp177 := lang.Apply(tmp139, []any{tmp176})
						tmp178 := lang.Apply(tmp108, []any{tmp112, tmp136, tmp177})
						tmp179 := lang.Apply(tmp105, []any{tmp178})
						tmp180 := lang.Apply(tmp102, []any{tmp179})
						tmp181 := lang.Apply(tmp87, []any{tmp91, tmp99, tmp180})
						tmp182 := lang.Apply(tmp84, []any{tmp181})
						tmp76 = tmp182
					} else {
						var tmp183 any
						if lang.IsTruthy(lang.NewKeyword("else")) {
							tmp184 := lang.Apply(lang.NewIllegalArgumentError, []any{"with-open only allows Symbols in bindings"})
							panic(tmp184)
						} else {
						}
						tmp76 = tmp183
					}
					tmp55 = tmp76
				}
				return tmp55
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-out-str
	{
		tmp0 := lang.NewSymbol("with-out-str").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(22), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(4738), lang.NewKeyword("end-line"), int(4738))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 2 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				var v5 any = lang.NewList(args[2:]...)
				_ = v5
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("seq"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp10 := tmp9.FindInternedVar(lang.NewSymbol("concat"))
				if tmp10.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
				}
				tmp11 := tmp10.Get()
				tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp13 := tmp12.FindInternedVar(lang.NewSymbol("list"))
				if tmp13.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
				}
				tmp14 := tmp13.Get()
				tmp15 := lang.Apply(tmp14, []any{lang.NewSymbol("glojure.core/let")})
				tmp16 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp17 := tmp16.FindInternedVar(lang.NewSymbol("list"))
				if tmp17.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp17)))
				}
				tmp18 := tmp17.Get()
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("apply"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp23 := tmp22.FindInternedVar(lang.NewSymbol("vector"))
				if tmp23.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp23)))
				}
				tmp24 := tmp23.Get()
				tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
				if tmp26.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
				}
				tmp27 := tmp26.Get()
				tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
				if tmp29.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
				}
				tmp30 := tmp29.Get()
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{lang.NewSymbol("s__0__auto__")})
				tmp35 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp36 := tmp35.FindInternedVar(lang.NewSymbol("list"))
				if tmp36.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp36)))
				}
				tmp37 := tmp36.Get()
				tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp39 := tmp38.FindInternedVar(lang.NewSymbol("seq"))
				if tmp39.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
				}
				tmp40 := tmp39.Get()
				tmp41 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp42 := tmp41.FindInternedVar(lang.NewSymbol("concat"))
				if tmp42.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp42)))
				}
				tmp43 := tmp42.Get()
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.Apply(tmp46, []any{lang.NewSymbol("new")})
				tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
				if tmp49.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
				}
				tmp50 := tmp49.Get()
				tmp51 := lang.Apply(tmp50, []any{lang.NewSymbol("strings.Builder")})
				tmp52 := lang.Apply(tmp43, []any{tmp47, tmp51})
				tmp53 := lang.Apply(tmp40, []any{tmp52})
				tmp54 := lang.Apply(tmp37, []any{tmp53})
				tmp55 := lang.Apply(tmp30, []any{tmp34, tmp54})
				tmp56 := lang.Apply(tmp27, []any{tmp55})
				tmp57 := lang.Apply(tmp21, []any{tmp24, tmp56})
				tmp58 := lang.Apply(tmp18, []any{tmp57})
				tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp60 := tmp59.FindInternedVar(lang.NewSymbol("list"))
				if tmp60.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
				}
				tmp61 := tmp60.Get()
				tmp62 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp63 := tmp62.FindInternedVar(lang.NewSymbol("seq"))
				if tmp63.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp63)))
				}
				tmp64 := tmp63.Get()
				tmp65 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp66 := tmp65.FindInternedVar(lang.NewSymbol("concat"))
				if tmp66.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp66)))
				}
				tmp67 := tmp66.Get()
				tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp69 := tmp68.FindInternedVar(lang.NewSymbol("list"))
				if tmp69.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
				}
				tmp70 := tmp69.Get()
				tmp71 := lang.Apply(tmp70, []any{lang.NewSymbol("glojure.core/binding")})
				tmp72 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp73 := tmp72.FindInternedVar(lang.NewSymbol("list"))
				if tmp73.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp73)))
				}
				tmp74 := tmp73.Get()
				tmp75 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp76 := tmp75.FindInternedVar(lang.NewSymbol("apply"))
				if tmp76.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp76)))
				}
				tmp77 := tmp76.Get()
				tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp79 := tmp78.FindInternedVar(lang.NewSymbol("vector"))
				if tmp79.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
				}
				tmp80 := tmp79.Get()
				tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp82 := tmp81.FindInternedVar(lang.NewSymbol("seq"))
				if tmp82.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
				}
				tmp83 := tmp82.Get()
				tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp85 := tmp84.FindInternedVar(lang.NewSymbol("concat"))
				if tmp85.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
				}
				tmp86 := tmp85.Get()
				tmp87 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp88 := tmp87.FindInternedVar(lang.NewSymbol("list"))
				if tmp88.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp88)))
				}
				tmp89 := tmp88.Get()
				tmp90 := lang.Apply(tmp89, []any{lang.NewSymbol("glojure.core/*out*")})
				tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp92 := tmp91.FindInternedVar(lang.NewSymbol("list"))
				if tmp92.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
				}
				tmp93 := tmp92.Get()
				tmp94 := lang.Apply(tmp93, []any{lang.NewSymbol("s__0__auto__")})
				tmp95 := lang.Apply(tmp86, []any{tmp90, tmp94})
				tmp96 := lang.Apply(tmp83, []any{tmp95})
				tmp97 := lang.Apply(tmp77, []any{tmp80, tmp96})
				tmp98 := lang.Apply(tmp74, []any{tmp97})
				tmp99 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp100 := tmp99.FindInternedVar(lang.NewSymbol("list"))
				if tmp100.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp100)))
				}
				tmp101 := tmp100.Get()
				tmp102 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp103 := tmp102.FindInternedVar(lang.NewSymbol("seq"))
				if tmp103.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp103)))
				}
				tmp104 := tmp103.Get()
				tmp105 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp106 := tmp105.FindInternedVar(lang.NewSymbol("concat"))
				if tmp106.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp106)))
				}
				tmp107 := tmp106.Get()
				tmp108 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp109 := tmp108.FindInternedVar(lang.NewSymbol("list"))
				if tmp109.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp109)))
				}
				tmp110 := tmp109.Get()
				tmp111 := lang.Apply(tmp110, []any{lang.NewSymbol("glojure.core/str")})
				tmp112 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp113 := tmp112.FindInternedVar(lang.NewSymbol("list"))
				if tmp113.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp113)))
				}
				tmp114 := tmp113.Get()
				tmp115 := lang.Apply(tmp114, []any{lang.NewSymbol("s__0__auto__")})
				tmp116 := lang.Apply(tmp107, []any{tmp111, tmp115})
				tmp117 := lang.Apply(tmp104, []any{tmp116})
				tmp118 := lang.Apply(tmp101, []any{tmp117})
				tmp119 := lang.Apply(tmp67, []any{tmp71, tmp98, v5, tmp118})
				tmp120 := lang.Apply(tmp64, []any{tmp119})
				tmp121 := lang.Apply(tmp61, []any{tmp120})
				tmp122 := lang.Apply(tmp11, []any{tmp15, tmp58, tmp121})
				tmp123 := lang.Apply(tmp8, []any{tmp122})
				return tmp123
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-precision
	{
		tmp0 := lang.NewSymbol("with-precision").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("precision"), lang.NewSymbol("&"), lang.NewSymbol("exprs"))), lang.NewKeyword("doc"), "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(24), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(5110), lang.NewKeyword("end-line"), int(5110))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				var tmp7 any
				{ // let
					// let binding "vec__65"
					var tmp8 any
					tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp10 := tmp9.FindInternedVar(lang.NewSymbol("="))
					if tmp10.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
					}
					tmp11 := tmp10.Get()
					tmp12 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp13 := tmp12.FindInternedVar(lang.NewSymbol("first"))
					if tmp13.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp13)))
					}
					tmp14 := tmp13.Get()
					tmp15 := lang.Apply(tmp14, []any{v6})
					tmp16 := lang.Apply(tmp11, []any{tmp15, lang.NewKeyword("rounding")})
					if lang.IsTruthy(tmp16) {
						tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp18 := tmp17.FindInternedVar(lang.NewSymbol("next"))
						if tmp18.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
						}
						tmp19 := tmp18.Get()
						tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp21 := tmp20.FindInternedVar(lang.NewSymbol("next"))
						if tmp21.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
						}
						tmp22 := tmp21.Get()
						tmp23 := lang.Apply(tmp22, []any{v6})
						tmp24 := lang.Apply(tmp19, []any{tmp23})
						tmp25 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp26 := tmp25.FindInternedVar(lang.NewSymbol("seq"))
						if tmp26.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp26)))
						}
						tmp27 := tmp26.Get()
						tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp29 := tmp28.FindInternedVar(lang.NewSymbol("concat"))
						if tmp29.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
						}
						tmp30 := tmp29.Get()
						tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
						if tmp32.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
						}
						tmp33 := tmp32.Get()
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("seq"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp38 := tmp37.FindInternedVar(lang.NewSymbol("concat"))
						if tmp38.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
						}
						tmp39 := tmp38.Get()
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("list"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{lang.NewSymbol(".")})
						tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
						if tmp45.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
						}
						tmp46 := tmp45.Get()
						tmp47 := lang.Apply(tmp46, []any{lang.NewSymbol("java.math.RoundingMode")})
						tmp48 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp49 := tmp48.FindInternedVar(lang.NewSymbol("list"))
						if tmp49.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp49)))
						}
						tmp50 := tmp49.Get()
						tmp51 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp52 := tmp51.FindInternedVar(lang.NewSymbol("second"))
						if tmp52.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp52)))
						}
						tmp53 := tmp52.Get()
						tmp54 := lang.Apply(tmp53, []any{v6})
						tmp55 := lang.Apply(tmp50, []any{tmp54})
						tmp56 := lang.Apply(tmp39, []any{tmp43, tmp47, tmp55})
						tmp57 := lang.Apply(tmp36, []any{tmp56})
						tmp58 := lang.Apply(tmp33, []any{tmp57})
						tmp59 := lang.Apply(tmp30, []any{tmp58})
						tmp60 := lang.Apply(tmp27, []any{tmp59})
						tmp61 := lang.NewVector(tmp24, tmp60)
						tmp62 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5121), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(5122), lang.NewKeyword("end-column"), int(69))
						tmp63, err := lang.WithMeta(tmp61, tmp62.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp63
					} else {
						tmp64 := lang.NewVector(v6, nil)
						tmp65 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(5123), lang.NewKeyword("column"), int(23), lang.NewKeyword("end-line"), int(5123), lang.NewKeyword("end-column"), int(33))
						tmp66, err := lang.WithMeta(tmp64, tmp65.(lang.IPersistentMap))
						if err != nil {
							panic(err)
						}
						tmp8 = tmp66
					}
					var v67 any = tmp8
					_ = v67
					// let binding "body"
					tmp68 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp69 := tmp68.FindInternedVar(lang.NewSymbol("nth"))
					if tmp69.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp69)))
					}
					tmp70 := tmp69.Get()
					tmp71 := lang.Apply(tmp70, []any{v67, int64(0), nil})
					var v72 any = tmp71
					_ = v72
					// let binding "rm"
					tmp73 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp74 := tmp73.FindInternedVar(lang.NewSymbol("nth"))
					if tmp74.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp74)))
					}
					tmp75 := tmp74.Get()
					tmp76 := lang.Apply(tmp75, []any{v67, int64(1), nil})
					var v77 any = tmp76
					_ = v77
					tmp78 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp79 := tmp78.FindInternedVar(lang.NewSymbol("seq"))
					if tmp79.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp79)))
					}
					tmp80 := tmp79.Get()
					tmp81 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp82 := tmp81.FindInternedVar(lang.NewSymbol("concat"))
					if tmp82.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp82)))
					}
					tmp83 := tmp82.Get()
					tmp84 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp85 := tmp84.FindInternedVar(lang.NewSymbol("list"))
					if tmp85.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp85)))
					}
					tmp86 := tmp85.Get()
					tmp87 := lang.Apply(tmp86, []any{lang.NewSymbol("glojure.core/binding")})
					tmp88 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp89 := tmp88.FindInternedVar(lang.NewSymbol("list"))
					if tmp89.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp89)))
					}
					tmp90 := tmp89.Get()
					tmp91 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp92 := tmp91.FindInternedVar(lang.NewSymbol("apply"))
					if tmp92.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp92)))
					}
					tmp93 := tmp92.Get()
					tmp94 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp95 := tmp94.FindInternedVar(lang.NewSymbol("vector"))
					if tmp95.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp95)))
					}
					tmp96 := tmp95.Get()
					tmp97 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp98 := tmp97.FindInternedVar(lang.NewSymbol("seq"))
					if tmp98.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp98)))
					}
					tmp99 := tmp98.Get()
					tmp100 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp101 := tmp100.FindInternedVar(lang.NewSymbol("concat"))
					if tmp101.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp101)))
					}
					tmp102 := tmp101.Get()
					tmp103 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp104 := tmp103.FindInternedVar(lang.NewSymbol("list"))
					if tmp104.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp104)))
					}
					tmp105 := tmp104.Get()
					tmp106 := lang.Apply(tmp105, []any{lang.NewSymbol("glojure.core/*math-context*")})
					tmp107 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp108 := tmp107.FindInternedVar(lang.NewSymbol("list"))
					if tmp108.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp108)))
					}
					tmp109 := tmp108.Get()
					tmp110 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp111 := tmp110.FindInternedVar(lang.NewSymbol("seq"))
					if tmp111.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp111)))
					}
					tmp112 := tmp111.Get()
					tmp113 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp114 := tmp113.FindInternedVar(lang.NewSymbol("concat"))
					if tmp114.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp114)))
					}
					tmp115 := tmp114.Get()
					tmp116 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp117 := tmp116.FindInternedVar(lang.NewSymbol("list"))
					if tmp117.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp117)))
					}
					tmp118 := tmp117.Get()
					tmp119 := lang.Apply(tmp118, []any{lang.NewSymbol("java.math.MathContext.")})
					tmp120 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp121 := tmp120.FindInternedVar(lang.NewSymbol("list"))
					if tmp121.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp121)))
					}
					tmp122 := tmp121.Get()
					tmp123 := lang.Apply(tmp122, []any{v5})
					tmp124 := lang.Apply(tmp115, []any{tmp119, tmp123, v77})
					tmp125 := lang.Apply(tmp112, []any{tmp124})
					tmp126 := lang.Apply(tmp109, []any{tmp125})
					tmp127 := lang.Apply(tmp102, []any{tmp106, tmp126})
					tmp128 := lang.Apply(tmp99, []any{tmp127})
					tmp129 := lang.Apply(tmp93, []any{tmp96, tmp128})
					tmp130 := lang.Apply(tmp90, []any{tmp129})
					tmp131 := lang.Apply(tmp83, []any{tmp87, tmp130, v72})
					tmp132 := lang.Apply(tmp80, []any{tmp131})
					tmp7 = tmp132
				} // end let
				return tmp7
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs
	{
		tmp0 := lang.NewSymbol("with-redefs").WithMeta(lang.NewMap(lang.NewKeyword("macro"), true, lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("bindings"), lang.NewSymbol("&"), lang.NewSymbol("body"))), lang.NewKeyword("doc"), "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(21), lang.NewKeyword("column"), int(11), lang.NewKeyword("line"), int(7544), lang.NewKeyword("end-line"), int(7544))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			switch len(args) {
			default:
				if len(args) < 3 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				v4 := args[1]
				_ = v4
				v5 := args[2]
				_ = v5
				var v6 any = lang.NewList(args[3:]...)
				_ = v6
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("seq"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("concat"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("list"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{lang.NewSymbol("glojure.core/with-redefs-fn")})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("list"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				tmp20 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp21 := tmp20.FindInternedVar(lang.NewSymbol("zipmap"))
				if tmp21.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp21)))
				}
				tmp22 := tmp21.Get()
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("map"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				var tmp26 lang.FnFunc
				tmp26 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v27 := args[0]
					_ = v27
					tmp28 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
					tmp29 := tmp28.FindInternedVar(lang.NewSymbol("list"))
					if tmp29.IsMacro() {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp29)))
					}
					tmp30 := tmp29.Get()
					tmp31 := lang.Apply(tmp30, []any{lang.NewSymbol("var"), v27})
					return tmp31
				})
				tmp27 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7555), lang.NewKeyword("column"), int(34), lang.NewKeyword("end-line"), int(7555), lang.NewKeyword("end-column"), int(47))
				tmp28, err := lang.WithMeta(tmp26, tmp27.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp29 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp30 := tmp29.FindInternedVar(lang.NewSymbol("take-nth"))
				if tmp30.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp30)))
				}
				tmp31 := tmp30.Get()
				tmp32 := lang.Apply(tmp31, []any{int64(2), v5})
				tmp33 := lang.Apply(tmp25, []any{tmp28, tmp32})
				tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp35 := tmp34.FindInternedVar(lang.NewSymbol("take-nth"))
				if tmp35.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
				}
				tmp36 := tmp35.Get()
				tmp37 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp38 := tmp37.FindInternedVar(lang.NewSymbol("next"))
				if tmp38.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp38)))
				}
				tmp39 := tmp38.Get()
				tmp40 := lang.Apply(tmp39, []any{v5})
				tmp41 := lang.Apply(tmp36, []any{int64(2), tmp40})
				tmp42 := lang.Apply(tmp22, []any{tmp33, tmp41})
				tmp43 := lang.Apply(tmp19, []any{tmp42})
				tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp45 := tmp44.FindInternedVar(lang.NewSymbol("list"))
				if tmp45.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
				}
				tmp46 := tmp45.Get()
				tmp47 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp48 := tmp47.FindInternedVar(lang.NewSymbol("seq"))
				if tmp48.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp48)))
				}
				tmp49 := tmp48.Get()
				tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp51 := tmp50.FindInternedVar(lang.NewSymbol("concat"))
				if tmp51.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
				}
				tmp52 := tmp51.Get()
				tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp54 := tmp53.FindInternedVar(lang.NewSymbol("list"))
				if tmp54.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
				}
				tmp55 := tmp54.Get()
				tmp56 := lang.Apply(tmp55, []any{lang.NewSymbol("glojure.core/fn")})
				tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp58 := tmp57.FindInternedVar(lang.NewSymbol("list"))
				if tmp58.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
				}
				tmp59 := tmp58.Get()
				tmp60 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp61 := tmp60.FindInternedVar(lang.NewSymbol("apply"))
				if tmp61.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp61)))
				}
				tmp62 := tmp61.Get()
				tmp63 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp64 := tmp63.FindInternedVar(lang.NewSymbol("vector"))
				if tmp64.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp64)))
				}
				tmp65 := tmp64.Get()
				tmp66 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp67 := tmp66.FindInternedVar(lang.NewSymbol("seq"))
				if tmp67.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp67)))
				}
				tmp68 := tmp67.Get()
				tmp69 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp70 := tmp69.FindInternedVar(lang.NewSymbol("concat"))
				if tmp70.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp70)))
				}
				tmp71 := tmp70.Get()
				tmp72 := lang.Apply(tmp71, nil)
				tmp73 := lang.Apply(tmp68, []any{tmp72})
				tmp74 := lang.Apply(tmp62, []any{tmp65, tmp73})
				tmp75 := lang.Apply(tmp59, []any{tmp74})
				tmp76 := lang.Apply(tmp52, []any{tmp56, tmp75, v6})
				tmp77 := lang.Apply(tmp49, []any{tmp76})
				tmp78 := lang.Apply(tmp46, []any{tmp77})
				tmp79 := lang.Apply(tmp12, []any{tmp16, tmp43, tmp78})
				tmp80 := lang.Apply(tmp9, []any{tmp79})
				return tmp80
			}
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// with-redefs-fn
	{
		tmp0 := lang.NewSymbol("with-redefs-fn").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("binding-map"), lang.NewSymbol("func"))), lang.NewKeyword("doc"), "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.3", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(20), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(7524), lang.NewKeyword("end-line"), int(7524))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "root-bind"
				var tmp6 lang.FnFunc
				tmp6 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v7 := args[0]
					_ = v7
					var tmp8 any
					{ // let
						// let binding "seq_326"
						tmp9 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp10 := tmp9.FindInternedVar(lang.NewSymbol("seq"))
						if tmp10.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp10)))
						}
						tmp11 := tmp10.Get()
						tmp12 := lang.Apply(tmp11, []any{v7})
						var v13 any = tmp12
						_ = v13
						// let binding "chunk_327"
						var v14 any = nil
						_ = v14
						// let binding "count_328"
						var v15 any = int64(0)
						_ = v15
						// let binding "i_329"
						var v16 any = int64(0)
						_ = v16
						for {
							var tmp17 any
							tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
							tmp19 := tmp18.FindInternedVar(lang.NewSymbol("<"))
							if tmp19.IsMacro() {
								panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
							}
							tmp20 := tmp19.Get()
							tmp21 := lang.Apply(tmp20, []any{v16, v15})
							if lang.IsTruthy(tmp21) {
								var tmp22 any
								{ // let
									// let binding "vec__330"
									tmp23, _ := lang.FieldOrMethod(v14, "nth")
									if reflect.TypeOf(tmp23).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("nth is not a function")))
									}
									tmp24 := lang.Apply(tmp23, []any{v16})
									var v25 any = tmp24
									_ = v25
									// let binding "a-var"
									tmp26 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp27 := tmp26.FindInternedVar(lang.NewSymbol("nth"))
									if tmp27.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp27)))
									}
									tmp28 := tmp27.Get()
									tmp29 := lang.Apply(tmp28, []any{v25, int64(0), nil})
									var v30 any = tmp29
									_ = v30
									// let binding "a-val"
									tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp32 := tmp31.FindInternedVar(lang.NewSymbol("nth"))
									if tmp32.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
									}
									tmp33 := tmp32.Get()
									tmp34 := lang.Apply(tmp33, []any{v25, int64(1), nil})
									var v35 any = tmp34
									_ = v35
									tmp36, _ := lang.FieldOrMethod(v30, "bindRoot")
									if reflect.TypeOf(tmp36).Kind() != reflect.Func {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
									}
									tmp37 := lang.Apply(tmp36, []any{v35})
									_ = tmp37
									var tmp38 any = v13
									var tmp39 any = v14
									var tmp40 any = v15
									tmp42 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp43 := tmp42.FindInternedVar(lang.NewSymbol("unchecked-inc"))
									if tmp43.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp43)))
									}
									tmp44 := tmp43.Get()
									tmp45 := lang.Apply(tmp44, []any{v16})
									var tmp41 any = tmp45
									v13 = tmp38
									v14 = tmp39
									v15 = tmp40
									v16 = tmp41
									continue
								} // end let
								tmp17 = tmp22
							} else {
								var tmp23 any
								{ // let
									// let binding "temp__0__auto__"
									tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
									tmp25 := tmp24.FindInternedVar(lang.NewSymbol("seq"))
									if tmp25.IsMacro() {
										panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
									}
									tmp26 := tmp25.Get()
									tmp27 := lang.Apply(tmp26, []any{v13})
									var v28 any = tmp27
									_ = v28
									var tmp29 any
									if lang.IsTruthy(v28) {
										var tmp30 any
										{ // let
											// let binding "seq_326"
											var v31 any = v28
											_ = v31
											var tmp32 any
											tmp33 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
											tmp34 := tmp33.FindInternedVar(lang.NewSymbol("chunked-seq?"))
											if tmp34.IsMacro() {
												panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp34)))
											}
											tmp35 := tmp34.Get()
											tmp36 := lang.Apply(tmp35, []any{v31})
											if lang.IsTruthy(tmp36) {
												var tmp37 any
												{ // let
													// let binding "c__0__auto__"
													tmp38 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp39 := tmp38.FindInternedVar(lang.NewSymbol("chunk-first"))
													if tmp39.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp39)))
													}
													tmp40 := tmp39.Get()
													tmp41 := lang.Apply(tmp40, []any{v31})
													var v42 any = tmp41
													_ = v42
													tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp45 := tmp44.FindInternedVar(lang.NewSymbol("chunk-rest"))
													if tmp45.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
													}
													tmp46 := tmp45.Get()
													tmp47 := lang.Apply(tmp46, []any{v31})
													var tmp43 any = tmp47
													var tmp48 any = v42
													tmp50 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp51 := tmp50.FindInternedVar(lang.NewSymbol("int"))
													if tmp51.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp51)))
													}
													tmp52 := tmp51.Get()
													tmp53 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp54 := tmp53.FindInternedVar(lang.NewSymbol("count"))
													if tmp54.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp54)))
													}
													tmp55 := tmp54.Get()
													tmp56 := lang.Apply(tmp55, []any{v42})
													tmp57 := lang.Apply(tmp52, []any{tmp56})
													var tmp49 any = tmp57
													tmp59 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp60 := tmp59.FindInternedVar(lang.NewSymbol("int"))
													if tmp60.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp60)))
													}
													tmp61 := tmp60.Get()
													tmp62 := lang.Apply(tmp61, []any{int64(0)})
													var tmp58 any = tmp62
													v13 = tmp43
													v14 = tmp48
													v15 = tmp49
													v16 = tmp58
													continue
												} // end let
												tmp32 = tmp37
											} else {
												var tmp38 any
												{ // let
													// let binding "vec__333"
													tmp39 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp40 := tmp39.FindInternedVar(lang.NewSymbol("first"))
													if tmp40.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp40)))
													}
													tmp41 := tmp40.Get()
													tmp42 := lang.Apply(tmp41, []any{v31})
													var v43 any = tmp42
													_ = v43
													// let binding "a-var"
													tmp44 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp45 := tmp44.FindInternedVar(lang.NewSymbol("nth"))
													if tmp45.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp45)))
													}
													tmp46 := tmp45.Get()
													tmp47 := lang.Apply(tmp46, []any{v43, int64(0), nil})
													var v48 any = tmp47
													_ = v48
													// let binding "a-val"
													tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp50 := tmp49.FindInternedVar(lang.NewSymbol("nth"))
													if tmp50.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
													}
													tmp51 := tmp50.Get()
													tmp52 := lang.Apply(tmp51, []any{v43, int64(1), nil})
													var v53 any = tmp52
													_ = v53
													tmp54, _ := lang.FieldOrMethod(v48, "bindRoot")
													if reflect.TypeOf(tmp54).Kind() != reflect.Func {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("bindRoot is not a function")))
													}
													tmp55 := lang.Apply(tmp54, []any{v53})
													_ = tmp55
													tmp57 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
													tmp58 := tmp57.FindInternedVar(lang.NewSymbol("next"))
													if tmp58.IsMacro() {
														panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp58)))
													}
													tmp59 := tmp58.Get()
													tmp60 := lang.Apply(tmp59, []any{v31})
													var tmp56 any = tmp60
													var tmp61 any = nil
													var tmp62 any = int64(0)
													var tmp63 any = int64(0)
													v13 = tmp56
													v14 = tmp61
													v15 = tmp62
													v16 = tmp63
													continue
												} // end let
												tmp32 = tmp38
											}
											tmp30 = tmp32
										} // end let
										tmp29 = tmp30
									} else {
									}
									tmp23 = tmp29
								} // end let
								tmp17 = tmp23
							}
							tmp8 = tmp17
							break
						}
					} // end let
					return tmp8
				})
				tmp7 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7533), lang.NewKeyword("column"), int(19), lang.NewKeyword("end-line"), int(7535), lang.NewKeyword("end-column"), int(93))
				tmp8, err := lang.WithMeta(tmp6, tmp7.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				var v9 any = tmp8
				_ = v9
				// let binding "old-vals"
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("zipmap"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp14 := tmp13.FindInternedVar(lang.NewSymbol("keys"))
				if tmp14.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp14)))
				}
				tmp15 := tmp14.Get()
				tmp16 := lang.Apply(tmp15, []any{v3})
				tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp18 := tmp17.FindInternedVar(lang.NewSymbol("map"))
				if tmp18.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
				}
				tmp19 := tmp18.Get()
				var tmp20 lang.FnFunc
				tmp20 = lang.NewFnFunc(func(args ...any) any {
					if len(args) != 1 {
						panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
					}
					v21 := args[0]
					_ = v21
					tmp22, ok := lang.FieldOrMethod(v21, "getRawRoot")
					if !ok {
						panic(lang.NewIllegalArgumentError(fmt.Sprintf("no such field or method on %T: %s", v21, "getRawRoot")))
					}
					var tmp23 any
					switch reflect.TypeOf(tmp22).Kind() {
					case reflect.Func:
						tmp23 = lang.Apply(tmp22, nil)
					default:
						tmp23 = tmp22
					}
					return tmp23
				})
				tmp21 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(7537), lang.NewKeyword("column"), int(31), lang.NewKeyword("end-line"), int(7537), lang.NewKeyword("end-column"), int(92))
				tmp22, err := lang.WithMeta(tmp20, tmp21.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp23 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp24 := tmp23.FindInternedVar(lang.NewSymbol("keys"))
				if tmp24.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp24)))
				}
				tmp25 := tmp24.Get()
				tmp26 := lang.Apply(tmp25, []any{v3})
				tmp27 := lang.Apply(tmp19, []any{tmp22, tmp26})
				tmp28 := lang.Apply(tmp12, []any{tmp16, tmp27})
				var v29 any = tmp28
				_ = v29
				var tmp30 any
				func() {
					defer func() {
						tmp31 := lang.Apply(v9, []any{v29})
						_ = tmp31
					}()
					tmp32 := lang.Apply(v9, []any{v3})
					_ = tmp32
					tmp33 := lang.Apply(v4, nil)
					tmp30 = tmp33
				}()
				tmp5 = tmp30
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// xml-seq
	{
		tmp0 := lang.NewSymbol("xml-seq").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("root"))), lang.NewKeyword("doc"), "A tree seq on the xml elements as per xml/parse", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(13), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(4982), lang.NewKeyword("end-line"), int(4982))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp5 := tmp4.FindInternedVar(lang.NewSymbol("tree-seq"))
			if tmp5.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
			}
			tmp6 := tmp5.Get()
			tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp8 := tmp7.FindInternedVar(lang.NewSymbol("complement"))
			if tmp8.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
			}
			tmp9 := tmp8.Get()
			tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp11 := tmp10.FindInternedVar(lang.NewSymbol("string?"))
			if tmp11.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
			}
			tmp12 := tmp11.Get()
			tmp13 := lang.Apply(tmp9, []any{tmp12})
			tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp15 := tmp14.FindInternedVar(lang.NewSymbol("comp"))
			if tmp15.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
			}
			tmp16 := tmp15.Get()
			tmp17 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
			tmp18 := tmp17.FindInternedVar(lang.NewSymbol("seq"))
			if tmp18.IsMacro() {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp18)))
			}
			tmp19 := tmp18.Get()
			tmp20 := lang.Apply(tmp16, []any{tmp19, lang.NewKeyword("content")})
			tmp21 := lang.Apply(tmp6, []any{tmp13, tmp20, v3})
			return tmp21
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zero?
	{
		var tmp1 lang.FnFunc
		{ // function zero?__inliner
			var v2 lang.FnFunc
			tmp1 = lang.NewFnFunc(func(args ...any) any {
				if len(args) != 1 {
					panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
				}
				v3 := args[0]
				_ = v3
				tmp4 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp5 := tmp4.FindInternedVar(lang.NewSymbol("seq"))
				if tmp5.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp5)))
				}
				tmp6 := tmp5.Get()
				tmp7 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp8 := tmp7.FindInternedVar(lang.NewSymbol("concat"))
				if tmp8.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp8)))
				}
				tmp9 := tmp8.Get()
				tmp10 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp11 := tmp10.FindInternedVar(lang.NewSymbol("list"))
				if tmp11.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp11)))
				}
				tmp12 := tmp11.Get()
				tmp13 := lang.Apply(tmp12, []any{lang.NewSymbol(".")})
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("list"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{lang.NewSymbol("github.com$glojurelang$glojure$pkg$lang.Numbers")})
				tmp18 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp19 := tmp18.FindInternedVar(lang.NewSymbol("list"))
				if tmp19.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp19)))
				}
				tmp20 := tmp19.Get()
				tmp21 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp22 := tmp21.FindInternedVar(lang.NewSymbol("seq"))
				if tmp22.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp22)))
				}
				tmp23 := tmp22.Get()
				tmp24 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp25 := tmp24.FindInternedVar(lang.NewSymbol("concat"))
				if tmp25.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp25)))
				}
				tmp26 := tmp25.Get()
				tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp28 := tmp27.FindInternedVar(lang.NewSymbol("list"))
				if tmp28.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
				}
				tmp29 := tmp28.Get()
				tmp30 := lang.Apply(tmp29, []any{lang.NewSymbol("glojure.core/IsZero")})
				tmp31 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp32 := tmp31.FindInternedVar(lang.NewSymbol("list"))
				if tmp32.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp32)))
				}
				tmp33 := tmp32.Get()
				tmp34 := lang.Apply(tmp33, []any{v3})
				tmp35 := lang.Apply(tmp26, []any{tmp30, tmp34})
				tmp36 := lang.Apply(tmp23, []any{tmp35})
				tmp37 := lang.Apply(tmp20, []any{tmp36})
				tmp38 := lang.Apply(tmp9, []any{tmp13, tmp17, tmp37})
				tmp39 := lang.Apply(tmp6, []any{tmp38})
				return tmp39
			})
			v2 = tmp1
			_ = v2
		}
		tmp0 := lang.NewSymbol("zero?").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("num"))), lang.NewKeyword("inline"), tmp1, lang.NewKeyword("doc"), "Returns true if num is zero, else false", lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(11), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(860), lang.NewKeyword("end-line"), int(860))).(*lang.Symbol)
		var tmp3 lang.FnFunc
		tmp3 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 1 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v4 := args[0]
			_ = v4
			tmp5, _ := lang.FieldOrMethod(lang.Numbers, "IsZero")
			if reflect.TypeOf(tmp5).Kind() != reflect.Func {
				panic(lang.NewIllegalArgumentError(fmt.Sprintf("IsZero is not a function")))
			}
			tmp6 := lang.Apply(tmp5, []any{v4})
			return tmp6
		})
		tmp3 = tmp3.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp2 := ns.InternWithValue(tmp0, tmp3, true)
		if tmp0.Meta() != nil {
			tmp2.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
	// zipmap
	{
		tmp0 := lang.NewSymbol("zipmap").WithMeta(lang.NewMap(lang.NewKeyword("arglists"), lang.NewList(lang.NewVector(lang.NewSymbol("keys"), lang.NewSymbol("vals"))), lang.NewKeyword("doc"), "Returns a map with the keys mapped to the corresponding vals.", lang.NewKeyword("static"), true, lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("added"), "1.0", lang.NewKeyword("ns"), lang.FindOrCreateNamespace(lang.NewSymbol("glojure.core")), lang.NewKeyword("end-column"), int(12), lang.NewKeyword("column"), int(7), lang.NewKeyword("line"), int(6583), lang.NewKeyword("end-line"), int(6583))).(*lang.Symbol)
		var tmp2 lang.FnFunc
		tmp2 = lang.NewFnFunc(func(args ...any) any {
			if len(args) != 2 {
				panic(lang.NewIllegalArgumentError("wrong number of arguments (" + fmt.Sprint(len(args)) + ")"))
			}
			v3 := args[0]
			_ = v3
			v4 := args[1]
			_ = v4
			var tmp5 any
			{ // let
				// let binding "map"
				tmp6 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp7 := tmp6.FindInternedVar(lang.NewSymbol("transient"))
				if tmp7.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp7)))
				}
				tmp8 := tmp7.Get()
				tmp9 := lang.NewMap()
				tmp10 := lang.NewMap(lang.NewKeyword("file"), "glojure/core.glj", lang.NewKeyword("line"), int(6588), lang.NewKeyword("column"), int(27), lang.NewKeyword("end-line"), int(6588), lang.NewKeyword("end-column"), int(28))
				tmp11, err := lang.WithMeta(tmp9, tmp10.(lang.IPersistentMap))
				if err != nil {
					panic(err)
				}
				tmp12 := lang.Apply(tmp8, []any{tmp11})
				var v13 any = tmp12
				_ = v13
				// let binding "ks"
				tmp14 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp15 := tmp14.FindInternedVar(lang.NewSymbol("seq"))
				if tmp15.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp15)))
				}
				tmp16 := tmp15.Get()
				tmp17 := lang.Apply(tmp16, []any{v3})
				var v18 any = tmp17
				_ = v18
				// let binding "vs"
				tmp19 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
				tmp20 := tmp19.FindInternedVar(lang.NewSymbol("seq"))
				if tmp20.IsMacro() {
					panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp20)))
				}
				tmp21 := tmp20.Get()
				tmp22 := lang.Apply(tmp21, []any{v4})
				var v23 any = tmp22
				_ = v23
				for {
					var tmp24 any
					var tmp25 any
					{ // let
						// let binding "and__0__auto__"
						var v26 any = v18
						_ = v26
						var tmp27 any
						if lang.IsTruthy(v26) {
							tmp27 = v23
						} else {
							tmp27 = v26
						}
						tmp25 = tmp27
					} // end let
					if lang.IsTruthy(tmp25) {
						tmp27 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp28 := tmp27.FindInternedVar(lang.NewSymbol("assoc!"))
						if tmp28.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp28)))
						}
						tmp29 := tmp28.Get()
						tmp30 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp31 := tmp30.FindInternedVar(lang.NewSymbol("first"))
						if tmp31.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp31)))
						}
						tmp32 := tmp31.Get()
						tmp33 := lang.Apply(tmp32, []any{v18})
						tmp34 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp35 := tmp34.FindInternedVar(lang.NewSymbol("first"))
						if tmp35.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp35)))
						}
						tmp36 := tmp35.Get()
						tmp37 := lang.Apply(tmp36, []any{v23})
						tmp38 := lang.Apply(tmp29, []any{v13, tmp33, tmp37})
						var tmp26 any = tmp38
						tmp40 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp41 := tmp40.FindInternedVar(lang.NewSymbol("next"))
						if tmp41.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp41)))
						}
						tmp42 := tmp41.Get()
						tmp43 := lang.Apply(tmp42, []any{v18})
						var tmp39 any = tmp43
						tmp45 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp46 := tmp45.FindInternedVar(lang.NewSymbol("next"))
						if tmp46.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp46)))
						}
						tmp47 := tmp46.Get()
						tmp48 := lang.Apply(tmp47, []any{v23})
						var tmp44 any = tmp48
						v13 = tmp26
						v18 = tmp39
						v23 = tmp44
						continue
					} else {
						tmp49 := lang.FindNamespace(lang.NewSymbol("glojure.core"))
						tmp50 := tmp49.FindInternedVar(lang.NewSymbol("persistent!"))
						if tmp50.IsMacro() {
							panic(lang.NewIllegalArgumentError(fmt.Sprintf("can't take value of macro: %v", tmp50)))
						}
						tmp51 := tmp50.Get()
						tmp52 := lang.Apply(tmp51, []any{v13})
						tmp24 = tmp52
					}
					tmp5 = tmp24
					break
				}
			} // end let
			return tmp5
		})
		tmp2 = tmp2.WithMeta(lang.NewMap(lang.NewKeyword("rettag"), nil)).(lang.FnFunc)
		tmp1 := ns.InternWithValue(tmp0, tmp2, true)
		if tmp0.Meta() != nil {
			tmp1.SetMeta(tmp0.Meta().(lang.IPersistentMap))
		}
	}
}
